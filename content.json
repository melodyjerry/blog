{"meta":{"title":"MelodyHub","subtitle":"你用走 可是我用跑","description":"","author":"Melody Jerry","url":"https://melodyjerry.github.io/blog","root":"/blog/"},"pages":[{"title":"404 Not Found","date":"2020-02-13T05:06:58.070Z","updated":"2020-02-13T05:06:58.070Z","comments":true,"path":"404.html","permalink":"https://melodyjerry.github.io/blog/404.html","excerpt":"","text":"404 Not Found 您访问的页面，呃，鬼知道跑哪去了(´･ω･`) 可能是因为： 你的节操掉光啦~~~ 手残⑨级输错了地址~~~ 或该地址已被删除~~~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"分类","date":"2020-02-01T09:53:46.111Z","updated":"2020-02-01T09:53:46.111Z","comments":true,"path":"categories/index.html","permalink":"https://melodyjerry.github.io/blog/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-02-09T06:07:15.686Z","updated":"2020-02-09T06:07:15.686Z","comments":true,"path":"mylist/index.html","permalink":"https://melodyjerry.github.io/blog/mylist/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"关于","date":"2020-07-10T15:46:17.990Z","updated":"2020-07-10T15:46:17.990Z","comments":true,"path":"about/index.html","permalink":"https://melodyjerry.github.io/blog/about/index.html","excerpt":"","text":"关……于……？ 关于啥呢？ 关于我这个小渣渣？ 目前， MelodyJerry还只是个某搬砖过来的码农， 现正在一块叫Java的田里种草。 然后，然后……没了，就这样。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"标签","date":"2020-02-01T09:54:04.836Z","updated":"2020-02-01T09:54:04.836Z","comments":true,"path":"tags/index.html","permalink":"https://melodyjerry.github.io/blog/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"友人帐","date":"2020-06-23T10:12:05.023Z","updated":"2020-06-23T10:12:05.023Z","comments":true,"path":"friends/index.html","permalink":"https://melodyjerry.github.io/blog/friends/index.html","excerpt":"","text":"欢迎小伙伴的到来。 如果有什么推荐/想法/问题，欢迎到底下留言。 给我留言，我们互相交换友链。 友链格式 名称：XXX 【博客名/昵称均可】头像链接：https://your/avatar/picture/ 【请使用https加密协议开头】博客地址：https://your/personal/blog/ 【请使用https加密协议开头】标签：#标签 #标签2 【这里可以写希望我贴上的标签喔~ 如：Web/Java/C++】 我的博客信息在这里喔~ 名称： MelodyHub头像链接： https://i.loli.net/2020/02/10/6yndjPI2rHL94vJ.png博客地址： https://melodyjerry.gitee.io/标签： # 后端 #音乐 最后，感谢小可爱们多多支持我喔٩(๑&gt;◡&lt;๑)۶有你们的鼓励，我会一定加油滴&gt;&lt;/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"成果展","date":"2020-02-09T06:42:13.805Z","updated":"2020-02-09T06:42:13.805Z","comments":true,"path":"projects/index.html","permalink":"https://melodyjerry.github.io/blog/projects/index.html","excerpt":"","text":"一枚 小渣渣 ，目前啥都没有~~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"藏宝阁","date":"2020-02-14T10:26:07.922Z","updated":"2020-02-14T10:26:07.922Z","comments":true,"path":"treasures/index.html","permalink":"https://melodyjerry.github.io/blog/treasures/index.html","excerpt":"","text":"欢迎来到 MelodyJerry的藏宝阁 能找到藏宝阁的入口，说明你与我有缘 以下所有资源可供你学习使用 有补充，可以留言告诉我 我不定时更新此内容 工具集 MCTool.cn在线工具 http://tool.liumingye.cn/ 兔二工具 http://www.tool2.cn/ 精准云工具 https://jingzhunyun.com/ 脚本之家 http://tools.jb51.net/ patorjk.com的线上工具集 http://patorjk.com/blog/software/ 图床 SM.MS（知名且免费） https://sm.ms/ 路过图床（免费） https://imgchr.com/ img.vim-cn.com（免费且访问速度快。） https://img.vim-cn.com/ 图片压缩 压缩图 https://www.yasuotu.com/ 建站 站长素材 http://sc.chinaz.com/ 网页游戏 2048-Game（作者：Tomotoes） https://tomotoes.com/2048/ 小霸王游戏免费玩 https://www.yikm.net/ 简历 xaoxuu制作 … Simon Ma制作 Windows 10 镜像（ISO） 微软官方 https://www.microsoft.com/zh-cn/software-download/windows10 MSDN我告诉你 https://msdn.itellyou.cn/ 网络亦是美 http://www.yishimei.cn/ UUP专制ISO https://uup.rg-adguard.net/index.php 动漫（我基本不看动漫，帮老弟存的hh）AGE动漫：https://www.agefans.tv/ Zzz Fun：http://d.mqaq.fun/ 康点动漫：http://www.zzzfun.com/ 樱花动漫：https://www.6111.tv/ Anime1：https://anime1.me/ 度盘搜索引擎 大力盘搜索（无需登录，有下载弹窗），网址：https://www.dalipan.com/ 大圣盘（无需登录，无下载弹窗），网址：https://www.dashengpan.com/ 小白盘（无需登录，有下载弹窗），网址：https://www.xiaobaipan.com/ SooHub 搜哈普（无需登录，无下载弹窗），网址：https://www.soohub.com/ bdy搜（无需登录，有下载链接跳转页面），网址：http://www.bdyso.com/ 度盘搜（Pandownload 内置），官网：http://pandownload.com/ 电子书搜索 一站式电子书搜索工具 网站非常简洁，打开官网，直接列出了包含的 70+ 电子书搜索网站。 以及网站特点，如是否需要注册、是否免费等，一目了然。 官网：http://www.soshuvip.com/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Linux命令小记","slug":"Linux命令小记","date":"2020-07-10T07:03:00.000Z","updated":"2020-07-10T06:46:17.615Z","comments":true,"path":"2020/07/10/Linux命令小记/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/10/Linux%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"rpm -q xx 查询xx是否安装 yum install xx 安装xx软件包 yum remove xx 卸载xx软件包 vim /路径 读写文件 i：编辑模式 Exc：退出到命令模式 :wq：保存并退出Vim startx （一次性地）从命令行切换到桌面环境 systemctl get-default 获取当前启动模式 systemctl set-default graphical.target 修改启动模式为图形化 systemctl set-default multi-user.target 修改启动模式为命令行 安装桌面环境 安装桌面环境（这里安装 GNOME） systemctl start xx 启动xx服务 systemctl enable xx 开机自启动xx服务 firewall-cmd --permanent --zone=public --add-port=3389/tcp 防火墙开放3389端口 firewall-cmd --reload 重启防火墙 systemctl stop firewalld 关闭防火墙 systemctl disable firewalld 禁止防火墙开机启动 cp /路径 复制文件 systemctl daemon-reload 让服务文件修改生效 netstat -lnpt|grep xx 查看xx的服务端口 sudo yum update -y 更新服务器地软件包 sudo yum install java-1.8.0-openjdk -y 安装 OpenJRE java -version 检测jre是否安装成功 sudo useradd -m halo 创建一个低权限地用户halo sudo su halo 登录用户halo wget url 下载xx安装包 useradd [-d home] [-s shell] [-c comment] [-m [-k template]] [-f inactive] [-e expire ] [-p passwd] [-r] name useradd或adduser命令用来建立用户帐号和创建用户的起始目录，使用权限是超级用户 主要参数 -c：加上备注文字，备注文字保存在passwd的备注栏中。 -d：指定用户登入时的主目录，替换系统默认值/home/&lt;用户名&gt; -D：变更预设值。 -e：指定账号的失效日期，日期格式为MM/DD/YY，例如06/30/12。缺省表示永久有效。 -f：指定在密码过期后多少天即关闭该账号。如果为0账号立即被停用；如果为-1则账号一直可用。默认值为-1. -g：指定用户所属的群组。值可以使组名也可以是GID。用户组必须已经存在的，期默认值为100，即users。 -G：指定用户所属的附加群组。 -m：自动建立用户的登入目录。 -M：不要自动建立用户的登入目录。 -n：取消建立以用户名称为名的群组。 -r：建立系统账号。 -s：指定用户登入后所使用的shell。默认值为/bin/bash。 -u：指定用户ID号。该值在系统中必须是唯一的。0~499默认是保留给系统用户账号使用的，所以该值必须大于499。 https://www.cnblogs.com/irisrain/p/4324593.html w # whoami 查看当前登陆用户 12:10:27 up 21:13, 1 user, load average: 0.00, 0.01, 0.08 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root pts/0 ***.**.***.** 11:33 0.00s 0.08s 0.00s w tmp_3254 ps1 ***.**.***.** 11:33 0.00s 0.08s 0.00s ls su xxx # 或者直接 exit 退出当前用户登录，进入一个有管理员权限的用户 pkill -kill -t [TTY] 强制退出已经登陆用户 0pkill -kill -t ps1 ls -a # ls --all 查看当前目录下的所有文件 service xx restart 重启xx应用 curl -o /路径 --create-dirs url 下载配置文件、模板等文件 sudo nginx -t 检查Nginx配置是否有误 sudo nginx -s reload 重载Nginx配置 sudo service xx status 查看xx的运行状态 sudo service halo stop 停止xx sudo service halo restart 重启xx sudo service halo start 启动xx sudo systemctl daemon-reload 修改service文件之后需要刷新Systemd sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 添加软件源信息 sudo yum makecache fast 更新yum缓存 镜像加速 # 新建 daemon.json 文件 sudo vim /etc/docker/daemon.json 将下面的配置复制进去即可： { \"registry-mirrors\": [\"http://hub-mirror.c.163.com\"] } 注意：修改完配置文件之后需要执行 service docker restart 才可生效。 sudo docker pull ruibaby/xx 拉取xx的最新镜像 docker run --rm -it -d --name halo -p 8090:8090 -v ~/.halo:/root/.halo ruibaby/halo 创建容器并运行halo –rm：停止之后自动删除容器。 –name：容器名。 -p：占用端口，前者为宿主机端口，后者为 Halo 的运行端口，可在 application.yaml 配置。 -v：目录映射，一般不要修改。 netstat -tln # netstat -tln | grep 8080 查找被占用的端口（可接特定端口号） netstat -ntlp 查看其他端口 lsof -i:8060 查看端口属于哪个程序、端口被哪个进程占用 kill -9 进程id 杀掉占用端口的进程 根据pid杀掉 shutdown -h now 立即关机 shutdown -r now # reboot 立即重启 docker run --name some-wordpress --link some-mysql:mysql -d wordpress 参数说明： --name 容器的的名字 --link 和其他容器做连接 -d/--detach 后台运行 docker run -d --privileged=true --name myMysql -v /data/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -p 33306:3306 mysql:5.6 参数解释： -p: 端口映射，33306表示宿主，3306表示容器中的端口。 这里表示将宿主机的33306映射给镜像的3306. -e: 环境变量， 环境变量和具体的Docker容器制作时设置有关，这里表示设置镜像中MySQL的root 密码时123456 -v: 指定数据卷，也就是将我们MySQL容器的/var/lib/mysql映射到宿主机的/data/mysql --privileged=true: CentOS系统下的安全Selinux禁止了一些安全权限，导致MySQL容器在运行时会因为权限不足而报错，所以需要增加该选项 docker ps -a 查看MySQL是否正常运行 docker stop 容器名 停止运行 docker rm 容器名 删除容器（之后去掉-d选项重新运行排查错误） 快速批量删除docker镜像或容器 Docker本身并没有提供批量删除的功能，当有大量的镜像或者容器需要删除的时候，手动的一个一个删就比较麻烦了。 # 直接删除所有镜像或容器 # 直接删除所有镜像 docker rmi `docker images -q` # 直接删除所有容器 docker rm `docker ps -aq` # 按条件筛选之后删除 # 按条件筛选之后删除镜像 docker rmi `docker images | grep xxxxx | awk '{print $3}'` # 按条件筛选之后删除容器 docker rm `docker ps -a | grep xxxxx | awk '{print $1}'` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"Docker学习笔记","slug":"Docker学习笔记","date":"2020-07-08T04:55:00.000Z","updated":"2020-07-10T06:46:17.182Z","comments":true,"path":"2020/07/08/Docker学习笔记/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/08/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Docker安装部署CentOS yum 包更新到最新（花的时间比较多） yum update 安装需要的软件包，yum-util 提供的yum-config-manager功能，另外两个是devicemapper驱动依赖的 yum install -y yum-utils device-mapper-persistent-data lvm2 设置yum源 yum-confi-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 安装docker，出现输入的页面都按 y yum install -y docker-ce 查看docker版本，验证是否安装成功 docker -v 其他安装方式(推荐)教程链接：Here! Docker命令Docker服务相关命令 启动docker服务 systemctl start docker systemctl start docker 停止docker服务 systemctl stop docker 重启docker服务 systemctl restart docker 查看docker服务状态 systemctl status docker 设置开机启动docker服务 systemstl enable docker Docker镜像相关命令 查看镜像：查看本地所有的镜像 docker images docker images -q # 查看所有镜像id 搜索镜像：从网络中查找需要的镜像 docker search 镜像名称 拉取镜像：从docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新版本。如果不知道镜像版本，可以去docker hub 搜索对应镜像查看 docker pull 镜像名称 删除镜像 docker rmi 镜像id docker rmi `docker images -q` # 删除所有本地镜像 Docker容器相关的命令 查看容器 docker ps # 查看正在运行的容器 docker ps -a # 查看所有容器 创建并启动容器 docker run 参数 参数说明： -i：保持容器运行。通常与-t同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。 -t：为容器重新分配一个伪输入终端，通常与-i同时使用。 -d:以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec进入容器。退出时，容器不会关闭。 -it：创建的容器一般称为交互式容器。 -id：创建的容器一般称为守护式容器。 –name：为创建的容器命名。 进入容器 docker exec 参数 # 退出容器，容器不会关闭 启动容器 docker start 容器名称 停止容器 docker stop 容器名称 删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除 docker rm 容器名称 查看容器信息 docker inspect 容器名称 Docker容器的数据卷数据卷概念和作用思考 Docker容器删除后，在容器中产生的数据也会随之销毁吗？ 会。 Docker容器和外部机器可以直接交换文件吗？ 不可以。 容器之间想要进行数据交互？ 不可以。 那咋办嘛？这就要用到数据卷了 数据卷 数据卷是宿主机中的一个目录或文件 当容器目录和数据卷目录绑定后，对方的修改会立即同步 一个数据卷可以被多个容器同时挂载 一个容器也可以被挂载多个数据卷 数据卷的作用 容器数据持久化 外部机器和容器间接通信 容器之间数据交换 配置数据卷 创建启动容器时，使用-v参数设置数据卷 docker run ...-v 宿主机目录(文件):容器内目录(文件)... 注意事项： 目录必须是绝对路径 如果目录不存在，会自动创建 可以挂载多个数据卷 数据卷容器配置数据卷容器 创建启动c3数据卷容器，使用-v参数设置数据卷 docker run -it --name-=c3 -v /volume centos:7 /bin/bash 创建启动c1 c2数据卷容器，使用-volumes-from参数设置数据卷 docker run -it --name-=c1 -volumes-from c3 centos:7 /bin/bash docker run -it --name-=c2 -volumes-from c3 centos:7 /bin/bash #Docker应用部署 MySQL部署 搜索MySQL镜像 docker search mysql 拉取MySQL镜像 docker pull mysql:5.6 创建容器，设置端口映射、目录映射 # 在/root目录下创建mysql目录用于存储mysql数据信息 mkdir ~/mysql cd ~/mysql docker run -id \\ --name=c_mysql \\ -p 3307:3306 \\ -v $PWD/conf:/etc/mysql/confi.d \\ -v $PWD/logs:/logs \\ -v $PWD/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ mysql:5.6 参数说明： -p 3307:3306：将容器的3306端口映射到宿主机的3307端口。 -v $PWD/conf:/etc/mysql/confi.d：将主机当前目录下的conf/my.cnf挂载到容器的/etc/mysql/my.cnf。配置目录 -v $PWD/logs:/logs：将主机当前目录下的logs目录挂载到容器的/logs。日志目录 -v $PWD/data:/var/lib/mysql：将主机当前目录下的data目录挂载到容器的/var/lib/mysql。数据目录 -e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码。 Tomcat部署 搜索Tomcat镜像 docker search tomcat 拉取Tomcat镜像 docker pull tomcat 创建容器，设置端口映射、目录映射 # 在/root目录下创建tomcat目录用于存储tomcat数据信息 mkdir ~/tomcat cd ~/tomcat docker run -id \\ --name=c_tomcat \\ -p 8080:8080 \\ -v $PWD:/usr/local/tomcat/webapps \\ tomcat 参数说明： -p 8000:8080：将容器的8080端口映射到宿主机的8000端口。 -v $PWD:/usr/local/tomcat/webapps：将主机当前目录挂载到容器的/usr/local/tomcat/webapps。 Nginx部署 搜索Nginx镜像 docker search nginx 拉取Nginx镜像 docker pull nginx 创建容器，设置端口映射、目录映射 # 在/root目录下创建nginx目录用于存储nginx数据信息 mkdir ~/nginx cd ~/nginx mkdir conf cd conf # 在~/nginx/conf/下创建nginx.conf文件，粘贴下面内容 vim nginx.conf user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } docker run -id \\ --name=c_nginx \\ -p 81:80 \\ -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \\ -v $PWD/logs:/var/log/nginx \\ -v $PWD/html:/usr/share/nginx/html \\ nginx 参数说明： -p 81:80：将容器的80端口映射到宿主机的81端口。 v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机当前目录下的/conf/nginx.conf挂载到容器的/etc/nginx/nginx.conf。配置目录 -v $PWD/logs:/var/log/nginx：将主机当前目录下的logs目录挂载到容器的/var/log/nginx。日志目录 -v $PWD/html:/usr/share/nginx/html：将主机当前目录下的/html挂载到容器的/usr/share/nginx/html。 Redis部署 搜索Redis镜像 docker search redis 拉取Redis镜像 docker pull redis:5.0 创建容器，设置端口映射、目录映射 docker run -id --name=c_redis -p 6379:6379 redis:5.0 参数说明： -p 6379:6379：将容器的6379端口映射到宿主机的6379端口。 使用外部机器连接redis ./redis-cli.exe -h &lt;your ipAddress&gt; -p 6379 DockerfileDocker镜像原理思考 Docker镜像本质是什么？ 是一个分层的文件系统 Docker中一个centos镜像为什么只有200MB，而一个centos操作系统的 iso 文件要几个GB？ Centos的iso镜像文件包含bootfs和rootfs，而docker的centos镜像复用操作系统的bootfs，只包含rootfs和其他镜像层 Docker中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？ 由于docker中镜像是分层的，tomcat虽然只有70多MB，但它需要依赖于父镜像和子镜像，所有整个对外暴露的tomcat镜像大小有500多MB Linux文件系统 bootfs：包含bootloader（引导加载系统）和kernel（内核） rootfs：root文件系统，包含的就是典型的Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件 不用的Linux发行版，bootfs基本一样，而rootfs不同，如Ubuntu，centos等 Docker镜像 Docker镜像是由特殊的文件系统叠加而成 最底端是bootfs,并使用宿主机的bootfs 第二层是root文件系统rootfs,称为base image 然后再往上可以叠加其他的镜像文件 统一文件系统(Union File System)\\技术能够将不同的层整合成一个文件系统,为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来,只存在一个文件系统。 一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像\\，最底部的镜像成为基础镜像\\。 当从一个镜像启动容器时，Docker会从最顶层加载一个读写文件系统作为容器 镜像制作 容器转为镜像 docker commit 容器id 镜像名称:版本号 # 将容器转换为镜像文件 docker save -o 压缩文件名称 镜像名称:版本号 # 将镜像文件打包成压缩文件，之后就能对压缩文件传送了 docker load -i 压缩文件名称 # 将压缩文件解压称为镜像文件 Dockerfile 看下面内容 Dockerfile概念及作用概念 Dockerfile是一个文本文件 包含了一条条的指令 每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像 对于开发人员：可以为开发团队提供一个完全一致的开发环境 对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了 对于运维人员：在部署时，可以实现应用的无缝移植 Dockerfile关键字列举一些常用的 关键字 作用 备注 FROM 指定父镜像 指定dockerfile基于那个image构建 MAINTAINER 作者信息 用来标明这个dockerfile谁写的 LABEL 标签 用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看 RUN 执行命令 执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”] CMD 容器启动命令 提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”] ENTRYPOINT 入口 一般在制作一些执行就关闭的容器中会使用 COPY 复制文件 build的时候复制文件到image中 ADD 添加文件 build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务 ENV 环境变量 指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value ARG 构建参数 构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数 VOLUME 定义外部可以挂载的数据卷 指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”] EXPOSE 暴露端口 定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp WORKDIR 工作目录 指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径 USER 指定执行用户 指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户 HEALTHCHECK 健康检查 指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制 ONBUILD 触发器 当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大 STOPSIGNAL 发送信号量到宿主机 该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。 SHELL 指定执行脚本的shell 指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell 制作自定义centos镜像自定义需求 默认登录路径为/usr 可以使用vim 操作 创建编辑dockerfile文件 mkdir /root/dockerfile cd dockerfile vim centos_dockerfile 定义父镜像：FROM centos:7 定义作者信息：MAINTAINER adongyo &lt;adongyo@it.cn&gt; 执行安装vim命令：RUN yum install -y vim 定义默认的工作目录：WORKDIR /usr 定义容器启动执行的命令：CMD /bin/bash 执行命令 docker build -f ./centos_dockerfile -t myCentos:1 . 参数说明： -f： 指定dockerfile文件 -t： 设置生成的新的镜像的名称 .： 别漏了后面还有一个’.’ 参考资料 b站转载黑马程序员 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"https://melodyjerry.github.io/blog/tags/Docker/"}]},{"title":"Hexo部署到云服务器","slug":"Hexo部署到云服务器","date":"2020-07-08T04:49:00.000Z","updated":"2020-07-10T06:46:17.219Z","comments":true,"path":"2020/07/08/Hexo部署到云服务器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/08/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"阿里云VPS搭建自己的的Hexo博客：https://segmentfault.com/a/1190000005723321Hexo个人博客部署到CentOS个人服务器：https://segmentfault.com/a/1190000010680022部署Hexo到个人服务器：https://www.huangtengxq.com/2017/08/19/BuildHexoOnVps/HEXO部署到unbuntu服务器详细指南：http://www.laoyuyu.me/2017/10/10/hexo_deploy_vps/服务器部署Hexo博客：https://dogorgod.github.io/2017/03/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/Hexo博客部署到服务器：https://i.jakeyu.top/2016/12/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/通过Git将Hexo博客部署到服务器：https://www.jianshu.com/p/e03e363713f9部署Hexo博客到linux云主机并实现自动发布：https://ghui.me/post/2016/07/host-hexo-vps/将Hexo博客部署到云主机：https://blog.fundebug.com/2017/05/18/deploy-hexo-on-cloud/配合Travis CI，将Hexo博客自动部署到你的服务器上：https://blog.keep.moe/2015/11/06/hexo-and-travis-ci/使用Git Hook自动部署Hexo到个人VPS：http://www.swiftyper.com/2016/04/17/deploy-hexo-with-git-hook/VPS Centos7安装Git服务器，部署Hexo静态博客：https://www.micronbot.com/blog/8.html在Ubuntu 14.04服务器上部署Hexo博客：https://cloud.tencent.com/developer/article/1004587阿里云ubuntu部署hexo,并与本地同步，实现自动部署：http://blog.csdn.net/nghuyong/article/details/54430093阿里云搭建Git服务，实现Hexo自动部署：https://imys.net/20160303/hexo-nginx-auto-deploy.htmlhexo博客部署到linux服务器上：https://lvshen9.github.io/2018/01/08/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"},{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"服务器安装宝塔面板","slug":"宝塔面板Linux命令大全","date":"2020-07-07T15:32:00.000Z","updated":"2020-07-10T06:46:17.920Z","comments":true,"path":"2020/07/07/宝塔面板Linux命令大全/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BFLinux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","excerpt":"","text":"安装宝塔Centos安装脚本 yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh Ubuntu/Deepin安装脚本 wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh Debian安装脚本 wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; bash install.sh Fedora安装脚本 wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; bash install.sh 管理宝塔宝塔工具箱(包含下列绝大部分功能 直接ssh中执行bt命令 仅限6.x以上版本面板) bt 停止 /etc/init.d/bt stop 启动 /etc/init.d/bt start 重启 /etc/init.d/bt restart 卸载 /etc/init.d/bt stop &amp;&amp; chkconfig --del bt &amp;&amp; rm -f /etc/init.d/bt &amp;&amp; rm -rf /www/server/panel 查看当前面板端口 cat /www/server/panel/data/port.pl 修改面板端口，如要改成8881（centos 6 系统） echo '8881' &gt; /www/server/panel/data/port.pl &amp;&amp; /etc/init.d/bt restart iptables -I INPUT -p tcp -m state --state NEW -m tcp --dport 8881 -j ACCEPT service iptables save service iptables restart 修改面板端口，如要改成8881（centos 7 系统） echo '8881' &gt; /www/server/panel/data/port.pl &amp;&amp; /etc/init.d/bt restart firewall-cmd --permanent --zone=public --add-port=8881/tcp firewall-cmd --reload 强制修改MySQL管理(root)密码，如要改成123456 cd /www/server/panel &amp;&amp; python tools.py root 123456 修改面板密码，如要改成123456 cd /www/server/panel &amp;&amp; python tools.py panel 123456 查看宝塔日志 cat /tmp/panelBoot.pl 查看软件安装日志 cat /tmp/panelExec.log 站点配置文件位置 /www/server/panel/vhost 删除域名绑定面板 rm -f /www/server/panel/data/domain.conf 清理登陆限制 rm -f /www/server/panel/data/*.login 查看面板授权IP cat /www/server/panel/data/limitip.conf 关闭访问限制 rm -f /www/server/panel/data/limitip.conf 查看许可域名 cat /www/server/panel/data/domain.conf 关闭面板SSL rm -f /www/server/panel/data/ssl.pl &amp;&amp; /etc/init.d/bt restart 查看面板错误日志 cat /tmp/panelBoot 查看数据库错误日志 cat /www/server/data/*.err 站点配置文件目录(nginx) /www/server/panel/vhost/nginx 站点配置文件目录(apache) /www/server/panel/vhost/apache 站点默认目录 /www/wwwroot 数据库备份目录 /www/backup/database 站点备份目录 /www/backup/site 站点日志 /www/wwwlogs Nginx服务管理nginx安装目录 /www/server/nginx 启动 /etc/init.d/nginx start 停止 /etc/init.d/nginx stop 重启 /etc/init.d/nginx restart 启载 /etc/init.d/nginx reload nginx配置文件 /www/server/nginx/conf/nginx.conf Apache服务管理apache安装目录 /www/server/httpd 启动 /etc/init.d/httpd start 停止 /etc/init.d/httpd stop 重启 /etc/init.d/httpd restart 启载 /etc/init.d/httpd reload apache配置文件 /www/server/apache/conf/httpd.conf MySQL服务管理mysql安装目录 /www/server/mysql phpmyadmin安装目录 /www/server/phpmyadmin 数据存储目录 /www/server/data 启动 /etc/init.d/mysqld start 停止 /etc/init.d/mysqld stop 重启 /etc/init.d/mysqld restart 启载 /etc/init.d/mysqld reload mysql配置文件 /etc/my.cnf FTP服务管理ftp安装目录 /www/server/pure-ftpd 启动 /etc/init.d/pure-ftpd start 停止 /etc/init.d/pure-ftpd stop 重启 /etc/init.d/pure-ftpd restart ftp配置文件 /www/server/pure-ftpd/etc/pure-ftpd.conf PHP服务管理php安装目录 /www/server/php 启动(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 start) /etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} start 停止(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 stop) /etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} stop 重启(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 restart) /etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} restart 启载(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 reload) /etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} reload 配置文件(请根据安装PHP版本号做更改，例如：/www/server/php/52/etc/php.ini) /www/server/php/{52|53|54|55|56|70|71|72|73|74}/etc/php.ini Redis服务管理redis安装目录 /www/server/redis 启动 /etc/init.d/redis start 停止 /etc/init.d/redis stop redis配置文件 /www/server/redis/redis.conf Memcached服务管理memcached安装目录 /usr/local/memcached 启动 /etc/init.d/memcached start 停止 /etc/init.d/memcached stop 重启 /etc/init.d/memcached restart 启载 /etc/init.d/memcached reload document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"},{"name":"宝塔","slug":"宝塔","permalink":"https://melodyjerry.github.io/blog/tags/%E5%AE%9D%E5%A1%94/"}]},{"title":"服务器安装宝塔面板","slug":"服务器安装宝塔面板","date":"2020-07-07T13:24:00.000Z","updated":"2020-07-10T06:46:17.934Z","comments":true,"path":"2020/07/07/服务器安装宝塔面板/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/","excerpt":"这里两篇文章关于“CentOS安装宝塔面板” https://developer.aliyun.com/ask/233242?spm=a2c6h.13524658 http://tencent.yundashi168.com/327.html?spm=a2c6h.13066369.0.0.328d79c6znCKp6","text":"这里两篇文章关于“CentOS安装宝塔面板” https://developer.aliyun.com/ask/233242?spm=a2c6h.13524658 http://tencent.yundashi168.com/327.html?spm=a2c6h.13066369.0.0.328d79c6znCKp6 ①购买完云服务器ECS后，对于新手而言如何搭建Web环境是比较棘手的，分享一款简单易用的主机面板：宝塔面板，分享阿里云服务器安装宝塔面板图文教程： 本文以：Linux云服务器，CentOS 7.4 64位系统为例。 一：开放安全组端口什么是安全组？是阿里云ECS云服务器特有的虚拟防火墙，是一种安全机制，默认情况下宝塔面板依赖的端口并没有开放，所以我们第一步是自定义安全组开放端口，如下图所示： 我们以开放8888号端口为例：1、登录到云服务器ECS控制台；2、点击“更多”–“网络和安全组”–“安全组配置”，点击“配置规则”3、如下图所示，端口范围填：8888/8888，授权对象填：0.0.0.0/0 端口范围按照格式，填写我们需要开放的端口；授权对象填0.0.0.0/0的意思是对所有人开放这个端口，授权范围大家可以按照自己的需求自定义。宝塔面板需要开放的端口有：8888、888、80、443、20、21，这6个端口都需要开放，大家按照上面的方法开放即可。 安全组不会操作，可以参考阿里云官方文档： 阿里云安全组的典型应用示例 二：安装宝塔面板SSH的方式登录到你的云服务器ECS上，命令：ssh root@你的服务器IP执行命令：yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh然后输入字母“y”，等待程序自行安装，大约2分钟 三：保存宝塔面板后台登录名和密码执行上述命令后，程序自动安装，安装完毕后，会出现宝塔后台登录的账户名和密码，大家保存下来Complete!==================================================================Congratulations! Install succeeded!==================================================================Bt-Panel: http://47.104.71.103:8888username: adminpassword: 66d52887Warning:If you cannot access the panel,release the following port (8888|888|80|443|20|21) in the security group==================================================================宝塔面板后台登录地址为：http://你的服务器IP/8888默认登录名为：admin密码：安装完成后，会随机生成一段密码，请保存好 四：登录到宝塔面板后台，安装web环境使用刚才保存的账户名和密码，登录到宝塔面吧后台，一键安装Web环境，登录宝塔面板后台，地址：http://你的服务器IP/8888，输入刚才保存好的账户和密码 登录后会自动弹出安装Web环境页面，如下图所示： 可选LNMP和LAMP两种Web环境，大家按需选择（推荐选择第一个LNMP），然后点击“一键安装”，等待即可。大约需要8分钟。 五：创建站点Web环境一键安装完毕后，点击左侧“网站”—“添加站点”，如下图所示： 输入域名后，默认不会自动创建FTP和MySQL数据库，我们可以选择自动创建，方便省事，点击“提交”，创建成功后，会显示你的FTP和MySQL数据信息，例如： FTP账号资料用户：aliyunbaike_com密码：625GcrKSc3只要将网站上传至以上FTP即可访问!数据库账号资料数据库名：aliyunbaike_com用户：aliyunbaike_com密码：e8QZfQDPDT 大家将新建站点的FTP账户密码、数据库账户密码都保存好。 六：域名解析将域名解析到你的服务器IP，解析出成功后，会显示“恭喜，站点创建成功！” 七：网站安装将你的网站程序上传到域名所对应的根目录，如果是新站，输入第五步的数据库账户和密码。 ②下面稍微介绍一下如何使用阿里云服务器安装宝塔面板。 一、准备阿里云的云服务器，即 阿里云ECS，默认的用户名 root，密码的话可以修改。 远程连接云服务器使用 ssh 软件工具，使用的是公网ip。 注意事项：出于性能考虑，服务器的操作系统一定要选Linux版本（centos或者ubuntu），不要选Window。 主要步骤：拥有一台云服务器》ssh工具连接云服务器》安装宝塔面板》配置云服务器安全组(放行端口)》宝塔面板在线访问成功 二、安装面板1、使用ssh工具连接云服务器windows下可以使用XShell，macOs的可以使用终端。 因为SSH工具有很多种，找到自己用的舒服的工具就可以，不用纠结使用哪一种。 我自己是用的FinalShell这一款SSH工具来进行Linux远程连接的,如何认为不安全的话，也可以继续用Xshell，只是需要激活码,如下图 2、输入宝塔面板安装命令 温馨提示：宝塔面板最近升级到了7.0版本，Centos7以上的系统建议安装宝塔面板最新版：https://www.bt.cn/bbs/thread-19376-1-1.html（宝塔面板7.x版本，点击查看安装命令）https://www.bt.cn/bbs/thread-30562-1-1.html（宝塔面板6.x版本，点击查看安装命令） 安装方法这里也有介绍（以宝塔面板5.x版本举例）：http://www.bt.cn/bbs/thread-1186-1-1.html 以下安装命令是宝塔面板5.x版本的，请注意。如果安装出错了，就去安装宝塔面板7.x版本 Centos安装脚本： yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh Ubuntu/Deepin安装脚本： wget -O install.sh http://download.bt.cn/install/install-ubuntu.sh &amp;&amp; sudo bash install.sh Debian安装脚本： wget -O install.sh http://download.bt.cn/install/install-ubuntu.sh &amp;&amp; bash install.sh Fedora安装脚本: wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; bash install.sh 前两者偏多。根据操作系统输入不同的安装命令，然后回车 此间不需要任何操作。 3、宝塔面板安装成功稍等一分钟（有时候网速差可能久一点)，然后不要关闭窗口 最终可以看到如下界面 这里会显示宝塔后台地址和账号密码，可以手动复制到记事本暂时存起来。 三、配置安全组 如果你已经会设置安全组的话，就可以省略这一步，直接浏览器访问宝塔面板访问地址：http://云服务器公网IP地址:8888/ 上面的黄色的字也说了，如果不能访问面板，请在安全组中放行端口。 因为刚装的系统，自然也没有放行8888端口，面板后台无法打开 下面我们添加安全组 1、进入云服务器管理后台进入服务器(实例)主页，点击右边的查看更多，点击安全组配置。 2、然后可以看到一条安全组点击配置规则（如果没有就新建一条安全组） 3、点击快速创建规则 4、可以看到如下页面 常用端口可以勾选，相当于多选。也可以自定义端口，比如我们要将8888和888添加进去。 授权对象像之前已经填的 0.0.0.0/0 一样。 基本就是这样。 5、最终安全记录如下 6、浏览器访问宝塔面板成功然后我们再刷新之前的网页就能正常啦 在云服务器上安装宝塔面板成功之后，访问地址：http://云服务器公网IP地址:8888/输入安装的时候产生的默认临时账号和密码登录。登录之后，请一定记得去改账号和密码哦！ 7、修改临时账号和密码 为了安全考虑，在云服务器上安装完成宝塔面板之后，你应该马上修改你的宝塔面板登录账户和密码（注意：这个账户和密码不是宝塔面板官网的，而是每个云服务器访问宝塔面板需要用到的账户和密码） 修改账号和密码之后，后面访问登录就是你新设置的账号和密码了 8、绑定宝塔面板账号 首先解释下为什么要绑定宝塔面板账号：每一台云服务器上安装了宝塔面板之后都需要去绑定你在宝塔面板官网上注册的 宝塔账号 这样每台云服务器的宝塔面板都可以享受你这个账号付过费的服务了。 安装宝塔面板之后必做的事情：如何注册和绑定宝塔面板账号？ 9、安装LNMP网站环境LNMP网站环境是Linux+Nginx+Mysql+PHP的组合搭配网站程序环境，用来快速搭建各种开源的网站程序（WordPress,帝国CMS，织梦，Zblog等） 为什么选择LNMP? 主要归功于Nignx服务器的功能强大和性能出色，还能节省服务器内存开销。 然后会出现这个界面，需要等待十分钟左右，这会你可以去忙其它事情，过会来看。 10、安装开源建站程序完成了以上步骤之后，你就可以随心所以的基于宝塔面板来安装各种建站程序了 基于宝塔面板安装WordPress个人网站（图文教程） 基于宝塔面板搭建Typecho博客网站（图文教程） 基于宝塔面板安装Hexo个人博客（图文教程） 基于宝塔面板对WordPress网站进行备份与恢复（网站迁移教程） 宝塔面板干什么用的? 有什么优点？搭建网站为什么要用它？ 使用宝塔面板搭建网站之后的经验总结 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"},{"name":"宝塔","slug":"宝塔","permalink":"https://melodyjerry.github.io/blog/tags/%E5%AE%9D%E5%A1%94/"}]},{"title":"CentOS7操作SSH/SSHD服务(查看/启动/重启/自启)","slug":"CentOS7操作SSH、SSHD服务(查看、启动、重启、自启)","date":"2020-07-07T08:05:00.000Z","updated":"2020-07-10T06:46:17.185Z","comments":true,"path":"2020/07/07/CentOS7操作SSH、SSHD服务(查看、启动、重启、自启)/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/CentOS7%E6%93%8D%E4%BD%9CSSH%E3%80%81SSHD%E6%9C%8D%E5%8A%A1(%E6%9F%A5%E7%9C%8B%E3%80%81%E5%90%AF%E5%8A%A8%E3%80%81%E9%87%8D%E5%90%AF%E3%80%81%E8%87%AA%E5%90%AF)/","excerpt":"查看状态： systemctl status sshd.service 启动服务： systemctl start sshd.service 重启服务： systemctl restart sshd.service 开机自启： systemctl enable sshd.service","text":"查看状态： systemctl status sshd.service 启动服务： systemctl start sshd.service 重启服务： systemctl restart sshd.service 开机自启： systemctl enable sshd.service document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"CentOS服务器升级Linux版本","slug":"CentOS服务器升级Linux版本","date":"2020-07-07T06:45:00.000Z","updated":"2020-07-10T06:46:17.178Z","comments":true,"path":"2020/07/07/CentOS服务器升级Linux版本/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/CentOS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%87%E7%BA%A7Linux%E7%89%88%E6%9C%AC/","excerpt":"检查系统版本$ cat /etc/redhat-release 显示 CentOS Linux release 7.1.1503 (Core) 备份重要数据备份例如/etc、/var、/opt如果是安装在虚拟机上，那么可以使用快照进行备份。像VMware虚拟机可以快照备份，当然更奢侈一点是备份整个虚拟机。也可以针对重要程序数据进行备份，例如MySQL, Appache, Nginx, DNS等等。 运行yum命令升级$ sudo yum clean all $ sudo yum update 重启系统$ sudo reboot 查看现在系统版本$ cat /etc/redhat-release 显示 CentOS Linux release 7.8.2003 (Core)","text":"检查系统版本$ cat /etc/redhat-release 显示 CentOS Linux release 7.1.1503 (Core) 备份重要数据备份例如/etc、/var、/opt如果是安装在虚拟机上，那么可以使用快照进行备份。像VMware虚拟机可以快照备份，当然更奢侈一点是备份整个虚拟机。也可以针对重要程序数据进行备份，例如MySQL, Appache, Nginx, DNS等等。 运行yum命令升级$ sudo yum clean all $ sudo yum update 重启系统$ sudo reboot 查看现在系统版本$ cat /etc/redhat-release 显示 CentOS Linux release 7.8.2003 (Core) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"阿里云云服务器漏洞修复","slug":"阿里云云服务器漏洞修复","date":"2020-07-07T06:22:00.000Z","updated":"2020-07-10T06:46:17.945Z","comments":true,"path":"2020/07/07/阿里云云服务器漏洞修复/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/","excerpt":"前阵子在阿里云618活动花“巨款”买下了一个T5型的云服务器，镜像版本为CentOS 7.4。由于是第一次购买阿里云的服务器，云安全中心提示需要修复的漏洞有98个，一看到就怕了，可以阿里云的修复要钱，最少都是30/台/月，耗不起。于是，百度了一下，找到了3篇有用的文章 https://www.cnblogs.com/wang-yaz/p/10563394.html https://www.cnblogs.com/ice-line/p/9590445.html https://www.v2ex.com/t/598779","text":"前阵子在阿里云618活动花“巨款”买下了一个T5型的云服务器，镜像版本为CentOS 7.4。由于是第一次购买阿里云的服务器，云安全中心提示需要修复的漏洞有98个，一看到就怕了，可以阿里云的修复要钱，最少都是30/台/月，耗不起。于是，百度了一下，找到了3篇有用的文章 https://www.cnblogs.com/wang-yaz/p/10563394.html https://www.cnblogs.com/ice-line/p/9590445.html https://www.v2ex.com/t/598779 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"Linux服务器安装Docker","slug":"Linux服务器安装Docker","date":"2020-07-07T05:56:00.000Z","updated":"2020-07-10T06:46:17.619Z","comments":true,"path":"2020/07/07/Linux服务器安装Docker/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Docker/","excerpt":"前阵子在阿里云618活动花“巨款”买下了一个T5型的云服务器，镜像版本为CentOS 7.4。现打算安装Docker。 官方文档https://docs.docker.com/install/linux/docker-ce/centos/","text":"前阵子在阿里云618活动花“巨款”买下了一个T5型的云服务器，镜像版本为CentOS 7.4。现打算安装Docker。 官方文档https://docs.docker.com/install/linux/docker-ce/centos/ 卸载旧版按官方的文档，新版Docker无法覆盖旧版的，所以无比先卸载原来的旧版本 在Linux虚拟机上，我是装有旧版的，但由于服务器是全新的，无任何配置的，可以跳过这步骤 # 移除旧版本的 Docker yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 安装 Docker 安装软件包 # 安装 Docker 依赖 yum install -y yum-utils device-mapper-persistent-data lvm2 配置阿里云Docker Yum源(个人觉的好) # 添加源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 更新 yum 缓存 yum makecache fast 安装最新版本的Docker # 安装 Docker-CE yum install -y docker-ce # 开启 Docker systemctl start docker # 安装 Docker Compose curl -L \"https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose 相关防火墙配置# Docker 和 Swarm 相关防火墙配置 systemctl status firewalld systemctl start firewalld firewall-cmd --add-port=9010/tcp --permanent firewall-cmd --add-port=9020/tcp --permanentfirewall-cmd --add-port=443/tcp --permanent firewall-cmd --add-port=80/tcp --permanent firewall-cmd --add-port=80/udp --permanentfirewall-cmd --add-port=22/tcp --permanent firewall-cmd --add-port=22/udp --permanent firewall-cmd --reload systemctl restart docker 这里说明一下如果开始 firewalld 服务被锁定Unit is masked 需要先解除锁定，然后才能开放端口 systemctl unmask firewall 开机启动# 开机自启动 systemctl enable firewalld systemctl enable docker 可能出现的问题在配置阿里云Docker Yum源时候，可能出现Loaded plugins: fastestmirror的错误提示，百度上的解决如下： 1、 # vi /etc/yum/pluginconf.d/fastestmirror.conf enabled=0 //由 1 改成0 ，禁用该插件 verbose=0 always_print_best_host = true socket_timeout=3 # Relative paths are relative to the cachedir (and so works for users as well # as root). hostfilepath=timedhosts.txt maxhostfileage=10 maxthreads=15 #exclude=.gov, facebook #include_only=.nl,.de,.uk,.ie 2、 #vi /etc/yum.conf [main] cachedir=/var/cache/yum/$basearch/$releasever keepcache=0 debuglevel=2 logfile=/var/log/yum.log exactarch=1 obsoletes=1 gpgcheck=1 plugins=1 #将plugins的值修改为0 installonly_limit=5 3、 $ yum clean dbcache 4、重新执行配置源和安装命令即可 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"https://melodyjerry.github.io/blog/tags/Docker/"}]},{"title":"服务器安装Nginx","slug":"服务器安装Nginx","date":"2020-07-07T05:26:00.000Z","updated":"2020-07-10T06:46:17.929Z","comments":true,"path":"2020/07/07/服务器安装Nginx/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Nginx/","excerpt":"图方便，用了个自动脚本： wget http://mirrors.linuxeye.com/oneinstack-full.tar.gz &amp;&amp; tar xzf oneinstack-full.tar.gz &amp;&amp; ./oneinstack/install.sh --nginx_option 1 安装 Nginx 成功，重启服务器，连接 SSH","text":"图方便，用了个自动脚本： wget http://mirrors.linuxeye.com/oneinstack-full.tar.gz &amp;&amp; tar xzf oneinstack-full.tar.gz &amp;&amp; ./oneinstack/install.sh --nginx_option 1 安装 Nginx 成功，重启服务器，连接 SSH document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"Hexo+GitEE 搭建、备份、恢复、多终端","slug":"Hexo + GitEE 搭建、备份、恢复、多终端","date":"2020-07-07T05:21:00.000Z","updated":"2020-07-10T06:46:17.217Z","comments":true,"path":"2020/07/07/Hexo + GitEE 搭建、备份、恢复、多终端/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/Hexo%20+%20GitEE%20%E6%90%AD%E5%BB%BA%E3%80%81%E5%A4%87%E4%BB%BD%E3%80%81%E6%81%A2%E5%A4%8D%E3%80%81%E5%A4%9A%E7%BB%88%E7%AB%AF/","excerpt":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 是使用的比较多的博客框架了，之所以没有使用 GitHub 而选择了码云， 我有自己的 VPS 不需要使用 GitHub Pages ，所以本文也没有关于如何使用 GitHub Pages 的教程； GitHub 上私有仓库是收费的，码云上面能创建免费的私有仓库。也有人选择使用 Docker 来创建博客环境，做镜像备份. 这里没有使用此方案，各有所好吧！","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 是使用的比较多的博客框架了，之所以没有使用 GitHub 而选择了码云， 我有自己的 VPS 不需要使用 GitHub Pages ，所以本文也没有关于如何使用 GitHub Pages 的教程； GitHub 上私有仓库是收费的，码云上面能创建免费的私有仓库。也有人选择使用 Docker 来创建博客环境，做镜像备份. 这里没有使用此方案，各有所好吧！ 1.环境主服务器系统版本与内核版本： [root@dbn- ~]# cat /etc/redhat-release CentOS Linux release 7.5.1804 (Core) [root@dbn- ~]# uname -r 3.10.0-862.3.2.el7.x86_64 测试服务器系统版本与内核版本： [root@host ~]# cat /etc/redhat-release CentOS Linux release 7.3.1611 (Core) [root@host ~]# uname -r 4.10.4-1.el7.elrepo.x86_64 2.安装2.1 wgetyum install -y wget 2.2 NodeJS# 下载nodejs最新的bin包 wget https://nodejs.org/dist/v12.18.2/node-v12.18.2-linux-x64.tar.xz # 解压 xz -d node-v12.18.2-linux-x64.tar.xz tar -xf node-v12.18.2-linux-x64.tar # 移动目录 mv node-v12.18.2-linux-x64 /usr/local/nodejs # 部署文件 ln -s /usr/local/nodejs/bin/node /usr/bin/node ln -s /usr/local/nodejs/bin/npm /usr/bin/npm 可以去官方网站下载，我这里使用的类型为：Linux Binaries (x64) 测试 [root@dbn-japan packages]# node -v v12.18.2 [root@dbn-japan packages]# npm -v 6.14.5 如果输出了版本号，说明安装成功。 2.3 Gityum install -y git 初始化设置： git config --global user.email \"vip@email.com\" git config --global user.name \"MelodyJerry\" 2.4 Hexonpm install -g hexo-cli 安装后尝试执行命令： hexo 如果出现下面的输出，按我下面的方法解决，没有则跳过。 [root@dbn-japan packages]# hexo -bash: hexo: command not found 编辑环境变量文件： vim /etc/profile ，在文件末尾增加下面设置： export PATH=$PATH:/usr/local/nodejs/lib/node_modules/hexo-cli/bin 刷新环境变量： source /etc/profile ，这时再运行命令 hexo 就会有正确的输出了。 3.配置3.1 创建项目与分支 创建新的分支：sources master：存放 Hexo 编译生成的静态资源。 sources：存放源文件，用来备份博客。 3.2 设置 SSH Key运行下面的命令创建 SSH Key，邮箱部分改成你创建账户时候的邮箱： [root@dbn-japan blog.dbnuo.org]# ssh-keygen -t rsa -C \"dbnuo@foxmail.com\" Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): # 目录 Enter passphrase (empty for no passphrase): # 输入密码，可回车跳过 Enter same passphrase again: # 再次输入密码 查看公开密钥： cat ~/.ssh/id_rsa.pub 将公开密钥添加至码云。 3.3 拉取项目跳转至网站根目录，克隆项目至本地： git clone https://gitee.com/dbnuo/bnd-hexo.git 跳转至拉取的项目目录： # 创建 hexo 目录 mkdir hexo # 进入 hexo 目录 cd hexo/ # 初始化 hexo 目录 hexo init npm install # 安装插件 npm install hexo-generator-index --save npm install hexo-generator-archive --save npm install hexo-generator-category --save npm install hexo-generator-tag --save npm install hexo-server --save npm install hexo-deployer-git --save npm install hexo-deployer-heroku --save npm install hexo-deployer-rsync --save npm install hexo-deployer-openshift --save npm install hexo-renderer-marked --save npm install hexo-renderer-stylus --save npm install hexo-generator-feed --save npm install hexo-generator-sitemap --save 4.建站先看文件夹里都有什么： [root@dbn-japan hexo]# ls -a . .. _config.yml .gitignore node_modules package.json package-lock.json scaffolds source themes _config.yml：站点的配置文件，需要备份； themes：主题文件夹，需要备份； source：博客文章的 .md 文件，需要备份； scaffolds：文章的模板，需要备份； package.json：安装包的名称，需要备份； .gitignore：限定在 push 时哪些文件可以忽略，需要备份； .git：主题和站点都有，标志这是一个 git 项目，不需要备份； node_modules：是安装包的目录，在执行 npm install 的时候会重新生成，不需要备份； public：是 hexo g 生成的静态网页，不需要备份； .deploy_git：同上，hexo g 也会生成，不需要备份； db.json：文件，不需要备份。 4.1 配置 _config.yml基础配置可以参考官方文档的配置说明。这里需要在末尾添加 Git 的配置： ...deploy: type: git repo: https://gitee.com/dbnuo/bnd-hexo.git branch: master message: 'web updata: {{now(\"YYYY-MM-DD HH/mm/ss\")}}' 4.2 生成页面并提交运行命令： hexo cl &amp;&amp; hexo g -d 输入用户名和密码后，页面代码就会提交至码云项目中。 将网站目录指定至 hexo 的 public 文件夹中，访问网站： cd hexo hexo s # hexo server 默认是4000端口 5.备份跳转至项目目录 bnd-hexo： git checkout -b sources # 创建切换分支 git push origin sources # 提交代码至分支 提交至码云项目分支： 至此搭建完毕，代码也备份到项目中了。为了测试备份恢复，我新建了个文章 test 并提交进行测试。 6.恢复切换至测试服务器，基础的安装和设置可以参考上面的流程。 跳转至网站的根目录： # 拉取项目至本地 git clone https://gitee.com/dbnuo/bnd-hexo.git # 跳转至目录 cd bnd-hexo # 创建分支并拉取 git checkout -b sources origin/sources # 跳转至源文件目录 cd hexo # 初始安装 npm install npm install hexo-generator-index --save npm install hexo-generator-archive --save npm install hexo-generator-category --save npm install hexo-generator-tag --save npm install hexo-server --save npm install hexo-deployer-git --save npm install hexo-deployer-heroku --save npm install hexo-deployer-rsync --save npm install hexo-deployer-openshift --save npm install hexo-renderer-marked --save npm install hexo-renderer-stylus --save npm install hexo-generator-feed --save npm install hexo-generator-sitemap --save 执行完毕，hexo 就恢复了，可以正常操作了。 7.多终端至此两台服务器都对一个项目库进行操作，可以说是多终端了，我在测试服务器新建了个文章： hexo new post “test2” 创建成功后提交上传。 切换回主服务器： # 跳转至项目目录 cd bnd-hexo # 拉取项目 git pull origin sources # 跳转至源文件目录 cd hexo/ # 重新编译 hexo cl &amp;&amp; hexo g -d 再访问网站： 看到这里出现了文章 test2 ，至此多终端编辑操作成功。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"服务器端简单Demo","slug":"服务器端简单Demo","date":"2020-07-07T05:05:00.000Z","updated":"2020-07-10T06:46:17.936Z","comments":true,"path":"2020/07/07/服务器端简单Demo/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%AE%80%E5%8D%95Demo/","excerpt":"","text":"void CSrvDemoDlg::OnBnClickedOk() { // TODO: 在此添加控件通知处理程序代码 //创建一个套接字的步骤 //定义套接字变量 SOCKET ls; //创建套接字 ls=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); //判断套接字是否成功，失败则退出 if(ls==INVALID_SOCKET){ printf(\"Error at socket():%d\\n\",WSAGetLastError()); WSACleanup(); return; } //绑定套接字和套接字地址 sockaddr_in sa; sa.sin_family=AF_INET; sa.sin_addr.S_un.S_addr=inet_addr(\"127.0.0.1\"); sa.sin_port=htons(12345); //判断是否绑定成功 if(bind(ls,(SOCKADDR*)&amp;sa,sizeof(sa))==SOCKET_ERROR){ printf(\"bind()failed.\\n\"); closesocket(ls); return; } //把套接字置入侦听状态 listen(ls,3); //接受连接请求 SOCKET snew; snew=accept(ls,NULL,NULL); char szmsg[50]; strcpy(szmsg,\"welcome to hgu.edu!\\r\\n\"); //发送数据 send(snew,szmsg,strlen(szmsg),0); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"【LeetCode】9. 回文数","slug":"【LeetCode】9. 回文数","date":"2020-06-10T03:58:00.000Z","updated":"2020-07-10T06:46:17.806Z","comments":true,"path":"2020/06/10/【LeetCode】9. 回文数/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/10/%E3%80%90LeetCode%E3%80%919.%20%E5%9B%9E%E6%96%87%E6%95%B0/","excerpt":"题目描述判断一个整数是否是回文数。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？","text":"题目描述判断一个整数是否是回文数。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 题解用数学方法直接计算出倒数 class Solution { public boolean isPalindrome(int x) { if(x &lt; 0) return false; int rec = 0; int num = x; while(num != 0) { rec = rec * 10 + num % 10; num /= 10; } return rec == x; } } 进阶 将整数转为字符串来解决动画：回文数的三种解法 | 法解种三的数文回：画动回文数 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"超星学习通脚本（油猴）","slug":"超星学习通脚本（油猴）","date":"2020-06-09T09:52:00.000Z","updated":"2020-07-10T06:46:17.942Z","comments":true,"path":"2020/06/09/超星学习通脚本（油猴）/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/09/%E8%B6%85%E6%98%9F%E5%AD%A6%E4%B9%A0%E9%80%9A%E8%84%9A%E6%9C%AC%EF%BC%88%E6%B2%B9%E7%8C%B4%EF%BC%89/","excerpt":"","text":"脚本①// ==UserScript== // @name 熊猫超星网课助手 // @namespace xiongmao // @version 9.0.1 // @description 自动挂机看尔雅MOOC，支持视频、音频、文档、图书自动完成，章节测验自动答题提交，支持自动切换任务点、挂机阅读时长、自动登录等，解除各类功能限制，开放自定义参数 // @author xiongmao // @match *://*.chaoxing.com/* // @match *://*.edu.cn/* // @connect api.xmlm8.com // @run-at document-end // @grant unsafeWindow // @grant GM_xmlhttpRequest // @grant GM_setClipboard // @license MIT // ==/UserScript== // 设置修改后，需要刷新或重新打开网课页面才会生效 var setting = { // 8E3 == 8000，科学记数法，表示毫秒数 time: 8E3 // 默认响应速度为8秒，不建议小于5秒 ,token: '' // 捐助用户可以使用定制功能，更精准的匹配答案，此处填写捐助后获取的识别码 ,review: 0 // 复习模式，完整挂机视频(音频)时长，支持挂机任务点已完成的视频和音频，默认关闭 ,queue: 1 // 队列模式，开启后任务点逐一完成，关闭则单页面所有任务点同时进行，默认开启 // 1代表开启，0代表关闭 ,video: 1 // 视频支持后台、切换窗口不暂停，支持多视频，默认开启 ,work: 0 // 自动答题功能(章节测验)，作业需要手动开启查询，高准确率，默认开启 ,audio: 1 // 音频自动播放，与视频功能共享vol和rate参数，默认开启 ,book: 1 // 图书阅读任务点，非课程阅读任务点，默认开启 ,docs: 1 // 文档阅读任务点，PPT类任务点自动完成阅读任务，默认开启 // 本区域参数，上方为任务点功能，下方为独立功能 ,jump: 1 // 自动切换任务点、章节、课程(需要配置course参数)，默认开启 ,read: '0' // 挂机课程阅读时间，单位是分钟，'65'代表挂机65分钟，请手动打开阅读页面，默认'0'分钟 ,face: 0 // 解除面部识别(不支持二维码类面部采集)，此功能仅为临时解除，默认关闭 ,total: 0 // 显示课程进度的统计数据，在学习进度页面的上方展示，默认关闭 // 仅开启video(audio)时，修改此处才会生效 ,line: '公网1' // 视频播放的默认资源线路，此功能适用于系统默认线路无资源，默认'公网1' ,http: '标清' // 视频播放的默认清晰度，无效参数则使用系统默认清晰度，默认'标清' // 本区域参数，上方为video功能独享，下方为audio功能共享 ,vol: '0' // 默认音量的百分数，设定范围：[0,100]，'0'为静音，默认'0' ,rate: '3' // 视频播放默认倍率，参数范围0∪[0.0625,16]，'0'为秒过，默认'1'倍 // 仅开启work时，修改此处才会生效 ,auto: 0 // 答题完成后自动提交，默认关闭 改为1开启 ,none: 0 // 无匹配答案时执行默认操作，关闭后若题目无匹配答案则会暂时保存已作答的题目，默认开启 ,scale: 0 // 富文本编辑器高度自动拉伸，用于文本类题目，答题框根据内容自动调整大小，默认关闭 // 仅开启jump时，修改此处才会生效 ,course: 0 // 当前课程完成后自动切换课程，仅支持按照根目录课程顺序切换，默认开启 ,lock: 1 // 跳过未开放(图标是锁)的章节，即闯关模式或定时发放的任务点，默认开启 // 自动登录功能配置区 ,school: '账号为手机号可以不修改此参数' // 学校/单位/机构码，要求完整有效可查询，例如'清华大学' ,username: '' // 学号/工号/借书证号(邮箱/手机号/账号)，例如'2018010101'，默认'' ,password: '' // 密码，例如'123456'，默认'' }, _self = unsafeWindow, url = location.pathname, top = _self; if (url != '/studyApp/studying' &amp;&amp; top != _self.top) document.domain = location.host.replace(/.+?\\./, ''); try { while (top != _self.top) { top = top.parent.document ? top.parent : _self.top; if (top.location.pathname == '/mycourse/studentstudy') break; } } catch (err) { // console.log(err); top = _self; } var $ = _self.jQuery || top.jQuery, parent = _self == top ? self : _self.parent, Ext = _self.Ext || parent.Ext || {}, UE = _self.UE, vjs = _self.videojs; String.prototype.toCDB = function() { return this.replace(/\\s/g, '').replace(/[\\uff01-\\uff5e]/g, function(str) { return String.fromCharCode(str.charCodeAt(0) - 65248); }).replace(/[“”]/g, '\"').replace(/[‘’]/g, \"'\").replace(/。/g, '.'); }; setting.normal = ''; // ':visible' // setting.time += Math.ceil(setting.time * Math.random()) - setting.time / 2; setting.job = [':not(*)']; setting.video &amp;&amp; setting.job.push('iframe[src*=\"/video/index.html\"]'); setting.work &amp;&amp; setting.job.push('iframe[src*=\"/work/index.html\"]'); setting.audio &amp;&amp; setting.job.push('iframe[src*=\"/audio/index.html\"]'); setting.book &amp;&amp; setting.job.push('iframe[src*=\"/innerbook/index.html\"]'); setting.docs &amp;&amp; setting.job.push('iframe[src*=\"/ppt/index.html\"]', 'iframe[src*=\"/pdf/index.html\"]'); setting.tip = !setting.queue || top != _self &amp;&amp; jobSort($ || Ext.query); if (url == '/mycourse/studentstudy') { _self.checkMobileBrowerLearn = $.noop; var classId = location.search.match(/cla[zs]{2}id=(\\d+)/i)[1] || 0, courseId = _self.courseId || location.search.match(/courseId=(\\d+)/i)[1] || 0; setting.lock || $('#coursetree').on('click', '[onclick*=void], [href*=void]', function() { _self.getTeacherAjax(courseId, classId, $(this).parent().attr('id').slice(3)); }); } else if (url == '/ananas/modules/video/index.html' &amp;&amp; setting.video) { if (setting.review) _self.greenligth = Ext.emptyFn; checkPlayer(_self.supportH5Video()); } else if (url == '/work/doHomeWorkNew' || url == '/api/work' || url == '/work/addStudentWorkNewWeb') { if (!UE) { var len = ($ || Ext.query || Array)('font:contains(未登录)', document).length; setTimeout(len == 1 ? top.location.reload : parent.greenligth, setting.time); } else if (setting.work) { setTimeout(relieveLimit, 0); beforeFind(); } } else if (url == '/ananas/modules/audio/index.html' &amp;&amp; setting.audio) { if (setting.review) _self.greenligth = Ext.emptyFn; _self.videojs = hookAudio; hookAudio.xhr = vjs.xhr; } else if (url == '/ananas/modules/innerbook/index.html' &amp;&amp; setting.book &amp;&amp; setting.tip) { setTimeout(function() { _self.setting ? _self.top.onchangepage(_self.getFrameAttr('end')) : _self.greenligth(); }, setting.time); } else if (url.match(/^\\/ananas\\/modules\\/(ppt|pdf)\\/index\\.html$/) &amp;&amp; setting.docs &amp;&amp; setting.tip) { setTimeout(function() { _self.setting ? _self.finishJob() : _self.greenligth(); }, setting.time); frameElement.setAttribute('download', 1); } else if (url == '/knowledge/cards') { $ &amp;&amp; checkToNext(); } else if (url.match(/^\\/(course|zt)\\/\\d+\\.html$/)) { setTimeout(function() { +setting.read &amp;&amp; _self.sendLogs &amp;&amp; $('.course_section:eq(0) .chapterText').click(); }, setting.time); } else if (url == '/ztnodedetailcontroller/visitnodedetail') { setting.read *= 60 / $('.course_section').length; setting.read &amp;&amp; _self.sendLogs &amp;&amp; autoRead(); } else if (url == '/mycourse/studentcourse') { var gv = location.search.match(/d=\\d+&amp;/g); setting.total &amp;&amp; $('&lt;a&gt;', { href: '/moocAnalysis/chapterStatisticByUser?classI' + gv[1] + 'courseI' + gv[0] + 'userId=' + _self.getCookie('_uid') + '&amp;ut=s', target: '_blank', title: '点击查看章节统计', style: 'margin: 0 25px;', html: '本课程共' + $('.icon').length + '节，剩余' + $('em:not(.openlock)').length + '节未完成' }).appendTo('.zt_logo').parent().width('auto'); } else if (url.match(/^\\/visit\\/(courses|interaction)$/)) { setting.face &amp;&amp; $('.zmodel').on('click', '[onclick^=openFaceTip]', DisplayURL); } else if (location.host.match(/^passport2/)) { setting.username &amp;&amp; getSchoolId(); } else if (location.hostname == 'i.mooc.chaoxing.com') { _self.layui.use('layer', function() { this.layer.open({content: '拖动进度条、倍速播放、秒过会导致不良记录！题库在慢慢补充，搜不到的题目系统会在次日进行自动补充', title: '超星网课助手提示', btn: '我已知悉', offset: 't', closeBtn: 0}); }); } else if (url == '/widget/pcvote/goStudentVotePage') { $(':checked').click(); $('.StudentTimu').each(function(index) { var ans = _self.questionlist[index].answer; $(':radio, :checkbox', this).each(function(num) { ans[num].isanswer &amp;&amp; this.click(); }); $(':text', this).val(function(num) { return $(ans[num].content).text().trim(); }); }); } else if (url == '/work/selectWorkQuestionYiPiYue') { submitAnswer(getIframe().parent(), $.extend(true, [], parent._data)); } function getIframe(tip, win, job) { if (!$) return Ext.get(frameElement || []).parent().child('.ans-job-icon') || Ext.get([]); do { win = win ? win.parent : _self; job = $(win.frameElement).prevAll('.ans-job-icon'); } while (!job.length &amp;&amp; win.parent.frameElement); return tip ? win : job; } function jobSort($) { var fn = $.fn ? [getIframe(1), 'length'] : [self, 'dom'], sel = setting.job.join(', :not(.ans-job-finished) &gt; .ans-job-icon' + setting.normal + ' ~ '); if ($(sel, fn[0].parent.document)[0] == fn[0].frameElement) return true; if (!getIframe()[fn[1]] || getIframe().parent().is('.ans-job-finished')) return null; setInterval(function() { $(sel, fn[0].parent.document)[0] == fn[0].frameElement &amp;&amp; fn[0].location.reload(); }, setting.time); } function checkPlayer(tip) { _self.videojs = hookVideo; hookVideo.xhr = vjs.xhr; Ext.isSogou = Ext.isIos = Ext.isAndroid = false; var data = Ext.decode(_self.config('data')) || {}; delete data.danmaku; data.doublespeed = 1; frameElement.setAttribute('data', Ext.encode(data)); if (tip) return; _self.supportH5Video = function() {return true;}; alert('此浏览器不支持html5播放器，请更换浏览器'); } function hookVideo() { _self.alert = console.log; var config = arguments[1], line = Ext.Array.filter(Ext.Array.map(config.playlines, function(value, index) { return value.label == setting.line &amp;&amp; index; }), function(value) { return Ext.isNumber(value); })[0] || 0, http = Ext.Array.filter(config.sources, function(value) { return value.label == setting.http; })[0]; config.playlines.unshift(config.playlines[line]); config.playlines.splice(line + 1, 1); config.plugins.videoJsResolutionSwitcher.default = http ? http.res : 360; config.plugins.studyControl.enableSwitchWindow = 1; config.plugins.timelineObjects.url = '/richvideo/initdatawithviewer?'; config.plugins.seekBarControl.enableFastForward = 1; if (!setting.queue) delete config.plugins.studyControl; // config.preload = setting.tip ? 'auto' : 'none'; var player = vjs.apply(this, arguments), a = '&lt;a href=\"https://d0.ananas.chaoxing.com/download/' + _self.config('objectid') + '\" target=\"_blank\"&gt;', img = '&lt;img src=\"https://d0.ananas.chaoxing.com/download/e363b256c0e9bc5bd8266bf99dd6d6bb\" style=\"margin: 6px 0 0 6px;\"&gt;'; player.volume(Math.round(setting.vol) / 100 || 0); Ext.get(player.controlBar.addChild('Button').el_).setHTML(a + img + '&lt;/a&gt;').dom.title = '下载视频'; player.on('loadstart', function() { setting.tip &amp;&amp; this.play().catch(Ext.emptyFn); this.playbackRate(setting.rate &gt; 16 || setting.rate &lt; 0.0625 ? 1 : setting.rate); }); player.one(['loadedmetadata', 'firstplay'], function() { setting.two = setting.rate === '0' &amp;&amp; setting.two &lt; 1; setting.two &amp;&amp; config.plugins.seekBarControl.sendLog(this.children_[0], 'ended', Math.floor(this.cache_.duration)); }); player.on('ended', function() { Ext.fly(frameElement).parent().addCls('ans-job-finished'); }); return player; } function hookAudio() { _self.alert = console.log; var config = arguments[1]; config.plugins.studyControl.enableSwitchWindow = 1; config.plugins.seekBarControl.enableFastForward = 1; if (!setting.queue) delete config.plugins.studyControl; var player = vjs.apply(this, arguments), a = '&lt;a href=\"https://d0.ananas.chaoxing.com/download/' + _self.config('objectid') + '\" target=\"_blank\"&gt;', img = '&lt;img src=\"https://d0.ananas.chaoxing.com/download/e363b256c0e9bc5bd8266bf99dd6d6bb\" style=\"margin: 6px 0 0 6px;\"&gt;'; player.volume(Math.round(setting.vol) / 100 || 0); player.playbackRate(setting.rate &gt; 16 || setting.rate &lt; 0.0625 ? 1 : setting.rate); Ext.get(player.controlBar.addChild('Button').el_).setHTML(a + img + '&lt;/a&gt;').dom.title = '下载音频'; player.on('loadeddata', function() { setting.tip &amp;&amp; this.play().catch(Ext.emptyFn); }); player.one('firstplay', function() { setting.rate === '0' &amp;&amp; config.plugins.seekBarControl.sendLog(this.children_[0], 'ended', Math.floor(this.cache_.duration)); }); player.on('ended', function() { Ext.fly(frameElement).parent().addCls('ans-job-finished'); }); return player; } function relieveLimit() { if (setting.scale) _self.UEDITOR_CONFIG.scaleEnabled = false; $.each(UE.instants, function() { var key = this.key; this.ready(function() { this.destroy(); UE.getEditor(key); }); }); } function beforeFind() { setting.regl = parent.greenligth || $.noop; if ($.type(parent._data) == 'array') return setting.regl(); setting.div = $( '&lt;div style=\"border: 2px dashed rgb(0, 85, 68); width: 330px; position: fixed; top: 0; right: 0; z-index: 99999; background-color: rgba(70, 196, 38, 0.6); overflow-x: auto;\"&gt;' + '&lt;span style=\"font-size: medium;\"&gt;&lt;/span&gt;' + '&lt;div style=\"font-size: medium;\"&gt;正在搜索答案...&lt;/div&gt;' + '&lt;button style=\"margin-right: 10px;\"&gt;暂停答题&lt;/button&gt;' + '&lt;button style=\"margin-right: 10px;\"&gt;' + (setting.auto ? '取消本次自动提交' : '开启本次自动提交') + '&lt;/button&gt;' + '&lt;button style=\"margin-right: 10px;\"&gt;重新查询&lt;/button&gt;' + '&lt;button&gt;折叠面板&lt;/button&gt;' + '&lt;div style=\"max-height: 300px; overflow-y: auto;\"&gt;' + '&lt;table border=\"1\" style=\"font-size: 12px;\"&gt;' + '&lt;thead&gt;' + '&lt;tr&gt;' + '&lt;th style=\"width: 25px; min-width: 25px;\"&gt;题号&lt;/th&gt;' + '&lt;th style=\"width: 60%; min-width: 130px;\"&gt;题目（点击可复制）&lt;/th&gt;' + '&lt;th style=\"min-width: 130px;\"&gt;答案（点击可复制）&lt;/th&gt;' + '&lt;/tr&gt;' + '&lt;/thead&gt;' + '&lt;tfoot style=\"display: none;\"&gt;' + '&lt;tr&gt;' + '&lt;th colspan=\"3\"&gt;答案提示框 已折叠&lt;/th&gt;' + '&lt;/tr&gt;' + '&lt;/tfoot&gt;' + '&lt;tbody&gt;' + '&lt;tr&gt;' + '&lt;td colspan=\"3\" style=\"display: none;\"&gt;&lt;/td&gt;' + '&lt;/tr&gt;' + '&lt;/tbody&gt;' + '&lt;/table&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;' ).appendTo('body').on('click', 'button, td', function() { var len = $(this).prevAll('button').length; if (this.nodeName == 'TD') { $(this).prev().length &amp;&amp; GM_setClipboard($(this).text()); } else if (!$(this).siblings().length) { $(this).parent().text('正在搜索答案...'); setting.num++; } else if (len === 0) { if (setting.loop) { clearInterval(setting.loop); delete setting.loop; len = ['已暂停搜索', '继续答题']; } else { setting.loop = setInterval(findAnswer, setting.time); len = ['正在搜索答案...', '暂停答题']; } setting.div.children('div:eq(0)').html(function() { return $(this).data('html') || len[0]; }).removeData('html'); $(this).html(len[1]); } else if (len == 1) { setting.auto = !setting.auto; $(this).html(setting.auto ? '取消本次自动提交' : '开启本次自动提交'); } else if (len == 2) { parent.location.reload(); } else if (len == 3) { setting.div.find('tbody, tfoot').toggle(); } }).find('table, td, th').css('border', '1px solid').end(); setting.lose = setting.num = 0; setting.data = parent._data = []; setting.over = '&lt;button style=\"margin-right: 10px;\"&gt;跳过此题&lt;/button&gt;'; setting.curs = $('script:contains(courseName)', top.document).text().match(/courseName:\\'(.+?)\\'|$/)[1] || $('h1').text().trim() || '无'; setting.loop = setInterval(findAnswer, setting.time); var tip = ({undefined: '任务点排队中', null: '等待切换中'})[setting.tip]; tip &amp;&amp; setting.div.children('div:eq(0)').data('html', tip).siblings('button:eq(0)').click(); } function findAnswer() { if (setting.num &gt;= $('.TiMu').length) { var arr = setting.lose ? ['共有 &lt;font color=\"red\"&gt;' + setting.lose + '&lt;/font&gt; 道题目待完善（已深色标注）', saveThis] : ['答题已完成', submitThis]; setting.div.children('div:eq(0)').data('html', arr[0]).siblings('button:eq(0)').hide().click(); return setTimeout(arr[1], setting.time); } var $TiMu = $('.TiMu').eq(setting.num), question = filterImg($TiMu.find('.Zy_TItle:eq(0) .clearfix')).replace(/^【.*?】\\s*/, '').replace(/\\s*（\\d+\\.\\d+分）$/, '').replace(/[(]\\s*[)]。$/,'').replace(/（\\s*）。$/,'').replace(/[(]\\s*[)]$/,'').replace(/（\\s*）$/,''), type = $TiMu.find('input[name^=answertype]:eq(0)').val() || '-1'; //setting.div.children('div:eq(0)').text(encodeURIComponent(question)+'正在搜索答案...'); GM_xmlhttpRequest({ method: 'GET', url: 'http://api.xmlm8.com/tp/tk.php?t='+ encodeURIComponent(question), headers: { 'Content-type': 'application/x-www-form-urlencoded' }, timeout: setting.time, onload: function(xhr) { if (!setting.loop) { } else if (xhr.status == 200) { var obj = $.parseJSON(xhr.responseText) || {}; if (obj.code == 1) { setting.div.children('div:eq(0)').text('正在搜索答案...'); var td = '&lt;td style=\"border: 1px solid;', answer = String(obj.answer).replace(/&amp;/g, '&amp;amp;').replace(/&lt;(?!img)/g, '&amp;lt;'); obj.answer = /^http/.test(answer) ? '&lt;img src=\"' + obj.answer + '\"&gt;' : obj.answer; $( '&lt;tr&gt;' + td + ' text-align: center;\"&gt;' + $TiMu.find('.Zy_TItle:eq(0) i').text().trim() + '&lt;/td&gt;' + td + '\" title=\"点击可复制\"&gt;' + (question.match('&lt;img') ? question : question.replace(/&amp;/g, '&amp;amp;').replace(/&lt;/g, '&amp;lt')) + '&lt;/td&gt;' + td + '\" title=\"点击可复制\"&gt;' + (/^http/.test(answer) ? obj.answer : '') + answer + '&lt;/td&gt;' + '&lt;/tr&gt;' ).appendTo(setting.div.find('tbody')).css('background-color', fillAnswer($TiMu.find('ul:eq(0)').find('li'), obj, type) ? '' : 'rgba(0, 150, 136, 0.6)'); setting.data[setting.num++] = { code: obj.code &gt; 0 ? 1 : 0, question: question, option: obj.answer, type: Number(type) }; } else { setting.div.children('div:eq(0)').html(setting.over + obj.answer || setting.over + '服务器繁忙，正在重试...'); } setting.div.children('span').html(obj.msg || ''); } else if (xhr.status == 403) { var html = xhr.responseText.indexOf('{') ? '请求过于频繁，建议稍后再试' : $.parseJSON(xhr.responseText).data; setting.div.children('div:eq(0)').data('html', html).siblings('button:eq(0)').click(); } else { setting.div.children('div:eq(0)').html(setting.over + '服务器异常，正在重试...'); } }, ontimeout: function() { setting.loop &amp;&amp; setting.div.children('div:eq(0)').html(setting.over + '服务器超时，正在重试...'); } }); } function fillAnswer($li, obj, type) { var $input = $li.find(':radio, :checkbox'), str = String(obj.answer).toCDB() || new Date().toString(), data = str.split(/#|\\x01|\\|/), opt = obj.opt || str, state = setting.lose; // $li.find(':radio:checked').prop('checked', false); obj.code &gt; 0 &amp;&amp; $input.each(function(index) { if (this.value == 'true') { data.join().match(/(^|,)(正确|是|对|√|T|ri)(,|$)/) &amp;&amp; this.click(); } else if (this.value == 'false') { data.join().match(/(^|,)(错误|否|错|×|F|wr)(,|$)/) &amp;&amp; this.click(); } else { var tip = filterImg($li.eq(index).find('.after')).toCDB() || new Date().toString(); Boolean($.inArray(tip, data) + 1 || (type == '1' &amp;&amp; str.indexOf(tip) + 1)) == this.checked || this.click(); } }).each(function() { if (!/^A?B?C?D?E?F?G?$/.test(opt)) return false; Boolean(opt.match(this.value)) == this.checked || this.click(); }); if (type.match(/^[013]$/)) { $input.is(':checked') || (setting.none ? ($input[Math.floor(Math.random() * $input.length)] || $()).click() : setting.lose++); } else if (type.match(/^(2|[4-9]|1[08])$/)) { data = String(obj.answer).split(/#|\\x01|\\|/); str = $li.end().find('textarea').each(function(index) { index = (obj.code &gt; 0 &amp;&amp; data[index]) || ''; UE.getEditor(this.name).setContent(index.trim()); }).length; (obj.code &gt; 0 &amp;&amp; data.length == str) || setting.none || setting.lose++; } else { setting.none || setting.lose++; } return state == setting.lose; } function saveThis() { if (!setting.auto) return setTimeout(saveThis, setting.time); setting.div.children('button:lt(3)').hide().eq(1).click(); _self.alert = console.log; $('#tempsave').click(); setting.regl(); } function submitThis() { if (!setting.auto) { } else if (!$('.Btn_blue_1:visible').length) { setting.div.children('button:lt(3)').hide().eq(1).click(); return setting.regl(); } else if ($('#confirmSubWin:visible').length) { var btn = $('#tipContent + * &gt; a').offset() || {top: 0, left: 0}, mouse = document.createEvent('MouseEvents'); btn = [btn.left + Math.ceil(Math.random() * 46), btn.top + Math.ceil(Math.random() * 26)]; mouse.initMouseEvent('click', true, true, document.defaultView, 0, 0, 0, btn[0], btn[1], false, false, false, false, 0, null); _self.event = $.extend(true, {}, mouse); delete _self.event.isTrusted; _self.form1submit(); } else { $('.Btn_blue_1')[0].click(); } setTimeout(submitThis, Math.ceil(setting.time * Math.random()) * 2); } function checkToNext() { var $tip = $(setting.job.join(', '), document).prevAll('.ans-job-icon' + setting.normal); setInterval(function() { $tip.parent(':not(.ans-job-finished)').length || setting.jump &amp;&amp; toNext(); }, setting.time); } function toNext() { var $cur = $('#cur' + $('#chapterIdid').val()), $tip = $('span.currents ~ span'), sel = setting.review ? 'html' : '.blue'; if (!$cur.has(sel).length &amp;&amp; $tip.length) return $tip.eq(0).click(); $tip = $('.roundpointStudent, .roundpoint').parent(); $tip = $tip.slice($tip.index($cur) + 1).not(':has(' + sel + ')'); $tip.not(setting.lock ? ':has(.lock)' : 'html').find('span').eq(0).click(); $tip.length || setting.course &amp;&amp; switchCourse(); } function switchCourse() { GM_xmlhttpRequest({ method: 'GET', url: '/visit/courses/study?isAjax=true&amp;fileId=0&amp;debug=', headers: { 'Referer': location.origin + '/visit/courses', 'X-Requested-With': 'XMLHttpRequest' }, onload: function(xhr) { var list = $('h3 a[target]', xhr.responseText).map(function() { return $(this).attr('href'); }), index = list.map(function(index) { return this.match(top.courseId) &amp;&amp; index; }).filter(function() { return $.isNumeric(this); })[0] + 1 || 0; setting.course = list[index] ? goCourse(list[index]) : 0; } }); } function goCourse(url) { GM_xmlhttpRequest({ method: 'GET', url: url, onload: function(xhr) { $.globalEval('location.href = \"' + $('.articlename a[href]', xhr.responseText).attr('href') + '\";'); } }); } function autoRead() { $('html, body').animate({ scrollTop: $(document).height() - $(window).height() }, Math.round(setting.read) * 1E3, function() { $('.nodeItem.r i').click(); }).one('click', '#top', function(event) { $(event.delegateTarget).stop(); }); } function DisplayURL() { _self.WAY.box.hide(); var $li = $(this).closest('li'); $.get('/visit/goToCourseByFace', { courseId: $li.find('input[name=courseId]').val(), clazzId: $li.find('input[name=classId]').val() }, function(data) { $li.find('[onclick^=openFaceTip]').removeAttr('onclick').attr({ target: '_blank', href: $(data).filter('script:last').text().match(/n\\(\"(.+?)\"/)[1] }); alert('本课程已临时解除面部识别'); }, 'html'); } function getSchoolId() { var school = /^1\\d{10}$/.test(setting.username) ? '' : setting.school; if (!isNaN(school)) return setTimeout(toLogin, setting.time, school); if (school == '账号为手机号可以不修改此参数') return alert('请修改school参数'); $.getJSON('/org/searchUnis?filter=' + encodeURI(school) + '&amp;product=44', function(data) { if (!data.result) return alert('学校查询错误'); var msg = $.grep(data.froms, function(value) { return value.name == school; })[0]; msg ? setTimeout(toLogin, setting.time, msg.schoolid) : alert('学校名称不完整'); }); } function toLogin(fid) { GM_xmlhttpRequest({ method: 'GET', url: '/api/login?name=' + setting.username + '&amp;pwd=' + setting.password + '&amp;schoolid=' + fid + '&amp;verify=0', onload: function(xhr) { var obj = $.parseJSON(xhr.responseText) || {}; obj.result ? location.href = decodeURIComponent($('#ref, #refer_0x001').val()) : alert(obj.errorMsg || 'Error'); } }); } function submitAnswer($job, data) { $job.removeClass('ans-job-finished'); data = data.length ? $(data) : $('.TiMu').map(function() { var title = filterImg($('.Zy_TItle .clearfix', this)); return { question: title.replace(/^【.*?】\\s*/, ''), type: ({单选题: 0, 多选题: 1, 填空题: 2, 判断题: 3})[title.match(/^【(.*?)】|$/)[1]] }; }); data = $.grep(data.map(function(index) { var $TiMu = $('.TiMu').eq(index); if (!($.isPlainObject(this) &amp;&amp; this.type &lt; 4 &amp;&amp; $TiMu.find('.fr').length)) { return false; } else if (this.type == 2) { var $ans = $TiMu.find('.Py_tk, .Py_answer').eq(0); if (!$TiMu.find('.cuo').length &amp;&amp; this.code) { return false; } else if (!$ans.find('.cuo').length) { this.option = $ans.find('.clearfix').map(function() { return $(this).text().trim(); }).get().join('#') || '无'; } else if (this.code) { this.code = -1; } else { return false; } } else if (this.type == 3) { var ans = $TiMu.find('.font20:last').text(); if ($TiMu.find('.cuo').length) { this.option = ({'√': '错误', '×': '正确'})[ans] || '无'; } else if (!this.code) { this.option = ({'√': '正确', '×': '错误'})[ans] || '无'; } else { return false; } } else { var text = $TiMu.find('.Py_answer &gt; span:eq(0)').text(); if ($TiMu.find('.dui').length &amp;&amp; this.code &amp;&amp; !/^A?B?C?D?E?F?G?$/.test(this.option)) { return false; } else if ($TiMu.find('.dui').length || text.match('正确答案')) { text = text.match(/[A-G]/gi) || []; this.option = $.map(text, function(value) { return filterImg($TiMu.find('.fl:contains(' + value + ') + a')); }).join('#') || '无'; this.key = text.join(''); } else if (this.code) { this.code = -1; } else { return false; } } return this; }), function(value) { return value &amp;&amp; value.option != '无'; }); setting.curs = $('script:contains(courseName)', top.document).text().match(/courseName:\\'(.+?)\\'|$/)[1] || $('h1').text().trim() || '无'; data.length &amp;&amp; GM_xmlhttpRequest({ method: 'POST', url: 'http://mooc.forestpolice.org/upload/cx/' + (setting.token || 0) + '/?workRelationId=' + $('#workId').val(), headers: { 'Content-type': 'application/x-www-form-urlencoded' }, data: 'course=' + encodeURIComponent(setting.curs) + '&amp;data=' + encodeURIComponent((Ext.encode || JSON.stringify)(data)) + '&amp;id=' + $('#jobid').val().slice(5) }); $job.addClass('ans-job-finished'); } /* function filterImg(dom) { return $(dom).clone().find('img[src]').replaceWith(function() { return $('&lt;p&gt;&lt;/p&gt;').text('&lt;img src=\"' + $(this).attr('src') + '\"&gt;'); }).end().find('iframe[src]').replaceWith(function() { return $('&lt;p&gt;&lt;/p&gt;').text('&lt;iframe src=\"' + $(this).attr('src') + '\"&gt;&lt;/irame&gt;'); }).end().text().trim(); } */ function filterImg(dom) { return $(dom).clone().find('img[src]').replaceWith(function() { return $('&lt;p&gt;&lt;/p&gt;').text(''); }).end().find('iframe[src]').replaceWith(function() { return $('&lt;p&gt;&lt;/p&gt;').text(''); }).end().text().trim(); } 脚本②超星学习通油猴脚本 // ==UserScript== // @name 超星网课助手(改)(查题可用) // @version 4.5.7 // @namespace coder_tq // @description 自动挂机看尔雅MOOC，支持视频、音频、文档、图书自动完成，章节测验自动答题提交，支持自动切换任务点、挂机阅读时长、自动登录等，解除各类功能限制，开放自定义参数 // @author coder_tq // @match *://*.chaoxing.com/* // @match *://*.edu.cn/* // @match *://*.nbdlib.cn/* // @match *://*.hnsyu.net/* // @connect cx.beaa.cn // @connect cx.icodef.com // @run-at document-end // @grant unsafeWindow // @grant GM_xmlhttpRequest // @grant GM_setValue // @grant GM_getValue // @grant GM_setClipboard // @license MIT // ==/UserScript== // 设置修改后，需要刷新或重新打开网课页面才会生效 var setting = { // 5E3 == 5000，科学记数法，表示毫秒数 time: 5E3 // 默认响应速度为5秒，不建议小于5秒 ,token: '' // token可以增加并发次数，用来打码，采集题库奖励 ,review: 0 // 复习模式，完整挂机视频(音频)时长，支持挂机任务点已完成的视频和音频，默认关闭 ,queue: 1 // 队列模式，开启后任务点逐一完成，关闭则单页面所有任务点同时进行，默认开启 // 1代表开启，0代表关闭 ,video: 1 // 视频支持后台、切换窗口不暂停，支持多视频，默认开启 ,work: 0 // 自动答题功能(章节测验)，作业需要手动开启查询，高准确率，默认开启 ,audio: 1 // 音频自动播放，与视频功能共享vol和rate参数，默认开启 ,book: 1 // 图书阅读任务点，非课程阅读任务点，默认开启 ,docs: 1 // 文档阅读任务点，PPT类任务点自动完成阅读任务，默认开启 // 本区域参数，上方为任务点功能，下方为独立功能 ,jump: 1 // 自动切换任务点、章节、课程(需要配置course参数)，默认开启 ,read: '65' // 挂机课程阅读时间，单位是分钟，'65'代表挂机65分钟，请手动打开阅读页面，默认'65'分钟 ,face: 1 // 解除面部识别(不支持二维码类面部采集)，此功能仅为临时解除，默认开启 ,total: 1 // 显示课程进度的统计数据，在学习进度页面的上方展示，默认开启 // 仅开启video(audio)时，修改此处才会生效 ,line: '公网1' // 视频播放的默认资源线路，此功能适用于系统默认线路无资源，默认'公网1' ,http: '标清' // 视频播放的默认清晰度，无效参数则使用系统默认清晰度，默认'标清' // 本区域参数，上方为video功能独享，下方为audio功能共享 ,vol: '0' // 默认音量的百分数，设定范围：[0,100]，'0'为静音，默认'0' ,rate: '3' // 视频播放默认倍率，参数范围0∪[0.0625,16]，'0'为秒过，默认'1'倍 // 仅开启work时，修改此处才会生效 ,auto: 0 // 答题完成后自动提交，默认关闭 ,none: 0 // 无匹配答案时执行默认操作，关闭后若题目无匹配答案则会暂时保存已作答的题目，默认开启 ,scale: 0 // 富文本编辑器高度自动拉伸，用于文本类题目，答题框根据内容自动调整大小，默认关闭 // 仅开启jump时，修改此处才会生效 ,course: 0 // 当前课程完成后自动切换课程，仅支持按照根目录课程顺序切换，默认开启 ,lock: 1 // 跳过未开放(图标是锁)的章节，即闯关模式或定时发放的任务点，默认开启 // 自动登录功能配置区 ,school: '账号为手机号可以不修改此参数' // 学校/单位/机构码，要求完整有效可查询，例如'清华大学' ,username: '' // 学号/工号/借书证号(邮箱/手机号/账号)，例如'2018010101'，默认'' ,password: '' // 密码，例如'123456'，默认'' // 题库接口配置区 ,tk_num: 0 // 题库接口，默认0 }, _self = unsafeWindow, url = location.pathname, top = _self; setting.tk_num = GM_getValue('tk_num'); setting.tk_num = setting.tk_num == undefined ? 1:setting.tk_num; setting.tk_num = isNaN(setting.tk_num)? 1:setting.tk_num; if (url != '/studyApp/studying' &amp;&amp; top != _self.top) document.domain = location.host.replace(/.+?\\./, ''); try { while (top != _self.top) { top = top.parent.document ? top.parent : _self.top; if (top.location.pathname == '/mycourse/studentstudy') break; } } catch (err) { // console.log(err); top = _self; } var $ = _self.jQuery || top.jQuery, parent = _self == top ? self : _self.parent, Ext = _self.Ext || parent.Ext || {}, UE = _self.UE, vjs = _self.videojs; String.prototype.toCDB = function() { return this.replace(/\\s/g, '').replace(/[\\uff01-\\uff5e]/g, function(str) { return String.fromCharCode(str.charCodeAt(0) - 65248); }).replace(/[“”]/g, '\"').replace(/[‘’]/g, \"'\").replace(/。/g, '.'); }; setting.normal = ''; // ':visible' // setting.time += Math.ceil(setting.time * Math.random()) - setting.time / 2; setting.job = [':not(*)']; setting.video &amp;&amp; setting.job.push('iframe[src*=\"/video/index.html\"]'); setting.work &amp;&amp; setting.job.push('iframe[src*=\"/work/index.html\"]'); setting.audio &amp;&amp; setting.job.push('iframe[src*=\"/audio/index.html\"]'); setting.book &amp;&amp; setting.job.push('iframe[src*=\"/innerbook/index.html\"]'); setting.docs &amp;&amp; setting.job.push('iframe[src*=\"/ppt/index.html\"]', 'iframe[src*=\"/pdf/index.html\"]'); setting.tip = !setting.queue || top != _self &amp;&amp; jobSort($ || Ext.query); if (url == '/mycourse/studentstudy') { _self.checkMobileBrowerLearn = $.noop; var classId = location.search.match(/cla[zs]{2}id=(\\d+)/i)[1] || 0, courseId = _self.courseId || location.search.match(/courseId=(\\d+)/i)[1] || 0; setting.lock || $('#coursetree').on('click', '[onclick*=void], [href*=void]', function() { _self.getTeacherAjax(courseId, classId, $(this).parent().attr('id').slice(3)); }); } else if (url == '/ananas/modules/video/index.html' &amp;&amp; setting.video) { if (setting.review) _self.greenligth = Ext.emptyFn; checkPlayer(_self.supportH5Video()); } else if (url == '/work/doHomeWorkNew' || url == '/api/work' || url == '/work/addStudentWorkNewWeb') { if (!UE) { var len = ($ || Ext.query || Array)('font:contains(未登录)', document).length; setTimeout(len == 1 ? top.location.reload : parent.greenligth, setting.time); } else if (setting.work) { setTimeout(relieveLimit, 0); beforeFind(); } } else if (url == '/ananas/modules/audio/index.html' &amp;&amp; setting.audio) { if (setting.review) _self.greenligth = Ext.emptyFn; _self.videojs = hookAudio; hookAudio.xhr = vjs.xhr; } else if (url == '/ananas/modules/innerbook/index.html' &amp;&amp; setting.book &amp;&amp; setting.tip) { setTimeout(function() { _self.setting ? _self.top.onchangepage(_self.getFrameAttr('end')) : _self.greenligth(); }, setting.time); } else if (url.match(/^\\/ananas\\/modules\\/(ppt|pdf)\\/index\\.html$/) &amp;&amp; setting.docs &amp;&amp; setting.tip) { setTimeout(function() { _self.setting ? _self.finishJob() : _self.greenligth(); }, setting.time); frameElement.setAttribute('download', 1); } else if (url == '/knowledge/cards') { $ &amp;&amp; checkToNext(); } else if (url.match(/^\\/(course|zt)\\/\\d+\\.html$/)) { setTimeout(function() { +setting.read &amp;&amp; _self.sendLogs &amp;&amp; $('.course_section:eq(0) .chapterText').click(); }, setting.time); } else if (url == '/ztnodedetailcontroller/visitnodedetail') { setting.read *= 60 / $('.course_section').length; setting.read &amp;&amp; _self.sendLogs &amp;&amp; autoRead(); } else if (url == '/mycourse/studentcourse') { var gv = location.search.match(/d=\\d+&amp;/g); setting.total &amp;&amp; $('&lt;a&gt;', { href: '/moocAnalysis/chapterStatisticByUser?classI' + gv[1] + 'courseI' + gv[0] + 'userId=' + _self.getCookie('_uid') + '&amp;ut=s', target: '_blank', title: '点击查看章节统计', style: 'margin: 0 25px;', html: '本课程共' + $('.icon').length + '节，剩余' + $('em:not(.openlock)').length + '节未完成' }).appendTo('.zt_logo').parent().width('auto'); } else if (url.match(/^\\/visit\\/(courses|interaction)$/)) { setting.face &amp;&amp; $('.zmodel').on('click', '[onclick^=openFaceTip]', DisplayURL); } else if (location.host.match(/^passport2/)) { setting.username &amp;&amp; getSchoolId(); } else if (location.hostname == 'i.mooc.chaoxing.com') { _self.layui.use('layer', function() { this.layer.open({content: '拖动进度条、倍速播放、秒过会导致不良记录！题库在慢慢补充，搜不到的题目系统会在次日进行自动补充', title: '超星网课助手提示', btn: '我已知悉', offset: 't', closeBtn: 0}); }); } else if (url == '/widget/pcvote/goStudentVotePage') { $(':checked').click(); $('.StudentTimu').each(function(index) { var ans = _self.questionlist[index].answer; $(':radio, :checkbox', this).each(function(num) { ans[num].isanswer &amp;&amp; this.click(); }); $(':text', this).val(function(num) { return $(ans[num].content).text().trim(); }); }); } else if (url == '/work/selectWorkQuestionYiPiYue') { submitAnswer(getIframe().parent(), $.extend(true, [], parent._data)); } function getIframe(tip, win, job) { if (!$) return Ext.get(frameElement || []).parent().child('.ans-job-icon') || Ext.get([]); do { win = win ? win.parent : _self; job = $(win.frameElement).prevAll('.ans-job-icon'); } while (!job.length &amp;&amp; win.parent.frameElement); return tip ? win : job; } function jobSort($) { var fn = $.fn ? [getIframe(1), 'length'] : [self, 'dom'], sel = setting.job.join(', :not(.ans-job-finished) &gt; .ans-job-icon' + setting.normal + ' ~ '); if ($(sel, fn[0].parent.document)[0] == fn[0].frameElement) return true; if (!getIframe()[fn[1]] || getIframe().parent().is('.ans-job-finished')) return null; setInterval(function() { $(sel, fn[0].parent.document)[0] == fn[0].frameElement &amp;&amp; fn[0].location.reload(); }, setting.time); } function checkPlayer(tip) { _self.videojs = hookVideo; hookVideo.xhr = vjs.xhr; Ext.isSogou = Ext.isIos = Ext.isAndroid = false; var data = Ext.decode(_self.config('data')) || {}; delete data.danmaku; data.doublespeed = 1; frameElement.setAttribute('data', Ext.encode(data)); if (tip) return; _self.supportH5Video = function() {return true;}; alert('此浏览器不支持html5播放器，请更换浏览器'); } function hookVideo() { _self.alert = console.log; var config = arguments[1], line = Ext.Array.filter(Ext.Array.map(config.playlines, function(value, index) { return value.label == setting.line &amp;&amp; index; }), function(value) { return Ext.isNumber(value); })[0] || 0, http = Ext.Array.filter(config.sources, function(value) { return value.label == setting.http; })[0]; config.playlines.unshift(config.playlines[line]); config.playlines.splice(line + 1, 1); config.plugins.videoJsResolutionSwitcher.default = http ? http.res : 360; config.plugins.studyControl.enableSwitchWindow = 1; config.plugins.timelineObjects.url = '/richvideo/initdatawithviewer?'; config.plugins.seekBarControl.enableFastForward = 1; if (!setting.queue) delete config.plugins.studyControl; // config.preload = setting.tip ? 'auto' : 'none'; var player = vjs.apply(this, arguments), a = '&lt;a href=\"https://d0.ananas.chaoxing.com/download/' + _self.config('objectid') + '\" target=\"_blank\"&gt;', img = '&lt;img src=\"https://d0.ananas.chaoxing.com/download/e363b256c0e9bc5bd8266bf99dd6d6bb\" style=\"margin: 6px 0 0 6px;\"&gt;'; player.volume(Math.round(setting.vol) / 100 || 0); Ext.get(player.controlBar.addChild('Button').el_).setHTML(a + img + '&lt;/a&gt;').dom.title = '下载视频'; player.on('loadstart', function() { setting.tip &amp;&amp; this.play().catch(Ext.emptyFn); this.playbackRate(setting.rate &gt; 16 || setting.rate &lt; 0.0625 ? 1 : setting.rate); }); player.one(['loadedmetadata', 'firstplay'], function() { setting.two = setting.rate === '0' &amp;&amp; setting.two &lt; 1; setting.two &amp;&amp; config.plugins.seekBarControl.sendLog(this.children_[0], 'ended', Math.floor(this.cache_.duration)); }); player.on('ended', function() { Ext.fly(frameElement).parent().addCls('ans-job-finished'); }); return player; } function hookAudio() { _self.alert = console.log; var config = arguments[1]; config.plugins.studyControl.enableSwitchWindow = 1; config.plugins.seekBarControl.enableFastForward = 1; if (!setting.queue) delete config.plugins.studyControl; var player = vjs.apply(this, arguments), a = '&lt;a href=\"https://d0.ananas.chaoxing.com/download/' + _self.config('objectid') + '\" target=\"_blank\"&gt;', img = '&lt;img src=\"https://d0.ananas.chaoxing.com/download/e363b256c0e9bc5bd8266bf99dd6d6bb\" style=\"margin: 6px 0 0 6px;\"&gt;'; player.volume(Math.round(setting.vol) / 100 || 0); player.playbackRate(setting.rate &gt; 16 || setting.rate &lt; 0.0625 ? 1 : setting.rate); Ext.get(player.controlBar.addChild('Button').el_).setHTML(a + img + '&lt;/a&gt;').dom.title = '下载音频'; player.on('loadeddata', function() { setting.tip &amp;&amp; this.play().catch(Ext.emptyFn); }); player.one('firstplay', function() { setting.rate === '0' &amp;&amp; config.plugins.seekBarControl.sendLog(this.children_[0], 'ended', Math.floor(this.cache_.duration)); }); player.on('ended', function() { Ext.fly(frameElement).parent().addCls('ans-job-finished'); }); return player; } function relieveLimit() { if (setting.scale) _self.UEDITOR_CONFIG.scaleEnabled = false; $.each(UE.instants, function() { var key = this.key; this.ready(function() { this.destroy(); UE.getEditor(key); }); }); } function beforeFind() { setting.regl = parent.greenligth || $.noop; if ($.type(parent._data) == 'array') return setting.regl(); setting.div = $( '&lt;div style=\"border: 2px dashed rgb(0, 85, 68); width: 330px; position: fixed; top: 0; right: 0; z-index: 99999; background-color: rgba(70, 196, 38, 0.6); overflow-x: auto;\"&gt;' + '&lt;span style=\"font-size: medium;\"&gt;&lt;/span&gt;' + '&lt;div style=\"font-size: medium;\"&gt;正在搜索答案...&lt;/div&gt;' + '&lt;button style=\"margin-right: 10px;\"&gt;暂停答题&lt;/button&gt;' + '&lt;button style=\"margin-right: 10px;\"&gt;' + (setting.auto ? '取消本次自动提交' : '开启本次自动提交') + '&lt;/button&gt;' + '&lt;button style=\"margin-right: 10px;\"&gt;重新查询&lt;/button&gt;' + '&lt;button&gt;折叠面板&lt;/button&gt;&lt;br&gt;' + '&lt;div style=\"font-size: medium;\"&gt;当前查题接口:'+ (setting.tk_num%2+1) + '&lt;/div&gt;' + '&lt;button id = \"next_tk\"&gt;切换为下一个查题接口&lt;/button&gt;' + '&lt;div style=\"max-height: 300px; overflow-y: auto;\"&gt;' + '&lt;table border=\"1\" style=\"font-size: 12px;\"&gt;' + '&lt;thead&gt;' + '&lt;tr&gt;' + '&lt;th style=\"width: 25px; min-width: 25px;\"&gt;题号&lt;/th&gt;' + '&lt;th style=\"width: 60%; min-width: 130px;\"&gt;题目（点击可复制）&lt;/th&gt;' + '&lt;th style=\"min-width: 130px;\"&gt;答案（点击可复制）&lt;/th&gt;' + '&lt;/tr&gt;' + '&lt;/thead&gt;' + '&lt;tfoot style=\"display: none;\"&gt;' + '&lt;tr&gt;' + '&lt;th colspan=\"3\"&gt;答案提示框 已折叠&lt;/th&gt;' + '&lt;/tr&gt;' + '&lt;/tfoot&gt;' + '&lt;tbody&gt;' + '&lt;tr&gt;' + '&lt;td colspan=\"3\" style=\"display: none;\"&gt;&lt;/td&gt;' + '&lt;/tr&gt;' + '&lt;/tbody&gt;' + '&lt;/table&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;' ).appendTo('body').on('click', 'button, td', function() { var len = $(this).prevAll('button').length; if (this.nodeName == 'TD') { $(this).prev().length &amp;&amp; GM_setClipboard($(this).text()); } else if (!$(this).siblings().length) { $(this).parent().text('正在搜索答案...'); setting.num++; } else if (len === 0) { if (setting.loop) { clearInterval(setting.loop); delete setting.loop; len = ['已暂停搜索', '继续答题']; } else { setting.loop = setInterval(findAnswer, setting.time); len = ['正在搜索答案...', '暂停答题']; } setting.div.children('div:eq(0)').html(function() { return $(this).data('html') || len[0]; }).removeData('html'); $(this).html(len[1]); } else if (len == 1) { setting.auto = !setting.auto; $(this).html(setting.auto ? '取消本次自动提交' : '开启本次自动提交'); } else if (len == 2) { parent.location.reload(); } else if (len == 3) { setting.div.find('tbody, tfoot').toggle(); } else if (len == 4) { setting.tk_num++; GM_setValue('tk_num',setting.tk_num); setting.tk_num = GM_getValue('tk_num'); console.log(setting.tk_num); parent.location.reload(); } }).find('table, td, th').css('border', '1px solid').end(); setting.lose = setting.num = 0; setting.data = parent._data = []; setting.over = '&lt;button style=\"margin-right: 10px;\"&gt;跳过此题&lt;/button&gt;'; setting.curs = $('script:contains(courseName)', top.document).text().match(/courseName:\\'(.+?)\\'|$/)[1] || $('h1').text().trim() || '无'; setting.loop = setInterval(findAnswer, setting.time); var tip = ({undefined: '任务点排队中', null: '等待切换中'})[setting.tip]; tip &amp;&amp; setting.div.children('div:eq(0)').data('html', tip).siblings('button:eq(0)').click(); } function findAnswer() { if (setting.num &gt;= $('.TiMu').length) { var arr = setting.lose ? ['共有 &lt;font color=\"red\"&gt;' + setting.lose + '&lt;/font&gt; 道题目待完善（已深色标注）', saveThis] : ['答题已完成', submitThis]; setting.div.children('div:eq(0)').data('html', arr[0]).siblings('button:eq(0)').hide().click(); return setTimeout(arr[1], setting.time); } var $TiMu = $('.TiMu').eq(setting.num), question = filterImg($TiMu.find('.Zy_TItle:eq(0) .clearfix')).replace(/^【.*?】\\s*/, '').replace(/\\s*（\\d+\\.\\d+分）$/, '').replace(/[(]\\s*[)]。$/,'').replace(/（\\s*）。$/,'').replace(/[(]\\s*[)]$/,'').replace(/（\\s*）$/,'').replace(/。$/,''), type = $TiMu.find('input[name^=answertype]:eq(0)').val() || '-1'; //setting.div.children('div:eq(0)').text(encodeURIComponent(question)+'正在搜索答案...'); switch(setting.tk_num%2) { case 0:{ GM_xmlhttpRequest({ method: 'POST', url: 'http://cx.icodef.com/wyn-nb', headers: { 'Content-type': 'application/x-www-form-urlencoded', 'Authorization': setting.token, }, data: 'question=' + encodeURIComponent(question) + '&amp;type=' + type + '&amp;id=' + ($('#workLibraryId').val() || $('#oldWorkId').val()), timeout: setting.time, onload: function(xhr) { if (!setting.loop) { } else if (xhr.status == 200) { var obj = $.parseJSON(xhr.responseText) || {}; obj.answer = obj.data; if (obj.code) { setting.div.children('div:eq(0)').text('正在搜索答案...'); var td = '&lt;td style=\"border: 1px solid;', answer = String(obj.answer).replace(/&amp;/g, '&amp;amp;').replace(/&lt;(?!img)/g, '&amp;lt;'); obj.answer = /^http/.test(answer) ? '&lt;img src=\"' + obj.answer + '\"&gt;' : obj.answer; $( '&lt;tr&gt;' + td + ' text-align: center;\"&gt;' + $TiMu.find('.Zy_TItle:eq(0) i').text().trim() + '&lt;/td&gt;' + td + '\" title=\"点击可复制\"&gt;' + (question.match('&lt;img') ? question : question.replace(/&amp;/g, '&amp;amp;').replace(/&lt;/g, '&amp;lt')) + '&lt;/td&gt;' + td + '\" title=\"点击可复制\"&gt;' + (/^http/.test(answer) ? obj.answer : '') + answer + '&lt;/td&gt;' + '&lt;/tr&gt;' ).appendTo(setting.div.find('tbody')).css('background-color', fillAnswer($TiMu.find('ul:eq(0)').find('li'), obj, type) ? '' : 'rgba(0, 150, 136, 0.6)'); setting.data[setting.num++] = { code: obj.code &gt; 0 ? 1 : 0, question: question, option: obj.answer, type: Number(type) }; } else { setting.div.children('div:eq(0)').html(obj.answer || setting.over + '服务器繁忙，正在重试...'); } setting.div.children('span').html(obj.msg || ''); } else if (xhr.status == 403) { var html = xhr.responseText.indexOf('{') ? '请求过于频繁，单击下面的切换题库接口按钮试试吧' : $.parseJSON(xhr.responseText).data; setting.div.children('div:eq(0)').data('html', html).siblings('button:eq(0)').click(); } else { setting.div.children('div:eq(0)').html('题库异常，单击下面的切换题库接口按钮试试吧...'); } }, ontimeout: function() { setting.loop &amp;&amp; setting.div.children('div:eq(0)').html(setting.over + '服务器超时，正在重试...'); } }); }; break; case 1:{ GM_xmlhttpRequest({ method: 'POST', url: 'http://cx.beaa.cn/cx.php', headers: { 'Content-type': 'application/x-www-form-urlencoded', }, data: 'content=' + encodeURIComponent(question.replace(/^&lt;img src=\"/,\"\").replace(/\"&gt;$/,\"\")), timeout: setting.time, onload: function(xhr) { if (!setting.loop) { } else if (xhr.status == 200) { var obj = $.parseJSON(xhr.responseText.replace(/^操作数据失败！/,'')) || {}; if (obj.code) { setting.div.children('div:eq(0)').text('正在搜索答案...'); var td = '&lt;td style=\"border: 1px solid;', answer = S document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Beyond Compare 4解除到期限制的技巧","slug":"Beyond Compare 4解除到期限制的技巧","date":"2020-06-08T14:50:00.000Z","updated":"2020-07-10T06:46:17.181Z","comments":true,"path":"2020/06/08/Beyond Compare 4解除到期限制的技巧/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/08/Beyond%20Compare%204%E8%A7%A3%E9%99%A4%E5%88%B0%E6%9C%9F%E9%99%90%E5%88%B6%E7%9A%84%E6%8A%80%E5%B7%A7/","excerpt":"如果提示 这个授权密钥已被吊销 ，删除 C:\\Users\\Administrator\\AppData\\Roaming\\Scooter Software\\Beyond Compare 4 目录下的文件即可（将Administrator换成自己的用户名） 如果没有输入激活码，且试用30天已到期，可以删除安装目录下 的 BCUnrar.dll 文件，发现又可以使用了，不过依然是试用。也可以删除注册表 \\HKEY_CURRENT_USER\\Software\\ScooterSoftware\\Beyond Compare 4\\CacheId ，也能够继续使用，且不会到期。","text":"如果提示 这个授权密钥已被吊销 ，删除 C:\\Users\\Administrator\\AppData\\Roaming\\Scooter Software\\Beyond Compare 4 目录下的文件即可（将Administrator换成自己的用户名） 如果没有输入激活码，且试用30天已到期，可以删除安装目录下 的 BCUnrar.dll 文件，发现又可以使用了，不过依然是试用。也可以删除注册表 \\HKEY_CURRENT_USER\\Software\\ScooterSoftware\\Beyond Compare 4\\CacheId ，也能够继续使用，且不会到期。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Java 常用资源工具集合","slug":"Java 常用资源工具集合","date":"2020-06-08T06:14:00.000Z","updated":"2020-07-10T06:46:17.294Z","comments":true,"path":"2020/06/08/Java 常用资源工具集合/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/08/Java%20%E5%B8%B8%E7%94%A8%E8%B5%84%E6%BA%90%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/","excerpt":"来源：http://rrd.me/emdDq","text":"来源：http://rrd.me/emdDq 搜索资源网站学习技术过程我们经常需要使用搜索引擎来检索资料，国内常用的也就是某度了。 当然有条件的话，搜索引擎首先还是推荐使用 Google，如果没办法使用，可以使用以下几个作为备用： BingBing 国际版：https://cn.bing.com/ 比某度好用，之前还被停用了几天，最近可以了。 DuckDuckGoDuckDuckGo：https://duckduckgo.com/ 从官网的介绍来看这个搜索引擎不收集用户信息，而且没有广告。 Stack OverflowStack Overflow：https://stackoverflow.com/ 我们如果常用 Google，很多技术问题的答案就在这个网站上，如果你无法使用 Google 可以在这个网站上直接检索就好了。 GitlogsGitlogs：https://www.gitlogs.com/ Gitlogs 是专门针对 GitHub 项目的搜索引擎，我们通过他可以快速找到想要项目。 jiumo search文档搜索引擎 jiumo search 鸠摩搜书：https://www.jiumodiary.com/ 可以用来找一些技术文档手册，很多在百度网盘里。 EbookeEbooke：https://ebookee.org/ Ebookee 是一个基于互联网并提供免费电子图书下载的搜索引擎网站。 Iconfinder图标搜索：https://www.iconfinder.com/ 用来查找 logo 图片。 TinEyeTinEye：https://www.tineye.com 用图片来检索图片，我们可以上传图片或输入图片的 URL 来检索。 SemanticScholarSemanticScholar：https://www.semanticscholar.org/ SemanticScholar 是一个免费学术搜索引擎，其检索结果来自于期刊、学术会议资料或者是学术机构的文献。 LibreStockLibreStock：https://librestock.com/ LibreStock 上可以检索一些优质的高清图片。 CC SearchCC Search：https://ccsearch.creativecommons.org/ CC Search 上搜索到的图片资源都是无版权的，我们可以免费的使用。 PexelsPexels：https://www.pexels.com/ 高质量的图片网站，可以免费使用。 UnsplashUnsplash：https://unsplash.com/ 免费高清素材网站。 The App StoreThe App Store：https://theappstore.org/ The App Store 是一个针对苹果手机、iPad、Mac 设备的应用搜索工具。 工具类图片相关工具TinyPNG：https://tinypng.com/ 免费的在线图片压缩工具，压缩率高，无损画质，直接拖拽使用，很方便。 picdiet：https://www.picdiet.com/zh-cn 独特且强悍的JavaScript 算法，能极速压缩 80% 的图片大小，而不损害其质量。 SmartResize： https://www.smartresize.com/zh-cn 这个工具基于 javascript+HTML5 编写而成的，是一个批量裁剪缩放图片的神器！ 正则表达式相关工具以下两个工具以图形的方式来展示正则表达式，更易于理解： https://regexr.com/ https://jex.im/regulex/#!flags=&amp;re=%5E(a%7Cb)*%3F%24 文件转换转换工具以下资源支持各种格式（PDF、图片、Word）相互转换。 https://smallpdf.com/cn https://convertio.co/zh/ https://www.online-convert.com/ https://www.pdftoword.com/ https://tools.pdf24.org/zh/ https://cn.office-converter.com/ 在线编译器包含前后端（php、java、c等）都可以在线运行测试 https://rextester.com/ https://www.onlinegdb.com/ https://c.runoob.com/ HTML、CSS、JS、设计类的工具JSFiddle: https://jsfiddle.net/ CodePen: https://codepen.io/ Runoob: https://c.runoob.com/front-end/61 JSON 解析器: https://c.runoob.com/front-end/53 在线 PS: http://www.kantu.com/ 表格转换工具: https://tableconvert.com/ 支持的 Markdown、HTML table、CSV 和 Excel 的相互转换。 DesignCap: https://www.designcap.com/ 在线设计海报，内置众多模板及素材。 思维导图工具推荐几款绘图工具： Xmind：https://www.xmind.cn/ 跨平台、跨终端，拥有全功能的思维导图软件。 ProcessOn：https://www.processon.com/ 免费在线作图，实时协作，支持流程图、思维导图、原型图、UML、网络拓扑图、组织结构图等。 MindMaster：https://www.edrawsoft.cn/mindmaster/ 多平台思维导图软件，可用于Windows，Mac和Linux等桌面环境，也可以在线使用或在苹果，安卓等移动端上使用。 MindMeister：https://www.mindmeister.com/zh 在线思维导图工具，已有超过1000万个用户。 百度脑图：http://naotu.baidu.com/ 简洁的在线思维导图工具 Gliffy：https://www.gliffy.com/ 我们可以在 Chrome 浏览器上安装 gliffy 插件。 可以在线创建流程图、UML图、线框图、BPNM、组织架构图等。 文档笔记平台推荐几个常用的国内外云笔记平台，比较常用的应该是印象、有道、石墨，有一些国外的访问速度比较慢，影响体验。 现在用云笔记的人应该蛮多的，可以总结归纳自己的一些知识储备或者相关的业务资料，加上他们自带的跨平台特性，用起来还是很方便的。 印象笔记：https://www.yinxiang.com/ 有道笔记：https://note.youdao.com/ OneNote：https://www.onenote.com/ 幕布：https://mubu.com/ 为知笔记：https://www.wiz.cn/ 石墨文档：https://shimo.im/ Google keep：https://keep.google.com/ Simplenote：https://simplenote.com/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java比较两个List集合的方法","slug":"Java实现比较两个List集合是否相等","date":"2020-06-08T05:27:00.000Z","updated":"2020-07-10T06:46:17.505Z","comments":true,"path":"2020/06/08/Java实现比较两个List集合是否相等/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/08/Java%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAList%E9%9B%86%E5%90%88%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/","excerpt":"","text":"/** * 比较两个List集合是否相等 * &lt;p&gt;注：1. 如果一个List的引用为&lt;code&gt;null&lt;/code&gt;，或者其包含的元素个数为0，那么该List在本逻辑处理中都算作空； * &lt;p&gt;2. 泛型参数E涉及到对象，所以需要确保正确实现了对应对象的&lt;code&gt;equal()&lt;/code&gt;方法。 * @param list1 * @param list2 * @return */ public static &lt;E&gt;boolean isListEqual(List&lt;E&gt; list1, List&lt;E&gt; list2) { // 两个list引用相同（包括两者都为空指针的情况） if (list1 == list2) { return true; } // 两个list都为空（包括空指针、元素个数为0） if ((list1 == null &amp;&amp; list2 != null &amp;&amp; list2.size() == 0) || (list2 == null &amp;&amp; list1 != null &amp;&amp; list1.size() == 0)) { return true; } // 两个list元素个数不相同 if (list1.size() != list2.size()) { return false; } // 两个list元素个数已经相同，再比较两者内容 // 采用这种可以忽略list中的元素的顺序 // 涉及到对象的比较是否相同时，确保实现了equals()方法 if (!list1.containsAll(list2)) { return false; } return true; } 参考参考文章两个List比较内容是否一样和Java判断2个List集合是否相等(不考虑元素的顺序)写的，主要对文章讲到的比较算法的具体实现进行了完善改造。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java比较两个List集合的方法","slug":"Java比较两个List集合的方法","date":"2020-06-08T05:25:00.000Z","updated":"2020-07-10T06:46:17.507Z","comments":true,"path":"2020/06/08/Java比较两个List集合的方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/08/Java%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAList%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.List; import java.util.Set; public class FindNumber { public static void main(String[] args) { // 注意：一定要使用创建对象的格式创建数组 Integer[] a = new Integer[] { 6, 3, 9, 3, 2, 4, 5, 7 }; Integer[] b = new Integer[] { 5, 8, 6, 2, 1, 9 }; List _a = Arrays.asList(a); List _b = Arrays.asList(b); // 创建集合 Collection realA = new ArrayList&lt;Integer&gt;(_a); Collection realB = new ArrayList&lt;Integer&gt;(_b); // 求交集 realA.retainAll(realB); System.out.println(\"交集结果：\" + realA); Set result = new HashSet(); // 求全集 result.addAll(_a); result.addAll(_b); System.out.println(\"全集结果：\" + result); // 求差集：结果 Collection aa = new ArrayList(realA); Collection bb = new ArrayList(result); bb.removeAll(aa); System.out.println(\"最终结果：\" + bb); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"【LeetCode】192周赛-5428. 重新排列数组","slug":"【LeetCode】192周赛-5428. 重新排列数组","date":"2020-06-07T03:16:00.000Z","updated":"2020-07-10T06:46:17.750Z","comments":true,"path":"2020/06/07/【LeetCode】192周赛-5428. 重新排列数组/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/07/%E3%80%90LeetCode%E3%80%91192%E5%91%A8%E8%B5%9B-5428.%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/","excerpt":"题目来自【192场周赛】 题目描述 重新排列数组 题目难度：Easy 给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。 请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。 示例 1： 输入：nums = [2,5,1,3,4,7], n = 3 输出：[2,3,5,4,1,7] 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7] 示例 2： 输入：nums = [1,2,3,4,4,3,2,1], n = 4 输出：[1,4,2,3,3,2,4,1] 示例 3： 输入：nums = [1,1,2,2], n = 2 输出：[1,2,1,2] 提示： 1 &lt;= n &lt;= 500 nums.length == 2n 1 &lt;= nums[i] &lt;= 10^3","text":"题目来自【192场周赛】 题目描述 重新排列数组 题目难度：Easy 给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。 请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。 示例 1： 输入：nums = [2,5,1,3,4,7], n = 3 输出：[2,3,5,4,1,7] 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7] 示例 2： 输入：nums = [1,2,3,4,4,3,2,1], n = 4 输出：[1,4,2,3,3,2,4,1] 示例 3： 输入：nums = [1,1,2,2], n = 2 输出：[1,2,1,2] 提示： 1 &lt;= n &lt;= 500 nums.length == 2n 1 &lt;= nums[i] &lt;= 10^3 题解思路贼简单，直接上代码： class Solution { public int[] shuffle(int[] nums, int n) { int count = (nums.length)/n; // 每轮的元素个数,n轮 int[] res = new int[nums.length]; int index = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0;j &lt;count; j++) { res[index] = nums[i + n * j]; ++index; } } return res; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode】面试题29. 顺时针打印矩阵","slug":"【LeetCode】面试题29. 顺时针打印矩阵","date":"2020-06-05T04:13:00.000Z","updated":"2020-07-10T06:46:17.848Z","comments":true,"path":"2020/06/05/【LeetCode】面试题29. 顺时针打印矩阵/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/05/%E3%80%90LeetCode%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9829.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/","excerpt":"题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制： 0 &lt;= matrix.length &lt;= 100 0 &lt;= matrix[i].length &lt;= 100注意：本题与主站 54 题相同：54. 螺旋矩阵","text":"题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制： 0 &lt;= matrix.length &lt;= 100 0 &lt;= matrix[i].length &lt;= 100注意：本题与主站 54 题相同：54. 螺旋矩阵 题解顺时针方向打印无非就是按着“右下左上”的方向进行遍历并打印，碰到边界就拐弯，然后再缩小边界。 源码有Java、C、C++两种，思路基本差不多。 class Solution { public int[] spiralOrder(int[][] matrix) { if(matrix.length == 0) return new int[0]; int l = 0, r = matrix[0].length - 1, t = 0, b = matrix.length - 1, x = 0; int[] res = new int[(r + 1) * (b + 1)]; while(true) { // left to right. for(int i = l; i &lt;= r; i++) res[x++] = matrix[t][i]; if(++t &gt; b) break; // top to bottom. for(int i = t; i &lt;= b; i++) res[x++] = matrix[i][r]; if(l &gt; --r) break; // right to left. for(int i = r; i &gt;= l; i--) res[x++] = matrix[b][i]; if(t &gt; --b) break; // bottom to top. for(int i = b; i &gt;= t; i--) res[x++] = matrix[i][l]; if(++l &gt; r) break; } return res; } } /** * Note: The returned array must be malloced, assume caller calls free(). */ int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize){ if (matrix == NULL || matrixSize == 0) { *returnSize = 0; return NULL; } *returnSize = matrixSize * matrixColSize[0]; int *res = calloc(*returnSize, sizeof(int)); int i = 0; int urow, rcol, drow, lcol, r, c; urow = -1; lcol = -1; drow = matrixSize; rcol = matrixColSize[0]; while (i &lt; *returnSize) { //right r = urow + 1; for (c = lcol + 1; i &lt; *returnSize &amp;&amp; c &lt; rcol; c++) { res[i] = matrix[r][c]; i++; } urow++; //down c = rcol - 1; for (r = urow + 1; i &lt; *returnSize &amp;&amp; r &lt; drow; r++) { res[i] = matrix[r][c]; i++; } rcol--; //left r = drow - 1; for (c = rcol - 1; i &lt; *returnSize &amp;&amp; c &gt; lcol; c--) { res[i] = matrix[r][c]; i++; } drow--; //up c = lcol + 1; for (r = drow - 1; i &lt; *returnSize &amp;&amp; r &gt; urow; r--) { res[i] = matrix[r][c]; i++; } lcol++; } return res; } class Solution { public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { // 边界情况 auto height = matrix.size(); if (!height) return {}; auto width = matrix[0].size(); if (!width) return {}; // 至少有一个元素 int dx[4]{1, 0, -1, 0}; // 代表 4 个变化方向 int dy[4]{0, 1, 0, -1}; // 同上 int d = 0; // 记录当前方向 int h = 0, w = 0; // 记录当前索引 int cycle = 0; // 记录当前是第几轮 vector&lt;int&gt; ans; for (int i = 0; i != height * width; ++i) { // 到达右边界 if (!d &amp;&amp; w &gt;= width - 1 - cycle) d = ++d % 4; // 到达下边界 if (d == 1 &amp;&amp; h &gt;= height - 1 - cycle) d = ++d % 4; // 到达左边界 if (d == 2 &amp;&amp; w &lt;= cycle) d = ++d % 4; // 到达上边界 if (d == 3 &amp;&amp; h &lt;= cycle + 1) { d = ++d % 4; // 进入下一轮 ++cycle; } ans.push_back(matrix[h][w]); h += dy[d]; w += dx[d]; } return ans; } }; 推荐极力推荐两个我喜欢的算法公众号的文章： 面试题29. 顺时针打印矩阵 顺时针打印矩阵 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"提高GitHub的访问速度(DNS实现)","slug":"提高GitHub的访问速度(DNS实现)","date":"2020-06-02T07:32:00.000Z","updated":"2020-07-10T06:46:17.924Z","comments":true,"path":"2020/06/02/提高GitHub的访问速度(DNS实现)/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/02/%E6%8F%90%E9%AB%98GitHub%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6(DNS%E5%AE%9E%E7%8E%B0)/","excerpt":"通过修改Hosts，文件路径C:\\Windows\\System32\\drivers\\etc\\hosts Linux 系统：/etc/hostsAndroid（安卓）系统：/system/etc/hosts 复制、粘贴： # GitHub520 Host Start 185.199.108.154 github.githubassets.com 199.232.68.133 camo.githubusercontent.com 199.232.68.133 github.map.fastly.net 199.232.69.194 github.global.ssl.fastly.net 140.82.112.3 github.com 140.82.114.5 api.github.com 199.232.68.133 raw.githubusercontent.com 199.232.68.133 favicons.githubusercontent.com 199.232.68.133 avatars5.githubusercontent.com 199.232.68.133 avatars4.githubusercontent.com 199.232.68.133 avatars3.githubusercontent.com 199.232.68.133 avatars2.githubusercontent.com 199.232.68.133 avatars1.githubusercontent.com 199.232.68.133 avatars0.githubusercontent.com # GitHub520 Host End 一般是立刻生效。没有的话，手动在 CMD 敲入：ipconfig /flushdns 更多前往GitHub让你“爱”上 GitHub，解决访问时图裂、加载慢的问题。","text":"通过修改Hosts，文件路径C:\\Windows\\System32\\drivers\\etc\\hosts Linux 系统：/etc/hostsAndroid（安卓）系统：/system/etc/hosts 复制、粘贴： # GitHub520 Host Start 185.199.108.154 github.githubassets.com 199.232.68.133 camo.githubusercontent.com 199.232.68.133 github.map.fastly.net 199.232.69.194 github.global.ssl.fastly.net 140.82.112.3 github.com 140.82.114.5 api.github.com 199.232.68.133 raw.githubusercontent.com 199.232.68.133 favicons.githubusercontent.com 199.232.68.133 avatars5.githubusercontent.com 199.232.68.133 avatars4.githubusercontent.com 199.232.68.133 avatars3.githubusercontent.com 199.232.68.133 avatars2.githubusercontent.com 199.232.68.133 avatars1.githubusercontent.com 199.232.68.133 avatars0.githubusercontent.com # GitHub520 Host End 一般是立刻生效。没有的话，手动在 CMD 敲入：ipconfig /flushdns 更多前往GitHub让你“爱”上 GitHub，解决访问时图裂、加载慢的问题。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"Github","slug":"Github","permalink":"https://melodyjerry.github.io/blog/tags/Github/"}]},{"title":"【LeetCode】面试题64. 求1+2+…+n","slug":"【LeetCode】面试题64. 求1+2+…+n","date":"2020-06-02T07:19:00.000Z","updated":"2020-07-10T06:46:17.844Z","comments":true,"path":"2020/06/02/【LeetCode】面试题64. 求1+2+…+n/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/02/%E3%80%90LeetCode%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9864.%20%E6%B1%821+2+%E2%80%A6+n/","excerpt":"来自《剑指Offer（第二版）》 题目描述求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 示例 1： 输入: n = 3 输出: 6 示例 2： 输入: n = 9 输出: 45 限制： 1 &lt;= n &lt;= 10000","text":"来自《剑指Offer（第二版）》 题目描述求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 示例 1： 输入: n = 3 输出: 6 示例 2： 输入: n = 9 输出: 45 限制： 1 &lt;= n &lt;= 10000 题解逻辑(短路)与看完标题，发现这是一道面试题！！！ 看到第一行的“要求不能使用……”，我人傻了，没错，就是人傻了~~ 想用“递归”，但是乘除法不能用、条件判断也不能用🤣🤣🤣 这要怎么做啊？！ 等等，没说不能用运算符哦！！！ 试试看呗~~ 直接写写源码~~ class Solution { // int res = 0; public int sumNums(int n) { // boolean x = n &gt; 1 &amp;&amp; sumNums(n - 1) &gt; 0; boolean x = n &gt; 1 &amp;&amp; (n += sumNums(n - 1)) &gt; 0; // res += n; // return res; return n; } } 思路吗？就直接看源码就懂了！！！ 不懂，那就看多几次！！！ 补充逻辑运算符的短路效应：常见的逻辑运算符有三种，即 “与 &amp;&amp; ”，“或 ∣∣ ”，“非 ! ” ；而其有重要的短路效应，如下所示： if(A &amp;&amp; B) // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true 本题需要实现 “当 n = 1n=1 时终止递归” 的需求，可通过短路效应实现。 n &gt; 1 &amp;&amp; sumNums(n - 1) // 当 n = 1 时 n &gt; 1 不成立 ，此时 “短路” ，终止后续递归 异常捕获这个方法会超时，但是确实是可以。 class Solution { int[] test=new int[]{0}; public int sumNums(int n) { try{ return test[n]; }catch(Exception e){ return n+sumNums(n-1); } } } 移位运算符移位运算符确实可以解，但是好像不是很多人用它写。 class Solution { public int sumNums(int n) { int ans = 0, A = n, B = n + 1; boolean flag; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; return ans &gt;&gt; 1; } } 我在题解区看到了“你是我见过最变态的题解”，不信就看👇原帖是解过最变态的一道题 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"使用云函数自动完成网易云每日打卡","slug":"使用云函数自动完成网易云每日打卡","date":"2020-06-01T07:19:00.000Z","updated":"2020-07-10T06:46:17.914Z","comments":true,"path":"2020/06/01/使用云函数自动完成网易云每日打卡/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/01/%E4%BD%BF%E7%94%A8%E4%BA%91%E5%87%BD%E6%95%B0%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E7%BD%91%E6%98%93%E4%BA%91%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/","excerpt":"","text":"搜索云函数 新建一个函数 名称随意 环境 PHP 7.2 空白函数 下一步 然后会出现这个界面 把 index.php 里面的内容全部删掉 替换为下面这些代码 记得填写手机号和密码 代码有两个版本，第一个是以前在用的，第二个未测试。 现在两个版本已经有段实践没有去运行测试了，难以保证可行性。（日后有再补新的API） 版本①&lt;?php $localurl = \"http://neteasecloudmusicapi.zhaoboy.com\"; $username = \"手机号\"; $password = \"密码\"; $SCKEY = \"\";//可选 //访问链接 function getcurl($url,$cookies,$headid){ $ch = curl_init(); curl_setopt($ch, CURLOPT_COOKIE, $cookies); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, $headid); $output = curl_exec($ch); curl_close($ch); return $output; } //获取日推歌单 function get_rec_res($cookies){ global $localurl; $url = $localurl.\"/recommend/resource\"; return json_decode(getcurl($url,$cookies,0),true); } //获取歌单中歌曲 function get_song($cookies,$id){ global $localurl; $url = $localurl.\"/playlist/detail?id={$id}\"; return json_decode(getcurl($url,$cookies,0),true); } //打卡歌曲 function daka($cookies,$id){ global $localurl; $url = $localurl.\"/scrobble?id={$id}&amp;time=71&amp;timestamp=\".rand(1, 100000); getcurl($url,$cookies,0); } //签到 function qiandao($cookies){ global $localurl; $urland = $localurl.\"/daily_signin\"; $urlpc = $localurl.\"/daily_signin?type=1\"; getcurl($urland,$cookies,0); getcurl($urlpc,$cookies,0); } //登录 function login($username,$password){ global $localurl; $url = $localurl.\"/login/cellphone?phone={$username}&amp;password={$password}\"; $data = getcurl($url,0,1); if(preg_match_all('/Set-Cookie:(.*);/iU',$data,$str)==0) die($data); $cookies = $str[1][0].\";\".$str[1][1].\";\".$str[1][2].\";\"; return $cookies; } //获取用户id function get_id($cookies){ global $localurl; $url = $localurl.\"/login/status\"; $state = json_decode(getcurl($url,$cookies,0),true); return $state[\"bindings\"][0][\"userId\"]; } //听歌量 function get_listenSongs($cookies){ global $localurl; $userid = get_id($cookies); $url = $localurl.\"/user/detail?uid={$userid}&amp;timestamp=\".rand(1, 100000); $detail = json_decode(getcurl($url,$cookies,0),true); return $detail[\"listenSongs\"]; } function run($username,$password){ global $localurl; global $SCKEY; $cookies = login($username,$password); qiandao($cookies); $songslist = get_rec_res($cookies); for($k=0;$k&lt;(count($songslist[\"recommend\"]));$k++){ $songlist = get_song($cookies,$songslist[\"recommend\"][$k][\"id\"]); for($j=0;$j&lt;(count($songlist[\"privileges\"]));$j++){ daka($cookies,$songlist[\"privileges\"][$j][\"id\"]); if(($j/10)==0){ sleep(1); } if(($j==(count($songlist[\"privileges\"])-1))||$j==300){ echo \"执行 {$j} 首\\n\"; sleep(10); break 1; } } } if($SCKEY){ $number = get_listenSongs($cookies); echo $number; $url = \"https://sc.ftqq.com/\".$SCKEY.\".send?text=\".urlencode($username.\" 当前听歌量 \".$number); getcurl($url,0,0); } } function main_handler($event, $context) { global $username; global $password; run($username,$password); return \" 任务完成 \"; } ?&gt; 版本② &lt;?php $localurl = \"http://wyyapi.aar0n.cn\"; $username = \"你的手机号\"; $password = \"你的密码\"; //访问链接 function getcurl($url,$cookies,$headid){ $ch = curl_init(); curl_setopt($ch, CURLOPT_COOKIE, $cookies); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, $headid); $output = curl_exec($ch); curl_close($ch); return $output; } //获取日推歌单 function get_rec_res($cookies){ global $localurl; $url = $localurl.\"/recommend/resource\"; return json_decode(getcurl($url,$cookies,0),true); } //获取歌单中歌曲 function get_song($cookies,$id){ global $localurl; $url = $localurl.\"/playlist/detail?id={$id}\"; return json_decode(getcurl($url,$cookies,0),true); } //打卡歌曲 function daka($cookies,$id){ global $localurl; $url = $localurl.\"/scrobble?id={$id}&amp;time=71&amp;timestamp=\".rand(1, 100000); getcurl($url,$cookies,0); } //签到 function qiandao($cookies){ global $localurl; $urland = $localurl.\"/daily_signin\"; $urlpc = $localurl.\"/daily_signin?type=1\"; getcurl($urland,$cookies,0); getcurl($urlpc,$cookies,0); } //登录 function login($username,$password){ global $localurl; $url = $localurl.\"/login/cellphone?phone={$username}&amp;password={$password}\"; $data = getcurl($url,0,1); if(preg_match_all('/Set-Cookie:(.*);/iU',$data,$str)==0) die($data); $cookies = $str[1][0].\";\".$str[1][1].\";\".$str[1][2].\";\"; return $cookies; } function run($username,$password){ global $localurl; $cookies = login($username,$password); qiandao($cookies); $songslist = get_rec_res($cookies); for($k=0;$k&lt;(count($songslist[\"recommend\"]));$k++){ $songlist = get_song($cookies,$songslist[\"recommend\"][$k][\"id\"]); for($j=0;$j&lt;(count($songlist[\"privileges\"]));$j++){ daka($cookies,$songlist[\"privileges\"][$j][\"id\"]); if(($j/10)==0){ sleep(1); } if(($j==(count($songlist[\"privileges\"])-1))||$j==300){ echo \"执行 {$j} 首\\n\"; sleep(10); break 1; } } } } function main_handler($event, $context) { global $username; global $password; run($username,$password); return \"ok\"; } ?&gt; 记得修改手机号和密码哦～ 点击编辑 超时时间 改为900 点击保存 找到触发方式 添加触发方式 定时触发 corn 表达式 每天八点自动打卡 0 0 8 */1 * * * 点击保存 这样就可以了 就可以享受每天纯自动打卡了 美滋滋啊 最后你过你对它感兴趣 还可以去研究研究其他的 API他是个开源项目地址：https://binaryify.github.io/NeteaseCloudMusicApi/#/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"【LeetCode】1431. 拥有最多糖果的孩子","slug":"【LeetCode】1431. 拥有最多糖果的孩子","date":"2020-06-01T07:00:00.000Z","updated":"2020-07-10T06:46:17.751Z","comments":true,"path":"2020/06/01/【LeetCode】1431. 拥有最多糖果的孩子/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/01/%E3%80%90LeetCode%E3%80%911431.%20%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/","excerpt":"首先祝Jerry生日快乐！ 今天这个打卡题是关于“糖果”的，恰好六一儿童节。 题目描述给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。 对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。 注意，允许有多个孩子同时拥有 最多 的糖果数目。 示例 1： 输入：candies = [2,3,5,1,3], extraCandies = 3 输出：[true,true,true,false,true] 解释： 孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。 孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。 孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。 孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 示例 2： 输入：candies = [4,2,1,1,2], extraCandies = 1 输出：[true,false,false,false,false] 解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。 示例 3： 输入：candies = [12,1,12], extraCandies = 10 输出：[true,false,true] 提示： 2 &lt;= candies.length &lt;= 100 1 &lt;= candies[i] &lt;= 100 1 &lt;= extraCandies &lt;= 50","text":"首先祝Jerry生日快乐！ 今天这个打卡题是关于“糖果”的，恰好六一儿童节。 题目描述给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。 对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。 注意，允许有多个孩子同时拥有 最多 的糖果数目。 示例 1： 输入：candies = [2,3,5,1,3], extraCandies = 3 输出：[true,true,true,false,true] 解释： 孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。 孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。 孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。 孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 示例 2： 输入：candies = [4,2,1,1,2], extraCandies = 1 输出：[true,false,false,false,false] 解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。 示例 3： 输入：candies = [12,1,12], extraCandies = 10 输出：[true,false,true] 提示： 2 &lt;= candies.length &lt;= 100 1 &lt;= candies[i] &lt;= 100 1 &lt;= extraCandies &lt;= 50 题解因为题目有这个关键信息“允许有多个孩子同时拥有 最多 的糖果数目”，这样直接减少了很多麻烦。 题解就“暴力枚举”，两个步骤，两次数组遍历： 找到数组中最大的元素 判断每个元素加上extraCandies能否达到最大值 直接上源码： class Solution { public List&lt;Boolean&gt; kidsWithCandies(int[] candies, int extraCandies) { List&lt;Boolean&gt; ans = new ArrayList&lt;&gt;(); // 定义 max 记录数组的最大值，初始化为 0 int max = 0; for (int c : candies) { max = Math.max(max, c); } // 依次遍历数组，判断元素加上额外糖果大于等于最大值则可以符合条件，否则不可以 for (int c : candies) { ans.add(c + extraCandies &gt;= max); } return ans; } } 提交 题后感想五月已逝，六月努力的💪 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java队列的部分调用方法","slug":"Java队列的部分调用方法","date":"2020-05-31T07:17:00.000Z","updated":"2020-07-10T06:46:17.509Z","comments":true,"path":"2020/05/31/Java队列的部分调用方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/31/Java%E9%98%9F%E5%88%97%E7%9A%84%E9%83%A8%E5%88%86%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"Java队列的部分调用方法 方法 作用 说明 add() 增加一个元素 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove() 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element() 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer() 添加一个元素并返回true 如果队列已满，则返回false poll() 移除并返问队列头部的元素 如果队列为空，则返回null peek() 返回队列头部的元素 如果队列为空，则返回null put() 添加一个元素 如果队列满，则阻塞 take() 移除并返回队列头部的元素 如果队列为空，则阻塞 关于Java队列更多详见：java队列——queue详细分析","text":"Java队列的部分调用方法 方法 作用 说明 add() 增加一个元素 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove() 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element() 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer() 添加一个元素并返回true 如果队列已满，则返回false poll() 移除并返问队列头部的元素 如果队列为空，则返回null peek() 返回队列头部的元素 如果队列为空，则返回null put() 添加一个元素 如果队列满，则阻塞 take() 移除并返回队列头部的元素 如果队列为空，则阻塞 关于Java队列更多详见：java队列——queue详细分析 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"【LeetCode】101. 对称二叉树","slug":"【LeetCode】101. 对称二叉树","date":"2020-05-31T07:17:00.000Z","updated":"2020-07-10T06:46:17.747Z","comments":true,"path":"2020/05/31/【LeetCode】101. 对称二叉树/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/31/%E3%80%90LeetCode%E3%80%91101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"题目描述给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 进阶： 你可以运用递归和迭代两种方法解决这个问题吗？","text":"题目描述给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 进阶： 你可以运用递归和迭代两种方法解决这个问题吗？ 题解思路阅读完题目，脑子里先是想到了栈这种数据结构。 栈的一个特性：先进后出、后进先出。 根据这个特性，很容易地搞定递归实现。 但是迭代地话，用队列更容易理解。 队列的一个特性：先进先出，后进后出。 这题比较容易，直接看代码和注释即可。 递归class Solution { public boolean isSymmetric(TreeNode root) { // 两树都为null，肯定对称 if (root == null) { return true; } // 比较 左子树root.left 与 右子树root.right 这两棵子树是否对称 return compareTree(root.left, root.right); } /* 递归实现 */ private boolean compareTree(TreeNode node1, TreeNode node2) { // 首先比较 node1 与 node2 这两个节点的值是否相等 // 两节点均同时为null时 if (node1 == null &amp;&amp; node2 == null) { return true; } // 最多一个节点为null时，当然还得考虑“值不空但不同”的情况 if (node1 == null || node2 == null || node1.val != node2.val) { // TreeNode.val返回的是该节点的值 return false; } // 再递归比较 node1 的左子树与 node2 的右子树是否对称，node1 的右子树与 node2 的左子树是否对称 return compareTree(node1.left, node2.right) &amp;&amp; compareTree(node1.right, node2.left); } } 迭代class Solution { public boolean isSymmetric(TreeNode root) { // 两树都为null，肯定对称 if (root == null) { return true; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root.left); queue.add(root.right); while (!queue.isEmpty()) { // 每次出队两个节点 node1 和 node2 TreeNode node1 = queue.poll(); TreeNode node2 = queue.poll(); // 首先比较 node1 与 node2 这两个节点的值是否相等 if (node1 == null &amp;&amp; node2 == null) { continue; } // 最多一个节点为null时，当然还得考虑“值不空但不同”的情况 if (node1 == null || node2 == null || node1.val != node2.val) { // TreeNode.val返回的是该节点的值 return false; } // 再将 node1 的左节点与 node2 的右节点一起入队（以便两节点一起出队，进行比较） queue.add(node1.left); queue.add(node2.right); // 再将 node1 的右节点与 node2 的左节点一起入队（以便两节点一起出队，进行比较） queue.add(node1.right); queue.add(node2.left); } return true; } } 复杂度分析无论是递归，还是迭代， 时间复杂度均为：O(n) 空间复杂度均为：O(n) 补充Java 队列的add()方法和offer()方法的区别 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java 队列的add()方法和offer()方法的区别","slug":"Java 队列的add()方法和offer()方法的区别","date":"2020-05-31T06:59:00.000Z","updated":"2020-07-10T06:46:17.459Z","comments":true,"path":"2020/05/31/Java 队列的add()方法和offer()方法的区别/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/31/Java%20%E9%98%9F%E5%88%97%E7%9A%84add()%E6%96%B9%E6%B3%95%E5%92%8Coffer()%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"查阅API文档，找到 add()：增加一个元素。如果队列已满，则抛出一个IIIegaISlabEepeplian异常 Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never throw IllegalStateException or return false. offer()：添加一个元素并返回true。如果队列已满，则返回false Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never return false. 分析 两者都是往队列尾部插入元素 当超出队列界限的时候，add()方法是抛出异常让你处理，而offer()方法是直接返回false Java队列的部分调用方法 方法 作用 说明 add() 增加一个元素 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove() 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element() 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer() 添加一个元素并返回true 如果队列已满，则返回false poll() 移除并返问队列头部的元素 如果队列为空，则返回null peek() 返回队列头部的元素 如果队列为空，则返回null put() 添加一个元素 如果队列满，则阻塞 take() 移除并返回队列头部的元素 如果队列为空，则阻塞 关于Java队列更多详见：java队列——queue详细分析","text":"查阅API文档，找到 add()：增加一个元素。如果队列已满，则抛出一个IIIegaISlabEepeplian异常 Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never throw IllegalStateException or return false. offer()：添加一个元素并返回true。如果队列已满，则返回false Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never return false. 分析 两者都是往队列尾部插入元素 当超出队列界限的时候，add()方法是抛出异常让你处理，而offer()方法是直接返回false Java队列的部分调用方法 方法 作用 说明 add() 增加一个元素 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove() 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element() 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer() 添加一个元素并返回true 如果队列已满，则返回false poll() 移除并返问队列头部的元素 如果队列为空，则返回null peek() 返回队列头部的元素 如果队列为空，则返回null put() 添加一个元素 如果队列满，则阻塞 take() 移除并返回队列头部的元素 如果队列为空，则阻塞 关于Java队列更多详见：java队列——queue详细分析 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"运行IDEA时报错Internal error","slug":"运行IDEA时报错Internal error","date":"2020-05-30T15:17:00.000Z","updated":"2020-07-10T06:46:17.948Z","comments":true,"path":"2020/05/30/运行IDEA时报错Internal error/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/30/%E8%BF%90%E8%A1%8CIDEA%E6%97%B6%E6%8A%A5%E9%94%99Internal%20error/","excerpt":"运行IDEA时，报错Internal error 下面有两种解决办法，优先选择第①种，不行再第②种。我的电脑试了前面两种都不行，所以有了第③种。","text":"运行IDEA时，报错Internal error 下面有两种解决办法，优先选择第①种，不行再第②种。我的电脑试了前面两种都不行，所以有了第③种。 解决①找到intellij的配置目录，windows系统一般是在用户目录下，即C:\\Users\\username\\.IntelliJIdea2019.3，重命名或删除这个文件夹，再次打开intellij时会提示是否加载以前的配置，选择一个较早的版本或者不加载，就能正常打开软件了。 解决② 管理员模式的命令行cmd/PowerShell 输入netsh winsock reset 重启电脑 解决③禁用Hyper-V和Windows 沙盒即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"【LeetCode】198. 打家劫舍","slug":"【LeetCode】198. 打家劫舍","date":"2020-05-29T08:39:00.000Z","updated":"2020-07-10T06:46:17.754Z","comments":true,"path":"2020/05/29/【LeetCode】198. 打家劫舍/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/29/%E3%80%90LeetCode%E3%80%91198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","excerpt":"题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。","text":"题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 题解优化奇偶求和阅读完题目，刚冒出的想法就是“这不就是奇偶数求和吗？”但是第一次提交代码后，提示报错，来看看用例： 输入: [2,1,1,2] 输出 3 预期结果 4 为什么会这样呢？因为不是最优解。 以为是奇偶数求和，但是这个用例中，最大值是下标0、3的求和。 因此必须优化一下，每次奇偶数求和时，除了奇数/偶数下标的求和，还要更新另一边偶数/奇数的求和的值。 多说不好理解，来看看这个对比： indexx 0 1 2 3 nums [2,1,1,2] → 4 优化前： sumEven 0 1 1 3 sumOdd 2 2 3 3 优化后： sumEven 0 2 2 4 sumOdd 2 2 3 3 这一比较，应该就好理解了。 以下为Java代码： class Solution { public int rob(int[] nums) { int sumEven = 0; // 偶数 int sumOdd = 0; // 奇数 for(int i = 0; i &lt; nums.length; i++) { if(i % 2 ==0) { sumEven += nums[i]; // 不是纯粹的偶数和 sumEven = Math.max(sumOdd, sumEven); } else { sumOdd += nums[i]; // 也不是纯粹的奇数和 sumOdd = Math.max(sumOdd, sumEven); } } return Math.max(sumEven, sumOdd); } } 提交后： 动态规划成功解决后，突然想到“能不能用别的办法？比如dp动态规划？” 我试着找了动态规划方程，还真找到了。 动态规划方程：dp[n] = max(dp[n-2] + nums[n], dp[n-1]) 使用上边的用例[2,1,1,2] → 4来验证 n 为数组 nums 的长度 初始： dp[0] = 0 //必须初始化为0 dp[1] = nums[0] = 2 //初始为nums[0] n&gt;=2时： dp[2] = max(dp[0]+nums[1], dp[1]) = max(0+1, 2) = 2 dp[3] = max(dp[1]+nums[2], dp[2]) = max(2+1, 2) = 3 dp[4] = max(dp[2]+nums[3], dp[3]) = max(2+2, 3) = 4 代码： class Solution { public int rob(int[] nums) { int len = nums.length; if(len == 0) return 0; int[] dp = new int[len + 1]; //dp[len] 存储最终结果 dp[0] = 0; //必须初始化为0 dp[1] = nums[0]; //初始为数组的第一个元素 for(int i = 2; i &lt;= len; i++) { //动态规划方程 dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]); } return dp[len]; } } 提交： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode】198. 打家劫舍","slug":"解决Win10开始菜单和搜索框挡重叠的问题","date":"2020-05-29T08:39:00.000Z","updated":"2020-07-10T06:46:17.940Z","comments":true,"path":"2020/05/29/解决Win10开始菜单和搜索框挡重叠的问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/29/%E8%A7%A3%E5%86%B3Win10%E5%BC%80%E5%A7%8B%E8%8F%9C%E5%8D%95%E5%92%8C%E6%90%9C%E7%B4%A2%E6%A1%86%E6%8C%A1%E9%87%8D%E5%8F%A0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。","text":"题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 题解优化奇偶求和阅读完题目，刚冒出的想法就是“这不就是奇偶数求和吗？”但是第一次提交代码后，提示报错，来看看用例： 输入: [2,1,1,2] 输出 3 预期结果 4 为什么会这样呢？因为不是最优解。 以为是奇偶数求和，但是这个用例中，最大值是下标0、3的求和。 因此必须优化一下，每次奇偶数求和时，除了奇数/偶数下标的求和，还要更新另一边偶数/奇数的求和的值。 多说不好理解，来看看这个对比： indexx 0 1 2 3 nums [2,1,1,2] → 4 优化前： sumEven 0 1 1 3 sumOdd 2 2 3 3 优化后： sumEven 0 2 2 4 sumOdd 2 2 3 3 这一比较，应该就好理解了。 以下为Java代码： class Solution { public int rob(int[] nums) { int sumEven = 0; // 偶数 int sumOdd = 0; // 奇数 for(int i = 0; i &lt; nums.length; i++) { if(i % 2 ==0) { sumEven += nums[i]; // 不是纯粹的偶数和 sumEven = Math.max(sumOdd, sumEven); } else { sumOdd += nums[i]; // 也不是纯粹的奇数和 sumOdd = Math.max(sumOdd, sumEven); } } return Math.max(sumEven, sumOdd); } } 提交后： 动态规划成功解决后，突然想到“能不能用别的办法？比如dp动态规划？” 我试着找了动态规划方程，还真找到了。 动态规划方程：dp[n] = max(dp[n-2] + nums[n], dp[n-1]) 使用上边的用例[2,1,1,2] → 4来验证 n 为数组 nums 的长度 初始： dp[0] = 0 //必须初始化为0 dp[1] = nums[0] = 2 //初始为nums[0] n&gt;=2时： dp[2] = max(dp[0]+nums[1], dp[1]) = max(0+1, 2) = 2 dp[3] = max(dp[1]+nums[2], dp[2]) = max(2+1, 2) = 3 dp[4] = max(dp[2]+nums[3], dp[3]) = max(2+2, 3) = 4 代码： class Solution { public int rob(int[] nums) { int len = nums.length; if(len == 0) return 0; int[] dp = new int[len + 1]; //dp[len] 存储最终结果 dp[0] = 0; //必须初始化为0 dp[1] = nums[0]; //初始为数组的第一个元素 for(int i = 2; i &lt;= len; i++) { //动态规划方程 dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]); } return dp[len]; } } 提交： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"自定义返回顶部小火箭","slug":"自定义返回顶部小火箭","date":"2020-05-27T06:52:00.000Z","updated":"2020-07-10T06:46:17.938Z","comments":true,"path":"2020/05/27/自定义返回顶部小火箭/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E5%B0%8F%E7%81%AB%E7%AE%AD/","excerpt":"","text":"&lt;!--自定义返回顶部小火箭--&gt; &lt;style&gt; #back-top { position: fixed; bottom: 10px; right: 5px; z-index: 99; } #back-top span { width: 50px; height: 64px; display: block; background:url(http://images.cnblogs.com/cnblogs_com/seanshao/855033/o_rocket.png) no-repeat center center; } #back-top a{outline:none} &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; $(function() { // hide #back-top first $(\"#back-top\").hide(); // fade in #back-top $(window).scroll(function() { if ($(this).scrollTop() &gt; 500) { $('#back-top').fadeIn(); } else { $('#back-top').fadeOut(); } }); // scroll body to 0px on click $('#back-top a').click(function() { $('body,html').animate({ scrollTop: 0 }, 800); return false; }); }); &lt;/script&gt; &lt;p id=\"back-top\" style=\"display:none\"&gt;&lt;a href=\"#top\"&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"}]},{"title":"为CSDN博客添加站内搜索栏目","slug":"为CSDN博客添加站内搜索栏目","date":"2020-05-27T06:45:00.000Z","updated":"2020-07-10T06:46:17.910Z","comments":true,"path":"2020/05/27/为CSDN博客添加站内搜索栏目/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/27/%E4%B8%BACSDN%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E6%A0%8F%E7%9B%AE/","excerpt":"栏目代码 &lt;div id=\"panel_Search\"&gt; &lt;img src=\"http://img.blog.csdn.net/20170719024744725?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva3hwOTU0NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"&gt; &lt;form action=\"https://www.google.com/search\" method=\"get\" target=\"_blank\"&gt; &lt;span&gt;&lt;input class=\"blogsearch\" title=\"请输入关键字\" id=\"inputSearch\" type=\"text\" placeholder=\"使用Google搜索本博客\" autofocus name=\"q\"&gt;&lt;/span&gt; &lt;input type=\"hidden\" name=\"hl\" value=\"zh-CN\"&gt; &lt;input type=\"hidden\" name=\"sitesearch\" value=\"blog.csdn.net/kxp9545\"&gt; &lt;input id=\"btnSubmit\" type=\"submit\" value=\"搜索 \"&gt; &lt;/form&gt; &lt;/div&gt;","text":"栏目代码 &lt;div id=\"panel_Search\"&gt; &lt;img src=\"http://img.blog.csdn.net/20170719024744725?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva3hwOTU0NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"&gt; &lt;form action=\"https://www.google.com/search\" method=\"get\" target=\"_blank\"&gt; &lt;span&gt;&lt;input class=\"blogsearch\" title=\"请输入关键字\" id=\"inputSearch\" type=\"text\" placeholder=\"使用Google搜索本博客\" autofocus name=\"q\"&gt;&lt;/span&gt; &lt;input type=\"hidden\" name=\"hl\" value=\"zh-CN\"&gt; &lt;input type=\"hidden\" name=\"sitesearch\" value=\"blog.csdn.net/kxp9545\"&gt; &lt;input id=\"btnSubmit\" type=\"submit\" value=\"搜索 \"&gt; &lt;/form&gt; &lt;/div&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Win10 沉浸式搜索框居中显示","slug":"Win10 沉浸式搜索框居中显示","date":"2020-05-27T06:37:00.000Z","updated":"2020-07-10T06:46:17.744Z","comments":true,"path":"2020/05/27/Win10 沉浸式搜索框居中显示/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/27/Win10%20%E6%B2%89%E6%B5%B8%E5%BC%8F%E6%90%9C%E7%B4%A2%E6%A1%86%E5%B1%85%E4%B8%AD%E6%98%BE%E7%A4%BA/","excerpt":"Windows 10 沉浸式搜索栏居中显示设置，可直接对注册表进行修改从而实现。导入注册表，重启 Windows 资源管理器即可。然后使用 Win + S 快捷键即可看到沉浸式搜索栏已在屏幕中央进行居中显示，复制下方命令，粘贴在记事本中，另存为 修改.reg 后双击运行导入使用。","text":"Windows 10 沉浸式搜索栏居中显示设置，可直接对注册表进行修改从而实现。导入注册表，重启 Windows 资源管理器即可。然后使用 Win + S 快捷键即可看到沉浸式搜索栏已在屏幕中央进行居中显示，复制下方命令，粘贴在记事本中，另存为 修改.reg 后双击运行导入使用。 Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Search] \"ImmersiveSearch\"=dword:00000001 [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Search\\Flighting\\Override] \"ImmersiveSearchFull\"=dword:00000001 \"CenterScreenRoundedCornerRadius\"=dword:00000009 动图操作示范 如果不想用了，可以删除注册表就能恢复Windows10默认搜索样式。 Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Search] \"ImmersiveSearch\"=- [-HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Search\\Flighting\\Override] \"ImmersiveSearchFull\"=dword:00000001 \"CenterScreenRoundedCornerRadius\"=dword:00000009 关于注册表文件的删除语法 要使用 .reg 文件删除注册表项，将 .reg 文件中的 RegistryPath 的前面放一个连字符 （-）。 要使用 .reg 文件删除注册表值，将 .reg 文件中的 DataItemName 的等号后放一个连字符 （-）。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"免费域名注册","slug":"免费域名注册","date":"2020-05-27T06:16:00.000Z","updated":"2020-07-10T06:46:17.912Z","comments":true,"path":"2020/05/27/免费域名注册/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/27/%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C/","excerpt":"Freenom offers a free domain name service for casual users.The Freenom domain name is free for one year and can be renewed manually before expiration.","text":"Freenom offers a free domain name service for casual users.The Freenom domain name is free for one year and can be renewed manually before expiration. 1、访问 freenom 官网，然后在输入框内直接输入想要注册的域名地址，输入完成后点击后面的 检查可用性 ； 2、在列表内选择自己想要的域名后缀，然后点击 Get it now 进行选择，然后待列表右上方出现 check out 直接点击进入确认界面； 3、在已选的域名地址列表后方的下拉菜单内选择 12 Months @ FREE ，有效期 12 个月可免费使用，然后再输入自己的 QQ 邮箱，点击 Verify My Email Address ； 4、下方弹出提示验证邮箱，打开我们的QQ邮箱接收验证邮件，点击邮件内的链接进行验证，在打开的页面内输入个人信息并保存即可完成账户的创建； 5、点击按钮进入登陆界面，输入注册的账户及密码，点击 Login 进行登陆，然后在 Services – My Domains 查看自己注册的域名，已注册域名即在下方显示，点击 Manage Domain 即可进入域名管理； 6、在域名设置界面内，点击 Manage Freenom DNS 进入域名解析设置，Name 处填写 www 后面的 Target 处填写需要解析的 IP 地址即可，再点击 More Records 添加一行，Name 为空 后面的 Target 处再次填写需要解析的 IP 地址，详细的设置可以百度 域名解析设置 进行了解，配置完成后点击 Save Changes 保存，待使用 ping 域名返回服务器正确的 IP 则说明解析成功。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"【LeetCode】287. 寻找重复数","slug":"【LeetCode】287. 寻找重复数","date":"2020-05-26T09:16:00.000Z","updated":"2020-07-10T06:46:17.802Z","comments":true,"path":"2020/05/26/【LeetCode】287. 寻找重复数/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/26/%E3%80%90LeetCode%E3%80%91287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/","excerpt":"题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1: 输入: [1,3,4,2,2] 输出: 2 示例 2: 输入: [3,1,3,4,2] 输出: 3 说明： 不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n^2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。","text":"题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1: 输入: [1,3,4,2,2] 输出: 2 示例 2: 输入: [3,1,3,4,2] 输出: 3 说明： 不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n^2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。 题解本题目限定了元素的取值范围”其数字都在 1 到 n 之间（包括 1 和 n）”。 另外，“说明”里的也特别重要~ 说明： &gt; 不能更改原数组（假设数组是只读的）。 &gt; 只能使用额外的 O(1) 的空间。 &gt; 时间复杂度小于 O(n^2) 。 &gt; 数组中只有一个重复的数字，但它可能不止重复出现一次。 最后解决的思路很简单，就是使用双指针，直接看代码注释即可。 代码class Solution { public int findDuplicate(int[] nums) { // 如果数组就只有两个元素，直接返回即可 if(nums.length &lt;= 2) { return nums[0]; } int q = 0, s = 0; int indexStart = 0; // indexStart用以记录起步位置 // 初始化q、s应该指向[第一个index!=nums[index]的元素],不应该为0 for(int index = 0; index &lt; nums.length; index++) { if(index != nums[index]) { q = index; s = index; indexStart = index; // 保存起步位置 break; } } // 快慢指针从同一位置(index)起步 while(true) { // 快指针q的步长=2 q = nums[nums[q]]; // 慢指针s的步长=1 s = nums[s]; // 两指针相遇,结束第一次循环 if(q == s) { // 慢指针回到初始起步点indexStart s = indexStart; break; } } // 快慢指针继续一起移动,但要修改快指针的步长 // 快慢指针再相遇的元素,即所要的结果 while(true) { // 快指针q的步长=1 q = nums[q]; // 慢指针s的步长=1 s = nums[s]; // 两指针相遇,结束循环 if(q == s) { break; } } return s; } } 提交 题后今天这“每日一题”和《【LeetCode】面试题03. 数组中重复的数字》有些类似。不同的是，今天这题限定了一些特别的条件，比如： 不能更改原数组（假设数组是只读的） 只能使用额外的 O(1) 的空间 *时间复杂度小于 O(n^2) *尤其是对复杂对的要求，这就提高了算法设计的难度。 我想着各种优化方法，很艰难地，最后找到了这种。哇地一声就哭出来了，太难了/(ㄒoㄒ)/~~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"通过css样式实现动态背景","slug":"通过css样式实现动态背景","date":"2020-05-25T09:00:00.000Z","updated":"2020-07-10T06:46:17.951Z","comments":true,"path":"2020/05/25/通过css样式实现动态背景/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/25/%E9%80%9A%E8%BF%87css%E6%A0%B7%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF/","excerpt":"分享一张可以用来做动态背景的gif 通过css样式可实现👇","text":"分享一张可以用来做动态背景的gif 通过css样式可实现👇 &lt;style type = \"text/css\"&gt; @media(prefers - color - scheme: dark) {.js_darkmode__0 { color: rgba(0, 0, 0, 0.9) ! important; background - image: linear - gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(\"https://blog-static.cnblogs.com/files/melodyjerry/%E8%93%9D%E8%89%B2%E7%A2%8E%E7%89%87%E9%A3%9E%E8%88%9E.gif\") ! important; }.js_darkmode__1 { color: rgba(0, 0, 0, 0.9) ! important; }.js_darkmode__bg__0 { background - image: linear - gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(\"https://blog-static.cnblogs.com/files/melodyjerry/%E8%93%9D%E8%89%B2%E7%A2%8E%E7%89%87%E9%A3%9E%E8%88%9E.gif\"), linear - gradient(#fff, #fff) ! important; }.js_darkmode__bg__1 { background - image: -webkit - linear - gradient(left, transparent, rgb(153, 153, 152), transparent) ! important; } } &lt;/style&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://melodyjerry.github.io/blog/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"}]},{"title":"【LeetCode】4. 寻找两个正序数组的中位数","slug":"【LeetCode】4. 寻找两个正序数组的中位数","date":"2020-05-24T08:15:00.000Z","updated":"2020-07-10T06:46:17.755Z","comments":true,"path":"2020/05/24/【LeetCode】4. 寻找两个正序数组的中位数/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/24/%E3%80%90LeetCode%E3%80%914.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"题目描述给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 示例 2: nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5","text":"题目描述给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 示例 2: nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 题解代码class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { // 若仅当nums1为空 if (nums1 == null || nums1.length == 0) { int length = nums2.length; int middle = length / 2; if (length % 2 == 0) { return (nums2[middle] + nums2[middle - 1]) / 2.0; } else { return nums2[middle]; } } // 若仅当nums2为空 if (nums2 == null || nums2.length == 0) { int length = nums1.length; int middle = length / 2; if (length % 2 == 0) { return (nums1[middle] + nums1[middle - 1]) / 2.0; } else { return nums1[middle]; } } int len1 = nums1.length; int len2 = nums2.length; int middle = (len1+len2)/2; int currentIndex = 0; int i1 = 0, i2 = 0; int last = 0, current = 0; while(currentIndex &lt;= middle){ currentIndex++; last = current; /** * 注意越界情况： * 比如， * 1 2 3 4 * 5 6 7 7 8 9 * 当然，数组为空的情况也包含在这里面 */ // i1越界 if(i1 == len1){ current = nums2[i2]; i2++; continue; } // i2越界 if(i2 == len2){ current = nums1[i1]; i1++; continue; } // 正常操作 if(nums1[i1] &lt;= nums2[i2]){ current = nums1[i1]; i1++; } else { current = nums2[i2]; i2++; } } // 分奇偶情况 if((len1+len2) % 2 == 0){ return (last + current) / 2.0; } else { return current; } } } 提交 更多题解详细通俗的思路分析，多解法寻找两个有序数组的中位数 C / C++中位数的小技巧 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Web开发技术&API 接口参考","slug":"Web开发技术&API 接口参考","date":"2020-05-24T07:48:00.000Z","updated":"2020-07-10T06:46:17.703Z","comments":true,"path":"2020/05/24/Web开发技术&API 接口参考/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/24/Web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF&API%20%E6%8E%A5%E5%8F%A3%E5%8F%82%E8%80%83/","excerpt":"Web 开发技术https://developer.mozilla.org/zh-CN/docs/Web Web API 接口参考https://developer.mozilla.org/zh-CN/docs/Web/API","text":"Web 开发技术https://developer.mozilla.org/zh-CN/docs/Web Web API 接口参考https://developer.mozilla.org/zh-CN/docs/Web/API document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://melodyjerry.github.io/blog/tags/Web/"},{"name":"API","slug":"API","permalink":"https://melodyjerry.github.io/blog/tags/API/"}]},{"title":"在VS Code上刷LeetCode","slug":"在VS Code上刷LeetCode","date":"2020-05-24T04:54:00.000Z","updated":"2020-07-10T06:46:17.917Z","comments":true,"path":"2020/05/24/在VS Code上刷LeetCode/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/24/%E5%9C%A8VS%20Code%E4%B8%8A%E5%88%B7LeetCode/","excerpt":"插件说明 该插件需要用户本地拥有Node.js 8+运行环境。读者可以通过在命令行中输入node -v查看。 安装插件之后，可以在 LeetCode 插件的浏览器中找到登录按钮： 登录完成后，浏览器内就会显示出所有问题，并且问题将会按照难度，算法类型，公司进行分类，方便使用者进行针对性训练。 插件同时支持中文及英文版LeetCode，可以通过点击导航栏中的切换按钮（ 图案）进行切换： 右键点击某一个题目并选择 Show Problem 会生成答题文件，接着我们就可以开始刷题了。也可以点击 Preview Problem 先查看一下题目内容： 写完后，可以点击文件最下方的 “Submit” 提交答案，或者“Test”执行测试： 另外，插件还支持题目搜索，存档管理等功能。更多详细的插件使用介绍可以前往GitHub项目主页查看。 参考文章：https://blog.csdn.net/lzuacm/article/details/103375905","text":"插件说明 该插件需要用户本地拥有Node.js 8+运行环境。读者可以通过在命令行中输入node -v查看。 安装插件之后，可以在 LeetCode 插件的浏览器中找到登录按钮： 登录完成后，浏览器内就会显示出所有问题，并且问题将会按照难度，算法类型，公司进行分类，方便使用者进行针对性训练。 插件同时支持中文及英文版LeetCode，可以通过点击导航栏中的切换按钮（ 图案）进行切换： 右键点击某一个题目并选择 Show Problem 会生成答题文件，接着我们就可以开始刷题了。也可以点击 Preview Problem 先查看一下题目内容： 写完后，可以点击文件最下方的 “Submit” 提交答案，或者“Test”执行测试： 另外，插件还支持题目搜索，存档管理等功能。更多详细的插件使用介绍可以前往GitHub项目主页查看。 参考文章：https://blog.csdn.net/lzuacm/article/details/103375905 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"复制文字时自动加版权","slug":"复制文字时自动加版权","date":"2020-05-24T04:42:00.000Z","updated":"2020-07-10T06:46:17.918Z","comments":true,"path":"2020/05/24/复制文字时自动加版权/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/24/%E5%A4%8D%E5%88%B6%E6%96%87%E5%AD%97%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8A%A0%E7%89%88%E6%9D%83/","excerpt":"复制正文文字时自动加版权 在知乎复制的文本为什么会自带一些版权声明，这个功能是如何实现的? 知乎上复制回答，剪贴板里自动加上版权出处的技术js如何实现？ 在知乎复制的文本为什么会自带一些版权声明，这个功能是如何实现的?","text":"复制正文文字时自动加版权 在知乎复制的文本为什么会自带一些版权声明，这个功能是如何实现的? 知乎上复制回答，剪贴板里自动加上版权出处的技术js如何实现？ 在知乎复制的文本为什么会自带一些版权声明，这个功能是如何实现的? document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"}]},{"title":"Linux安装Docker","slug":"Linux安装Docker","date":"2020-05-24T03:51:00.000Z","updated":"2020-07-10T06:46:17.558Z","comments":true,"path":"2020/05/24/Linux安装Docker/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/24/Linux%E5%AE%89%E8%A3%85Docker/","excerpt":"介绍 来自百度百科的介绍 Docker的三大核心概念：镜像、容器、仓库 镜像：类似虚拟机的镜像、用俗话说就是安装文件。 容器：类似一个轻量级的沙箱，容器是从镜像创建应用运行实例，可以将其启动、开始、停止、删除、而这些容器都是相互隔离、互不可见的。 仓库：类似代码仓库，是Docker集中存放镜像文件的场所。 是收费软件？就目前来讲，docker有两个版本Docker CE和Docker EE，CE是社区版的免费软件，EE是企业版的收费软件。 安装使用脚本来安装 查询内核 ![Y2PztK.png](https://s1.ax1x.com/2020/05/17/Y2PztK.png) 2. 使用root用户登录linux系统后，将yum包更新到最新： 关于root模式，见[Linux root 模式](https://www.cnblogs.com/melodyjerry/p/12904792.html) ```$ yum update 执行docker安装脚本(因curl命令需要一个网址，网址被禁止发布，此处不能列出) ```sh get-docker.sh 启动docker进程 systemctl start docker 验证docker是否安装成功：docker run hello-world 删除使用yum命令 然后将docker的安装目录删除 ```rm -rf /var/lib/docker 就可以了。 参考阅读菜鸟教程-CentOS Docker 安装","text":"介绍 来自百度百科的介绍 Docker的三大核心概念：镜像、容器、仓库 镜像：类似虚拟机的镜像、用俗话说就是安装文件。 容器：类似一个轻量级的沙箱，容器是从镜像创建应用运行实例，可以将其启动、开始、停止、删除、而这些容器都是相互隔离、互不可见的。 仓库：类似代码仓库，是Docker集中存放镜像文件的场所。 是收费软件？就目前来讲，docker有两个版本Docker CE和Docker EE，CE是社区版的免费软件，EE是企业版的收费软件。 安装使用脚本来安装 查询内核 ![Y2PztK.png](https://s1.ax1x.com/2020/05/17/Y2PztK.png) 2. 使用root用户登录linux系统后，将yum包更新到最新： 关于root模式，见[Linux root 模式](https://www.cnblogs.com/melodyjerry/p/12904792.html) ```$ yum update 执行docker安装脚本(因curl命令需要一个网址，网址被禁止发布，此处不能列出) ```sh get-docker.sh 启动docker进程 systemctl start docker 验证docker是否安装成功：docker run hello-world 删除使用yum命令 然后将docker的安装目录删除 ```rm -rf /var/lib/docker 就可以了。 参考阅读菜鸟教程-CentOS Docker 安装 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"【LeetCode】面试题03. 数组中重复的数字","slug":"【LeetCode】面试题03. 数组中重复的数字","date":"2020-05-23T14:37:00.000Z","updated":"2020-07-10T06:46:17.804Z","comments":true,"path":"2020/05/23/【LeetCode】面试题03. 数组中重复的数字/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/23/%E3%80%90LeetCode%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9803.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"题目来源《剑指 Offer（第 2 版）》 题目描述找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制： 2 &lt;= n &lt;= 100000","text":"题目来源《剑指 Offer（第 2 版）》 题目描述找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 题解思路题目中有2句很重要的话“在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内”、“任意一个重复的数字”，前者限定了元素的取值范围；而后者要求只要找到了重复数字就可以直接return了。 本题的关键是“重复”！！！ 既然是“重复”，那第一会想到什么？Set 集合！ Set集合有个重要的特性：不能存储相同的元素。 利用Set集合就很好解决了，操作步骤如下： 初始化一个set 遍历数组 将元素加入到set中，并判断是否加入成功 若成功了，就继续遍历 若失败了，说明该元素已经再该集合中- 直接break，并return该元素的值 若没有重复元素，就return -1 关于Set集合见Java集合-Set（含转载） 代码class Solution { public int findRepeatNumber(int[] nums) { Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int num : nums){ /* 若添加失败，说明该元素已经在集合中，因此该元素是重复元素 */ if(!set.add(num)){ return num; } } // 若没有重复元素，直接返回-1 return -1; } } 提交 拓展评论里第一条是👇，可以当作这次拓展内容补充补充。 class Solution: def findRepeatNumber(self, nums: List[int]) -&gt; int: def count(start,end): c,i=0,0 while i&lt;len(nums): if start&lt;=nums[i]&lt;=end: c+=1 i+=1 return c left,right = 0,len(nums)-1 if right&lt;1:return -1 while left+1&lt;right: mid = (left+right)//2 if count(left,mid)&gt;mid-left+1: right = mid else: left = mid if count(nums[left],nums[left])&gt;1:return nums[left] if count(nums[right],nums[right])&gt;1:return nums[right] return -1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java集合-Set（含转载）","slug":"Java集合-Set（含转载）","date":"2020-05-23T12:43:00.000Z","updated":"2020-07-10T06:46:17.613Z","comments":true,"path":"2020/05/23/Java集合-Set（含转载）/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/23/Java%E9%9B%86%E5%90%88-Set%EF%BC%88%E5%90%AB%E8%BD%AC%E8%BD%BD%EF%BC%89/","excerpt":"Set概述set集合不能存储相同的元素 同时因为其是一个抽象的接口：所以不能直接实例化一个set对象。 Set s = new Set() ：× 该接口主要继承于Collections接口，所以具有Collection的一些常见的方法。 常见用法 Sr.No. Method Description 1 add( ) 向集合中添加元素 2 clear( ) 去掉集合中所有的元素 3 contains( ) 判断集合中是否包含某一个元素 4 isEmpty( ) 判断集合是否为空 5 iterator( ) 主要用于递归集合，返回一个Iterator()对象 6 remove( ) 从集合中去掉特定的对象 7 size( ) 返回集合的大小 Set接口最长用的两大实现： HashSet TreeSet","text":"Set概述set集合不能存储相同的元素 同时因为其是一个抽象的接口：所以不能直接实例化一个set对象。 Set s = new Set() ：× 该接口主要继承于Collections接口，所以具有Collection的一些常见的方法。 常见用法 Sr.No. Method Description 1 add( ) 向集合中添加元素 2 clear( ) 去掉集合中所有的元素 3 contains( ) 判断集合中是否包含某一个元素 4 isEmpty( ) 判断集合是否为空 5 iterator( ) 主要用于递归集合，返回一个Iterator()对象 6 remove( ) 从集合中去掉特定的对象 7 size( ) 返回集合的大小 Set接口最长用的两大实现： HashSet TreeSet HashSet类（散列存放）Java.util.HashSet类实现了Java.util.Set接口。 它不允许出现重复元素； 不保证和政集合中元素的顺序 允许包含值为null的元素，但最多只能有一个null元素。 import java.util.Date; import java.util.HashSet; import java.util.Iterator; public class TestHashSet { public static void main(String [] args) { HashSet h=new HashSet(); h.add(\"1st\"); h.add(\"2nd\"); h.add(new Integer(3)); h.add(new Double(4.0)); h.add(\"2nd\"); //重复元素，未被添加 h.add(new Integer(3)); //重复元素，未被添加 h.add(new Date()); System.out.println(\"开始：size=\"+h.size()); Iterator it=h.iterator(); while(it.hasNext()) { Object o=it.next(); System.out.println(o); } h.remove(\"2nd\"); System.out.println(\"移除元素后：size=\"+h.size()); System.out.println(h); } } TreeSet（有序存放） TreeSet描述的是Set的一种变体 ———— 可以实现排序等功能的集合，它在讲对象元素添加到集合中时会自动按照某种比较规则将其插入到有序的对象序列中，并保证该集合元素组成的读uixiangxulie时刻按照“升序”排列。 import java.util.TreeSet; import java.util.Iterator; public class TestTreeSet { public static void main(String [] args) { TreeSet ts=new TreeSet(); ts.add(\"orange\"); ts.add(\"apple\"); ts.add(\"banana\"); ts.add(\"grape\"); Iterator it=ts.iterator(); while(it.hasNext()) { String fruit=(String)it.next(); System.out.println(fruit); } } } Java中三种Set类型用法、性能大比拼 - 云+社区 - 腾讯云 转载内容转载学习一份关于Java Set集合的基础笔记，一下内容来自~ 作者：贾博岩链接：https://www.jianshu.com/p/b48c47a42916来源：简书 Set上一篇，我们介绍Java中的List集合。本篇，让我们继续学习，来了解下Set集合； Set继承于Collection接口，是一个不允许出现重复元素，并且无序的集合，主要有HashSet和TreeSet两大实现类。 在判断重复元素的时候，Set集合会调用hashCode()和equal()方法来实现。 HashSet是哈希表结构，主要利用HashMap的key来存储元素，计算插入元素的hashCode来获取元素在集合中的位置； TreeSet是红黑树结构，每一个元素都是树中的一个节点，插入的元素都会进行排序； Set集合框架结构： Set常用方法与List接口一样，Set接口也提供了集合操作的基本方法。 但与List不同的是，Set还提供了equals(Object o)和hashCode()，供其子类重写，以实现对集合中插入重复元素的处理； public interface Set&lt;E&gt; extends Collection&lt;E&gt; { A:添加功能 boolean add(E e); boolean addAll(Collection&lt;? extends E&gt; c); B:删除功能 boolean remove(Object o); boolean removeAll(Collection&lt;?&gt; c); void clear(); C:长度功能 int size(); D:判断功能 boolean isEmpty(); boolean contains(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); E:获取Set集合的迭代器： Iterator&lt;E&gt; iterator(); F:把集合转换成数组 Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); //判断元素是否重复，为子类提高重写方法 boolean equals(Object o); int hashCode(); } HashSetHashSet实现Set接口，底层由HashMap(后面讲解)来实现，为哈希表结构，新增元素相当于HashMap的key，value默认为一个固定的Object。在我看来，HashSet相当于一个阉割版的HashMap; 当有元素插入的时候，会计算元素的hashCode值，将元素插入到哈希表对应的位置中来； 它继承于AbstractSet，实现了Set, Cloneable, Serializable接口。 (1)HashSet继承AbstractSet类，获得了Set接口大部分的实现，减少了实现此接口所需的工作，实际上是又继承了AbstractCollection类； (2)HashSet实现了Set接口，获取Set接口的方法，可以自定义具体实现，也可以继承AbstractSet类中的实现； (3)HashSet实现Cloneable，得到了clone()方法，可以实现克隆功能； (4)HashSet实现Serializable，表示可以被序列化，通过序列化去传输，典型的应用就是hessian协议。 具有如下特点： 不允许出现重复因素； 允许插入Null值； 元素无序（添加顺序和遍历顺序不一致）； 线程不安全，若2个线程同时操作HashSet，必须通过代码实现同步； HashSet基本操作HashSet底层由HashMap实现，插入的元素被当做是HashMap的key，根据hashCode值来确定集合中的位置，由于Set集合中并没有角标的概念，所以并没有像List一样提供get（）方法。当获取HashSet中某个元素时，只能通过遍历集合的方式进行equals()比较来实现； public class HashSetTest { public static void main(String[] agrs){ //创建HashSet集合： Set&lt;String&gt; hashSet = new HashSet&lt;String&gt;(); System.out.println(\"HashSet初始容量大小：\"+hashSet.size()); //元素添加： hashSet.add(\"my\"); hashSet.add(\"name\"); hashSet.add(\"is\"); hashSet.add(\"jiaboyan\"); hashSet.add(\",\"); hashSet.add(\"hello\"); hashSet.add(\"world\"); hashSet.add(\"!\"); System.out.println(\"HashSet容量大小：\"+hashSet.size()); //迭代器遍历： Iterator&lt;String&gt; iterator = hashSet.iterator(); while (iterator.hasNext()){ String str = iterator.next(); System.out.println(str); } //增强for循环 for(String str:hashSet){ if(\"jiaboyan\".equals(str)){ System.out.println(\"你就是我想要的元素:\"+str); } System.out.println(str); } //元素删除： hashSet.remove(\"jiaboyan\"); System.out.println(\"HashSet元素大小：\" + hashSet.size()); hashSet.clear(); System.out.println(\"HashSet元素大小：\" + hashSet.size()); //集合判断： boolean isEmpty = hashSet.isEmpty(); System.out.println(\"HashSet是否为空：\" + isEmpty); boolean isContains = hashSet.contains(\"hello\"); System.out.println(\"HashSet是否为空：\" + isContains); } } HashSet元素添加分析Set集合不允许添加重复元素，那么到底是个怎么情况呢？ 来看一个简单的例子： public class HashSetTest { public static void main(String[] agrs){ //hashCode() 和 equals()测试： hashCodeAndEquals(); } public static void hashCodeAndEquals(){ //第一个 Set集合： Set&lt;String&gt; set1 = new HashSet&lt;String&gt;(); String str1 = new String(\"jiaboyan\"); String str2 = new String(\"jiaboyan\"); set1.add(str1); set1.add(str2); System.out.println(\"长度：\"+set1.size()+\",内容为：\"+set1); //第二个 Set集合： Set&lt;App&gt; set2 = new HashSet&lt;App&gt;(); App app1 = new App(); app1.setName(\"jiaboyan\"); App app2 = new App(); app2.setName(\"jiaboyan\"); set2.add(app1); set2.add(app2); System.out.println(\"长度：\"+set2.size()+\",内容为：\"+set2); //第三个 Set集合： Set&lt;App&gt; set3 = new HashSet&lt;App&gt;(); App app3 = new App(); app3.setName(\"jiaboyan\"); set3.add(app3); set3.add(app3); System.out.println(\"长度：\"+set3.size()+\",内容为：\"+set3); } } 测试结果： 长度：1,内容为：[jiaboyan] 长度：2,内容为：[com.jiaboyan.collection.App@efb78af, com.jiaboyan.collection.App@5f3306ad] 长度：1,内容为：[com.jiaboyan.collection.App@1fb030d8] 可以看到，第一个Set集合中最终只有一个元素；第二个Set集合保留了2个元素；第三个集合也只有1个元素； 究竟是什么原因呢？ 让我们来看看HashSet的add(E e)方法： public boolean add(E e) { return map.put(e, PRESENT)==null; } 在底层HashSet调用了HashMap的put(K key, V value)方法: public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); return null; } 通过查看以上的源码，我们可以了解到：实际的逻辑都是在HashMap的put()方法中。 int hash = hash(key) 对传入的key计算hash值； int i = indexFor(hash, table.length) 对hash值进行转换，转换成数组的index(HashMap中底层存储使用了Entry&lt;K,V&gt;[]数组)； for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) 判断对应index下是否存在元素； 如果存在，则if(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))判断； 如果不存在，则addEntry(hash, key, value, i)直接添加； 简单概括如下： 在向HashMap中添加元素时，先判断key的hashCode值是否相同，如果相同，则调用equals()、==进行判断，若相同则覆盖原有元素；如果不同，则直接向Map中添加元素； 反过来，我们在看下上面的例子： 在第一个Set集合中，我们new了两个String对象，赋了相同的值。当传入到HashMap中时，key均为“jiaboyan”，所以hash和i的值都相同。进行if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))判断，由于String对象重写了equals()方法，所以在((k = e.key) == key || key.equals(k))判断时，返回了true，所以第二次的插入并不会增加Set集合的长度； 第二个Set集合中，也是new了两个对象，但没有重写equals()方法（底层调用的Object的equals()，也就是==判断），所以会增加2个元素； 第三个Set集合中，只new了一个对象，调用的两次add方法都添加的这个新new的对象，所以也只是保留了1个元素； TreeSet从名字上可以看出，此集合的实现和树结构有关。与HashSet集合类似，TreeSet也是基于Map来实现，具体实现TreeMap(后面讲解)，其底层结构为红黑树（特殊的二叉查找树）； 与HashSet不同的是，TreeSet具有排序功能，分为自然排序(123456)和自定义排序两类，默认是自然排序；在程序中，我们可以按照任意顺序将元素插入到集合中，等到遍历时TreeSet会按照一定顺序输出–倒序或者升序； 它继承AbstractSet，实现NavigableSet, Cloneable, Serializable接口。 （1）与HashSet同理，TreeSet继承AbstractSet类，获得了Set集合基础实现操作； （2）TreeSet实现NavigableSet接口，而NavigableSet又扩展了SortedSet接口。这两个接口主要定义了搜索元素的能力，例如给定某个元素，查找该集合中比给定元素大于、小于、等于的元素集合，或者比给定元素大于、小于、等于的元素个数；简单地说，实现NavigableSet接口使得TreeSet具备了元素搜索功能； （3）TreeSet实现Cloneable接口，意味着它也可以被克隆； （4）TreeSet实现了Serializable接口，可以被序列化，可以使用hessian协议来传输； 具有如下特点： 对插入的元素进行排序，是一个有序的集合（主要与HashSet的区别）; 底层使用红黑树结构，而不是哈希表结构； 允许插入Null值； 不允许插入重复元素； 线程不安全； TreeSet基本操作public class TreeSetTest { public static void main(String[] agrs){ TreeSet&lt;String&gt; treeSet = new TreeSet&lt;String&gt;(); System.out.println(\"TreeSet初始化容量大小：\"+treeSet.size()); //元素添加： treeSet.add(\"my\"); treeSet.add(\"name\"); treeSet.add(\"jiaboyan\"); treeSet.add(\"hello\"); treeSet.add(\"world\"); treeSet.add(\"1\"); treeSet.add(\"2\"); treeSet.add(\"3\"); System.out.println(\"TreeSet容量大小：\" + treeSet.size()); System.out.println(\"TreeSet元素顺序为：\" + treeSet.toString()); //增加for循环遍历： for(String str:treeSet){ System.out.println(\"遍历元素：\"+str); } //迭代器遍历：升序 Iterator&lt;String&gt; iteratorAesc = treeSet.iterator(); while(iteratorAesc.hasNext()){ String str = iteratorAesc.next(); System.out.println(\"遍历元素升序：\"+str); } //迭代器遍历：降序 Iterator&lt;String&gt; iteratorDesc = treeSet.descendingIterator(); while(iteratorDesc.hasNext()){ String str = iteratorDesc.next(); System.out.println(\"遍历元素降序：\"+str); } //元素获取:实现NavigableSet接口 String firstEle = treeSet.first();//获取TreeSet头节点： System.out.println(\"TreeSet头节点为：\" + firstEle); // 获取指定元素之前的所有元素集合：(不包含指定元素) SortedSet&lt;String&gt; headSet = treeSet.headSet(\"jiaboyan\"); System.out.println(\"jiaboyan节点之前的元素为：\"+headSet.toString()); //获取给定元素之间的集合：（包含头，不包含尾） SortedSet subSet = treeSet.subSet(\"1\",\"world\"); System.out.println(\"1--jiaboan之间节点元素为：\"+subSet.toString()); //集合判断： boolean isEmpty = treeSet.isEmpty(); System.out.println(\"TreeSet是否为空：\"+isEmpty); boolean isContain = treeSet.contains(\"who\"); System.out.println(\"TreeSet是否包含who元素：\"+isContain); //元素删除： boolean jiaboyanRemove = treeSet.remove(\"jiaboyan\"); System.out.println(\"jiaboyan元素是否被删除\"+jiaboyanRemove); //集合中不存在的元素，删除返回false boolean whoRemove = treeSet.remove(\"who\"); System.out.println(\"who元素是否被删除\"+whoRemove); //删除并返回第一个元素：如果set集合不存在元素，则返回null String pollFirst = treeSet.pollFirst(); System.out.println(\"删除的第一个元素：\"+pollFirst); //删除并返回最后一个元素：如果set集合不存在元素，则返回null String pollLast = treeSet.pollLast(); System.out.println(\"删除的最后一个元素：\"+pollLast); treeSet.clear();//清空集合: } } TreeSet元素排序在前面的章节，我们讲到了TreeSet是一个有序集合，可以对集合元素排序，其中分为自然排序和自定义排序，那么这两种方式如何实现呢？ 首先，我们通过JDK提供的对象来展示，我们使用String、Integer： public class TreeSetTest { public static void main(String[] agrs){ naturalSort(); } //自然排序顺序：升序 public static void naturalSort(){ TreeSet&lt;String&gt; treeSetString = new TreeSet&lt;String&gt;(); treeSetString.add(\"a\"); treeSetString.add(\"z\"); treeSetString.add(\"d\"); treeSetString.add(\"b\"); System.out.println(\"字母顺序：\" + treeSetString.toString()); TreeSet&lt;Integer&gt; treeSetInteger = new TreeSet&lt;Integer&gt;(); treeSetInteger.add(1); treeSetInteger.add(24); treeSetInteger.add(23); treeSetInteger.add(6); System.out.println(treeSetInteger.toString()); System.out.println(\"数字顺序：\" + treeSetString.toString()); } } 测试结果： 字母顺序：[a, b, d, z] 数字顺序：[1, 6, 23, 24] 接下来，我们自定义对象，看能否实现： public class App{ private String name; private Integer age; public App(){} public App(String name,Integer age){ this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public static void main(String[] args ){ System.out.println( \"Hello World!\" ); } } public class TreeSetTest { public static void main(String[] agrs){ customSort(); } //自定义排序顺序：升序 public static void customSort(){ TreeSet&lt;App&gt; treeSet = new TreeSet&lt;App&gt;(); //排序对象： App app1 = new App(\"hello\",10); App app2 = new App(\"world\",20); App app3 = new App(\"my\",15); App app4 = new App(\"name\",25); //添加到集合： treeSet.add(app1); treeSet.add(app2); treeSet.add(app3); treeSet.add(app4); System.out.println(\"TreeSet集合顺序为：\"+treeSet); } } 测试结果： 抛出异常：提示App不能转换为Comparable对象： Exception in thread \"main\" java.lang.ClassCastException: com.jiaboyan.collection.App cannot be cast to java.lang.Comparable 为什么会报错呢？ compare(key, key); // type (and possibly null) check final int compare(Object k1, Object k2) { return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2); } 通过查看源码发现，在TreeSet调用add方法时，会调用到底层TreeMap的put方法，在put方法中会调用到compare(key, key)方法，进行key大小的比较； 在比较的时候，会将传入的key进行类型强转，所以当我们自定义的App类进行比较的时候，自然就会抛出异常，因为App类并没有实现Comparable接口； 将App实现Comparable接口，在做比较: public class App implements Comparable&lt;App&gt;{ private String name; private Integer age; public App(){} public App(String name,Integer age){ this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } //自定义比较：先比较name的长度，在比较age的大小； public int compareTo(App app) { //比较name的长度： int num = this.name.length() - app.name.length(); //如果name长度一样，则比较年龄的大小： return num == 0 ? this.age - app.age : num; } @Override public String toString() { return \"App{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试结果如下： TreeSet集合顺序为：[App{name='my', age=15}, App{name='name', age=25}, App{name='hello', age=10}, App{name='world', age=20}] 此外，还有另一种方式，那就是实现Comparetor接口，并重写compare方法； //自定义App类的比较器： public class AppComparator implements Comparator&lt;App&gt; { //比较方法：先比较年龄，年龄若相同在比较名字长度； public int compare(App app1, App app2) { int num = app1.getAge() - app2.getAge(); return num == 0 ? app1.getName().length() - app2.getName().length() : num; } } 此时，App不用在实现Comparerable接口了，单纯的定义一个类即可； public class App{ private String name; private Integer age; public App(){} public App(String name,Integer age){ this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public static void main(String[] args ){ System.out.println( \"Hello World!\" ); } } public class TreeSetTest { public static void main(String[] agrs){ customSort(); } //自定义比较器：升序 public static void customComparatorSort(){ TreeSet&lt;App&gt; treeSet = new TreeSet&lt;App&gt;(new AppComparator()); //排序对象： App app1 = new App(\"hello\",10); App app2 = new App(\"world\",20); App app3 = new App(\"my\",15); App app4 = new App(\"name\",25); //添加到集合： treeSet.add(app1); treeSet.add(app2); treeSet.add(app3); treeSet.add(app4); System.out.println(\"TreeSet集合顺序为：\"+treeSet); } } 测试结果： TreeSet集合顺序为：[App{name='hello', age=10}, App{name='my', age=15}, App{name='world', age=20}, App{name='name', age=25}] 最后，在说下关于compareTo()、compare()方法： 结果返回大于0时，方法前面的值大于方法中的值； 结果返回等于0时，方法前面的值等于方法中的值； 结果返回小于0时，方法前面的值小于方法中的值； 集合排序方法 @Test public void testFor() { String orderId1 = \"2321837281372913\"; String userId1 = \"20180701001\"; String orderId2 = \"2321837281372914\"; String userId2 = \"20180701002\"; String orderId3 = \"2321837281372912\"; String userId3 = \"20180701003\"; String orderId4 = \"2321837281372918\"; String userId4 = \"20180701005\"; String orderId5 = \"2321837281372918\"; String userId5 = \"20180701004\"; Order order = new Order(); order.setUserId(userId1); order.setOrderId(orderId1); Order order1 = new Order(); order1.setOrderId(orderId2); order1.setUserId(userId2); Order order2 = new Order(); order2.setOrderId(orderId3); order2.setUserId(userId3); Order order3 = new Order(); order3.setOrderId(orderId4); order3.setUserId(userId4); Order order4 = new Order(); order4.setOrderId(orderId5); order4.setUserId(userId5); List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); orderList.add(order); orderList.add(order1); orderList.add(order2); orderList.add(order3); orderList.add(order4); //1.jdk8 lambda排序，带参数类型 // orderList.sort(( Order ord1, Order ord2) -&gt; ord2.getOrderId().compareTo(ord1.getOrderId())); //2.jdk8 lambda排序，不带参数类型 // orderList.sort(( ord1, ord2) -&gt; ord2.getOrderId().compareTo(ord1.getOrderId())); //3.jdk8 升序排序，Comparator提供的静态方法 Collections.sort(orderList, Comparator.comparing(Order::getOrderId)); //4.jdk8 降序排序，Comparator提供的静态方法 // Collections.sort(orderList, Comparator.comparing(Order::getOrderId).reversed()); //5.jdk8 组合排序，Comparator提供的静态方法，先按orderId排序，orderId相同的按userId排序 // Collections.sort(orderList, Comparator.comparing(Order::getOrderId).reversed().thenComparing(Order::getUserId)); orderList.stream().forEach(str -&gt; System.out.println(str.getOrderId()+\"/\" + str.getUserId())); } 作者：贾博岩链接：https://www.jianshu.com/p/b48c47a42916来源：简书 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"【LeetCode】680. 验证回文字符串 Ⅱ","slug":"【LeetCode】680. 验证回文字符串 Ⅱ","date":"2020-05-21T02:42:00.000Z","updated":"2020-07-10T06:46:17.805Z","comments":true,"path":"2020/05/21/【LeetCode】680. 验证回文字符串 Ⅱ/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/21/%E3%80%90LeetCode%E3%80%91680.%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%20%E2%85%A1/","excerpt":"题目描述给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: “aba”输出: True 示例 2: 输入: “abca”输出: True解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。","text":"题目描述给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: “aba”输出: True 示例 2: 输入: “abca”输出: True解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 题解思路我们先来看看最简单的情况，也就是不删除字符的情况，然后再递进看看删除情况。 不删除字符的情况 先考虑如果不允许删除字符，如何判断一个字符串是否是回文串？双指针！！！定义左右指针left、right，初始时分别指向字符串的第一个字符和最后一个字符。每次判断左右指针指向的字符是否相同，如果不相同，则不是回文串；如果相同，则将左右指针都往中间移动一位，直到左右指针相遇，则字符串是回文串。 删除1个字符的情况 在前面不删除的情况下，发现在找到不相等的元素时，[0, left) 和 (right, len(s) - 1] 这两部分已经判断过是回文，因此不用再次判断。 剩下的只需要再判断 [left, right] 区间中的字符串，即删除 left 或者 right 指向的元素，剩余的区间 (left, right] 或者 [left, right) 是否为回文串。 若 (left, right] 或者 [left, right) 为回文串，则说明删除了一个字符可以构成回文串。 注意的是：若删除过一次，则不是回文串。 如果左右指针从两端同时向中间走，那么： 第一步： a b c a | | left right 第二步： a b c a | | left right 第一步，左右指针遇到的元素相等，继续向中间走；第二步，左右指针遇到的元素不等，则必须进行处理：我们必须删除其中的一个字符，然后再判断 剩余的所有字符 是否是回文串。 删除 b： a c a 或者 删除 c： a b a 即判断 aca 或者 aba 是否为回文字符串。 看看官方给出的实例，辅助理解： 代码class Solution { int del = 0; // 记录删除节点的次数 public boolean validPalindrome(String s) { int left = 0, right = s.length()-1; // left左指针 right右指针 while(left &lt; right){ if(s.charAt(left) == s.charAt(right)){ left++; right--; }else{ // 不相等的话，若没有删除字符，则删除左边或右边的字符再判断 // 若删除过一次，则不是回文串 if(del == 0){ del++; return validPalindrome(s.substring(left, right)) || validPalindrome(s.substring(left+1, right+1)); } return false; } } return true; /* if(left &gt; right) return true; */ } } 复杂度分析时间复杂度：O(n)。其中 n 是字符串的长度。判断整个字符串是否是回文字符串的时间复杂度是 O(n)，遇到不同字符时，判断两个子串是否是回文字符串的时间复杂度也都是 O(n)。空间复杂度：O(1)。只需要维护有限的常量空间。 提交 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Linux root 模式","slug":"Linux root 模式","date":"2020-05-17T04:34:00.000Z","updated":"2020-07-10T06:46:17.617Z","comments":true,"path":"2020/05/17/Linux root 模式/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/17/Linux%20root%20%E6%A8%A1%E5%BC%8F/","excerpt":"第一种方式：sudo（暂时的） 输入sudo，然后显示可以输入的命令 sudo-b：在后台执行指令-h：帮助-H：将HOME环境变量设为新身份的HOME环境变量-k：结束密码的有效期限，即下次再执行sudo时需要输入密码-l：列出目前用户可执行与无法执行的指令-p：改变询问密码的提示符号-s：执行指定的shell-u&lt;用户&gt;：以指定的用户作为新的身份-v：延长密码有效期限5分钟-V ：显示版本信息 这里我们输入sudo -i，再输入你的用户密码，就会进入root模式了。 但是这个方法持续的时间只有五分钟，想要延长时间可以用sudo -v再延长五分钟。 第二种方法：root（非暂时的） 输入sudo passwd root（注意passwd的拼写），再输入用户密码，接下来会让你设置root密码，并再次确认。 接下来输入su，再输入刚刚设置的root密码就可以进入root了。 之后想要退出输入exit即可。","text":"第一种方式：sudo（暂时的） 输入sudo，然后显示可以输入的命令 sudo-b：在后台执行指令-h：帮助-H：将HOME环境变量设为新身份的HOME环境变量-k：结束密码的有效期限，即下次再执行sudo时需要输入密码-l：列出目前用户可执行与无法执行的指令-p：改变询问密码的提示符号-s：执行指定的shell-u&lt;用户&gt;：以指定的用户作为新的身份-v：延长密码有效期限5分钟-V ：显示版本信息 这里我们输入sudo -i，再输入你的用户密码，就会进入root模式了。 但是这个方法持续的时间只有五分钟，想要延长时间可以用sudo -v再延长五分钟。 第二种方法：root（非暂时的） 输入sudo passwd root（注意passwd的拼写），再输入用户密码，接下来会让你设置root密码，并再次确认。 接下来输入su，再输入刚刚设置的root密码就可以进入root了。 之后想要退出输入exit即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"Ubuntu使用yum","slug":"Ubuntu使用yum","date":"2020-05-17T04:32:00.000Z","updated":"2020-07-10T06:46:17.701Z","comments":true,"path":"2020/05/17/Ubuntu使用yum/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/17/Ubuntu%E4%BD%BF%E7%94%A8yum/","excerpt":"yum介绍详细转见yum 命令讲解","text":"yum介绍详细转见yum 命令讲解 安装 首先打开终端（Ctrl+Alt+T），进入root模式 jerry是用户名，也就是你自己起的名字。@是分割的符号jerry-VirtualBox是主机名，也就是你所使用的机器的名称是当前目录，”“表示根目录$是提示符，当进入root时，会变成# 第一种方式：sudo（暂时的） 输入sudo，然后显示可以输入的命令 sudo-b：在后台执行指令-h：帮助-H：将HOME环境变量设为新身份的HOME环境变量-k：结束密码的有效期限，即下次再执行sudo时需要输入密码-l：列出目前用户可执行与无法执行的指令-p：改变询问密码的提示符号-s：执行指定的shell-u&lt;用户&gt;：以指定的用户作为新的身份-v：延长密码有效期限5分钟-V ：显示版本信息 这里我们输入sudo -i，再输入你的用户密码，就会进入root模式了。 但是这个方法持续的时间只有五分钟，想要延长时间可以用sudo -v再延长五分钟。 第二种方法：root（非暂时的） 输入sudo passwd root（注意passwd的拼写），再输入用户密码，接下来会让你设置root密码，并再次确认。 接下来输入su，再输入刚刚设置的root密码就可以进入root了。 之后想要退出输入exit即可。 检测是否安装了build-essential程序包 ![Y2Vg6U.png](https://s1.ax1x.com/2020/05/17/Y2Vg6U.png) &gt; 如果提示下面这个，就是没进入root模式 &gt; ![Y2AWgU.png](https://s1.ax1x.com/2020/05/17/Y2AWgU.png) 3. 安装yum ```apt-get install yum 安装成功 使用yum的命令形式一般是如下：yum [options] [command] [package ...] 添加 yum 仓库 首先要进入到”/etc/yum.repos.d/“目录中（因为该目录存放着yum仓库的配置文件） 使用vim编辑器创建一个名为docker.repo的新配置文件（命令 vim /etc/yum.repos.d/docker.repo 文件名称可随意，但后缀必须为repo），逐项写入下面加粗的配置参数并保存退出（不写中文注释）。[rhel-media] yum仓库唯一标识符，避免与其他仓库冲突。name=linuxprobe yum仓库的名称描述，易于识别仓库用处。。baseurl=file:///media/cdrom 提供方式包括FTP（ftp://..）、HTTP（http://..）、本地（file:///..）enabled=1 设置此源是否可用，1为可用，0为禁用。gpgcheck=1 设置此源是否校验文件，1为校验，0为不校验。gpgkey=file:///media/cdrom/RPM-GPG-KEY-redhat-release 若为校验请指定公钥文件地址。 在原文的基础上略修改。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"【LeetCode】560. 和为K的子数组","slug":"【LeetCode】560. 和为K的子数组","date":"2020-05-15T02:53:00.000Z","updated":"2020-07-10T06:46:17.803Z","comments":true,"path":"2020/05/15/【LeetCode】560. 和为K的子数组/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/15/%E3%80%90LeetCode%E3%80%91560.%20%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","excerpt":"题目描述给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。","text":"题目描述给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 思路看到这题，我唯一能想到的解决方法就是暴力法（或枚举法）。 定下两个下表start、end，使用两次for循环，外层关于end并依次从0开始向后移动，内层关于start并从end开始向前移动。因为题目中要求的是“连续的子数组”，因此就直接构造了[start,end]的数组，并对其求和sum。只要sum值等于k值，那我们用计数count记录。最后函数返回count即可。 方法很简单，这样分析的话，不需要用到什么额外的空间，所以空间复杂度为O(1)；时间复杂度方面，由于使用两次for循环对数组进行遍历为O(n^2)，再加上求和时间为O(1)，因此总体的时间复杂度为O(n^2)。 代码class Solution { //注意题中说的是“连续的子数组” public int subarraySum(int[] nums, int k) { int count = 0; // 计算[start,end]构成的子数组的和sum for(int end = 0; end &lt; nums.length; end++) { int sum = 0; for (int start = end; start &gt;= 0; start--) { sum += nums[start]; if(sum == k) count++; } } return count; } /* 时间复杂度：O(n^2)，n为数组的长度；两层循环O(n^2)+求和时间为O(1) 空间复杂度：O(1)，无需其他存储空间的使用 */ } 执行 题后心得刚看到这题的时候，注意到难度为“中等”，我想肯定不止有这种方法，而且这种方法过于简单，肯定有更高效的、更有技术含量的算法。于是，去看了他人的算法，发现使用了哈希表。可是，我还不会哈希表啊接下来这段时间，得找时间把哈希表这块学一点。 接下来的话特别有意思、深刻：提交后，我也顺便看了一下评论，有意思的是，我发现了“老马”。 当然，是假的！！！ 精选题解 暴力解法、前缀和、前缀和哈希表优化 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode】136. 只出现一次的数字","slug":"【LeetCode】136. 只出现一次的数字","date":"2020-05-14T02:59:00.000Z","updated":"2020-07-10T06:46:17.749Z","comments":true,"path":"2020/05/14/【LeetCode】136. 只出现一次的数字/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/14/%E3%80%90LeetCode%E3%80%91136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"看到今天的“每日一题”，第一时间发现用位运算很简单、快速。 题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1 示例 2: 输入: [4,1,2,1,2]输出: 4","text":"看到今天的“每日一题”，第一时间发现用位运算很简单、快速。 题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1 示例 2: 输入: [4,1,2,1,2]输出: 4 题解思路位运算首先，来看个例子，比如：a^b假设，a、b的值分别是15、2，a 的值是15，转换成二进制为 1111，b 的值是2，转换成二进制为 0010，这下可以根据异或的运算规律，可以得出其结果为 1101，即13。 &nbsp;&nbsp;&nbsp;&nbsp; 1 1 1 1⊕&nbsp; 0 0 1 0————————————&nbsp;&nbsp;&nbsp;&nbsp; 1 1 0 1 继续看看，我们可以来看看⊕的运算性质： a⊕0 = a a⊕a = 0 a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b 继续看这道题，输入的数组一定是奇数个，现在我假设一共有 2m+1 个元素，其中，m对元素是成对出现的，唯一1个元素就是将被输出的结果。 接下来可以根据这个假设，列出这个表达式，(a1⊕a2⊕⋯⊕am)⊕(a1⊕a2⊕⋯⊕am)⊕am+1⇨ (a1​⊕a1​)⊕(a2​⊕a2​)⊕⋯⊕(am​⊕am​)⊕am+1​⇨ 0⊕0⊕⋯⊕0⊕am+1​⇨ am+1​ 下面的代码就是采用按位异或操作符来完成的。 哈希表成功提交后，我看了其他其他题解，大部分都是使用异或运算来完成。但是，还有一些是使用哈希表来完成的。对哦，为什么我不用 Hash 表呢？因为我还不会 Hash 表啊hhh好吧，不会归不会，但也得学学。 这里就直接小本本上记录两个使用Hash来实现的算法： 利用 Hash 表，Time: O(n)，Space: O(n) 解决方案：哈希集（HashSet） 代码 使用位运算来完成。 class Solution { public int singleNumber(int[] nums) { // (a1​⊕a1​)⊕(a2​⊕a2​)⊕⋯⊕(am​⊕am​)⊕am+1​ // ⇨ 0⊕0⊕⋯⊕0⊕am+1​=am+1​ // 结合三个性质： // 1、a⊕0 = a // 2、a⊕a = 0 // 3、a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b int key = 0; for(int num : nums){ // 比如：a^b=13 // a 的值是15，转换成二进制为1111， // b 的值是2，转换成二进制为0010， // 根据异或的运算规律，可以得出其结果为1101，即13 key ^= num; } return key; } } 复杂度分析 时间复杂度：O(n)，其中 n 是数组长度。因为只需要对数组遍历一次即可 空间复杂度：O(1) 执行 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode】102. 二叉树的层序遍历","slug":"【LeetCode】102. 二叉树的层序遍历","date":"2020-05-13T04:37:00.000Z","updated":"2020-07-10T06:46:17.746Z","comments":true,"path":"2020/05/13/【LeetCode】102. 二叉树的层序遍历/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/13/%E3%80%90LeetCode%E3%80%91102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"题目描述给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ]","text":"题目描述给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ] 题解我想用栈来实现，但是发现有些问题。日后再补充。现在，干脆就直接学习学习他人的优秀算法，顺便记录一下感想。 该算法题解来自~微信公众号：看图学算法链接：https://mp.weixin.qq.com/s/oI_pmqvaA9AFQUPxKX13vw 用广度优先BFS处理是很直观的，可以想象成是一把刀横着切割了每一层，但是深度优先遍历就不那么直观了。 我们开下脑洞，把这个二叉树的样子调整一下，摆成一个田字形的样子。田字形的每一层就对应一个list。 按照深度优先DFS的处理顺序，会先访问节点1，再访问节点2，接着是节点3。之后是第二列的4和5，最后是第三列的6。每次递归的时候都需要带一个index(表示当前的层数)，也就对应那个田字格子中的第几行，如果当前行对应的list不存在，就加入一个空list进去。 动态演示如下： 代码import java.util.*; class Solution { void dfs(int index,TreeNode root, List&lt;List&lt;Integer&gt;&gt; res) { //每次递归的时候都需要带一个index(表示当前的层数) //如果当前行对应的list不存在，就加入一个空list进去。 //假设res是[ [1],[2,3] ]， index是3，就再插入一个空list放到res中 if(res.size()&lt;index) { res.add(new ArrayList&lt;Integer&gt;()); } //将当前节点的值加入到res中，index代表当前层，假设index是3，节点值是99 //res是[ [1],[2,3] [4] ]，加入后res就变为 [ [1],[2,3] [4,99] ] res.get(index-1).add(root.val); //递归的处理左子树，右子树，同时将层数index+1 if(root.left!=null) { dfs(index+1, root.left, res); } if(root.right!=null) { dfs(index+1, root.right, res); } } public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { if(root==null) { return new ArrayList&lt;List&lt;Integer&gt;&gt;(); } //用来存放最终结果 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); dfs(1,root,res); return res; } } 时间复杂度:O(N)空间复杂度:O(h)，h是树的高度** 心得体会首先，我绝对不会想到用list，因为我对集合一是不敏感，二是基础知识掌握不多。第二点是，灵活性的不足，即使我想不到list，但是我也没想过“我们开下脑洞，把这个二叉树的样子调整一下，摆成一个田字形的样子”🤣先前写算法基本都是用C来写，偶尔用C++。有的题目用C写起来轻松，但是有的却用Java轻松。很必要的一点，就是学会使用两种及以上的语言来写算法。 其他题解 【精选】递归和迭代 官方题解 二叉树层次遍历 图片来源：微信公众号“看图学算法”学习笔记，待补充… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"一些常用的 Emoji 符号（可直接复制）","slug":"一些常用的 Emoji 符号（可直接复制）","date":"2020-05-13T04:34:00.000Z","updated":"2020-07-10T06:46:17.846Z","comments":true,"path":"2020/05/13/一些常用的 Emoji 符号（可直接复制）/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/13/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%20Emoji%20%E7%AC%A6%E5%8F%B7%EF%BC%88%E5%8F%AF%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%EF%BC%89/","excerpt":"","text":"其他方法https://blog.csdn.net/u014636245/article/details/82945997 表情类😀 😁 😂 🤣 😃 😄 😅 😆 😉 😊 😋 😎 😍 😘 😗 😙 😚 ☺️ 🙂 🤗 🤩 🤔 🤨 😐 😑 😶 🙄 😏 😣 😥 😮 🤐 😯 😪 😫 😴 😌 😛 😜 😝 🤤 😒 😓 😔 😕 🙃 🤑 😲 ☹️ 🙁 😖 😞 😟 😤 😢 😭 😦 😧 😨 😩 🤯 😬 😰 😱 😳 🤪 😵 😡 😠 🤬 😷 🤒 🤕 🤢 🤮 🤧 😇 🤠 🤡 🤥 🤫 🤭 🧐 🤓 😈 👿 👹 👺 💀 👻 👽 🤖 💩 😺 😸 😹 😻 😼 😽 🙀 😿 😾 手势类🤲 👐 🙌 👏 🤝 👍 👎 👊 ✊ 🤛 🤜 🤞 ✌️ 🤟 🤘 👌 👈 👉 👆 👇 ☝️ ✋ 🤚 🖐 🖖 👋 🤙 💪🖕 ✍️ 🙏 人物👶 👧 🧒 👦 👩 🧑 👨 👵 🧓 👴 👲 👳‍♀️ 👳‍♂️ 🧕 🧔 👱‍♂️ 👱‍♀️ 👮‍♀️ 👮‍♂️ 👷‍♀️ 👷‍♂️ 💂‍♀️ 💂‍♂️ 🕵️‍♀️ 🕵️‍♂️ 👩‍⚕️ 👨‍⚕️ 👩‍🌾 👨‍🌾 👩‍🍳 👨‍🍳 👩‍🎓 👨‍🎓 👩‍🎤 👨‍🎤 👩‍🏫 👨‍🏫 👩‍🏭 👨‍🏭 👩‍💻 👨‍💻 👩‍💼 👨‍💼 👩‍🔧 👨‍🔧 👩‍🔬 👨‍🔬 👩‍🎨 👨‍🎨 👩‍🚒 👨‍🚒 👩‍✈️ 👨‍✈️ 👩‍🚀 👨‍🚀 👩‍⚖️ 👨‍⚖️ 👰 🤵 👸 🤴 🤶 🎅 🧙‍♀️ 🧙‍♂️ 🧝‍♀️ 🧝‍♂️ 🧛‍♀️ 🧛‍♂️ 🧟‍♀️ 🧟‍♂️ 🧞‍♀️ 🧞‍♂️ 🧜‍♀️ 🧜‍♂️ 🧚‍♀️ 🧚‍♂️ 👼 🤰 🤱 🙇‍♀️ 🙇‍♂️ 💁‍♀️ 💁‍♂️ 🙅‍♀️ 🙅‍♂️ 🙆‍♀️ 🙆‍♂️ 🙋‍♀️ 🙋‍♂️ 🤦‍♀️ 🤦‍♂️ 🤷‍♀️ 🤷‍♂️ 🙎‍♀️ 🙎‍♂️ 🙍‍♀️ 🙍‍♂️ 💇‍♀️ 💇‍♂️ 💆‍♀️ 💆‍♂️ 🧖‍♀️ 🧖‍♂️ 💅 🤳 💃 🕺 👯‍♀️ 👯‍♂️ 🕴 🚶‍♀️ 🚶‍♂️ 🏃‍♀️ 🏃‍♂️ 👫 👭 👬 💑 👩‍❤️‍👩 👨‍❤️‍👨 💏 👩‍❤️‍💋‍👩 👨‍❤️‍💋‍👨 👪 👨‍👩‍👧 👨‍👩‍👧‍👦 👨‍👩‍👦‍👦 👨‍👩‍👧‍👧 👩‍👩‍👦 👩‍👩‍👧 👩‍👩‍👧‍👦 👩‍👩‍👦‍👦 👩‍👩‍👧‍👧 👨‍👨‍👦 👨‍👨‍👧 👨‍👨‍👧‍👦 👨‍👨‍👦‍👦 👨‍👨‍👧‍👧 👩‍👦 👩‍👧 👩‍👧‍👦 👩‍👦‍👦 👩‍👧‍👧 👨‍👦 👨‍👧 👨‍👧‍👦 👨‍👦‍👦 👨‍👧‍👧 动植物 自然🐶 🐱 🐭 🐹 🐰 🦊 🦝 🐻 🐼 🦘 🦡 🐨 🐯 🦁 🐮 🐷 🐽 🐸 🐵 🙈 🙉 🙊 🐒 🐔 🐧 🐦 🐤 🐣 🐥 🦆 🦢 🦅 🦉 🦚 🦜 🦇 🐺 🐗 🐴 🦄 🐝 🐛 🦋 🐌 🐚 🐞 🐜 🦗 🕷 🕸 🦂 🦟 🦠 🐢 🐍 🦎 🦖 🦕 🐙 🦑 🦐 🦀 🐡 🐠 🐟 🐬 🐳 🐋 🦈 🐊 🐅 🐆 🦓 🦍 🐘 🦏 🦛 🐪 🐫 🦙 🦒 🐃 🐂 🐄 🐎 🐖 🐏 🐑 🐐 🦌 🐕 🐩 🐈 🐓 🦃 🕊 🐇 🐁 🐀 🐿 🦔 🐾 🐉 🐲 🌵 🎄 🌲 🌳 🌴 🌱 🌿 ☘️ 🍀 🎍 🎋 🍃 🍂 🍁 🍄 🌾 💐 🌷 🌹 🥀 🌺 🌸 🌼 🌻 🌞 🌝 🌛 🌜 🌚 🌕 🌖 🌗 🌘 🌑 🌒 🌓 🌔 🌙 🌎 🌍 🌏 💫 ⭐️ 🌟 ✨ ⚡️ ☄️ 💥 🔥 🌪 🌈 ☀️ 🌤 ⛅️ 🌥 ☁️ 🌦 🌧 ⛈ 🌩 🌨 ❄️ ☃️ ⛄️ 🌬 💨 💧 💦 ☔️ ☂️ 🌊 🌫 十二生肖🐁🐂🐅🐇🐉🐍🐎🐐🐒🐓🐕🐖 水果 食物🍏 🍎 🍐 🍊 🍋 🍌 🍉 🍇 🍓 🍈 🍒 🍑 🍍 🥭 🥥 🥝 🍅 🍆 🥑 🥦 🥒 🥬 🌶 🌽 🥕 🥔 🍠 🥐 🍞 🥖 🥨 🥯 🧀 🥚 🍳 🥞 🥓 🥩 🍗 🍖 🌭 🍔 🍟 🍕 🥪 🥙 🌮 🌯 🥗 🥘 🥫 🍝 🍜 🍲 🍛 🍣 🍱 🥟 🍤 🍙 🍚 🍘 🍥 🥮 🥠 🍢 🍡 🍧 🍨 🍦 🥧 🍰 🎂 🍮 🍭 🍬 🍫 🍿 🧂 🍩 🍪 🌰 🥜 🍯 🥛 🍼 ☕️ 🍵 🥤 🍶 🍺 🍻 🥂 🍷 🥃 🍸 🍹 🍾 🥄 🍴 🍽 🥣 🥡 🥢 运动 娱乐⚽️ 🏀 🏈 ⚾️ 🥎 🏐 🏉 🎾 🥏 🎱 🏓 🏸 🥅 🏒 🏑 🥍 🏏 ⛳️ 🏹 🎣 🥊 🥋 🎽 ⛸ 🥌 🛷 🛹 🎿 ⛷ 🏂 🏋️‍♀️ 🏋🏻‍♀️ 🏋🏼‍♀️ 🏋🏽‍♀️ 🏋🏾‍♀️ 🏋🏿‍♀️ 🏋️‍♂️ 🏋🏻‍♂️ 🏋🏼‍♂️ 🏋🏽‍♂️ 🏋🏾‍♂️ 🏋🏿‍♂️ 🤼‍♀️ 🤼‍♂️ 🤸‍♀️ 🤸🏻‍♀️ 🤸🏼‍♀️ 🤸🏽‍♀️ 🤸🏾‍♀️ 🤸🏿‍♀️ 🤸‍♂️ 🤸🏻‍♂️ 🤸🏼‍♂️ 🤸🏽‍♂️ 🤸🏾‍♂️ 🤸🏿‍♂️ ⛹️‍♀️ ⛹🏻‍♀️ ⛹🏼‍♀️ ⛹🏽‍♀️ ⛹🏾‍♀️ ⛹🏿‍♀️ ⛹️‍♂️ ⛹🏻‍♂️ ⛹🏼‍♂️ ⛹🏽‍♂️ ⛹🏾‍♂️ ⛹🏿‍♂️ 🤺 🤾‍♀️ 🤾🏻‍♀️ 🤾🏼‍♀️ 🤾🏾‍♀️ 🤾🏾‍♀️ 🤾🏿‍♀️ 🤾‍♂️ 🤾🏻‍♂️ 🤾🏼‍♂️ 🤾🏽‍♂️ 🤾🏾‍♂️ 🤾🏿‍♂️ 🏌️‍♀️ 🏌🏻‍♀️ 🏌🏼‍♀️ 🏌🏽‍♀️ 🏌🏾‍♀️ 🏌🏿‍♀️ 🏌️‍♂️ 🏌🏻‍♂️ 🏌🏼‍♂️ 🏌🏽‍♂️ 🏌🏾‍♂️ 🏌🏿‍♂️ 🏇 🏇🏻 🏇🏼 🏇🏽 🏇🏾 🏇🏿 🧘‍♀️ 🧘🏻‍♀️ 🧘🏼‍♀️ 🧘🏽‍♀️ 🧘🏾‍♀️ 🧘🏿‍♀️ 🧘‍♂️ 🧘🏻‍♂️ 🧘🏼‍♂️ 🧘🏽‍♂️ 🧘🏾‍♂️ 🧘🏿‍♂️ 🏄‍♀️ 🏄🏻‍♀️ 🏄🏼‍♀️ 🏄🏽‍♀️ 🏄🏾‍♀️ 🏄🏿‍♀️ 🏄‍♂️ 🏄🏻‍♂️ 🏄🏼‍♂️ 🏄🏽‍♂️ 🏄🏾‍♂️ 🏄🏿‍♂️ 🏊‍♀️ 🏊🏻‍♀️ 🏊🏼‍♀️ 🏊🏽‍♀️ 🏊🏾‍♀️ 🏊🏿‍♀️ 🏊‍♂️ 🏊🏻‍♂️ 🏊🏼‍♂️ 🏊🏽‍♂️ 🏊🏾‍♂️ 🏊🏿‍♂️ 🤽‍♀️ 🤽🏻‍♀️ 🤽🏼‍♀️ 🤽🏽‍♀️ 🤽🏾‍♀️ 🤽🏿‍♀️ 🤽‍♂️ 🤽🏻‍♂️ 🤽🏼‍♂️ 🤽🏽‍♂️ 🤽🏾‍♂️ 🤽🏿‍♂️ 🚣‍♀️ 🚣🏻‍♀️ 🚣🏼‍♀️ 🚣🏽‍♀️ 🚣🏾‍♀️ 🚣🏿‍♀️ 🚣‍♂️ 🚣🏻‍♂️ 🚣🏼‍♂️ 🚣🏽‍♂️ 🚣🏾‍♂️ 🚣🏿‍♂️ 🧗‍♀️ 🧗🏻‍♀️ 🧗🏼‍♀️ 🧗🏽‍♀️ 🧗🏾‍♀️ 🧗🏿‍♀️ 🧗‍♂️ 🧗🏻‍♂️ 🧗🏼‍♂️ 🧗🏽‍♂️ 🧗🏾‍♂️ 🧗🏿‍♂️ 🚵‍♀️ 🚵🏻‍♀️ 🚵🏼‍♀️ 🚵🏽‍♀️ 🚵🏾‍♀️ 🚵🏿‍♀️ 🚵‍♂️ 🚵🏻‍♂️ 🚵🏼‍♂️ 🚵🏽‍♂️ 🚵🏾‍♂️ 🚵🏿‍♂️ 🚴‍♀️ 🚴🏻‍♀️ 🚴🏼‍♀️ 🚴🏽‍♀️ 🚴🏾‍♀️ 🚴🏿‍♀️ 🚴‍♂️ 🚴🏻‍♂️ 🚴🏼‍♂️ 🚴🏽‍♂️ 🚴🏾‍♂️ 🚴🏿‍♂️ 🏆 🥇 🥈 🥉 🏅 🎖 🏵 🎗 🎫 🎟 🎪 🤹‍♀️ 🤹🏻‍♀️ 🤹🏼‍♀️ 🤹🏽‍♀️ 🤹🏾‍♀️ 🤹🏿‍♀️ 🤹‍♂️ 🤹🏻‍♂️ 🤹🏼‍♂️ 🤹🏽‍♂️ 🤹🏾‍♂️ 🤹🏿‍♂️ 🎭 🎨 🎬 🎤 🎧 🎼 🎹 🥁 🎷 🎺 🎸 🎻 🎲 🧩 ♟ 🎯 🎳 🎮 🎰 交通 旅行🚗 🚕 🚙 🚌 🚎 🏎 🚓 🚑 🚒 🚐 🚚 🚛 🚜 🛴 🚲 🛵 🏍 🚨 🚔 🚍 🚘 🚖 🚡 🚠 🚟 🚃 🚋 🚞 🚝 🚄 🚅 🚈 🚂 🚆 🚇 🚊 🚉 ✈️ 🛫 🛬 🛩 💺 🛰 🚀 🛸 🚁 🛶 ⛵️ 🚤 🛥 🛳 ⛴ 🚢 ⚓️ ⛽️ 🚧 🚦 🚥 🚏 🗺 🗿 🗽 🗼 🏰 🏯 🏟 🎡 🎢 🎠 ⛲️ ⛱ 🏖 🏝 🏜 🌋 ⛰ 🏔 🗻 🏕 ⛺️ 🏠 🏡 🏘 🏚 🏗 🏭 🏢 🏬 🏣 🏤 🏥 🏦 🏨 🏪 🏫 🏩 💒 🏛 ⛪️ 🕌 🕍 🕋 ⛩ 🛤 🛣 🗾 🎑 🏞 🌅 🌄 🌠 🎇 🎆 🌇 🌆 🏙 🌃 🌌 🌉 🌁 物体⌚️ 📱 📲 💻 ⌨️ 🖥 🖨 🖱 🖲 🕹 🗜 💽 💾 💿 📀 📼 📷 📸 📹 🎥 📽 🎞 📞 ☎️ 📟 📠 📺 📻 🎙 🎚 🎛 ⏱ ⏲ ⏰ 🕰 ⌛️ ⏳ 📡 🔋 🔌 💡 🔦 🕯 🗑 🛢 💸 💵 💴 💶 💷 💰 💳 🧾 💎 ⚖️ 🔧 🔨 ⚒ 🛠 ⛏ 🔩 ⚙️ ⛓ 🔫 💣 🔪 🗡 ⚔️ 🛡 🚬 ⚰️ ⚱️ 🏺 标志❤️ 🧡 💛 💚 💙 💜 🖤 💔 ❣️ 💕 💞 💓 💗 💖 💘 💝 💟 ☮️ ✝️ ☪️ 🕉 ☸️ ✡️ 🔯 🕎 ☯️ ☦️ 🛐 ⛎ ♈️ ♉️ ♊️ ♋️ ♌️ ♍️ ♎️ ♏️ ♐️ ♑️ ♒️ ♓️ 🆔 ⚛️ 🉑 ☢️ ☣️ 📴 📳 🈶 🈚️ 🈸 🈺 🈷️ ✴️ 🆚 💮 🉐 ㊙️ ㊗️ 🈴 🈵 🈹 🈲 🅰️ 🅱️ 🆎 🆑 🅾️ 🆘 ❌ ⭕️ 🛑 ⛔️ 📛 🚫 💯 💢 ♨️ 🚷 🚯 🚳 🚱 🔞 📵 🚭 ❗️ ❕ ❓ ❔ ‼️ ⁉️ 🔅 🔆 〽️ ⚠️ 🚸 🔱 ⚜️ 🔰 ♻️ ✅ 🈯️ 💹 ❇️ ✳️ ❎ 🌐 💠 Ⓜ️ 🌀 💤 🏧 🚾 ♿️ 🅿️ 🈳 🈂️ 🛂 🛃 🛄 🛅 🚹 🚺 🚼 🚻 🚮 🎦 📶 🈁 🔣 ℹ️ 🔤 🔡 🔠 🆖 🆗 🆙 🆒 🆕 🆓 0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣ 🔟 🔢 #️⃣ *️⃣ ⏏️ ▶️ ⏸ ⏯ ⏹ ⏺ ⏭ ⏮ ⏩ ⏪ ⏫ ⏬ ◀️ 🔼 🔽 ➡️ ⬅️ ⬆️ ⬇️ ↗️ ↘️ ↙️ ↖️ ↕️ ↔️ ↪️ ↩️ ⤴️ ⤵️ 🔀 🔁 🔂 🔄 🔃 🎵 🎶 ➕ ➖ ➗ ✖️ ♾ 💲 💱 ™️ ©️ ®️ 〰️ ➰ ➿ 🔚 🔙 🔛 🔝 🔜 ✔️ ☑️ 🔘 ⚪️ ⚫️ 🔴 🔵 🔺 🔻 🔸 🔹 🔶 🔷 🔳 🔲 ▪️ ▫️ ◾️ ◽️ ◼️ ◻️ ⬛️ ⬜️ 🔈 🔇 🔉 🔊 🔔 🔕 📣 📢 👁‍🗨 💬 💭 🗯 ♠️ ♣️ ♥️ ♦️ 🃏 🎴 🀄️ 🕐 🕑 🕒 🕓 🕔 🕕 🕖 🕗 🕘 🕙 🕚 🕛 🕜 🕝 🕞 🕟 🕠 🕡 🕢 🕣 🕤 🕥 🕦 🕧 ⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝 来源：https://www.cnblogs.com/cckui/p/11046826.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"Java中List集合的常用方法","slug":"Java中List集合的常用方法","date":"2020-05-13T02:15:00.000Z","updated":"2020-07-10T06:46:17.503Z","comments":true,"path":"2020/05/13/Java中List集合的常用方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/13/Java%E4%B8%ADList%E9%9B%86%E5%90%88%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"ListList接口是继承Collection接口，所以Collection集合中有的方法，List集合也继承过来。 常用方法： void add(int index, E element) 在指定位置插入元素，后面的元素都往后移一个元素。 boolean addAll(int index, Collection&lt;? extends E&gt; c) 在指定的位置中插入c集合全部的元素，如果集合发生改变，则返回true，否则返回false。 意思就是当插入的集合c没有元素，那么就返回false，如果集合c有元素，插入成功，那么就返回true。 E get(int index) 返回list集合中指定索引位置的元素 int indexOf(Object o) 返回list集合中第一次出现o对象的索引位置，如果list集合中没有o对象，那么就返回-1 ListIterator listIterator() 返回此列表元素的列表迭代器（按适当顺序）。 ListIterator listIterator(int index) 从指定位置开始，返回此列表元素的列表迭代器（按适当顺序）。 和上面那个迭代器不同的就是多了一个参数，就是能控制迭代器开始的位置。 E remove(int index) 删除指定索引的对象 E set(int index, E element) 在索引为index位置的元素更改为element元素 List subList(int fromIndex, int toIndex) 返回从索引fromIndex到toIndex的元素集合，包左不包右 void add(int index, E element)在指定位置插入元素，后面的元素都往后移一个元素。 boolean addAll(int index, Collection&lt;? extends E&gt; c)在指定的位置中插入c集合全部的元素，如果集合发生改变，则返回true，否则返回false。 意思就是当插入的集合c没有元素，那么就返回false，如果集合c有元素，插入成功，那么就返回true。 E get(int index)返回list集合中指定索引位置的元素 int indexOf(Object o)返回list集合中第一次出现o对象的索引位置，如果list集合中没有o对象，那么就返回-1 ListIterator&lt; E &gt; listIterator()返回此列表元素的列表迭代器（按适当顺序）。 listIterator和iterator的区别是什么呢？下面这篇博客比较详细的分析，可以参考。 https://blog.csdn.net/longshengguoji/article/details/41551491 这里大概讲一下他们的区别： 当只需要遍历集合时，两个迭代器的功能都是一样。 但是listIterator迭代器只能用于List和他的实现子类，iterator迭代器可以用于所有的集合使用。 所不同的就是listIterator迭代器的功能会比iterator迭代器的功能要多。 listIterator迭代器可以在遍历集合时添加、修改和删除，而iterator迭代器在遍历集合时只有删除。 ListIterator&lt; E &gt; listIterator(int index)从指定位置开始，返回此列表元素的列表迭代器（按适当顺序）。 和上面那个迭代器不同的就是多了一个参数，就是能控制迭代器开始的位置。 E remove(int index)删除指定索引的对象 E set(int index, E element)在索引为index位置的元素更改为element元素 List subList(int fromIndex, int toIndex)返回从索引fromIndex到toIndex的元素集合，包左不包右 更多Java集合List详解 学习笔记，待补充… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java集合小抄","slug":"Java的Collection集合的常用方法","date":"2020-05-13T02:05:00.000Z","updated":"2020-07-10T06:46:17.506Z","comments":true,"path":"2020/05/13/Java的Collection集合的常用方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/13/Java%E7%9A%84Collection%E9%9B%86%E5%90%88%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"常用方法 boolean add(E e) 添加元素到Collection集合中。 boolean addAll(Collection&lt;? extends E&gt; c) 将指定c中的所有元素都添加到此Collection集合中。 void clear() 移除此collection集合中的所有元素 boolean contains(Object o) 检查Collection集合中是否包含o对象，如果包含则返回true，否则返回false。 boolean containsAll(Collection&lt;?&gt; c) 检查Collection集合中是否包含c的全部对象，全部包含则返回true，否则返回false。 boolean equals(Object o) 比较此collection集合与指定对象是否相等，是比较的是里面元素是否相等，而不是比较地址是否相等。 在Object类中，equals()方法底层就是“==”，也就是说就是比较地址是否相等，但是继承后，大多数的类都重写了该方法。由于Collection是接口，不能直接new对象，所以只能new一个它的子类。 int hashCode() 返回此Collection集合的哈希码值。 boolean isEmpty() 检查Collection集合是否包含有元素，如果没有包含元素，则返回true，否则返回false。 此方法与contains方法的区别是，此方法是判断集合是否包含有元素，就是说，如果一个元素都没有的话就返回true，如果有一个或者以上就返回false。contains的方法是判断集合中是否包含特定的元素，如果包含特定的元素就返回true，如果没有包含特定元素就返回false。 Iterator iterator() 返回在此collection集合的元素上进行迭代的迭代器 注意：迭代过程中不能用集合里的添加. 删除等方法修改集合，不然会报错。如果想在迭代过程中还想操作集合，那么只能用迭代器类里面的方法。 boolean remove(Object o) 从collection集合中删除指定的元素，如果集合中有这个元素，并且删除成功，那么就返回true，否则返回false。 boolean removeAll(Collection&lt;?&gt; c) 从集合中删除c集合中所有的元素 boolean retainAll(Collection&lt;?&gt; c) 集合中仅保留c集合中的所有元素 int size() 返回集合中元素个数 Object[] toArray() 返回包含此collection集合中所有元素的数组 boolean add(E e)添加元素到Collection集合中。 boolean addAll(Collection&lt;? extends E&gt; c)将指定c中的所有元素都添加到此Collection集合中。 void clear()移除此collection集合中的所有元素 boolean contains(Object o)检查Collection集合中是否包含o对象，如果包含则返回true，否则返回false。 boolean containsAll(Collection&lt;?&gt; c)检查Collection集合中是否包含c的全部对象，全部包含则返回true，否则返回false。 boolean equals(Object o)比较此collection集合与指定对象是否相等，是比较的是里面元素是否相等，而不是比较地址是否相等。 在Object类中，equals()方法底层就是“==”，也就是说就是比较地址是否相等，但是继承后，大多数的类都重写了该方法。 由于Collection是接口，不能直接new对象，所以只能new一个它的子类。 下面这个是Object类的equals()方法，底层就是用”==”。 下面我们来看Collection的一个实现类Vector。 Vector是继承了AbstractList 所以它的equals方法是调用了父类的方法 我们再跟进去看看。真的是重写的equals方法 int hashCode()返回此Collection集合的哈希码值。 boolean isEmpty()检查Collection集合是否包含有元素，如果没有包含元素，则返回true，否则返回false。 此方法与contains方法的区别是，此方法是判断集合是否包含有元素，就是说，如果一个元素都没有的话就返回true，如果有一个或者以上就返回false。 contains的方法是判断集合中是否包含特定的元素，如果包含特定的元素就返回true，如果没有包含特定元素就返回false。 Iterator iterator()返回在此collection集合的元素上进行迭代的迭代器 注意：迭代过程中不能用集合里的添加、删除等方法修改集合，不然会报错。 如果想在迭代过程中还想操作集合，那么只能用迭代器类里面的方法。 boolean remove(Object o)从collection集合中删除指定的元素，如果集合中有这个元素，并且删除成功，那么就返回true，否则返回false。 boolean removeAll(Collection&lt;?&gt; c)从集合中删除c集合中所有的元素 boolean retainAll(Collection&lt;?&gt; c)集合中仅保留c集合中的所有元素 int size()返回集合中元素个数 Object[] toArray()返回包含此collection集合中所有元素的数组 学习笔记，待补充… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java集合小抄","slug":"Java集合小抄","date":"2020-05-13T01:42:00.000Z","updated":"2020-07-10T06:46:17.616Z","comments":true,"path":"2020/05/13/Java集合小抄/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/13/Java%E9%9B%86%E5%90%88%E5%B0%8F%E6%8A%84/","excerpt":"Java 集合 Java集合类是我们在工作中运用最多的、最频繁的类。相比于数组(Array)来说，集合类的长度可变，更加适合于现代开发需求； Java集合就像一个容器，可以存储任何类型的数据，也可以结合泛型来存储具体的类型对象。 在程序运行时，Java集合可以动态的进行扩展(动态增容)，随着元素的增加而扩大。在Java中，集合类通常存在于java.util包中。 Java集合主要由2大体系构成，分别是 Collection 体系 Map 体系 其中Collection和Map分别是2大体系中的顶层接口。","text":"Java 集合 Java集合类是我们在工作中运用最多的、最频繁的类。相比于数组(Array)来说，集合类的长度可变，更加适合于现代开发需求； Java集合就像一个容器，可以存储任何类型的数据，也可以结合泛型来存储具体的类型对象。 在程序运行时，Java集合可以动态的进行扩展(动态增容)，随着元素的增加而扩大。在Java中，集合类通常存在于java.util包中。 Java集合主要由2大体系构成，分别是 Collection 体系 Map 体系 其中Collection和Map分别是2大体系中的顶层接口。 CollectionCollection主要有三个子接口，分别为 List(列表) Set(集) Queue(队列)。 其中，List、Queue中的元素有序可重复，而Set中的元素无序不可重复。 ListList中主要有两个实现类： ArrayList LinkedList SetSet中则是有实现类: HashSet Queue而Queue是主要以数组和链表两种形式存在。 Queue是在JDK1.5后才出现的新集合 MapMap同属于java.util包中，是集合的一部分，但与Collection是相互独立的，没有任何关系。Map中都是以key-value的形式存在，其中key必须唯一主要有三个实现类： HashMap HashTable TreeMap 学习笔记，待补充… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"【LeetCode】155. 最小栈","slug":"【LeetCode】155. 最小栈","date":"2020-05-12T12:32:00.000Z","updated":"2020-07-10T06:46:17.752Z","comments":true,"path":"2020/05/12/【LeetCode】155. 最小栈/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/12/%E3%80%90LeetCode%E3%80%91155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/","excerpt":"题目描述设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例: 输入： [“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”][[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; 返回 -3.minStack.pop();minStack.top(); –&gt; 返回 0.minStack.getMin(); –&gt; 返回 -2. 提示： pop、top 和 getMin 操作总是在 非空栈 上调用。","text":"题目描述设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例: 输入： [“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”][[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; 返回 -3.minStack.pop();minStack.top(); –&gt; 返回 0.minStack.getMin(); –&gt; 返回 -2. 提示： pop、top 和 getMin 操作总是在 非空栈 上调用。 题解思路使用额外的栈（同步辅助栈）来完成。 由于栈有后进先出的特点。假设元素a入栈时，栈里有元素 b、c、d，那么只要 a 在栈中，b、c、d 就一定会在栈中，因为在 a 被出栈前，b、c、d 不会被出栈。 我们使用同步辅助栈来依次存储新元素在入栈时当前整个栈的最小值。当元素a入栈时，将当前整个栈的最小值min入栈到同步辅助栈中存储起来。 如果知道栈顶元素是a，那就可以直接知道此时原栈的最小值min了。 同步辅助栈与原栈的同步关系入栈 当原栈为空，新元素a入栈时，将新元素a拷贝一份，并入栈到辅助栈当中。 当原栈非空，新元素k入栈时，取出辅助栈的栈顶元素min_top，与k比较，将min{k, min_top}入栈到辅助栈中去。 出栈 原栈有元素出栈，辅助栈同时将栈顶元素弹出。 在任意一个时刻，原栈内元素的最小值就存储在辅助栈的栈顶中。 代码#define MAXSIZE 1600 typedef struct { // 只用一个(数组模拟的)栈来同时模拟原栈、同步辅助栈并存 // 原栈：偶数，0,2,4...... // 辅助栈：奇数，1,3,5...... int top; int *data; } MinStack; /** initialize your data structure here. */ MinStack* minStackCreate() { MinStack *obj=(MinStack *)malloc(sizeof(MinStack)); obj-&gt;data=(int *)malloc(MAXSIZE*sizeof(int)); obj-&gt;top=-1; return obj; } void minStackPush(MinStack* obj, int x) { if(obj-&gt;top == MAXSIZE-1){ // 栈满了，不做任何操作 } else if(obj-&gt;top == -1){ // 原栈 obj-&gt;top++; obj-&gt;data[obj-&gt;top] = x; // 辅助栈 obj-&gt;top++; obj-&gt;data[obj-&gt;top] = x; } else { // 当原栈非空，新元素k入栈时，取出辅助栈的栈顶元素min_top，与k比较，将`min{k, min_top}`入栈到辅助栈中去 int tmp = obj-&gt;data[obj-&gt;top]; // 原栈 obj-&gt;top++; obj-&gt;data[obj-&gt;top] = x; // 辅助栈 if(tmp &lt; x){ obj-&gt;top++; obj-&gt;data[obj-&gt;top] = tmp; } else { obj-&gt;top++; obj-&gt;data[obj-&gt;top] = x; } } } void minStackPop(MinStack* obj) { if(obj-&gt;top != -1){ // 原栈 obj-&gt;top--; // 辅助栈 obj-&gt;top--; } } int minStackTop(MinStack* obj) { if(obj-&gt;top == -1){ return; // 返回空（void） } return obj-&gt;data[obj-&gt;top-1]; // 必须减1，减1才是原栈的栈顶 } int minStackGetMin(MinStack* obj) { // 在任意一个时刻，原栈内元素的最小值就存储在辅助栈的栈顶中 return obj-&gt;data[obj-&gt;top]; } void minStackFree(MinStack* obj) { free(obj-&gt;data); obj-&gt;data = NULL; free(obj); obj = NULL; } 提交 优秀、精明的题解 【精选】使用辅助栈（同步和不同步) 详细通俗的思路分析，多解法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C语言中几种return的区分","slug":"C语言中几种return的区分","date":"2020-05-12T11:55:00.000Z","updated":"2020-07-10T06:46:17.187Z","comments":true,"path":"2020/05/12/C语言中几种return的区分/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/12/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%A0%E7%A7%8Dreturn%E7%9A%84%E5%8C%BA%E5%88%86/","excerpt":"return 0; 一般0代表的是正常结束 return -1; -1代表非正常结束 return ; void 返回是空，void返回值可以什么也不写，可以写return； return NULL; 如果数据类型是指针类型，那我们一般成功的时候返回相应的地址，失败的时候返回NULL 关于NULL，我这就简单记成 描述地址时用NULL‘清零’，描述数据时 用 0 清零.","text":"return 0; 一般0代表的是正常结束 return -1; -1代表非正常结束 return ; void 返回是空，void返回值可以什么也不写，可以写return； return NULL; 如果数据类型是指针类型，那我们一般成功的时候返回相应的地址，失败的时候返回NULL 关于NULL，我这就简单记成 描述地址时用NULL‘清零’，描述数据时 用 0 清零. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Stack，一个后进先出的集合容器","slug":"Stack，一个后进先出的集合容器","date":"2020-05-12T09:32:00.000Z","updated":"2020-07-10T06:46:17.702Z","comments":true,"path":"2020/05/12/Stack，一个后进先出的集合容器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/12/Stack%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%90%8E%E8%BF%9B%E5%85%88%E5%87%BA%E7%9A%84%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/","excerpt":"今天刷LC的每日一题时，需要使用到“栈”这种数据结构。就顺便复习了有关“栈”的知识。本文就用C来复习(预习)“Stack”。 特点Stack，本身就具有数据结构中栈的一般特性：后进先出。 定义Stack#include&lt;stack&gt; stack&lt;typename&gt; name; 栈中元素的访问 top() 只能访问其栈顶元素 通过top()来获取（或遍历） 常用的调用函数 push()：入栈 pop()：出栈（弹出栈顶元素） top：获取栈顶元素 empty()：判空，返回值是Bool类型，true为空，false为非空 size()：返回stack内元素的个数","text":"今天刷LC的每日一题时，需要使用到“栈”这种数据结构。就顺便复习了有关“栈”的知识。本文就用C来复习(预习)“Stack”。 特点Stack，本身就具有数据结构中栈的一般特性：后进先出。 定义Stack#include&lt;stack&gt; stack&lt;typename&gt; name; 栈中元素的访问 top() 只能访问其栈顶元素 通过top()来获取（或遍历） 常用的调用函数 push()：入栈 pop()：出栈（弹出栈顶元素） top：获取栈顶元素 empty()：判空，返回值是Bool类型，true为空，false为非空 size()：返回stack内元素的个数 DEMO#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct node { int data; struct node *next; }Node ,*PNode; typedef struct stack { PNode pTop; PNode pBot; }Stack, *PStack; void init(PStack pS) { pS-&gt;pTop = pS-&gt;pBot = (PNode)malloc(sizeof(Node)); pS-&gt;pBot-&gt;next = NULL; } void push(PStack pS, int val) { PNode pNew = (PNode)malloc(sizeof(Node)); pNew-&gt;data = val; pNew-&gt;next = pS-&gt;pTop; pS-&gt;pTop = pNew; } void traverse(PStack pS) { PNode p = pS-&gt;pTop; while (p != pS-&gt;pBot) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\"); } void pop(PStack pS) { if (pS-&gt;pTop != NULL) { if (pS-&gt;pTop == pS-&gt;pBot) { printf(\"已到栈底\\n\"); return; } PNode p = pS-&gt;pTop; pS-&gt;pTop = p-&gt;next; free(p); p = NULL; } } void clean(PStack pS) { PNode q = NULL; while (pS-&gt;pTop != pS-&gt;pBot){ q = pS-&gt;pTop-&gt;next; free(pS-&gt;pTop); pS-&gt;pTop = q; } } int main(void) { Stack s; init(&amp;s); push(&amp;s, 5); push(&amp;s, 4); push(&amp;s, 3); push(&amp;s, 2); push(&amp;s, 1); traverse(&amp;s); pop(&amp;s); traverse(&amp;s); clean(&amp;s); pop(&amp;s); traverse(&amp;s); system(\"pause\"); return 0; } 相关文章 stack的常见用法 java集合容器之Stack 数据结构之栈（C语言版） Java 栈 stack方法总结 Java Stack 类 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode】236. 二叉树的最近公共祖先","slug":"【LeetCode】236. 二叉树的最近公共祖先","date":"2020-05-10T02:30:00.000Z","updated":"2020-07-10T06:46:17.800Z","comments":true,"path":"2020/05/10/【LeetCode】236. 二叉树的最近公共祖先/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/10/%E3%80%90LeetCode%E3%80%91236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","excerpt":"题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。","text":"题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 代码/** * 时间复杂度：O(n) 每个节点最多就遍历一次 * 空间复杂度：O(n) 用到栈空间 */ class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) return null; if(p == root || q == root) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left == null &amp;&amp; right == null) // 根节点为空，公共祖先便为空 return null; else if(left != null &amp;&amp; right != null) // 左右两边各一个节点，那root一定是p、q的公共祖先 return root; else if(left == null) // 左子树为空，那就只用看右子树的根 return right; else if(right == null) // 右子树为空，那就只用看左子树的根 return left; // 因为函数的返回值是TreeNode，最后一定要return return null; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"最长递增子序列（LIS）","slug":"最长递增子序列（LIS）","date":"2020-05-09T13:57:00.000Z","updated":"2020-07-10T06:46:17.931Z","comments":true,"path":"2020/05/09/最长递增子序列（LIS）/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/09/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LIS%EF%BC%89/","excerpt":"","text":"代码/** * @Classname LIS * @Description 最长递增子序列（LIS） * @Date 2020/5/9 下午 9:09 * @Created by jerry */ public class LIS { public static int LIS(int[] nums) { if(nums.length &lt;= 1){ return nums.length; } //最大长度 int max = 1; //dp[i]表示第i长的子序列，最后的元素 int[] dp = new int[nums.length + 1]; dp[1] = nums[0]; for(int i = 1;i &lt; nums.length;i++){ //如果当前元素比最大的那个子串的最后一个元素还要大 //那就直接长度加一，新子串的最后一个元素为当前元素 if(nums[i] &gt; dp[max]){ dp[++max] = nums[i]; }else if(nums[i] &lt; dp[max]){ //如果当前元素比最大的那个子串的最后一个元素要小 //那就要更新dp数组，保证每一个子串都是最优解 for(int j = 1 ;j &lt;= max; j++){ //因为是递增，所以是&lt;=,在将等于的时候直接终止循环 if(nums[i] &lt;= dp[j]){ dp[j] = nums[i]; break; } } } } for (int i = 1; i &lt;= max; i++) { System.out.print(dp[i] + \" \"); } System.out.println(); return max; } public static void main(String[] args) { int[] nums = new int[]{10,9,2,5,3,7,101,18}; System.out.println(LIS(nums)); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode】69. x 的平方根","slug":"【LeetCode】69. x 的平方根","date":"2020-05-09T12:51:00.000Z","updated":"2020-07-10T06:46:17.808Z","comments":true,"path":"2020/05/09/【LeetCode】69. x 的平方根/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/09/%E3%80%90LeetCode%E3%80%9169.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/","excerpt":"","text":"这是今天”每日一题”的题目，等级是简单。不过，确实耐人寻味。最简单的方法就是采用JAVA的Math类库的方法 但是这样做，还有什么意义呢，是吧？ # 题目描述 实现 `int sqrt(int x)` 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: &gt; 输入: 4 &gt; 输出: 2 示例 2: &gt; 输入: 8 &gt; 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 &lt;!--more--&gt; # 题解 采用&lt;font color='red' size='6'&gt;“二分法”&lt;/font&gt;的思想可以很容易的完成。 其思想简单的来说，就像是玩“猜数字”的游戏，猜小了就往大的猜，猜大了就往小的猜，随着猜的次数增加，范围越来越小，离结果也就越来越近了。 那么，这里也一样的。 我们不妨可以采用这个公式来做 $$\\sqrt{k} ≦ \\frac{k}{2}$$ 我们这样子看，假设一个很大的数k，k的开方肯定不会超过它的一半，越是很大的数越是如此。 但是我们回来这个公式，看看这个公式的边界，边界是4。 0、1、2、3、4、5这样的数的开方，我们都一清二楚，所以我们要考虑的是从4开始的数字，那就完全可以忽略那些小细节了。 注意的是，**在取中位数mid的时候，应该向右取。**如果向左取得话，会陷入死循环中。 # 代码 class Solution { public int mySqrt(int x) { if(x == 0) return 0; long left = 1; long right = x / 2; while (left &lt; right){ long mid = (left + right + 1) &gt;&gt;&gt; 1; // 向右取中位数 long mid_square = mid * mid; if(mid_square &gt; x) right = mid - 1; else left = mid; } return (int)left; }} # 更多题解 官方：https://leetcode-cn.com/problems/sqrtx/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"最长公共子序列（LCS）","slug":"最长公共子序列（LCS）","date":"2020-05-09T12:51:00.000Z","updated":"2020-07-10T06:46:17.926Z","comments":true,"path":"2020/05/09/最长公共子序列（LCS）/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/09/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LCS%EF%BC%89/","excerpt":"","text":"代码#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; using namespace std; const int MAX = 100; const int m = 7, n = 6; int C[MAX][MAX]; // C[i][j]：Xi和Yj的LCS长度 int X[m] = {'A', 'B', 'C', 'B', 'D', 'A', 'B'}, Y[n] = {'B', 'D', 'C', 'A', 'B', 'A'}; void LCS(int X[], int Y[], int m, int n){ int i, j; char B[MAX][MAX]; // B[i][j]：C[i][j]取得最大值的标志 for (i = 1; i &lt;= m; i++) C[i][0] = 0; for (i = 1; i &lt;= n; i++) C[0][i] = 0; for (i = 1; i &lt;= m; i++){ for (j = 1; j &lt;= n; j++){ if (X[i] == Y[j]){ C[i][j] = C[i - 1][j - 1] + 1; B[i][j] = 'lu'; } else if (C[i-1][j] &gt;= C[i][j-1]){ C[i][j] = C[i - 1][j]; B[i][j] = 'u'; } else { C[i][j] = C[i][j - 1]; B[i][j] = 'l'; } } } printf(\"\\nC[i][j]\\n\"); for (i = 1; i &lt;= m; i++){ printf(\"%d\\t\", i); for (j = 1; j &lt;= n; j++){ printf(\"%d\\t\", C[i][j]); } printf(\"\\n\"); } printf(\"\\nB[j][j]\\n\"); for (i = 1; i &lt;= m; i++){ printf(\"%d\\t\", i); for (j = 1; j &lt;= n; j++){ printf(\"%c\\t\", B[i][j]); } printf(\"\\n\"); } } int main () { LCS(X, Y, m, n); return 0; system(\"pause\"); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"博客园写随笔时用数学公式","slug":"Java中有三种移位运算符","date":"2020-05-09T10:00:00.000Z","updated":"2020-07-10T06:46:17.460Z","comments":true,"path":"2020/05/09/Java中有三种移位运算符/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/09/Java%E4%B8%AD%E6%9C%89%E4%B8%89%E7%A7%8D%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"插入公式在开启后你就可以使用LATEX格式的公式了 行内公式使用如下格式书写，公式使用$包裹： 二元一次方程的判别式：$\\Delta=b^2-4ac$ 编译结果为：二元一次方程的判别式：$\\Delta=b^2-4ac$ 陈列(独立)公式使用如下格式书写，公式使用$$包裹： 二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 编译结果为：二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 相关阅读 https://www.cnblogs.com/linxd/p/4955530.html https://www.cnblogs.com/q735613050/p/7253073.html https://www.cnblogs.com/zhuxiaoxi/p/8320683.html","text":"插入公式在开启后你就可以使用LATEX格式的公式了 行内公式使用如下格式书写，公式使用$包裹： 二元一次方程的判别式：$\\Delta=b^2-4ac$ 编译结果为：二元一次方程的判别式：$\\Delta=b^2-4ac$ 陈列(独立)公式使用如下格式书写，公式使用$$包裹： 二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 编译结果为：二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 相关阅读 https://www.cnblogs.com/linxd/p/4955530.html https://www.cnblogs.com/q735613050/p/7253073.html https://www.cnblogs.com/zhuxiaoxi/p/8320683.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"【LeetCode】69. x 的平方根","slug":"博客园写随笔时用数学公式","date":"2020-05-09T10:00:00.000Z","updated":"2020-07-10T06:46:17.916Z","comments":true,"path":"2020/05/09/博客园写随笔时用数学公式/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/09/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%86%99%E9%9A%8F%E7%AC%94%E6%97%B6%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","excerpt":"插入公式在开启后你就可以使用LATEX格式的公式了 行内公式使用如下格式书写，公式使用$包裹： 二元一次方程的判别式：$\\Delta=b^2-4ac$ 编译结果为：二元一次方程的判别式：$\\Delta=b^2-4ac$ 陈列(独立)公式使用如下格式书写，公式使用$$包裹： 二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 编译结果为：二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 相关阅读 https://www.cnblogs.com/linxd/p/4955530.html https://www.cnblogs.com/q735613050/p/7253073.html https://www.cnblogs.com/zhuxiaoxi/p/8320683.html","text":"插入公式在开启后你就可以使用LATEX格式的公式了 行内公式使用如下格式书写，公式使用$包裹： 二元一次方程的判别式：$\\Delta=b^2-4ac$ 编译结果为：二元一次方程的判别式：$\\Delta=b^2-4ac$ 陈列(独立)公式使用如下格式书写，公式使用$$包裹： 二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 编译结果为：二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 相关阅读 https://www.cnblogs.com/linxd/p/4955530.html https://www.cnblogs.com/q735613050/p/7253073.html https://www.cnblogs.com/zhuxiaoxi/p/8320683.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"正式开通博客园","slug":"正式开通博客园","date":"2020-04-23T14:40:27.000Z","updated":"2020-04-23T11:40:36.814Z","comments":true,"path":"2020/04/23/正式开通博客园/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/23/%E6%AD%A3%E5%BC%8F%E5%BC%80%E9%80%9A%E5%8D%9A%E5%AE%A2%E5%9B%AD/","excerpt":"现在正式开通【博客园】：https://www.cnblogs.com/melodyjerry/","text":"现在正式开通【博客园】：https://www.cnblogs.com/melodyjerry/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Fiddler抓包工具","slug":"Fiddler抓包工具总结","date":"2020-04-23T11:38:39.421Z","updated":"2020-04-23T11:40:36.716Z","comments":true,"path":"2020/04/23/Fiddler抓包工具总结/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/23/Fiddler%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/","excerpt":"Fiddler抓包工具总结 https://www.cnblogs.com/yyhh/p/5140852.html","text":"Fiddler抓包工具总结 https://www.cnblogs.com/yyhh/p/5140852.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"MVC：开发模式","slug":"MVC：开发模式","date":"2020-04-23T11:38:39.409Z","updated":"2020-04-23T11:40:36.767Z","comments":true,"path":"2020/04/23/MVC：开发模式/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/23/MVC%EF%BC%9A%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/","excerpt":"MVC：开发模式一、jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 二、MVC M Model，模型。JavaBean 完成具体的业务操作，如：查询数据库，封装对象 V View，视图。JSP 展示数据 C Controller，控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 三、优缺点优点 耦合性低，方便维护，可以利于分工协作 重用性高 生命周期成本低 部署快 可维护性高 有软件工程化管理 缺点 使得项目架构变得复杂，对开发人员要求高 不适合小型，中等规模的应用程序 增加系统结构和实现的复杂性 视图与控制器间的过于紧密的连接 视图对模型数据的低效率访问 一般高级的界面工具或构造器不支持模式 扩展阅读 [CSDN] MVC模式简介 [菜鸟教程] MVC 模式 [百度百科] MVC框架","text":"MVC：开发模式一、jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 二、MVC M Model，模型。JavaBean 完成具体的业务操作，如：查询数据库，封装对象 V View，视图。JSP 展示数据 C Controller，控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 三、优缺点优点 耦合性低，方便维护，可以利于分工协作 重用性高 生命周期成本低 部署快 可维护性高 有软件工程化管理 缺点 使得项目架构变得复杂，对开发人员要求高 不适合小型，中等规模的应用程序 增加系统结构和实现的复杂性 视图与控制器间的过于紧密的连接 视图对模型数据的低效率访问 一般高级的界面工具或构造器不支持模式 扩展阅读 [CSDN] MVC模式简介 [菜鸟教程] MVC 模式 [百度百科] MVC框架 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MVC","slug":"MVC","permalink":"https://melodyjerry.github.io/blog/tags/MVC/"}]},{"title":"将博客搬至CSDN","slug":"将博客搬至CSDN","date":"2020-04-23T01:04:00.000Z","updated":"2020-04-23T11:40:36.811Z","comments":true,"path":"2020/04/23/将博客搬至CSDN/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/23/%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%87%B3CSDN/","excerpt":"现将本博客中，截止到2020-4-23 09点04分的所有博客拷贝到CSDN。 CSDN博客链接：https://blog.csdn.net/weixin_43438052","text":"现将本博客中，截止到2020-4-23 09点04分的所有博客拷贝到CSDN。 CSDN博客链接：https://blog.csdn.net/weixin_43438052 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"“点击查看”隐藏式按钮html实现","slug":"“点击查看”隐藏式按钮html实现","date":"2020-04-22T15:00:00.000Z","updated":"2020-04-23T11:40:36.795Z","comments":true,"path":"2020/04/22/“点击查看”隐藏式按钮html实现/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/22/%E2%80%9C%E7%82%B9%E5%87%BB%E6%9F%A5%E7%9C%8B%E2%80%9D%E9%9A%90%E8%97%8F%E5%BC%8F%E6%8C%89%E9%92%AEhtml%E5%AE%9E%E7%8E%B0/","excerpt":"点击查看Hexo NexT主题美化2.0浏览器控制台个性化输出Hexo 优化与加速本站主题已整理开源Hexo NexT主题之自定义标签页Hexo NexT主题移动端样式适配Hexo NexT接入Google AdSense广告NexT主题之LeanCloud切换国际版Hexo NexT主题之代码块Mac Panel特效Hexo-abbrlink生成唯一文章链接","text":"点击查看Hexo NexT主题美化2.0浏览器控制台个性化输出Hexo 优化与加速本站主题已整理开源Hexo NexT主题之自定义标签页Hexo NexT主题移动端样式适配Hexo NexT接入Google AdSense广告NexT主题之LeanCloud切换国际版Hexo NexT主题之代码块Mac Panel特效Hexo-abbrlink生成唯一文章链接 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"一款炫丽的网页播放器插件","slug":"一款炫丽的网页播放器插件","date":"2020-04-22T14:00:00.000Z","updated":"2020-04-23T11:40:36.796Z","comments":true,"path":"2020/04/22/一款炫丽的网页播放器插件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/22/%E4%B8%80%E6%AC%BE%E7%82%AB%E4%B8%BD%E7%9A%84%E7%BD%91%E9%A1%B5%E6%92%AD%E6%94%BE%E5%99%A8%E6%8F%92%E4%BB%B6/","excerpt":"一款炫丽的网页播放器插件网上看到一款挺不错的基于 HTML 5 实现的播放器插件，支持多平台音乐解析、精准 LRC 歌词、智能记忆、视频播放等多种功能。目前免费使用，只需注册即可 DIY。作者表明自己是个初！中！生！，在 2016 年用业余时间写的（网传是抄袭、暴力破解他人作品），目前每天的访问量 10W+，用的人还是挺多的，本站点也进行了集成，可在左下角体验效果。 2020 年 04 月 01 日更新：本站已弃用绚丽彩虹，推荐 明月浩空 转载链接：https://www.liaofuzhan.com/posts/2636059693.html","text":"一款炫丽的网页播放器插件网上看到一款挺不错的基于 HTML 5 实现的播放器插件，支持多平台音乐解析、精准 LRC 歌词、智能记忆、视频播放等多种功能。目前免费使用，只需注册即可 DIY。作者表明自己是个初！中！生！，在 2016 年用业余时间写的（网传是抄袭、暴力破解他人作品），目前每天的访问量 10W+，用的人还是挺多的，本站点也进行了集成，可在左下角体验效果。 2020 年 04 月 01 日更新：本站已弃用绚丽彩虹，推荐 明月浩空 转载链接：https://www.liaofuzhan.com/posts/2636059693.html 绚丽彩虹播放器 相关的功能介绍可参考： 绚丽彩虹播放器http://www.badapple.top/ 之前用的是 APlayer 这款播放器，其吸盘模式能放在网页左下角，外链需自己逐个添加。由于本站要过滤 HTTP 链接，想要的外链不好找，而且在 IE 11 （博主的破旧电脑） 里 JS 一大堆报错。。部分非主流浏览器（谁会用呢 -.-!）兼容还有点问题。 PS：NexT 5.1.4 在 Pisces 这个 scheme 下，左侧栏 sidebar 在 IE 11 里会不显示。（本站已修复） 基于这些原因（主要是找到了更好的~），所以将 Aplayer 进行了替换，步骤也很简单： 在 next/layout/_layout.swig 的 body 体内部，新增如下代码： 复制&lt;!-- badApplePlayer --&gt; {% if theme.badApplePlayer.enable %} &lt;!-- Your XlchPlayerKey --&gt; &lt;script&gt;XlchKey=\"{{theme.badApplePlayer.XlchKey}}\";&lt;/script&gt; &lt;!-- font-awesome 4.2.0 --&gt; &lt;link href=\"https://lib.baomitu.com/font-awesome/4.2.0/css/font-awesome.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt; &lt;!-- JQuery-mousewheel 3.1.9 --&gt; &lt;script src=\"https://lib.baomitu.com/jquery-mousewheel/3.1.9/jquery.mousewheel.min.js\"&gt;&lt;/script&gt; &lt;!-- Scrollbar --&gt; &lt;script src=\"https://static.https.badapple.top/BadApplePlayer/js/scrollbar.js\"&gt;&lt;/script&gt; &lt;!-- BadApplePlayer --&gt; &lt;script src=\"https://static.https.badapple.top/BadApplePlayer/Player.js\"&gt;&lt;/script&gt; {% endif %} 其还需要依赖 jquery ，我在做其它功能时已经引入，这里就不需要了，如果你加了以上代码没效果，那么再补充： 复制&lt;script src=\"https://lib.baomitu.com/jquery/2.2.4/jquery.min.js\"&gt;&lt;/script&gt; 以上链接均可换成 http 的，按需修改即可。 在主题配置文件 _config.yml 中，添加配置： 复制# http://www.badapple.top badApplePlayer: enable: true XlchKey: your_key # 播放器Key XlchKey 为你自己的播放器 Key，官网完成注册，添加播放器后即可生成。你也可使用我的 BZ9DLOyFjh 来测试下。 调整播放器在移动端大小（可选）。需要在 head 标签内添加以下代码，比如我是在 next/layout/_layout.swig 的 head 内加的： 复制{% if theme.badApplePlayer.enable %} &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=0.9, maximum-scale=0.9\" /&gt; {% endif %} hexo 三连即可看到效果。附上视频教程地址： 绚丽彩虹播放器 [BadApplePlayer] 播放器教程 V20170122https://www.bilibili.com/video/av8153459 按照教程就可以添加网易云这些第三方平台的歌单啦！ 明月浩空音乐播放器由于绚丽彩虹经常宕机，在网上找替换方案的同时，翻到了明月浩空 的网站。细品了这位大佬诸多文章后，才发现他才是播放器的原作者，只能说盗版行为太昌盛，真假难辨…明月浩空音乐播放器已经商用，功能很强大，如今开放了免费注册功能，大家不妨体验一下 明月浩空音乐播放器https://player.lmih.cn/ PS：其实也是基于 APlayer 的定制版本，又绕回来了。。😝 宅音乐播放器另外一款，看了下代码，插件是修改于明月浩空免费版，体验了下，bug 挺多，毕竟是阉割版，不过它可以添加多个播放器和歌单，而明月浩空则需要付费才可以。体验地址： 宅音乐播放器https://player.ilt.me/ 作者还分享了源代码和安装教程： 宅音乐播放器源代码https://github.com/lzx8589561/zhai-music 底层使用 PHP 所写，前端为 LayUI 框架，数据库用的 MySQL 写在最后之前搭建的几款 JAVA 后端框架，可以用来 DIY 一个自己的播放器，彻底重写，有兴趣的朋友可以尝试一下。 相关文章点击查看Hexo NexT主题美化2.0浏览器控制台个性化输出Hexo 优化与加速本站主题已整理开源Hexo NexT主题之自定义标签页Hexo NexT主题移动端样式适配Hexo NexT接入Google AdSense广告NexT主题之LeanCloud切换国际版Hexo NexT主题之代码块Mac Panel特效Hexo-abbrlink生成唯一文章链接 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"浏览器截长图的方法","slug":"浏览器截长图方法","date":"2020-04-09T14:00:00.000Z","updated":"2020-04-23T11:40:36.814Z","comments":true,"path":"2020/04/09/浏览器截长图方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E9%95%BF%E5%9B%BE%E6%96%B9%E6%B3%95/","excerpt":"Chrome -&gt; F12 -&gt; Ctrl+Shift+P -&gt; Capture full size screenshot Firefox -&gt; F12 -&gt; 右上角”…“ -&gt; 设置 -&gt; 可选的工具箱按钮 -&gt; 截取整个页面 -&gt; 右上角“相机”按钮","text":"Chrome -&gt; F12 -&gt; Ctrl+Shift+P -&gt; Capture full size screenshot Firefox -&gt; F12 -&gt; 右上角”…“ -&gt; 设置 -&gt; 可选的工具箱按钮 -&gt; 截取整个页面 -&gt; 右上角“相机”按钮 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"win10快速在当前文件夹打开cmd","slug":"win10快速在当前文件夹打开cmd","date":"2020-04-08T09:43:23.000Z","updated":"2020-04-23T11:40:36.792Z","comments":true,"path":"2020/04/08/win10快速在当前文件夹打开cmd/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/08/win10%E5%BF%AB%E9%80%9F%E5%9C%A8%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E5%A4%B9%E6%89%93%E5%BC%80cmd/","excerpt":"一般有两种简单、直接的方法： 在路径栏输入cmd，回车 即可在当前位置打开命令窗口 按住Shift键+鼠标右键，可见在“在此处打开cmd”","text":"一般有两种简单、直接的方法： 在路径栏输入cmd，回车 即可在当前位置打开命令窗口 按住Shift键+鼠标右键，可见在“在此处打开cmd” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"将idea工程打包成jar文件的全步骤","slug":"将idea工程打包成jar文件的全步骤","date":"2020-04-08T06:43:23.000Z","updated":"2020-04-23T11:40:36.810Z","comments":true,"path":"2020/04/08/将idea工程打包成jar文件的全步骤/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/08/%E5%B0%86idea%E5%B7%A5%E7%A8%8B%E6%89%93%E5%8C%85%E6%88%90jar%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E6%AD%A5%E9%AA%A4/","excerpt":"前言 近日在工作中遇到了一个问题，需要把本地的java文件打成jar包，传到云服务器上运行。于是学习了一下如何在intellijidea中将java工程打成jar包。","text":"前言 近日在工作中遇到了一个问题，需要把本地的java文件打成jar包，传到云服务器上运行。于是学习了一下如何在intellijidea中将java工程打成jar包。 步骤如下： 1、File-&gt;PorjectStructure 2、在ProjectSetings中选择Artifects。 点击+号选择jar文件中的Empty选项 Artifacts –&gt; + –&gt; JAR –&gt; From modules with dependencies… 参见文末 3、在Name选项中修改jar文件的名字。 然后点击下方的CreatManifest按钮，点击ok(应该默认是当前工程) 4、点击Main Class右侧的文件夹图标，选择当前工程的入口类，即主函数所在类，点击ok Main Class是你这个项目(\\脚本*)的主方法,就是要运行的类,选一个* 5、在右侧的AvailableElements一栏中双击编译后的资源文件，将其打入左侧jar包 6、点击Build选项中的BuildArtifacts 点击Build选项。这里Build选项是第一次构建jar，Rebuild是修改后重新构建jar，clean是删除jar。 7、在这里我们可以看见生成的jar包 8、 进入jar包所在目录，在地址栏中输入cmd按回车，进入命令行 9、执行如图命令即可运行jar文件 如果是选择 Artifacts –&gt; + –&gt; JAR –&gt; From modules with dependencies… 的话 Main Class是你这个项目(\\脚本*)的主方法,就是要运行的类,选一个* 如下图,设置 META-INF/MANIFEST.MF !!!!!切记,不能用默认的(起码我用默认的是不成功的)!!!!! 选中你这个项目的根目录,一定要放在根目录下 设置完是这样子的,关于 JAR files from libraries的两个选项: 选中第一个的话,打完包后是一个jar包 选中第二个的话,打完包后是一个jar包,外带你项目所用的jar包,个人推荐第二个 设置完后就可以点OK了 这个页面, Build on make打上勾,其他的不一样也没事 最后一步, Build Artifacts… –&gt; XXX.jar –&gt; Build 复制这里的路径去找jar包就行 参考资料： https://blog.csdn.net/weixin_42089175/article/details/89113271 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"JAVA","slug":"JAVA","permalink":"https://melodyjerry.github.io/blog/tags/JAVA/"}]},{"title":"virtualbox安装ubuntu16 LTS及其配置","slug":"virtualbox安装ubuntu16-LTS及其配置","date":"2020-04-07T11:00:00.000Z","updated":"2020-04-23T11:40:36.791Z","comments":true,"path":"2020/04/07/virtualbox安装ubuntu16-LTS及其配置/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/07/virtualbox%E5%AE%89%E8%A3%85ubuntu16-LTS%E5%8F%8A%E5%85%B6%E9%85%8D%E7%BD%AE/","excerpt":"virtualbox安装ubuntu16 LTS及其配置 https://www.cnblogs.com/luengmingbiao/p/10859905.html","text":"virtualbox安装ubuntu16 LTS及其配置 https://www.cnblogs.com/luengmingbiao/p/10859905.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}],"author":{"name":"buildings","url":"https://www.cnblogs.com/luengmingbiao/"}},{"title":"Java-生成验证码并保存到硬盘","slug":"Java-生成验证码并保存到硬盘","date":"2020-03-31T11:00:00.000Z","updated":"2020-04-23T11:40:36.764Z","comments":true,"path":"2020/03/31/Java-生成验证码并保存到硬盘/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/31/Java-%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%E5%B9%B6%E4%BF%9D%E5%AD%98%E5%88%B0%E7%A1%AC%E7%9B%98/","excerpt":"做课设时候，选择是做“图书借阅管理系统”。 在写登陆界面时候，想把前段时间学的web中生成验证码的知识用上。 于是，就写了这个。 分为两个文件：&lt;CheckCode.java&gt; 和 &lt;CheckCodeRead.java&gt; ，前者是生成，后者是读取，均可以在控制台打印验证码值 checkValue 。","text":"做课设时候，选择是做“图书借阅管理系统”。 在写登陆界面时候，想把前段时间学的web中生成验证码的知识用上。 于是，就写了这个。 分为两个文件：&lt;CheckCode.java&gt; 和 &lt;CheckCodeRead.java&gt; ，前者是生成，后者是读取，均可以在控制台打印验证码值 checkValue 。 CheckCodepackage view; import javax.imageio.ImageIO; import java.awt.*; import java.awt.image.BufferedImage; import java.io.*; import java.util.Random; /** * @Classname CheckCode * @Description TODO * @Date 2020/3/31 下午 5:13 * @Created by jerry */ public class CheckCode { public void creatCheck() { char[] chs = new char[4]; int width = 100; int height = 50; //1.创建一对象，在内存中图片(验证码图片对象) BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2.美化图片 //2.1 填充背景色 Graphics g = image.getGraphics();//画笔对象 g.setColor(Color.PINK);//设置画笔颜色 g.fillRect(0,0,width,height); //2.2画边框 g.setColor(Color.BLUE); g.drawRect(0,0,width - 1,height - 1); String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789\"; //生成随机角标 Random ran = new Random(); StringBuilder sb = new StringBuilder(); // StringBuilder：一个可变的字符序列 for (int i = 1; i &lt;= 4; i++) { int index = ran.nextInt(str.length()); //获取字符 char ch = str.charAt(index);//随机字符 sb.append(ch); chs[i-1] = ch; //2.3写验证码 g.drawString(ch+\"\",width/5*i,height/2); } String checkCode_session = sb.toString(); /* //将验证码存入session request.getSession().setAttribute(\"checkCode_session\",checkCode_session);*/ //2.4画干扰线 g.setColor(Color.GREEN); //随机生成坐标点 for (int i = 0; i &lt; 10; i++) { int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1,y1,x2,y2); } //3.将图片、验证码值写入硬盘 // ImageIO.write(image,\"jpg\",response.getOutputStream()); try { String encoding=\"GBK\"; ImageIO.write(image, \"png\",new File(\"F:\\\\MyJava\\\\LibrarySystem\\\\v0.0\\\\src\\\\image\\\\check.png\")); File file = new File(\"F:\\\\MyJava\\\\LibrarySystem\\\\v0.0\\\\src\\\\image\\\\check.txt\"); Writer out = new OutputStreamWriter(new FileOutputStream(file),encoding); out.write(checkCode_session); // 将验证码值写入check.txt文件里 out.close(); // 关闭输出流，回收资源 System.out.println(checkCode_session); } catch (IOException e) { e.printStackTrace(); } } public static void main(String[] args) { new CheckCode().creatCheck(); } } CheckCodeReadpackage view; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.InputStreamReader; /** * @Classname CheckCodeCreate * @Description TODO * @Date 2020/3/31 下午 5:51 * @Created by jerry */ public class CheckCodeRead { /** * 功能：Java读取txt文件的内容 * 步骤：1：先获得文件句柄 * 2：获得文件句柄当做是输入一个字节码流，需要对这个输入流进行读取 * 3：读取到输入流后，需要读取生成字节流 * 4：一行一行的输出。readline()。 * 备注：需要考虑的是异常情况 * @param filePath */ public static void readTxtFile(String filePath){ try { String encoding=\"GBK\"; File file=new File(filePath); if(file.isFile() &amp;&amp; file.exists()){ //判断文件是否存在 InputStreamReader read = new InputStreamReader( new FileInputStream(file),encoding);//考虑到编码格式 BufferedReader bufferedReader = new BufferedReader(read); String lineTxt = null; while((lineTxt = bufferedReader.readLine()) != null){ System.out.println(lineTxt); } read.close(); }else{ System.out.println(\"找不到指定的文件\"); } } catch (Exception e) { System.out.println(\"读取文件内容出错\"); e.printStackTrace(); } } public CheckCodeRead() { String filePath = \"F:\\\\MyJava\\\\LibrarySystem\\\\v0.0\\\\src\\\\image\\\\check.txt\"; // \"res/\"; readTxtFile(filePath); } public static void main(String argv[]){ new CheckCodeRead(); } } 效果验证码图片 check.png 👇 控制台输出 👇 check.txt 保存 验证码值 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java.sql的接口PreparedStatement使用","slug":"Java.sql的接口PreparedStatement使用","date":"2020-03-28T10:51:11.000Z","updated":"2020-04-23T11:40:36.765Z","comments":true,"path":"2020/03/28/Java.sql的接口PreparedStatement使用/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/28/Java.sql%E7%9A%84%E6%8E%A5%E5%8F%A3PreparedStatement%E4%BD%BF%E7%94%A8/","excerpt":"","text":"package utils; import java.sql.*; /** * @Classname JdbcUtils * @Description JDBC的工具类。(尽量用单例模式) * @Created by melodyjerry */ public class JdbcUtil { private static final String driverName = \"com.mysql.jdbc.Driver\"; // 数据库连接路径 private static final String URL = \"jdbc:mysql://localhost:3306/librarysystem?\" //127.0.0.1 + \"useUnicode = true &amp; serverTimezone = GMT\" // MySQL在高版本需要指明是否进行SSL连接 + \"&amp; characterEncoding = utf8 &amp; useSSL = false\"; private static final String userName = \"root\"; private static final String userPassword = \"root\"; private static Connection dbConn = null; private static Statement stmt; private static JdbcUtil utils = null; // 预编译语句 private static PreparedStatement pstmt = null; /** * 不是线程安全的 * 如果有并发访问实例化的时候会出现线程安全的问题 * 解决办法加同步锁synchronized */ public synchronized static JdbcUtil getJdbcUtil() { if (utils == null) { utils = new JdbcUtil(); return utils; } return utils; } /** * 静态代码块 * 将加载驱动、连接数据库放入静态块中 */ static { if (dbConn == null) { try { // 使用Class.forName()方式来加载数据库的驱动类 // Class.forName()是Java提供的一种基于反射的方式，直接根据类的全限定名（包+类） Class.forName(driverName); System.out.println(\"加载驱动成功！\"); }catch(Exception e){ e.printStackTrace(); System.out.println(\"加载驱动失败！\"); } try{ dbConn= DriverManager.getConnection(URL,userName,userPassword); System.out.println(\"连接数据库成功！\"); }catch(Exception e) { e.printStackTrace(); System.out.print(\"SQL Server连接失败！\"); } } } /** * 对外提供一个方法来获取数据库连接 * @return dbConn * @throws Exception */ public static Connection getConn() throws Exception { return dbConn; } /** * 创建语句对象 * @return stmt * @throws Exception */ public static Statement getStmt() throws Exception { if(stmt == null) { try { if(dbConn == null) { dbConn = getConn(); } stmt = dbConn.createStatement(); } catch (Exception e) { e.printStackTrace(); } } return stmt; } /** * 预编译语句对象 * PreparedStatement对象可以防止sql注入，而Statement不能防止sql注入 * @param sql * @return * @throws Exception */ public static PreparedStatement getPstmt(String sql) throws Exception { if(pstmt == null) { try { pstmt = dbConn.prepareStatement(sql); } catch (SQLException e) { e.printStackTrace(); } } return pstmt; } /** * 关闭数据库连接 * @param dbConn * @throws Exception */ public void closeConn(Connection dbConn) throws Exception { try { if(dbConn != null) dbConn.close(); } catch (SQLException e) { e.printStackTrace(); System.out.print(\"MySQL数据库关闭失败！\"); } } /** * 测试数据库连接、sql操作 * @param args */ public static void main(String[] args) { // 创建实例来测试连接 JdbcUtil jdbcUtil = new JdbcUtil(); try { getConn(); // jdbcUtil.getConn(); // 基于数据库连接Connection对象，创建SQL语句执行句柄，Statement对象 // prepareStatement对象，就是用来基于底层的Connection代表的数据库连接 // 允许我们通过java程序，通过prepareStatement对象，向MySQL数据库发送SQL语句 // 从而实现通过发送的SQL语句来执行增删改查等逻辑 // 第一个，SQL语句中，值所在的地方，都用问号（?）代表 String sql = \"select * from admin where adminName = ? and adminPassword = ?;\"; pstmt = dbConn.prepareStatement(sql); // 第二个，必须调用PreparedStatement的setX()系列方法，对指定的占位符设置实际的值 pstmt.setString(1,\"admin\"); pstmt.setString(2,\"admin\"); // Statement.executeQuery()方法，用来执行select语句 // Statement.executeUpdate()方法，就可以用来执行insert、update、delete语句 // executeUpdate()方法，返回类型是个int值，也就是SQL语句影响的行数 // 第三个，执行SQL语句时，直接使用executeQuery()即可，不用传入任何参数 ResultSet rs = pstmt.executeQuery(); // int rsn = pstmt.executeUpdate(); // System.out.println(\"SQL语句影响了【\" + rsn + \"】行。\"); while(rs.next()){ //打印的就是总记录数。把检索结果看成只有一跳记录一个字段的表 System.out.println(rs.getString(3)+\"\\t\"); } } catch (SQLException e) { e.printStackTrace(); System.out.println(\"sql语句操作失败！\"+e.toString()); } catch (Exception e) { e.printStackTrace(); System.out.println(\"存在异常！\"+e.toString()); }finally { try { // 最后一定要记得在finally代码块中，尽快在执行完SQL语句之后，就释放数据库连接 if (pstmt != null){ pstmt.close(); } if (dbConn !=null){ dbConn.close(); } }catch (Exception e){ e.printStackTrace(); } } } } 参考资料： PreparedStatement用法详解 对PreparedStatement、Statement的一点总结 java中PreparedStatement和Statement详细讲解 prepareStatement的用法和解释 PreparedStatement接口，prepareStatement方法 PreparedStatement的用法 Java.sql的接口PreparedStatement使用 怎么得到PreparedStatement查询条数的结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"https://melodyjerry.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"全能终端神器——MobaXterm","slug":"全能终端神器MobaXterm","date":"2020-03-25T03:17:00.000Z","updated":"2020-04-23T11:40:36.797Z","comments":true,"path":"2020/03/25/全能终端神器MobaXterm/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/25/%E5%85%A8%E8%83%BD%E7%BB%88%E7%AB%AF%E7%A5%9E%E5%99%A8MobaXterm/","excerpt":"现今软件市场上有很多终端工具，比如：secureCRT、Putty、telnet，等等。secureCRT其实也是一款很强大的终端工具，良许也使用过它很长时间，但是，它毕竟是收费软件，在公司里不允许使用。而且在良许自己的电脑里一量输入大写，整个界面就乱了（原因未知，未深究），这是直接导致良许放弃它的原因。 而Putty，它非常小巧，而且免费，在我们公司大量使用。但是良许不喜欢它的原因是它真的不好用，不支持标签，开多个会话的话就需要开多个窗口，窗口切换也很不方便，因此良许就使用了一两个月后就放弃它了。 当然还有其它终端工具，比如XShell，由于没用过就不敢乱评价了。 本文要隆重推出一款集万千于一身的全能型终端神器——MobaXterm！这款神器是我师傅介绍给我的，在我第一次使用它的时候，就深深爱上它了，真的是相见恨晚，从此一发不不可收拾，自己电脑，公司电脑全部都安上了这款神器。 先说说这款神器的优点： 功能十分强大，支持SSH，FTP，串口，VNC，X server等功能； 支持标签，切换也十分方便； 众多快捷键，操作方便； 有丰富的插件，可以进一步增强功能； 虽然有收费版，但免费版已经可以让我们装逼装上天…… 当然优点、功能远不止这些，更多闪光点期待读者去发掘！ 废话这么多，下面进入教学阶段。","text":"现今软件市场上有很多终端工具，比如：secureCRT、Putty、telnet，等等。secureCRT其实也是一款很强大的终端工具，良许也使用过它很长时间，但是，它毕竟是收费软件，在公司里不允许使用。而且在良许自己的电脑里一量输入大写，整个界面就乱了（原因未知，未深究），这是直接导致良许放弃它的原因。 而Putty，它非常小巧，而且免费，在我们公司大量使用。但是良许不喜欢它的原因是它真的不好用，不支持标签，开多个会话的话就需要开多个窗口，窗口切换也很不方便，因此良许就使用了一两个月后就放弃它了。 当然还有其它终端工具，比如XShell，由于没用过就不敢乱评价了。 本文要隆重推出一款集万千于一身的全能型终端神器——MobaXterm！这款神器是我师傅介绍给我的，在我第一次使用它的时候，就深深爱上它了，真的是相见恨晚，从此一发不不可收拾，自己电脑，公司电脑全部都安上了这款神器。 先说说这款神器的优点： 功能十分强大，支持SSH，FTP，串口，VNC，X server等功能； 支持标签，切换也十分方便； 众多快捷键，操作方便； 有丰富的插件，可以进一步增强功能； 虽然有收费版，但免费版已经可以让我们装逼装上天…… 当然优点、功能远不止这些，更多闪光点期待读者去发掘！ 废话这么多，下面进入教学阶段。 1. 软件的安装 直接去官网下载，有免费版下载。当然你要是够土豪买收费版良许也不介意。免费版不仅提供了安装版，还提供了免安装的绿色版，我们甚至可以将它拷到U盘，在家里有公司所有配置都一样。 2. 创建SSH session 安装完毕之后界面长这个样。 当然你们刚安装完成是不会有任何session的。下面来创建第一个SSH session。 点击菜单栏 「sessions」 –&gt; 「new session」，即可弹出 「session setting」 对话框。由上面那一大串的连接方式我们就可以知道Moba的强大之处。 我们点选第一个SSH图标，并填入相关信息，就可以完成session创建了。 点击确定后，输入密码就可以连接上虚拟机了。而且边上虚拟机之后，它会自动通过FTP也连接到虚拟机，直接拖拽就可以进行文件复制了。 3. 快速连接session 创建一个session之后，就可以在左侧的session标签里留下它的信息，下次需要连接的时候直接双击即可。 4. 创建串口session 下面介绍串口session的创建。 如同第2步，在「session setting」 对话框里选择serial，再选好串口号及波特率，点击OK就完成连接了。 同样session会保存在左侧的session标签页里，方便下次连接。 5. 几个有用的设置 5.1 隐藏菜单栏下的那排按钮 菜单栏下的那排按钮感觉有点鸡肋，全部可以从菜单栏里找到，而且使用频率也不是非常高。况且，大部分屏幕是长方形的，上下空间有限，左右还比较富余一些，因此去掉它可以省下很大空间。 在菜单栏点击 「view」 –&gt; 「show menu bar」，即可隐藏此排按钮。 5.2 右键粘贴 在Moba及很多终端工具里，都有这样的功能：鼠标左键划选复制文件，右键粘贴文本。但在Moba中右键粘贴功能默认不打开，我们可以手动打开。 在菜单栏点击 「settings」 –&gt; 「Configuration」，在弹出的对话框中选择 「terminal」，再将 「paste using right-click」 打上对勾即可。 5.3 关闭自动弹出SFTP Moba在连接上远程电脑之后，将自动打开左侧的SFTP侧边栏。有时我们并不需要SFTP，同时主窗口是黑色的，SFTP又是白色的，显得有点刺眼，因此可以将自动弹出SFTP功能关闭掉。 在菜单栏点击 「settings」 –&gt; 「Configuration」，在弹出的对话框中选择 「SSH」，再将 「automaticall switch to SSH-browser tab after login」 前面的对勾去掉即可。 6. 小结 本文介绍了三种连接方式：SSH，FTP，serial，以及三个有用的设置。当然Moba的功能远不止这些，但这三种连接方式是最基本，最常用的，因此先拿出来讲。在后续的博文中，将进一步介绍Moba的高级用法，敬请期待！ 本文章转载自知乎 [良许Linux] 本文仅供学习使用 原文链接：https://zhuanlan.zhihu.com/p/56341917 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}],"author":{"name":"良许Linux","url":"https://zhuanlan.zhihu.com/p/56341917"}},{"title":"VS Code配置C/C++环境","slug":"VS Code 配置C、C++环境","date":"2020-03-21T03:17:00.000Z","updated":"2020-04-23T11:40:36.778Z","comments":true,"path":"2020/03/21/VS Code 配置C、C++环境/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/21/VS%20Code%20%E9%85%8D%E7%BD%AEC%E3%80%81C++%E7%8E%AF%E5%A2%83/","excerpt":"","text":"1、安装 VS Code官网下载安装包直接安装即可 https://code.visualstudio.com/ 2、VS Code 插件 C/C++ 彩虹括号 汉化 Include Autocorrelete 3、安装mingw-w64在mingw-w64官网下载64位的mingw-w64离线包 https://sourceforge.net/projects/mingw-w64/files/?source=navbar 根据系统选择合适的安装包进行下载（win10_64位选择如图标签） 可以直接下载文件压缩包(我是下载文件压缩包直接解压就可以用了) 4、配置计算机环境变量PATH我的bin目录是：C:\\mingw64\\bin 把它加到环境变量中的PATH里去 5、重启电脑、检验安装重启电脑后，打开CMD，输入gcc -v查看是否安装正确 输入gcc -v的最后一行输出。版本要和你自己下的对应，例如64位要有x86_64和seh 6、VS Code 配置运行环境打开vscode，选择或新建一个空文件夹目录打开作为项目目录。点击“文件”按钮，再点击“新建文件夹”按钮，并重命名为”.vscode”。在该文件夹内，在点击“新建文件”按钮，建launch.json，settings.json，tasks.json三个.json文件。 launch.json{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"(gdb) Launch\", \"preLaunchTask\": \"build\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${fileDirname}/${fileBasenameNoExtension}.exe\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": true, \"MIMode\": \"gdb\", \"miDebuggerPath\": \"C:/Program Files/mingw-w64/x86_64-8.1.0-release-posix-sjlj-rt_v6-rev0/mingw64/bin/gdb.exe\", // 这里修改GDB路径为安装的mingw64的bin下的gdb.exe路径 \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true, } ] }] } tasks.json{ \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"build\", \"type\": \"shell\", \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"presentation\": { \"echo\": true, \"reveal\": \"always\", \"focus\": false, \"panel\": \"shared\" }, \"windows\": { \"command\": \"g++\", \"args\": [ \"-ggdb\", \"\\\"${file}\\\"\", \"--std=c++11\", \"-o\", \"\\\"${fileDirname}\\\\${fileBasenameNoExtension}.exe\\\"\", \"-finput-charset=UTF-8\",//输入编译器文本编码 默认为UTF-8 \"-fexec-charset=GBK\"//编译器输出文本编码 自行选择 ] } } ] } settings.json// Configuring tasks.json for C/C++ debugging // author: huihut // repo: https://gist.github.com/huihut/887d3c28db92617bd5148c20a5ff112a // Available variables which can be used inside of strings. // ${workspaceRoot}: the root folder of the team // ${file}: the current opened file // ${fileBasename}: the current opened file's basename // ${fileDirname}: the current opened file's dirname // ${fileExtname}: the current opened file's extension // ${cwd}: the current working directory of the spawned process { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"build\", \"type\": \"shell\", \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"presentation\": { \"echo\": true, \"reveal\": \"always\", \"focus\": false, \"panel\": \"shared\" }, \"windows\": { \"command\": \"g++\", \"args\": [ \"-ggdb\", \"\\\"${file}\\\"\", \"--std=c++11\", \"-o\", \"\\\"${fileDirname}\\\\${fileBasenameNoExtension}.exe\\\"\" ] } } ], \"files.autoSave\": \"afterDelay\", \"[c]\": { }, \"files.encoding\": \"utf8\", \"files.autoGuessEncoding\": true, \"explorer.confirmDragAndDrop\": false, \"workbench.colorTheme\": \"Visual Studio Dark\", \"team.showWelcomeMessage\": false } 工作区设置（可选）{ \"C_Cpp.errorSquiggles\": \"Disabled\", \"files.associations\": { \"stdlib.h\": \"c\", \"time.h\": \"c\" } } 7、运行测试代码新建一个文件，run试试 #include &lt;iostream&gt; int main() { std::cout &lt;&lt; \"Hello World!\\n\"; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://melodyjerry.github.io/blog/tags/C-C/"}]},{"title":"蓝桥杯-模拟正整数序列的数量","slug":"蓝桥杯-模拟正整数序列的数量","date":"2020-03-15T06:41:11.000Z","updated":"2020-04-23T11:40:36.819Z","comments":true,"path":"2020/03/15/蓝桥杯-模拟正整数序列的数量/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/15/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%A8%A1%E6%8B%9F%E6%AD%A3%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E9%87%8F/","excerpt":"问题描述 小明想知道，满足以下条件的正整数序列的数量： 1. 第一项为 n； 2. 第二项不超过 n； 3. 从第三项开始，每一项小于前两项的差的绝对值。 请计算，对于给定的 n，有多少种满足条件的序列。","text":"问题描述 小明想知道，满足以下条件的正整数序列的数量： 1. 第一项为 n； 2. 第二项不超过 n； 3. 从第三项开始，每一项小于前两项的差的绝对值。 请计算，对于给定的 n，有多少种满足条件的序列。 输入格式 输入一行包含一个整数 n。 输出格式 输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。 样例输入4 样例输出7 样例说明 以下是满足条件的序列： 4 1 4 1 1 4 1 2 4 2 4 2 1 4 3 4 4 评测用例规模与约定 对于 20% 的评测用例，1 &lt;= n &lt;= 5； 对于 50% 的评测用例，1 &lt;= n &lt;= 10； 对于 80% 的评测用例，1 &lt;= n &lt;= 100； 对于所有评测用例，1 &lt;= n &lt;= 1000。 代码实现import java.util.Scanner; public class Demo8序列 { public static int n=0,count=0; public static int [] []map ; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n =sc.nextInt(); sc.close(); map = new int [n+1][n+1]; for (int i = 1; i &lt;=n; i++) { map[i][i]=1; map[i][0]=1; map[0][i]=1; } for (int i = 1; i &lt;=n; i++) { count+=f(n,i); count%=10000; // System.out.println(count); } System.out.println(count); // System.out.println(f(4,2)); } public static int f(int x,int y){ if(map[x][y]!=0){ return map[x][y]; } for (int i = Math.abs(x-y)-1; i&gt;=0; i--) { map[x][y]+=f(y,i); } map[x][y]%=10000; map[y][x]=map[x][y]; return map[x][y]; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"蓝桥杯-模拟组织晚会","slug":"蓝桥杯-模拟组织晚会","date":"2020-03-15T06:33:11.000Z","updated":"2020-04-23T11:40:36.820Z","comments":true,"path":"2020/03/15/蓝桥杯-模拟组织晚会/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/15/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%A8%A1%E6%8B%9F%E7%BB%84%E7%BB%87%E6%99%9A%E4%BC%9A/","excerpt":"问题描述 小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。 这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。 小明发现，观众对于晚上的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。 小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。","text":"问题描述 小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。 这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。 小明发现，观众对于晚上的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。 小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。 输入格式 输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。 第二行包含 n 个整数，依次为每个节目的好看值。 输出格式 输出一行包含 m 个整数，为选出的节目的好看值。 样例输入5 33 1 2 5 4 样例输出3 5 4 样例说明 选择了第1, 4, 5个节目。 评测用例规模与约定对于 30% 的评测用例，1 &lt;= n &lt;= 20； 对于 60% 的评测用例，1 &lt;= n &lt;= 100； 对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。 代码实现import java.util.ArrayList; import java.util.Arrays; import java.util.Scanner; public class Demo10选节目 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int[] num = new int[n]; int[] order = new int[n]; for (int i = 0; i &lt; n; i++) { num[i] = sc.nextInt(); order[i] = num[i]; } sc.close(); Arrays.sort(order); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for (int i = n - m; i &lt; n; i++) { list.add(order[i]); } StringBuilder sb = new StringBuilder(\"\"); for (int i : num) { if (list.contains(i)) { sb.append(i + \" \"); } } System.out.println(sb); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"蓝桥杯-模拟带九9的数的个数","slug":"蓝桥杯-模拟带九9的数的个数","date":"2020-03-15T06:21:11.000Z","updated":"2020-04-23T11:40:36.818Z","comments":true,"path":"2020/03/15/蓝桥杯-模拟带九9的数的个数/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/15/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%A8%A1%E6%8B%9F%E5%B8%A6%E4%B9%9D9%E7%9A%84%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0/","excerpt":"问题描述 在1至2019中，有多少个数的数位中包含数字9？ 注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算只是算一个数。","text":"问题描述 在1至2019中，有多少个数的数位中包含数字9？ 注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算只是算一个数。 答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 ​ 答案：544 代码实现/** * @Classname Main * @Description 模拟带九9的数的个数 * @Date 2020/3/15 下午 2:21 * @Created by jerry */ public class Main { public static void main(String[] args) { int count=0; A: for (int i = 1; i &lt;=2019; i++) { int a=i; while(a!=0){ int b = a%10; if(b==9){ count++; continue A; } a/=10; } } System.out.println(count); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"蓝桥杯-求一个数的约数个数","slug":"蓝桥杯-求一个数的约数个数","date":"2020-03-15T06:11:11.000Z","updated":"2020-04-23T11:40:36.819Z","comments":true,"path":"2020/03/15/蓝桥杯-求一个数的约数个数/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/15/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0/","excerpt":"问题描述 1200000有多少个约数（只计算正约数）。","text":"问题描述 1200000有多少个约数（只计算正约数）。 答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 答案：96 代码实现import java.io.*; import java.util.*; public class Main{ public static void main(String [] args){ Scanner s=new Scanner(System.in); String sc=s.nextLine(); int num=Integer.valueOf(sc); String ss=s.nextLine(); String []sss=ss.split(\" \"); for(int i=0;i&lt;num;i++){ System.out.println(yueshu(Integer.valueOf(sss[i]))); } } static int yueshu(int a){ int num=0; for(int i=1;i&lt;=Math.sqrt(a);i++){ if(a%i==0){ if(i!=Math.sqrt(a)) num=num+2; else num=num+1; } } return num; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"生成n位的所有二进制数","slug":"生成n位的所有二进制数","date":"2020-03-12T04:14:11.000Z","updated":"2020-04-23T11:40:36.815Z","comments":true,"path":"2020/03/12/生成n位的所有二进制数/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/12/%E7%94%9F%E6%88%90n%E4%BD%8D%E7%9A%84%E6%89%80%E6%9C%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/","excerpt":"需求要求输入位数n，生成所有情况的二进制数并存进数组","text":"需求要求输入位数n，生成所有情况的二进制数并存进数组 实现import java.util.ArrayList; import java.util.List; /** * @Classname BinaryList * @Description 输入位数n，生成所有情况的二进制数并存进数组 * @Date 2020/3/12 上午 11:54 * @Created by MelodyJerry */ public class BinaryList { public static void main(String[] args){ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int n = 4; //二进制位数 int i = 1; for(int j = n; j &gt; 0; j--){ i = i * 2; //对应位权 } for(i = i-1 ; i &gt;= 0; i--){ //System.out.println(i); String bin = Integer.toBinaryString(i); while(bin.length() &lt; n){ bin = \"0\"+bin; } //System.out.println(bin); list.add(bin); } for(String entry : list){ System.out.println(entry); } } } 需求用户输入一个整数，程序输出该数的二进制 实现package org.pcl; import java.util.Scanner; /** * 用户输入一个整数，程序输出该数的二进制 * * @version 1.0 2014-05-05 * @author yifan */ public class OutBinary { public static void main(String[] args) { Scanner scan = new Scanner(System.in); System.out.println(\"请输入一个整数:\"); int number = scan.nextInt(); int tmp = 1&lt;&lt;31; //用于计算的临时变量 System.out.println(); for(int i=0; i&lt;Integer.SIZE-1; i++) { //System.out.print(number &amp;(tmp&gt;&gt;&gt;=1)); System.out.print( (number &amp;(tmp&gt;&gt;&gt;=1))&gt;0? 1:0); } System.out.println(); if(scan != null) { scan.close(); } } } 该实现代码由CSDN博主「yfstdio」提供原文链接：https://blog.csdn.net/yfstdio/article/details/25079563 需求二、八、十六进制输出 实现一、未使用移位运算 public static void main(String[] args) { int a = -17; System.out.println(\"二进制输出\"+Integer.toBinaryString(a)); System.out.println(\"八进制输出\"+Integer.toOctalString(a)); System.out.printf(\"八进制输出\"+\"%010o\\n\",a); //按10位十六进制输出，向右靠齐，左边用0补齐 System.out.printf(\"十六进制输出\"+\"%010x\\n\",a); //按10位八进制输出，向右靠齐，左边用0补齐 System.out.println(\"十六进制输出\"+Integer.toHexString(a)); System.out.println(); int b = 17; System.out.println(\"二进制输出\"+Integer.toBinaryString(b)); System.out.println(\"八进制输出\"+Integer.toOctalString(b)); System.out.printf(\"八进制输出\"+\"%010o\\n\",b); System.out.printf(\"十六进制输出\"+\"%010x\\n\",b); System.out.println(\"十六进制输出\"+Integer.toHexString(b)); } /* 运行结果： 二进制输出11111111111111111111111111101111 八进制输出37777777757 八进制输出37777777757 十六进制输出00ffffffef 十六进制输出ffffffef 二进制输出10001 八进制输出21 八进制输出0000000021 十六进制输出0000000011 十六进制输出11 */ 二、使用移位运算 public static void main(String[] args) { int a = -5; System.out.println(a); System.out.println(\"二进制输出\"+Integer.toBinaryString(a)); System.out.println(a+\"&lt;&lt;2\"+\"=\"+(a&lt;&lt;2)); System.out.println(\"二进制输出\"+Integer.toBinaryString(a&lt;&lt;2)); System.out.println(a+\"&gt;&gt;2\"+\"=\"+(a&gt;&gt;2)); System.out.println(\"二进制输出\"+Integer.toBinaryString(a&gt;&gt;2)); System.out.println(\"无符号右移\"+a+\"&gt;&gt;&gt;2\"+\"=\"+(a&gt;&gt;&gt;2)); System.out.println(\"二进制输出\"+Integer.toBinaryString(a&gt;&gt;&gt;2)); System.out.println(); int b = 5; System.out.println(b); System.out.println(\"二进制输出\"+Integer.toBinaryString(b)); System.out.println(b+\"&lt;&lt;2\"+\"=\"+(b&lt;&lt;2)); System.out.println(\"二进制输出\"+Integer.toBinaryString(b&lt;&lt;2)); System.out.println(b+\"&gt;&gt;2\"+\"=\"+(b&gt;&gt;2)); System.out.println(\"二进制输出\"+Integer.toBinaryString(b&gt;&gt;2)); System.out.println(\"无符号右移\"+b+\"&gt;&gt;&gt;2\"+\"=\"+(b&gt;&gt;&gt;2)); System.out.println(\"二进制输出\"+Integer.toBinaryString(b&gt;&gt;&gt;2)); } /* 运行结果： -5 二进制输出11111111111111111111111111111011 -5&lt;&lt;2=-20 二进制输出11111111111111111111111111101100 -5&gt;&gt;2=-2 二进制输出11111111111111111111111111111110 无符号右移-5&gt;&gt;&gt;2=1073741822 二进制输出111111111111111111111111111110 5 二进制输出101 5&lt;&lt;2=20 二进制输出10100 5&gt;&gt;2=1 二进制输出1 无符号右移5&gt;&gt;&gt;2=1 二进制输出1 */ 左移运算符&lt;&lt; 1、a&lt;&lt;n 将a的二进制数据左移b位，右边移空的部分补0 可以理解为数字a= a2^n（移了n位）。5&lt;&lt;2 –&gt;52^2=20 -5&lt;&lt;2^2=-20 2、a&gt;&gt;n 将a的二进制数据右移b位，如果最高位是0，则左边移空的部分补0，如果最高位是1，则左边移空的部分补1 可以理解为数字a= a/2^n（移了n位），向下取整。5&gt;&gt;2 —&gt; 5/2^2=1; 3、-5&gt;&gt;2 –&gt; -5/2^2=-2 (向下取整) a&gt;&gt;&gt;n 不管最高位是0或1，左边移空部分都补0 正数可以按右移计算，负数没有捷径。 本实现代码由 CSDN博主「qq_36503510」提供原文链接：https://blog.csdn.net/qq_36503510/article/details/83957214 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"和一个人聊天很舒服是什么感觉？","slug":"和一个人聊天很舒服是什么感觉？","date":"2020-03-02T11:58:00.000Z","updated":"2020-03-02T12:35:48.202Z","comments":true,"path":"2020/03/02/和一个人聊天很舒服是什么感觉？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/02/%E5%92%8C%E4%B8%80%E4%B8%AA%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%BE%88%E8%88%92%E6%9C%8D%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%9F%E8%A7%89%EF%BC%9F/","excerpt":"说来这文案是有问题的。和一个人聊天很舒服是什么感觉？ 当然是很舒服啊。 我也是不知道当时为什么会这么写。 不过，确实很开心 ——2020.3.2","text":"说来这文案是有问题的。和一个人聊天很舒服是什么感觉？ 当然是很舒服啊。 我也是不知道当时为什么会这么写。 不过，确实很开心 ——2020.3.2 运气 彩 蛋 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"一熟悉的陌生人","slug":"一熟悉的陌生人","date":"2020-02-29T11:26:11.000Z","updated":"2020-03-02T12:35:48.192Z","comments":true,"path":"2020/02/29/一熟悉的陌生人/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/29/%E4%B8%80%E7%86%9F%E6%82%89%E7%9A%84%E9%99%8C%E7%94%9F%E4%BA%BA/","excerpt":"昨晚 和一个女孩在聊天，聊到了很多。聊着聊着，聊到了一些事情让我联想到一些经历。 后来，和她说了一些奇怪的话。想哭，早早结束了一日的聊天，自己静了静。 一觉醒来，却收到了她的另一大段话。看完的那刻，我觉得这是个好女孩。很可爱的女孩。 对她，我不知道如何去定位她。彼此都说了一些奇怪但又是奇妙的话。 硬要是用一个词来形容，我只能想到“熟悉的陌生人”。 陌生是此前从未有过任何交流，熟悉是原来都知道对方还有着很多相似的地方。 这么些天来，对她，心跳有过那么几次起伏跌落。 有那么几个时候觉得她是我想找的那个人，但可能是吧也可能不是…… 于我，生活和情感，是我目前觉得最难的两个了吧。——2020.2.29随笔 选自聊天记录的其中一张","text":"昨晚 和一个女孩在聊天，聊到了很多。聊着聊着，聊到了一些事情让我联想到一些经历。 后来，和她说了一些奇怪的话。想哭，早早结束了一日的聊天，自己静了静。 一觉醒来，却收到了她的另一大段话。看完的那刻，我觉得这是个好女孩。很可爱的女孩。 对她，我不知道如何去定位她。彼此都说了一些奇怪但又是奇妙的话。 硬要是用一个词来形容，我只能想到“熟悉的陌生人”。 陌生是此前从未有过任何交流，熟悉是原来都知道对方还有着很多相似的地方。 这么些天来，对她，心跳有过那么几次起伏跌落。 有那么几个时候觉得她是我想找的那个人，但可能是吧也可能不是…… 于我，生活和情感，是我目前觉得最难的两个了吧。——2020.2.29随笔 选自聊天记录的其中一张 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"HTTP案例：文件下载","slug":"HTTP案例：文件下载","date":"2020-02-24T14:10:12.000Z","updated":"2020-04-23T11:40:36.738Z","comments":true,"path":"2020/02/24/HTTP案例：文件下载/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/24/HTTP%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/","excerpt":"结束HTTP的学习后，记录一份案例学习的笔记。 需求 页面显示超链接 点击超链接后弹出下载提示框 完成图片文件下载","text":"结束HTTP的学习后，记录一份案例学习的笔记。 需求 页面显示超链接 点击超链接后弹出下载提示框 完成图片文件下载 分析 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示。如果不能解析，则弹出下载提示框。不不满足需求。 任何资源都必须弹出下载提示框。 使用响应头设置资源的打开方式： content-disposition:attachment;filename=xxx 步骤一、定义页面，编辑超链接href属性，并指向Servlet，传递资源名称filename 二、定义Servlet 获取文件名称 使用字节输入流加载文件进内存 指定response的响应头： content-disposition:attachment;filename=xxx 将数据写出到response输出流 代码 web下New一个download.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;文件下载&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"/day15/img/1.jpg\"&gt;图片1&lt;/a&gt; &lt;hr&gt; &lt;a href=\"/day15/downloadServlet?filename=1.jpg\"&gt;图片1&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 包cn.itcast.web.download下New一个DownloadServlet.java package cn.itcast.web.download; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.FileInputStream; import java.io.IOException; /** * @Classname DownloadServlet * @Description 文件下载 * @Date 2020/2/24 下午 5:37 * @Created by jerry */ @WebServlet(\"/downloadServlet\") public class DownloadServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求参数，即文件名称 String filename = request.getParameter(\"filename\"); //2.使用字节输入流加载进内存 //2-1.找到文件的服务器路径 ServletContext servletContext = this.getServletContext(); String realPath = servletContext.getRealPath(\"/img/\" + filename);//服务器路径 //2-2.用字节输入流关联 FileInputStream fileInputStream = new FileInputStream(realPath); //3.设置response的响应头 //3-1.设置响应头类型：content-type String minetype = servletContext.getMimeType(filename); response.setHeader(\"content-type\", minetype); //3-2.设置响应头打开方式：content-disposition response.setHeader(\"content-disposition\",\"attachment;filename=\"+filename); //4.将输入流写到输出流中 ServletOutputStream servletOutputStream = response.getOutputStream(); byte[] buff = new byte[1024 * 8]; //作为缓冲区 int lenght = 0; //读取 while ((lenght = fileInputStream.read(buff)) != -1){ //写入 servletOutputStream.write(buff, 0, lenght); } servletOutputStream.close(); //可以不关闭输出流 fileInputStream.close(); //建议关闭输出流，释放资源 } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 演示 思考/分析 中文文件问题 解决思路 获取客户端使用的浏览器版本信息 根据不同的版本信息，设置filename的编码方式不同 详细见 【视频】 ，里面有详解。 ****** 与本笔记相关的资源： 链接: https://pan.baidu.com/s/1q_B3k1LzQwxlslEOdpeDWQ 提取码: dx5u document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"HTTP中的ServletContext对象","slug":"HTTP中的ServletContext对象","date":"2020-02-24T09:08:11.000Z","updated":"2020-04-23T11:40:36.737Z","comments":true,"path":"2020/02/24/HTTP中的ServletContext对象/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/24/HTTP%E4%B8%AD%E7%9A%84ServletContext%E5%AF%B9%E8%B1%A1/","excerpt":"ServletContext对象 ServletContext对象范围：所有用户所有请求的数据 谨慎使用。所有用户可以操控它，不太安全；而且，它的生命周期长：服务器始到终，存储的数据多了，会造成内存的压力。 概念 代表整个web应用，可以和程序的容器（服务器）来通信（交互数据） 获取 通过request对象获取 调用request.getServletContext(); 通过HttpServlet获取 调用this.getServletContext(); 注意：2个调用方法获取到的ServletContext都是一样的。因此，更多的时候会使用this.getServletContext(); 功能 获取mine类型 域对象：共享数据 获取文件的真实路径(服务器路径)","text":"ServletContext对象 ServletContext对象范围：所有用户所有请求的数据 谨慎使用。所有用户可以操控它，不太安全；而且，它的生命周期长：服务器始到终，存储的数据多了，会造成内存的压力。 概念 代表整个web应用，可以和程序的容器（服务器）来通信（交互数据） 获取 通过request对象获取 调用request.getServletContext(); 通过HttpServlet获取 调用this.getServletContext(); 注意：2个调用方法获取到的ServletContext都是一样的。因此，更多的时候会使用this.getServletContext(); 功能 获取mine类型 域对象：共享数据 获取文件的真实路径(服务器路径) Demopackage cn.itcast.web.servletcontext; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/servletContextDemo1\") public class ServletContextDemo1 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext对象获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext(); */ //1. 通过request对象获取 ServletContext context1 = request.getServletContext(); //2. 通过HttpServlet获取 ServletContext context2 = this.getServletContext(); System.out.println(context1); System.out.println(context2); System.out.println(context1 == context2);//true } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 控制台输出👇 1.获取mine类型 格式：大类型/小类型 比如，text/html 、 image/jpeg 等等 mine类型 在互联网通信过程中定义的一种文件数据类型 调用方法 String getMimeType(String file) Demopackage cn.itcast.web.servletcontext; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/servletContextDemo2\") public class ServletContextDemo2 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext功能： 1. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) 2. 域对象：共享数据 3. 获取文件的真实(服务器)路径 */ //2. 通过HttpServlet获取 ServletContext context = this.getServletContext(); //3. 定义文件名称 String filename = \"a.jpg\";//image/jpeg //4.获取MIME类型 String mimeType = context.getMimeType(filename); System.out.println(mimeType); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 2.域对象 共享数据 ServletContext对象范围：所有用户所有请求的数据 调用方法 设置数据 setAttribute(String name,Object value) 获取数据 getAttribute(String name) removeAttribute(String name) DemoServletContextDemo3.java package cn.itcast.web.servletcontext; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/servletContextDemo3\") public class ServletContextDemo3 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext功能： 1. 获取MIME类型： 2. 域对象：共享数据 3. 获取文件的真实(服务器)路径 */ //2. 通过HttpServlet获取 ServletContext context = this.getServletContext(); //设置数据 context.setAttribute(\"msg\",\"haha\"); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } ServletContextDemo4.java package cn.itcast.web.servletcontext; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/servletContextDemo4\") public class ServletContextDemo4 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext功能： 1. 获取MIME类型： 2. 域对象：共享数据 3. 获取文件的真实(服务器)路径 */ //2. 通过HttpServlet获取 ServletContext context = this.getServletContext(); //获取数据 Object msg = context.getAttribute(\"msg\"); System.out.println(msg); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 3.获取文件的真实路径(服务器路径) 调用方法 String getRealPath(String path) Demopackage cn.itcast.web.servletcontext; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.File; import java.io.IOException; @WebServlet(\"/servletContextDemo5\") public class ServletContextDemo5 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext功能： 1. 获取MIME类型： 2. 域对象：共享数据 3. 获取文件的真实(服务器)路径 */ // 通过HttpServlet获取 ServletContext context = this.getServletContext(); // 获取文件的服务器路径 String b = context.getRealPath(\"/b.txt\");//工作空间(IDEA)web目录下资源访问 System.out.println(b); // File file = new File(realPath); String c = context.getRealPath(\"/WEB-INF/c.txt\");//工作空间(IDEA)WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(\"/WEB-INF/classes/a.txt\");//工作空间(IDEA)src目录下的资源访问 System.out.println(a); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 项目空间、工作空间的区别：视频 进度条【04:52】 注意： 将来配置文件/资源文件的放置的路径不一样，要会写路径的字符串写法。 src目录的资源路径可以使用ClassLoader（类加载器，不能获取web目录的路径） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"热部署-IDEA实现不用重启Tomcat服务便可自动更新","slug":"热部署-IDEA实现不用重启Tomcat服务便可自动更新","date":"2020-02-24T06:36:53.000Z","updated":"2020-04-23T11:40:36.816Z","comments":true,"path":"2020/02/24/热部署-IDEA实现不用重启Tomcat服务便可自动更新/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/24/%E7%83%AD%E9%83%A8%E7%BD%B2-IDEA%E5%AE%9E%E7%8E%B0%E4%B8%8D%E7%94%A8%E9%87%8D%E5%90%AFTomcat%E6%9C%8D%E5%8A%A1%E4%BE%BF%E5%8F%AF%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/","excerpt":"Tomcat的热部署👇 一、配置Tomcat的Deployment处的“+”的Artifacts是war exploded形式： _:war exploded 作用：展开部署(相当于将资源文件进行展开后进行部署)_:war 作用：发布模式,这是先打成war包,再部署 二、修改Run/Debug Configurations On ‘Update’ Action：update class and resources On frame deactivation：update class and resources 三、浏览器F12，勾选上disable cache 四、以上都不行，那就到Plugins安装JRebel插件","text":"Tomcat的热部署👇 一、配置Tomcat的Deployment处的“+”的Artifacts是war exploded形式： _:war exploded 作用：展开部署(相当于将资源文件进行展开后进行部署)_:war 作用：发布模式,这是先打成war包,再部署 二、修改Run/Debug Configurations On ‘Update’ Action：update class and resources On frame deactivation：update class and resources 三、浏览器F12，勾选上disable cache 四、以上都不行，那就到Plugins安装JRebel插件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"IDEA设置方法参数列表类型自动提示","slug":"IDEA设置方法参数列表类型自动提示","date":"2020-02-23T14:36:53.000Z","updated":"2020-04-23T11:40:36.758Z","comments":true,"path":"2020/02/23/IDEA设置方法参数列表类型自动提示/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/23/IDEA%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA/","excerpt":"期望有这样的参数列表提示👇 File-Settings打开设置(或者ctrl +Alt+S)👇","text":"期望有这样的参数列表提示👇 File-Settings打开设置(或者ctrl +Alt+S)👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"BeanUtils的基本使用","slug":"BeanUtils的基本使用","date":"2020-02-23T08:36:53.000Z","updated":"2020-04-23T11:40:36.736Z","comments":true,"path":"2020/02/23/BeanUtils的基本使用/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/23/BeanUtils%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"在《HTTP案例学习：用户登录》的学习中，使用到BeanUtils。 案例中只涉及到封装username、password两个对象，但是实际上的用户登录界面，有十几个数据对象需要封装。 按原来的方式，是非常麻烦的。期望能够一次把所有参数获取到，并且通过一个方法，一次把所有数据封装成一个对象。 BeanUtils，一个工具类，简化数据封装 这里专门挑出来，做一份简单的笔记。 配合【教学视频】、【BeanUtils工具类常用方法】 食用更佳。","text":"在《HTTP案例学习：用户登录》的学习中，使用到BeanUtils。 案例中只涉及到封装username、password两个对象，但是实际上的用户登录界面，有十几个数据对象需要封装。 按原来的方式，是非常麻烦的。期望能够一次把所有参数获取到，并且通过一个方法，一次把所有数据封装成一个对象。 BeanUtils，一个工具类，简化数据封装 这里专门挑出来，做一份简单的笔记。 配合【教学视频】、【BeanUtils工具类常用方法】 食用更佳。 我们将原来写的代码， //2.获取请求参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); 使用BeanUtils工具类进行封装， //2.获取所有请求参数 Map&lt;String, String[]&gt; map = req.getParameterMap(); //3.创建User对象 User loginUser = new User(); //3-2.使用BeanUtils封装 try { BeanUtils.populate(loginUser,map); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } 会发现只用简单几行代码就完成了封装，而不用和之前一样分别对每个数据进行封装。 BeanUtils 工具类，简化数据封装 用于封装JavaBean的 JavaBean：标准(简单)的Java类 概念 JavaBean 成员变量 属性：setter和getter方法截取后的产物 例如：getUsername() –&gt; Username–&gt; username（大多数下，名字一样） JavaBean 标准的Java类 一般放在domain等package下 功能 封装数据 要求 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共setter和getter方法 属性 setter和getter方法截取后的产物 例如：getUsername() –&gt; Username–&gt; username（大多数下，名字一样） 调用方法 setProperty() 设置属性值 getProperty() 获取属性值 populate(Object obj, Map map) 将map集合的键值对信息，封装到对应的JavaBean对象中 Demo配合 《HTTP案例学习：用户登录》 ，现在New一个BeanUtils.java package cn.itcast.test; import cn.itcast.domain.User; import org.apache.commons.beanutils.BeanUtils; import org.junit.Test; import java.lang.reflect.InvocationTargetException; public class BeanUtilsTest { @Test public void test(){ User user = new User(); try { BeanUtils.setProperty(user,\"username\",\"zhangsan\"); System.out.println(user); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } 控制台输出： 扩展后来看的一篇博客 【BeanUtils工具类常用方法】，觉得写的很不错，一起记录在这里。 相关资料【教学视频】：https://www.bilibili.com/video/av70420291?p=143 【BeanUtils工具类常用方法】：https://blog.csdn.net/wzc1991520/article/details/80176679 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"html中form表单的action路径的写法","slug":"html中form表单的action路径的写法","date":"2020-02-23T07:36:53.000Z","updated":"2020-04-23T11:40:36.782Z","comments":true,"path":"2020/02/23/html中form表单的action路径的写法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/23/html%E4%B8%ADform%E8%A1%A8%E5%8D%95%E7%9A%84action%E8%B7%AF%E5%BE%84%E7%9A%84%E5%86%99%E6%B3%95/","excerpt":"在 《HTTP案例学习：用户登录》 中提及到html中form表单的action路径的写法 是 虚拟目录+Servlet的资源路径 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/day14_test/loginServlet\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码:&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 先记住，日后还会涉及到的。","text":"在 《HTTP案例学习：用户登录》 中提及到html中form表单的action路径的写法 是 虚拟目录+Servlet的资源路径 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/day14_test/loginServlet\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码:&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 先记住，日后还会涉及到的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"IDEA添加jar包的三种方式(小结)","slug":"IDEA中单元测试@Test使用","date":"2020-02-23T04:36:53.000Z","updated":"2020-04-23T11:40:36.755Z","comments":true,"path":"2020/02/23/IDEA中单元测试@Test使用/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/23/IDEA%E4%B8%AD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95@Test%E4%BD%BF%E7%94%A8/","excerpt":"相关文章： https://blog.csdn.net/QQljh123456/article/details/81583786","text":"相关文章： https://blog.csdn.net/QQljh123456/article/details/81583786 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"HTTP响应信息数据-Response","slug":"HTTP响应信息数据-Response","date":"2020-02-22T13:15:01.000Z","updated":"2020-04-23T11:40:36.752Z","comments":true,"path":"2020/02/22/HTTP响应信息数据-Response/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/22/HTTP%E5%93%8D%E5%BA%94%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE-Response/","excerpt":"接着前面两篇博文 《HTTP：超文本传输协议》 、 《HTTP请求信息数据 - Request》 的学习。 现在记录关于 HTTP响应信息数据-Response 的笔记。 响应信息数据 格式 Servlet类中service()方法的参数ServletResponse Response在一次响应结束后，自动被销毁，其输出流也会自动被关闭。 字符串数据，比如： HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt;","text":"接着前面两篇博文 《HTTP：超文本传输协议》 、 《HTTP请求信息数据 - Request》 的学习。 现在记录关于 HTTP响应信息数据-Response 的笔记。 响应信息数据 格式 Servlet类中service()方法的参数ServletResponse Response在一次响应结束后，自动被销毁，其输出流也会自动被关闭。 字符串数据，比如： HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; 响应行 格式：协议/版本 响应状态码 状态码描述 响应状态码 服务器告诉客户端浏览器本次请求和响应的一个状态。 特点 状态码都是3位数字 分类 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx状态码 2xx：成功。代表： 200 3xx：重定向。代表： 302：重定向 304：访问缓存 4xx：客户端错误。代表： 403：错误是一种在网站访问过程中，常见的错误提示，表示资源不可用。服务器理解客户的请求，但拒绝处理它，通常由于服务器上文件或目录的权限设置导致的WEB访问错误。 404：请求路径没有对应的资源 405：请求方式没有对应的doXxx方法 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头 格式：响应头名称 ：值 常见的响应头 Content-Type Content-disposition Content-Type 服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition 服务器告诉客户端以什么格式打开响应体数据 其值： in-line：默认值，在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体。涉及文件下载等功能。 响应空行 就是一个空行（空白行） 作用：分割响应头和响应体 响应体 传输的数据 文件、HTML网页源码等等。比如， &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; 案例1：重定向 重定向：资源跳转的方式 步骤 ResponseDemo1.java package cn.itcast.web.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * 重定向 */ @WebServlet(\"/responseDemo1\") public class ResponseDemo1 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo1........\"); //访问/responseDemo1，会自动跳转到/responseDemo2资源 /* //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(\"location\",\"/day15/responseDemo2\");*/ //演示，不能使用request对象来共享数据 request.setAttribute(\"msg\",\"response\"); //动态获取虚拟目录 String contextPath = request.getContextPath(); //简单的重定向方法 response.sendRedirect(contextPath+\"/responseDemo2\"); //response.sendRedirect(\"http://www.itcast.cn\"); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } ResponseDemo2.java package cn.itcast.web.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/responseDemo2\") public class ResponseDemo2 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo2222222........\"); //演示，不能使用request对象来共享数据 Object msg = request.getAttribute(\"msg\"); System.out.println(msg); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 演示： 特点 重定向的特点：redirect 地址栏发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。不能使用request对象来共享数据 转发的特点：forward 转发地址栏路径不变 转发只能访问当前服务器下的资源 转发是一次请求，可以使用request对象来共享数据 forward 和 redirect 区别 路径写法分类 相对路径 绝对路径 相对路径 通过相对路径不可以确定唯一资源 如：./index.html 不以/开头，以.开头路径 规则 找到当前资源和目标资源之间的相对位置关系 ./：当前目录 ../：后退一级目录 绝对路径(JSP时推荐使用) 通过绝对路径可以确定唯一资源 如：http://localhost/day15/responseDemo2 中 /day15/responseDemo2 以/开头的路径 JSP时推荐使用 规则 判断定义的路径是给谁用的？判断请求将来从哪儿发出 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) 建议动态获取虚拟目录：request.getContextPath() 重定向是客户端浏览器进行的 &lt;a&gt;、 &lt;form&gt;等要重定向… 给服务器使用：不需要加虚拟目录 比如：转发时的路径request.getRequestDispatcher(\"/responseDemo2\").forward(request,response); 案例2：服务器输出字符数据到浏览器步骤 获取字符输出流 输出数据 演示 ResponseDemo4.java package cn.itcast.web.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @WebServlet(\"/responseDemo4\") public class ResponseDemo4 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取流对象之前，设置流的默认编码：ISO-8859-1 设置为：GBK // response.setCharacterEncoding(\"utf-8\"); //告诉浏览器，服务器发送的消息体数据的编码。建议浏览器使用该编码解码 //response.setHeader(\"content-type\",\"text/html;charset=utf-8\"); //简单的形式，设置编码 response.setContentType(\"text/html;charset=utf-8\"); //1.获取字符输出流 PrintWriter pw = response.getWriter(); //2.输出数据 pw.write(\"&lt;h1&gt;hello response&lt;/h1&gt;\"); pw.write(\"&lt;br&gt;你好啊啊啊 response\"); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 演示 注意乱码问题(编解码问题) PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 设置该流的默认编码 告诉浏览器响应体使用的编码 简单的形式，设置编码，是在获取流之前设置 response.setContentType(\"text/html;charset=utf-8\"); Demo上面ResponseDemo4.java文件中 //获取流对象之前，设置流的默认编码：ISO-8859-1 设置为：GBK // response.setCharacterEncoding(\"utf-8\"); //告诉浏览器，服务器发送的消息体数据的编码。建议浏览器使用该编码解码 //response.setHeader(\"content-type\",\"text/html;charset=utf-8\"); //简单的形式，设置编码 response.setContentType(\"text/html;charset=utf-8\"); 案例3：服务器输出字节数据到浏览器步骤 获取字符输出流 输出数据 演示 ResponseDemo5.java package cn.itcast.web.servlet; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/responseDemo5\") public class ResponseDemo5 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\"text/html;charset=utf-8\"); //1.获取字节输出流 ServletOutputStream sos = response.getOutputStream(); //2.输出数据 sos.write(\"你好\".getBytes(\"utf-8\")); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 演示 案例4：验证码 本质：图片 目的：防止恶意表单注册 步骤 创建一对象，在内存中代表一个图片（验证码图片对象） 美化图片 将图片输出到页面展示 演示 New一个CheckCode.java package cn.itcast.web.servlet; import javax.imageio.ImageIO; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.awt.image.BufferedImage; import java.io.IOException; /** * @Classname CheckCode * @Description TODO * @Date 2020/2/23 下午 10:20 * @Created by jerry */ @WebServlet(\"/checkCodeServlet\") public class CheckCode extends HttpServlet { @Override protected void doPost(HttpServletRequest requeste, HttpServletResponse response) throws ServletException, IOException { int width = 100; int height = 50; //1.创建一对象，在内存中代表一个图片（验证码图片对象） BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2. 美化图片 //3.将图片输出到页面展示 ImageIO.write(image, \"jpg\", response.getOutputStream()); } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 没有美化前 美化图片 package cn.itcast.web.servlet; import javax.imageio.ImageIO; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.awt.*; import java.awt.image.BufferedImage; import java.io.IOException; import java.util.Random; /** * 验证码 */ @WebServlet(\"/checkCodeServlet\") public class CheckCode extends HttpServlet { @Override protected void doPost(HttpServletRequest requeste, HttpServletResponse response) throws ServletException, IOException { int width = 100; int height = 50; //1.创建一对象，在内存中代表一个图片（验证码图片对象） BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2. 美化图片 //2-1.填充背景色 Graphics g = image.getGraphics(); //画笔对象，可画/填充 g.setColor(Color.pink); //设置画笔颜色 g.fillRect(0,0,width,height); //g.fill3DRect(0, 0, width, height, true); //2-2.画边框 g.setColor(Color.BLUE); g.drawRect(0, 0, width-1, height-1); //2-3.随机字符（全部） String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789\"; //生产随机角标 Random ran = new Random(); //2-3.写验证码 for (int i = 1; i &lt;= 4; i++) { int index = ran.nextInt(str.length()); //获取字符 char ch = str.charAt(index); //随机字符 //写入字符 g.drawString(ch+\"\", width/5*i , height/2); } /*g.drawString(\"a\", 20, 25); g.drawString(\"2\", 33, 15); g.drawString(\"4\", 72, 35); g.drawString(\"g\", 80, 20);*/ //2-4.画出干扰线 g.setColor(Color.green); //随机生成坐标点 for (int i = 0; i &lt; 10; i++) { int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1, y1, x2, y2); } //3.将图片输出到页面展示 ImageIO.write(image, \"jpg\", response.getOutputStream()); } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 美化后 在页面中配合注册表单等使用验证码 点击超链接或图片后，直接加载随机验证码 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;验证码&lt;/title&gt; &lt;script&gt; /**分析： * 点击超链接/图片，需要换一张 * 1.给超链接/图片绑定单击事件 * 2.重新设置图片的src属性值 */ window.onload = function () { //1.获取图片对象 var img = document.getElementById(\"checkCode\"); var a = document.getElementById(\"change\"); //2.绑定单击事件 img.onclick = function () { //获取时间戳 var date = new Date().getTime(); //毫秒值 //利用时间戳，浏览器访问就一定不会去访问缓存了。每一时刻的链接都是不一样的。 img.src = \"/day15/checkCodeServlet?\" + date; } a.onlick = function () { var date = new Date().getTime(); a.href = \"/day15/checkCodeServlet?\" + date; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=\"checkCode\" src=\"/day15/checkCodeServlet\" /&gt;&lt;br&gt; &lt;a id=\"change\" href=\"\"&gt;看不清，换一张？&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 演示 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"创建@Test测试Druid连接池时的问题","slug":"创建@Test测试Druid连接池时的问题","date":"2020-02-22T12:55:12.000Z","updated":"2020-04-23T11:40:36.798Z","comments":true,"path":"2020/02/22/创建@Test测试Druid连接池时的问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/22/%E5%88%9B%E5%BB%BA@Test%E6%B5%8B%E8%AF%95Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"记录学习 《HTTP案例学习：用户登录》 时候遇到的一些问题","text":"记录学习 《HTTP案例学习：用户登录》 时候遇到的一些问题 IDEA run之后，控制台输出一堆问题： 二月 23, 2020 1:30:34 下午 com.alibaba.druid.pool.DruidDataSource error 严重: init datasource error com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server. 二月 23, 2020 1:30:34 下午 com.alibaba.druid.pool.DruidDataSource error 严重: dataSource init error 二月 23, 2020 1:30:34 下午 com.alibaba.druid.pool.DruidDataSource info 信息: {dataSource-1} inited 我估计是MySQL版本的问题，因为从我开始学习MySQL来安装的是8.0，学习期间就遇到很多问题，不过都能逐一解决。 但是这次我果断直接降级到5.7。 不过，降级后还是被提示错误 二月 23, 2020 2:41:58 下午 com.alibaba.druid.pool.DruidDataSource info 信息: {dataSource-1} inited 二月 23, 2020 2:41:58 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions 信息: Loading XML bean definitions from class path resource [org/springframework/jdbc/support/sql-error-codes.xml] 二月 23, 2020 2:41:58 下午 org.springframework.jdbc.support.SQLErrorCodesFactory &lt;init&gt; 信息: SQLErrorCodes loaded: [DB2, Derby, H2, HSQL, Informix, MS-SQL, MySQL, Oracle, PostgreSQL, Sybase, Hana] ...................................... org.springframework.dao.EmptyResultDataAccessException: Incorrect result size: expected 1, actual 0 at org.springframework.dao.support.DataAccessUtils.requiredSingleResult(DataAccessUtils.java:74) at org.springframework.jdbc.core.JdbcTemplate.queryForObject(JdbcTemplate.java:777) at cn.itcast.Dao.UserDao.login(UserDao.java:25) at cn.itcast.test.UserDaoTest.testLogin(UserDaoTest.java:23) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Process finished with exit code -1 分析了信息: SQLErrorCodes loaded: [DB2, Derby, H2, HSQL, Informix, MS-SQL, MySQL, Oracle, PostgreSQL, Sybase, Hana]， 信息是提示sql语句错了。 仔细检查一下sql语句，单纯的去 cmd 中用自己的sql语句执行一下检查问题。 果然是sql语句的问题。 剩下的错误提示，是数据库的字段的问题。 //正确 loginuser.setUsername(\"superbaby\"); //错误，字段少了个y loginuser.setUsername(\"superbab\"); 再次run，这次得到如期的结果。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Druid","slug":"Druid","permalink":"https://melodyjerry.github.io/blog/tags/Druid/"}]},{"title":"HTTP案例学习：用户登录&验证码","slug":"HTTP案例学习：用户登录&验证码","date":"2020-02-22T12:44:12.000Z","updated":"2020-04-23T11:40:36.753Z","comments":true,"path":"2020/02/22/HTTP案例学习：用户登录&验证码/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/22/HTTP%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95&%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"本笔记包括两个案例，分别是用户登录、验证码。","text":"本笔记包括两个案例，分别是用户登录、验证码。 案例：用户登录接着 《HTTP：超文本传输协议》 、 《HTTP请求信息数据 - Request》 的学习，现在记录一份案例学习。 用户需求 编写 login.html 登录页面，并且有 username &amp; password 两个输入框 使用 Druid 数据库连接池技术，操作 MySQL，day14数据库中user表 使用 JdbcTemplate 技术封装 JDBC 登录成功跳转到 SuccessServlet 展示：登录成功！用户名,欢迎您 登录失败跳转到 FailServlet 展示：登录失败，用户名或密码错误 分析 步骤 创建项目，导入html页面，配置文件，jar包 创建数据库环境 创建包cn.itcast.domain,创建类User 创建包cn.itcast.util,编写工具类JDBCUtils 创建包cn.itcast.dao,创建类UserDao,提供login方法 编写cn.itcast.web.servlet.LoginServlet类 编写FailServlet和SuccessServlet类 BeanUtils工具类，简化数据封装 一、创建项目，导入html页面，配置文件，jar包 新建Module web文件夹下创建login.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/day14_test/loginServlet\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码:&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 这里的login.html中form表单的action路径的写法：虚拟目录+Servlet的资源路径是虚拟目录+Servlet的资源路径 关于 《html中form表单的action路径的写法》 将Druid配置文件druid.properties导入到src文件下 driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql:///day14 username=root password=root initialSize=5 maxActive=10 maxWait=3000 导入jar包到Web的WEB-INF文件中 在项目的web文件夹下创建文件夹WEB-INF，将lib文件夹粘贴进去 并把jar包加入到工作空间里 二、创建数据库环境 打开Navicat，创建数据库和数据表 CREATE DATABASE day14; USE day14; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL ); 插入一条记录 三、创建包cn.itcast.domain,创建类User 右键项目的src文件，New一个包cn.itcast.domain 在包下，New一个User.java package cn.itcast.domain; /** * 用户的实体类 */ public class User { private int id; private String username; private String password; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } 四、创建包cn.itcast.util,编写工具类JDBCUtils New一个包cn.itcast.util New一个JDBCUtils.java package cn.itcast.util; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.ConnectionEvent; import javax.sql.DataSource; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; /** * JDBC的工具类 使用Durid连接池 */ public class JDBCUtils { private static DataSource ds; static { try { //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\"); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static DataSource getDataSource(){ return ds; } /** * 获取连接池Connection对象 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } } 五、创建包cn.itcast.dao,创建类UserDao,提供login方法 New一个包cn.itcast.dao New一个UserDao.java package cn.itcast.Dao; import cn.itcast.domain.User; import cn.itcast.util.JDBCUtils; import com.alibaba.druid.util.JdbcUtils; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; /** * 操作数据库中User表的类 */ public class UserDao { // 声明JDBCTemplate对象公用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return User包含用户全部数据；没有查询到，返回null */ public User login(User loginUser) { try { //1.编写SQL String sql = \"select * from user where username = ? and password = ?\"; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; } catch (DataAccessException e) { e.printStackTrace(); // 记录日志，后期写入文件里，不会总在控制台打印 return null; } } } 测试一下UserDao New一个包cn.itcast.test，New一个UserDaoTest.java package cn.itcast.test; import cn.itcast.Dao.UserDao; import cn.itcast.domain.User; import org.junit.Test; /** * @Classname UserDaoTest * @Description TODO * @Date 2020/2/23 下午 1:00 * @Created by jerry */ public class UserDaoTest { @Test public void testLogin(){ User loginuser = new User(); loginuser.setUsername(\"superbaby\"); loginuser.setPassword(\"123\"); UserDao dao = new UserDao(); User user = dao.login(loginuser); System.out.println(user); } } run后，控制台输出 这个@Test部分，遇到了一些问题，就顺便记录在《创建@Test测试Druid连接池时的问题》 里面。 六、编写cn.itcast.web.servlet.LoginServlet类 New一个包cn.itcast.web.servlet New一个LoginServlet.java package cn.itcast.web.servlet; import cn.itcast.Dao.UserDao; import cn.itcast.domain.User; import cn.itcast.test.UserDaoTest; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/loginServlet\") public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.设置编码 req.setCharacterEncoding(\"utf-8\"); //2.获取请求参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(\"username\"); loginUser.setPassword(\"password\"); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //真正获取到的user //5.判断user if(user == null){ //登录失败 req.getRequestDispatcher(\"/failServlet\").forward(req,resp); //转发 }else{ //登录成功 //存储数据 req.setAttribute(\"user\",user); //转发 req.getRequestDispatcher(\"/successServlet\").forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } 七、编写FailServlet和SuccessServlet类 New一个FailServlet.java package cn.itcast.web.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * @Classname failServlet * @Description TODO * @Date 2020/2/23 下午 3:38 * @Created by jerry */ @WebServlet(\"/failServlet\") public class FailServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //给页面写一句话 //设置页面编码 response.setContentType(\"text/html;charset=utf-8\"); //输出 response.getWriter().write(\"登录失败，用户名或密码错误\"); } } New一个SuccessServlet.java package cn.itcast.web.servlet; import cn.itcast.domain.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * @Classname successServlet * @Description TODO * @Date 2020/2/23 下午 3:38 * @Created by jerry */ @WebServlet(\"/successServlet\") public class SuccessServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取request域中共享的user对象 User user = (User) request.getAttribute(\"user\"); if(user != null){ //给页面写一句话 //设置页面编码 response.setContentType(\"text/html;charset=utf-8\"); //输出 response.getWriter().write(\"登录失败，用户名或密码错误\"); } } } 八、测试浏览器访问：http://localhost/day14_test/login.html 九、BeanUtils工具类，简化数据封装 在LoginServlet.java中使用BeanUtils工具类 package cn.itcast.web.servlet; import cn.itcast.Dao.UserDao; import cn.itcast.domain.User; import cn.itcast.test.UserDaoTest; import org.apache.commons.beanutils.BeanUtils; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.util.Map; @WebServlet(\"/loginServlet\") public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.设置编码 req.setCharacterEncoding(\"utf-8\"); /*//2.获取请求参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password);*/ //2.获取所有请求参数 Map&lt;String, String[]&gt; map = req.getParameterMap(); //3.创建User对象 User loginUser = new User(); //3-2.使用BeanUtils封装 try { BeanUtils.populate(loginUser,map); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //真正获取到的user //5.判断user if(user == null){ //登录失败 req.getRequestDispatcher(\"/failServlet\").forward(req,resp); //转发 }else{ //登录成功 //存储数据 req.setAttribute(\"user\",user); //转发 req.getRequestDispatcher(\"/successServlet\").forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } 关于BeanUtils的更多使用，看下一篇笔记《BeanUtils的基本使用》 。 与本笔记相关的资源： 链接: https://pan.baidu.com/s/1pV1ArOotLcoH9mKYABEm5g 提取码: w9h8 案例：验证码接着 《JSP&amp;Cookie&amp;Session技术》 的学习， 现在记录一份案例的学习。 用户需求 访问带有验证码的登录页面login.jsp 用户输入用户名，密码以及验证码， 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 如果验证码输入有误，跳转登录页面，提示：验证码错误 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 分析 设置request编码 获取参数 获取生成的验证码 将用户信息封装到User对象 判断程序生成的验证码和用户输入的验证码是否一致。从session中获取程序生成的验证码 一致：再判断用户名和密码是否正确 正确： 1.登陆成功 2.存储数据到session中 3.跳转（重定向）到success.jsp 不正确： 1.给提示信息：用户名或密码错误 2.跳转（转发）到登录页面 不一致： 1.给用户提示信息：验证码错误 2.存储提示信息到request 3.跳转（转发）到登录页面 login.jsp显示错误信息，从request域中获取 CodeCheckCodeServlet.javapackage cn.itcast.servlet; import javax.imageio.ImageIO; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.awt.*; import java.awt.image.BufferedImage; import java.io.IOException; import java.util.Random; @WebServlet(\"/checkCodeServlet\") public class CheckCodeServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { int width = 100; int height = 50; //1.创建一对象，在内存中图片(验证码图片对象) BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2.美化图片 //2.1 填充背景色 Graphics g = image.getGraphics();//画笔对象 g.setColor(Color.PINK);//设置画笔颜色 g.fillRect(0,0,width,height); //2.2画边框 g.setColor(Color.BLUE); g.drawRect(0,0,width - 1,height - 1); String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789\"; //生成随机角标 Random ran = new Random(); StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt;= 4; i++) { int index = ran.nextInt(str.length()); //获取字符 char ch = str.charAt(index);//随机字符 sb.append(ch); //2.3写验证码 g.drawString(ch+\"\",width/5*i,height/2); } String checkCode_session = sb.toString(); //将验证码存入session request.getSession().setAttribute(\"checkCode_session\",checkCode_session); //2.4画干扰线 g.setColor(Color.GREEN); //随机生成坐标点 for (int i = 0; i &lt; 10; i++) { int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1,y1,x2,y2); } //3.将图片输出到页面展示 ImageIO.write(image,\"jpg\",response.getOutputStream()); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } login.jsp&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;!--点击刷新验证码--&gt; &lt;script&gt; window.onload = function(){ document.getElementById(\"img\").onclick = function(){ this.src=\"/day16/checkCodeServlet?time=\"+new Date().getTime(); } } &lt;/script&gt; &lt;style&gt; div{ color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/day16/loginServlet\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"checkCode\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;img id=\"img\" src=\"/day16/checkCodeServlet\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;input type=\"submit\" value=\"登录\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;div&gt;&lt;%=request.getAttribute(\"cc_error\") == null ? \"\" : request.getAttribute(\"cc_error\")%&gt;&lt;/div&gt; &lt;div&gt;&lt;%=request.getAttribute(\"login_error\") == null ? \"\" : request.getAttribute(\"login_error\") %&gt;&lt;/div&gt; &lt;!-- 等同于 EL表达式。有信息就打印输出，没有就显示空字符串。 ${requestScope.cc_error} ${requestScope.login.error} --&gt; &lt;/body&gt; &lt;/html&gt; LoginServlet.javapackage cn.itcast.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; @WebServlet(\"/loginServlet\") public class LoginServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.设置request编码 request.setCharacterEncoding(\"utf-8\"); //2.获取参数 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); String checkCode = request.getParameter(\"checkCode\"); //3.先获取生成的验证码 HttpSession session = request.getSession(); String checkCode_session = (String) session.getAttribute(\"checkCode_session\"); //删除session中存储的验证码 session.removeAttribute(\"checkCode_session\"); //3.先判断验证码是否正确 if(checkCode_session!= null &amp;&amp; checkCode_session.equalsIgnoreCase(checkCode)){ //忽略大小写比较 //验证码正确 //判断用户名和密码是否一致 if(\"zhangsan\".equals(username) &amp;&amp; \"123\".equals(password)){//需要调用UserDao查询数据库 //登录成功 //存储信息，用户信息 session.setAttribute(\"user\",username); //重定向到success.jsp response.sendRedirect(request.getContextPath()+\"/success.jsp\"); }else{ //登录失败 //存储提示信息到request request.setAttribute(\"login_error\",\"用户名或密码错误\"); //转发到登录页面 request.getRequestDispatcher(\"/login.jsp\").forward(request,response); } }else{ //验证码不一致 //存储提示信息到request request.setAttribute(\"cc_error\",\"验证码错误\"); //转发到登录页面 request.getRequestDispatcher(\"/login.jsp\").forward(request,response); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } success.jsp&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;成功登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%=request.getSession().getAttribute(\"user\")%&gt;,欢迎您&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; Demo 视频详解 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"2020.2.22随笔","slug":"2020.2.22随笔","date":"2020-02-22T09:36:53.000Z","updated":"2020-03-02T12:35:48.151Z","comments":true,"path":"2020/02/22/2020.2.22随笔/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/22/2020.2.22%E9%9A%8F%E7%AC%94/","excerpt":"好久好久，没能有人和我聊着久，聊的这么嗨了。就当做这两天的随笔吧。晚安🌙 ——2020.2.22","text":"好久好久，没能有人和我聊着久，聊的这么嗨了。就当做这两天的随笔吧。晚安🌙 ——2020.2.22 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"HTTP请求信息数据-Request","slug":"HTTP请求信息数据-Request","date":"2020-02-21T12:25:00.000Z","updated":"2020-04-23T11:40:36.757Z","comments":true,"path":"2020/02/21/HTTP请求信息数据-Request/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/21/HTTP%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE-Request/","excerpt":"接着上篇博文 《HTTP：超文本传输协议》 的学习。 现在，来学习两个对象：Request &amp; Response。 request对象和response对象的原理 request和response对象是由服务器创建的。接着我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 其基本原理，如下图👇 request对象继承体系结构ServletRequest – interface，接口 ↓|继承 HttpServletRequest – interface，接口 ↓|实现 org.apache.catalina.connector.RequestFacade – 类，Tomcat编写的 Tomcat 是用纯Java语言编写的 request功能 基础功能 获取请求消息数据 其他功能： 1.获取请求参数通用方式 2.请求转发 3.共享数据 4.获取ServletContext 获取请求消息数据 获取请求行数据 获取请求头数据 获取请求体数据","text":"接着上篇博文 《HTTP：超文本传输协议》 的学习。 现在，来学习两个对象：Request &amp; Response。 request对象和response对象的原理 request和response对象是由服务器创建的。接着我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 其基本原理，如下图👇 request对象继承体系结构ServletRequest – interface，接口 ↓|继承 HttpServletRequest – interface，接口 ↓|实现 org.apache.catalina.connector.RequestFacade – 类，Tomcat编写的 Tomcat 是用纯Java语言编写的 request功能 基础功能 获取请求消息数据 其他功能： 1.获取请求参数通用方式 2.请求转发 3.共享数据 4.获取ServletContext 获取请求消息数据 获取请求行数据 获取请求头数据 获取请求体数据 获取请求消息数据的字符串格式 👇 POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan 一.获取请求行数据GET /day14/demo1?name=zhangsan HTTP/1.1 调用方法（★★重点掌握）： 获取请求方式：GET String getMethod() ★★获取虚拟目录：/day14 String getContextPath() 获取Servlet路径：/demo1 String getServletPath() 获取get方式请求参数：name=zhangsan String getQueryString() 不用这个，以后会用更高级的方式 多个参数之间用&amp;连接 ★★获取请求URI：/day14/demo1 String getRequestURI()：/day14/demo1 StringBuffer getRequestURL()：http://localhost/day14/demo1 URL：统一资源定位符 ： http://localhost/day14/demo1 其地位相当于”中华人民共和国” URI：统一资源标识符，其表示范围更大 ：/day14/demo1 其地位相当于”共和国” 获取协议及版本：HTTP/1.1 String getProtocol() 该方法在Interface ServletRequest中 获取客户机的IP地址： String getRemoteAddr() 该方法在Interface ServletRequest中 示例新建RequestDemo1.java，输入代码👇 可以在新建时候选择创建Servlet，IDEA自动生成相应模板。 import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * 演示Request对象获取请求行数据 */ @WebServlet(\"/RequestDemo1\") public class RequestDemo1 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：/Servlet * String getContextPath() 3. 获取Servlet路径: /requestDemo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (*)获取请求URI：/Servlet/requestDemo1 * String getRequestURI(): /day14/requestDemo1 * StringBuffer getRequestURL() :http://localhost/Servlet/requestDemo1 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() */ //1. 获取请求方式 ：GET String method = request.getMethod(); System.out.println(method); //2.(*)获取虚拟目录：/day14 String contextPath = request.getContextPath(); System.out.println(contextPath); //3. 获取Servlet路径: /demo1 String servletPath = request.getServletPath(); System.out.println(servletPath); //4. 获取get方式请求参数：name=zhangsan String queryString = request.getQueryString(); System.out.println(queryString); //5.(*)获取请求URI：/day14/demo1 String requestURI = request.getRequestURI(); StringBuffer requestURL = request.getRequestURL(); System.out.println(requestURI); System.out.println(requestURL); //6. 获取协议及版本：HTTP/1.1 String protocol = request.getProtocol(); System.out.println(protocol); //7. 获取客户机的IP地址： String remoteAddr = request.getRemoteAddr(); System.out.println(remoteAddr); } } 演示👇 浏览器访问：http://localhost/Servlet/RequestDemo1?name=zhangsan IDEA控制台输出： 二.获取请求头数据Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 调用方法（★★重点掌握）： ★★String getHeader(String name) 通过请求头的名称获取请求头的值 参数不分大小写，只要单词拼写的对即可 Enumeration&lt;String&gt; getHeaderNames() 获取所有的请求头名称 封装成 Enumeration&lt;String&gt; 注意：从JDK1.0开始，该接口的功能由Iterator（迭代器）接口 复制。此外，Iterator还添加了一个可选的删除操作，并且有较短的方法名称。新的实现应该考虑使用迭代器优选于枚举。——JDK 8 文档 示例一、调用Enumeration&lt;String&gt; getHeaderNames()，演示获取所有请求头数据 新建一个Servlet，名为RequestDemo2.java import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.Enumeration; @WebServlet(\"/RequestDemo2\") public class RequestDemo2 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 演示获取请求头数据 // 1.获取所有请求头数据 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); // 2.遍历 while(headerNames.hasMoreElements()){ String name = headerNames.nextElement(); // 根据名称获取请求头的值 String value = request.getHeader(name); System.out.println(name + \"--\" + value); } } } 浏览器访问：http://localhost/Servlet/RequestDemo2 IDEA控制台输出： 二、调用String getHeader(String name)，user-agent、referer 新建一个Servlet，名为RequestDemo3.java import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/RequestDemo3\") public class RequestDemo3 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 演示获取请求头数据：user-agent(客户端版本) // 获取请求头数据：user-agent String agent = request.getHeader(\"user-agent\"); // 判断agent的浏览器版本，可以解决浏览器兼容问题 if(agent.contains(\"Chrome\")) { // 谷歌浏览器 System.out.println(\"谷歌来了。。。\"); } else if (agent.contains(\"Firefox\")) { // 火狐浏览器 System.out.println(\"火狐来了。。。\"); } } } 浏览器访问：http://localhost/Servlet/RequestDemo3 IDEA控制台输出： 注意： 获取请求头数据：user-agent(客户端版本) 判断agent的浏览器版本，可以解决浏览器兼容问题 新建一个Servlet，名为RequestDemo4.java import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/RequestDemo4\") public class RequestDemo4 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 演示请求头数据：referer String referer = request.getHeader(\"referer\"); System.out.println(referer); // http://localhost/Servlet/login.html //防盗链 if(referer != null) { if(referer.contains(\"/Servlet\")) { // 正常访问 System.out.println(\"播放电影。。。\"); /* 等同于，只不过不再是输出到控制台，而是直接打印在页面上 response.setContentType(\"text/html;charset=utf-8\"); response.getWriter.writer(\"播放电影。。。\") */ } else { // 盗链 System.out.println(\"想看电影吗？来优酷吧。。。\"); /* 等同于，只不过不再是输出到控制台，而是直接打印在页面上 response.setContentType(\"text/html;charset=utf-8\"); response.getWriter.writer(\"想看电影吗？来优酷吧。。。\") */ } } } } 新建一个html文件，名为login.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/Servlet/Demo3\" method=\"get\"&gt; &lt;input name=\"username\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;!--加入超链接--&gt; &lt;a href=\"http://localhost/Servlet/RequestDemo4\"&gt;RequestDemo3&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 演示👉获取请求头数据：referer 关于获取referer来防盗链，观看 视频（进度条【10:56】） 三.获取请求体数据username=zhangsan 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 步骤： 获取流对象 获取字符输入流：文字等字符数据 获取字节输入流：上传图片、文件等字节数据 再从流对象中获取数据 调用方法： BufferedReader getReader() 获取字符输入流，只能操作字符数据 返回值是BufferedReader，高效的、带有缓冲区的 该方法在Interface ServletRequest中 ServletInputStream getInputStream() 获取字节输入流，可以操作所有类型数据 但是获取字符时不方便，更推荐用第一个调用方法 返回值是ServletInputStream，继承了InputStream。 涉及到文件上传等知识 该方法在Interface ServletRequest中 示例 新建html文件，名为regist.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/Servlet/RequestDemo5\" method=\"post\"&gt; &lt;input type=\"text\" placeholder=\"请输入用户名\" name=\"username\"&gt;&lt;br&gt; &lt;input type=\"text\" placeholder=\"请输入密码\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 新建一个Servlet，名为RequestDemo5.java import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; @WebServlet(\"/RequestDemo5\") public class RequestDemo5 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取请求消息体--请求参数 //1.获取字符流 BufferedReader br = request.getReader(); //2.读取数据 String line = null; while((line = br.readLine()) != null){ System.out.println(line); } br.close(); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } } 浏览器访问：http://localhost/Servlet/regist.html 控制台输出： 注意：多个参数之间用&amp;连接。 其他功能 获取请求参数通用方式 请求转发 共享数据 一、获取请求参数通用方式 不论GET还是POST请求方式都可以使用下列方法来获取请求参数 上述即，doGet() 和 doPost() 的方法体代码完全一样 因此，为了简化，只需要选择在doPost() 的方法体中写代码，之后在doGet() 中调用 this.doPost(request,response); 调用方法： String getParameter(String name) 根据参数名称获取参数值： username=zs&amp;password=123 String[] getParameterValues(String name) 根据参数名称获取参数值的数组：hobby=xuexi&amp;hobby=game 将键值对，按一个键来封装不同的值并封装成一个数组 多用于复选框 Enumeration&lt;String&gt; getParameterNames() 获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap() 获取所有参数的Map集合 示例 新建regist2.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/Servlet/RequestDemo6\" method=\"post\"&gt; &lt;input type=\"text\" placeholder=\"请输入用户名\" name=\"username\"&gt;&lt;br&gt; &lt;input type=\"text\" placeholder=\"请输入密码\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"checkbox\" name=\"hobby\" value=\"game\"&gt;游戏 &lt;input type=\"checkbox\" name=\"hobby\" value=\"study\"&gt;学习 &lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 新建RequestDemo6.java import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; import java.util.Enumeration; import java.util.Map; import java.util.Set; @WebServlet(\"/RequestDemo6\") public class RequestDemo6 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //post 获取请求参数 //根据参数名称获取参数值 String username = request.getParameter(\"username\"); /* System.out.println(\"post\"); System.out.println(username);*/ //根据参数名称获取参数值的数组 String[] hobbies = request.getParameterValues(\"hobby\"); /*for (String hobby : hobbies) { System.out.println(hobby); }*/ //获取所有请求的参数名称 Enumeration&lt;String&gt; parameterNames = request.getParameterNames(); /*while(parameterNames.hasMoreElements()){ String name = parameterNames.nextElement(); System.out.println(name); String value = request.getParameter(name); System.out.println(value); System.out.println(\"----------------\"); }*/ // 获取所有参数的map集合 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); //遍历 Set&lt;String&gt; keyset = parameterMap.keySet(); for (String name : keyset) { //获取键获取值 String[] values = parameterMap.get(name); System.out.println(name); for (String value : values) { System.out.println(value); } System.out.println(\"-----------------\"); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //get 获取请求参数 /* //根据参数名称获取参数值 String username = request.getParameter(\"username\"); System.out.println(\"get\"); System.out.println(username);*/ this.doPost(request,response); } } 浏览器访问：http://localhost/Servlet/regist2.html 控制台输出： 中文乱码问题 GET方式：tomcat 8 已经将 GET方式乱码问题解决了 POST方式：会乱码 解决：在获取参数前，设置request的编码request.setCharacterEncoding(\"utf-8\"); 。对应着html页面的编码。 二、请求转发 一种在服务器内部的资源跳转方式 特点 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中 转发就是一次请求。像上图的AServlet和BServlet两种资源使用的是同一次请求。 步骤 通过request对象获取请求转发器对象 RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发 forward(ServletRequest request, ServletResponse response) 示例 新建RequestDemo8.java import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/RequestDemo8\") public class RequestDemo8 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"Demo8888被访问了。。。\"); //转发到Demo9资源 /* RequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/RequestDemo9\"); requestDispatcher.forward(request,response); // 一般不这么写，直接写成： request.getRequestDispatcher(\"/RequestDemo9\").forward(request,response); */ //存储数据到request域中 request.setAttribute(\"msg\",\"hello\"); request.getRequestDispatcher(\"/RequestDemo9\").forward(request,response); //没法跳转到外部资源，比如下面这个是不行的 //request.getRequestDispatcher(\"http://www.itcast.cn\").forward(request,response); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 新建RequestDemo9.java import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/RequestDemo9\") public class RequestDemo9 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取数据 Object msg = request.getAttribute(\"msg\"); System.out.println(msg); System.out.println(\"Demo9999也被访问了。。。\"); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 浏览器访问：http://localhost/Servlet/RequestDemo8 控制台输出： 三、共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 调用方法： void setAttribute(String name,Object obj) 存储数据 Object getAttitude(String n ame) 通过键获取值 void removeAttribute(String name) 通过键移除键值对 👉视频 的【03:15】，详细说到 如何共享数据。 示例示例放在 __ 请求转发 的示例 __ 中。 详细见代码文件中的两个注释： RequestDemo8的【// 存储数据到request域中】 RequestDemo9的【// 获取数据】 四、获取ServletContext调用方法： ServletContext getServletContext() 示例 新建RequestDemo10.java import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/RequestDemo10\") public class RequestDemo10 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ServletContext servletContext = request.getServletContext(); System.out.println(servletContext); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 浏览器访问：http://localhost/Servlet/RequestDemo10 控制台输出： 下篇博客 《HTTP响应信息数据 - Response》 中，详细学习响应信息数据 - Response。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"HTTP：超文本传输协议","slug":"HTTP：超文本传输协议","date":"2020-02-21T10:25:00.000Z","updated":"2020-04-23T11:40:36.753Z","comments":true,"path":"2020/02/21/HTTP：超文本传输协议/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/21/HTTP%EF%BC%9A%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/","excerpt":"概念 HTTP == Hyper Text Transfer Protocol 超文本传输协议 传输协议：定义了客户端和服务器端通信时，发送数据的格式。 特点 基于TCP/IP的高级协议 默认端口号:80 基于请求/响应模型的：一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 网页中每一个文件都是一次单独的请求，几张图片，就是几次请求。如下图所示。","text":"概念 HTTP == Hyper Text Transfer Protocol 超文本传输协议 传输协议：定义了客户端和服务器端通信时，发送数据的格式。 特点 基于TCP/IP的高级协议 默认端口号:80 基于请求/响应模型的：一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 网页中每一个文件都是一次单独的请求，几张图片，就是几次请求。如下图所示。 历史版本http 0.9 只有一个命令GET 没有HEADER等描述数据的信息 服务器发送完毕，就关闭TCP连接 每一次请求响应都会建立新的连接 http 1.0 增加了很多命令，如status code和header 多字符集支持、多部分发送、权限、缓存等 http 1.1 持久连接：keep-alive 复用连接（较http1.0的每一次请求响应都会建立新的连接。好处：节约了连接的资源，提升了传输的速度。） 提高性能的关键是低延迟而不是高带宽。 较http1.0，对缓存的支持更好 推送：主动发送js、css推送到浏览器。 二进制流：可以并行发送数据。 http 2.0 所有数据以二进制传输 同一个连接里面发送多个请求不再需要按顺序来 头消息压缩以及推送等提高效率的功能 所有的请求共用一个连接，可以更有效的使用tcp连接，通过带宽来提升http性能 可以减少服务链接的压力，内存减少了，链接吞吐量大了 解决浏览器连接数有限的问题 资源合并减少请求的优化手段在http2.0来说是没有效果的 请求信息数据 格式 Servlet类中service()方法的参数ServletRequest 字符串格式，比如： POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan 以下关于 请求信息数据格式 的内容有缺省，详细见下一篇博客 《HTTP请求信息数据 - Request》 中。 请求行 格式：请求方式 请求url 请求协议/版本 请求方式 HTTP协议有7种请求协议，常用的有GET、POST两种 GET 请求参数在请求行中，在url后 请求的url长度有限制的 不太安全（参数跟在url之后） 浏览器控制台显示👇 POST 请求参数在请求体中 请求的url长度没有限制的 相对安全（参数在请求体中） 浏览器控制台显示👇 请求url 假设为 /login.html 请求协议/版本 HTTP/1.1 请求头 客户端浏览器告诉服务器一些信息 格式：请求头名称 : 请求头值 若有多个，则一行一个。 常见的请求头 Host User-Agent Referer Host 请求的主机地址 User-Agent 浏览器告诉服务器，我访问你时候使用的浏览器版本信息 作用：可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer 比如上面几张图片的Referer是 http://localhost/login.html 告诉服务器，我（当前请求）从哪里来？ 作用：防盗链、统计工作 举个例子：我的网站想播放《战狼2》电影👇 Connection keep-alive http1.1，表示该链接可以被复用 请求空行 就是一个空行（空白行） 作用：分割POST请求的请求头和请求体 请求体/请求正文 封装POST请求信息的请求参数 下一篇博客 《HTTP请求信息数据 - Request》 中，详细学习了 请求信息数据 - Request。 响应信息数据 格式 Servlet类中service()方法的参数ServletResponse 字符串数据，比如： HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; 响应行 格式：协议/版本 响应状态码 状态码描述 响应状态码 服务器告诉客户端浏览器本次请求和响应的一个状态。 特点 状态码都是3位数字 分类 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx状态码 2xx：成功。代表： 200 3xx：重定向。代表： 302：重定向 304：访问缓存 4xx：客户端错误。代表： 403：错误是一种在网站访问过程中，常见的错误提示，表示资源不可用。服务器理解客户的请求，但拒绝处理它，通常由于服务器上文件或目录的权限设置导致的WEB访问错误。 404：请求路径没有对应的资源 405：请求方式没有对应的doXxx方法 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头 格式：响应头名称 ：值 常见的响应头 Content-Type Content-disposition Content-Type 服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition 服务器告诉客户端以什么格式打开响应体数据 其值： in-line：默认值，在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体。涉及文件下载等功能。 响应空行 就是一个空行（空白行） 作用：分割响应头和响应体 响应体 传输的数据 文件、HTML网页源码等等。比如， &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; 下下篇博客 《HTTP响应信息数据 - Response》 中，详细学习响应信息数据 - Response。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"hexo s浏览博客时，提示4000端口问题","slug":"hexo s浏览博客时，提示4000端口问题","date":"2020-02-21T10:17:00.000Z","updated":"2020-04-23T11:40:36.789Z","comments":true,"path":"2020/02/21/hexo s浏览博客时，提示4000端口问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/21/hexo%20s%E6%B5%8F%E8%A7%88%E5%8D%9A%E5%AE%A2%E6%97%B6%EF%BC%8C%E6%8F%90%E7%A4%BA4000%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98/","excerpt":"记录一次使用Hexo来，第一次遇到的问题。 讲真我也不知道为什么我的4000端口会被占用，我只是如常一样地使用Hexo而已。 问题hexo s浏览博客时，提示4000端口问题。代码提示如下： $ hexo server FATAL Port 4000 has been used. Try other port instead. FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/do Error: listen EADDRINUSE 0.0.0.0:4000 at Object.exports._errnoException (util.js:1026:11) at exports._exceptionWithHostPort (util.js:1049:20) at Server._listen2 (net.js:1257:14) at listen (net.js:1293:10) at net.js:1403:9 at _combinedTickCallback (internal/process/next_tick.js:77:11) at process._tickCallback (internal/process/next_tick.js:98:9) FATAL listen EADDRINUSE 0.0.0.0:4000 Error: listen EADDRINUSE 0.0.0.0:4000 at Object.exports._errnoException (util.js:1026:11) at exports._exceptionWithHostPort (util.js:1049:20) at Server._listen2 (net.js:1257:14) at listen (net.js:1293:10) at net.js:1403:9 at _combinedTickCallback (internal/process/next_tick.js:77:11) at process._tickCallback (internal/process/next_tick.js:98:9) 解决可以在站点下的文件_config.yml内加上如下代码更改hexo-server运行时的端口号： server: port: 40401 compress: true header: true 其中40401可以换成想要运行的端口号。","text":"记录一次使用Hexo来，第一次遇到的问题。 讲真我也不知道为什么我的4000端口会被占用，我只是如常一样地使用Hexo而已。 问题hexo s浏览博客时，提示4000端口问题。代码提示如下： $ hexo server FATAL Port 4000 has been used. Try other port instead. FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/do Error: listen EADDRINUSE 0.0.0.0:4000 at Object.exports._errnoException (util.js:1026:11) at exports._exceptionWithHostPort (util.js:1049:20) at Server._listen2 (net.js:1257:14) at listen (net.js:1293:10) at net.js:1403:9 at _combinedTickCallback (internal/process/next_tick.js:77:11) at process._tickCallback (internal/process/next_tick.js:98:9) FATAL listen EADDRINUSE 0.0.0.0:4000 Error: listen EADDRINUSE 0.0.0.0:4000 at Object.exports._errnoException (util.js:1026:11) at exports._exceptionWithHostPort (util.js:1049:20) at Server._listen2 (net.js:1257:14) at listen (net.js:1293:10) at net.js:1403:9 at _combinedTickCallback (internal/process/next_tick.js:77:11) at process._tickCallback (internal/process/next_tick.js:98:9) 解决可以在站点下的文件_config.yml内加上如下代码更改hexo-server运行时的端口号： server: port: 40401 compress: true header: true 其中40401可以换成想要运行的端口号。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"将本地文件传到阿里云服务器","slug":"将本地文件传到阿里云服务器","date":"2020-02-21T05:47:34.000Z","updated":"2020-04-23T11:40:36.803Z","comments":true,"path":"2020/02/21/将本地文件传到阿里云服务器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/21/%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%BC%A0%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"问题怎么将本地文件传到阿里云服务器里面？ 解决 第一种：在阿里云服务器里建一个FTP服务商，在本地用FTP客户端上传文件 第二种：进阿里云服务器远程界面的时候，把本地磁盘带进去，然后进服务器里直接从本地磁盘里把文件复制到服务器里 第三种：QQ安装到阿里云服务器里，用QQ对传 第四种：把本地文件上传到邮箱里 ，然后进阿里云服务器里打开您的邮箱，进去下载文件即可 链接：https://www.w3cschool.cn/intellij_idea_doc/","text":"问题怎么将本地文件传到阿里云服务器里面？ 解决 第一种：在阿里云服务器里建一个FTP服务商，在本地用FTP客户端上传文件 第二种：进阿里云服务器远程界面的时候，把本地磁盘带进去，然后进服务器里直接从本地磁盘里把文件复制到服务器里 第三种：QQ安装到阿里云服务器里，用QQ对传 第四种：把本地文件上传到邮箱里 ，然后进阿里云服务器里打开您的邮箱，进去下载文件即可 链接：https://www.w3cschool.cn/intellij_idea_doc/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"云服务器","slug":"云服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"Servlet 体系结构","slug":"Servlet 体系结构","date":"2020-02-20T12:23:11.000Z","updated":"2020-04-23T11:40:36.768Z","comments":true,"path":"2020/02/20/Servlet 体系结构/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/Servlet%20%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"我们在写一个class 并 implement Servlet时，需要重写Servlet中的5个方法，但是大多时候都只用到 service 方法。 虽然中用到service方法，但其余的4个方法还得重写。 那我们能不能编写一个class，去继承或实现 Servlet 后，只用定义一个 service 方法就可以了。其他方法想有就有，不想有就没有？ 这时候我们就要聊聊 Servlet 体系结构了。 Servlet 体系结构Servlet – interface，接口 ↓|实现 GenericServlet – 实现类，抽象类 ↓|继承 HttpServlet – 实现类，抽象类 做项目时，创建Servlet时候，推荐使用第三种方式：👉继承HttpServlet👉定义类继承HttpServlet👉 复写doGet/doPost方法","text":"我们在写一个class 并 implement Servlet时，需要重写Servlet中的5个方法，但是大多时候都只用到 service 方法。 虽然中用到service方法，但其余的4个方法还得重写。 那我们能不能编写一个class，去继承或实现 Servlet 后，只用定义一个 service 方法就可以了。其他方法想有就有，不想有就没有？ 这时候我们就要聊聊 Servlet 体系结构了。 Servlet 体系结构Servlet – interface，接口 ↓|实现 GenericServlet – 实现类，抽象类 ↓|继承 HttpServlet – 实现类，抽象类 做项目时，创建Servlet时候，推荐使用第三种方式：👉继承HttpServlet👉定义类继承HttpServlet👉 复写doGet/doPost方法 GenericServlet 将 Servlet 接口中的其他方法做了默认空实现，只将 service() 方法作为抽象 将来定义 Servlet 类时候，可以继承 GenericServlet，实现 service() 方法即可 其余四种方法， 若有需要，手动重写即可。 @WebServlet(\"/demo2\") public class ServletDemo2 extends GenericServlet { @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"demo2....\"); } } HttpServlet 该抽象类是对 HTTP协议 的封装和描述，可以简化某些操作 HTTP协议 有 7种 请求方式。现在，我们假设只是用最常用的两种请求方式GET和POST这两种请求方式。 service()方法中 最先要干 的其中2件事👇 将来不管怎么样，都得做这么一件事：“先判断请求方式👉判断完后，要通过不同的请求方式，做出不同的代码逻辑“。 那么，这个过程是非常麻烦的。 同时，这个过程也是所有 service() 都该做的一个过程。 所以这个时候，官方针对这个过程，专门提供了一个class HttpServlet。 HttpServlet 已经帮程序员做好了这个过程，写好了相应的代码，就如上图的红色字体部分。集程序员不再需要去判断请求方式了。 HttpServlet 内部定义了 doGet(){} 和 doPost(){} 这两个方法。并且在判断请求方式的 if 中调用了这两个方法。 这就是其基本的定义原理。就如下图👇 若将来想要屏蔽这种GET或POST请求方式的处理逻辑：我们可以继承 HttpServlet，并且去重写 doGet(){} 和 doPost(){}这两个方法。 因为将来都是调用 service()方法 ，并且 service()会做一个方法分发：你是get就调用 doGet() ，你是post就调用 doPost() 。 做项目时，创建Servlet时候，推荐使用第三种方式：👉继承HttpServlet👉定义类继承HttpServlet👉 复写doGet/doPost方法 步骤 定义 class 继承 HttpServlet 重写doGet() 和 doPost() 两个方法 /* ServletDemo3.java */ import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * @Classname ServletDemo3 * @Description TODO * @Date 2020/2/20 下午 10:54 * @Created by jerry */ @WebServlet(\"demo3\") public class ServletDemo3 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doGet......\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doPost......\"); } } 注意 通过浏览器直接请求，是GET方式 现在掌握的知识，只能通过表单，完成POST方式 简单案例 新建login.html文件 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/demo3\" method=\"post\"&gt; &lt;input name=\"username\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 重启服务，访问页面 将 method=\"post\" 改为 method=\"get\" 再访问页面 注意： 使用get方式后，请求的参数会跟在url后。 后续阅读相关文章1、GenericServlet和HttpServlet 2、GenericServlet 、Servlet和httpServler他们之间的关系 3、GenericServlet和HttpServlet有什么区别？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Servlet","slug":"Servlet","permalink":"https://melodyjerry.github.io/blog/tags/Servlet/"}]},{"title":"IDEA官方文档","slug":"IntelliJ IDEA官方文档","date":"2020-02-20T11:47:34.000Z","updated":"2020-04-23T11:40:36.762Z","comments":true,"path":"2020/02/20/IntelliJ IDEA官方文档/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/IntelliJ%20IDEA%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/","excerpt":"一份 W3C school 提供的 《IntelliJ IDEA官方文档》 链接：https://www.w3cschool.cn/intellij_idea_doc/","text":"一份 W3C school 提供的 《IntelliJ IDEA官方文档》 链接：https://www.w3cschool.cn/intellij_idea_doc/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"愿有情人终成眷属，执手前走共度一生","slug":"愿有情人终成眷属，执手前走共度一生","date":"2020-02-20T10:47:34.000Z","updated":"2020-03-02T12:35:48.206Z","comments":true,"path":"2020/02/20/愿有情人终成眷属，执手前走共度一生/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/%E6%84%BF%E6%9C%89%E6%83%85%E4%BA%BA%E7%BB%88%E6%88%90%E7%9C%B7%E5%B1%9E%EF%BC%8C%E6%89%A7%E6%89%8B%E5%89%8D%E8%B5%B0%E5%85%B1%E5%BA%A6%E4%B8%80%E7%94%9F/","excerpt":"浏览博客 网易云热评墙 时，看见两段很感触的网易云音乐热评。截了两张图，就当做今天的随笔。 “愿有情人终成眷属”，这话我想在后边加上一句，“执手前走共度一生”。——2020.02.20随笔","text":"浏览博客 网易云热评墙 时，看见两段很感触的网易云音乐热评。截了两张图，就当做今天的随笔。 “愿有情人终成眷属”，这话我想在后边加上一句，“执手前走共度一生”。——2020.02.20随笔 图片[1]链接：https://www.7ooooo.cn/490/.html 图片[2]链接：https://www.7ooooo.cn/523/.html 关注我们：请关注一下我们的微信公众号（xielihaia）版权声明：版权归 网易云热评墙 所有！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"IDEA与Tomcat的其他相关配置","slug":"IDEA与Tomcat的其他相关配置","date":"2020-02-20T09:42:00.000Z","updated":"2020-04-23T11:40:36.756Z","comments":true,"path":"2020/02/20/IDEA与Tomcat的其他相关配置/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/IDEA%E4%B8%8ETomcat%E7%9A%84%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","excerpt":"IDEA会为每一个Tomcat部署的项目单独建立一份配置文件 查看控制台的log Using CATALINA_BASE: \"C:\\Users\\丶Melody\\.IntelliJIdea2019.1\\system\\tomcat\\_test\" 工作空间项目 和 Tomcat部署的Web项目 Tomcat真正访问的是“Tomcat部署的Web项目” “Tomcat部署的Teb项目”对应着“工作空间项目” 的Web目录下的所有资源 IDEA工作台中，项目的src对应着WEB-INF目录 WEB-INF目录下的资源不能被浏览器直接访问。日后可以利用其他技术访问到。 断点调试：使用”小虫子”启动 dubug 启动 视频讲解【00:28】1.IDEA会为每一个Tomcat部署的项目单独建立一份配置文件 【03:15】2.工作空间项目 和 Tomcat部署的Web项目 【09:04】3.断点调试：使用”小虫子”启动 dubug 启动","text":"IDEA会为每一个Tomcat部署的项目单独建立一份配置文件 查看控制台的log Using CATALINA_BASE: \"C:\\Users\\丶Melody\\.IntelliJIdea2019.1\\system\\tomcat\\_test\" 工作空间项目 和 Tomcat部署的Web项目 Tomcat真正访问的是“Tomcat部署的Web项目” “Tomcat部署的Teb项目”对应着“工作空间项目” 的Web目录下的所有资源 IDEA工作台中，项目的src对应着WEB-INF目录 WEB-INF目录下的资源不能被浏览器直接访问。日后可以利用其他技术访问到。 断点调试：使用”小虫子”启动 dubug 启动 视频讲解【00:28】1.IDEA会为每一个Tomcat部署的项目单独建立一份配置文件 【03:15】2.工作空间项目 和 Tomcat部署的Web项目 【09:04】3.断点调试：使用”小虫子”启动 dubug 启动 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"Servlet：运行在服务器端的小程序","slug":"Servlet：运行在服务器端的小程序","date":"2020-02-20T07:19:00.000Z","updated":"2020-04-23T11:40:36.772Z","comments":true,"path":"2020/02/20/Servlet：运行在服务器端的小程序/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/Servlet%EF%BC%9A%E8%BF%90%E8%A1%8C%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/","excerpt":"Servlet： server applet 概念：运行在服务器端的小程序 Servlet就是一个接口，定义了Java类被浏览器访问到（Tomcat识别）的规则（我是跳转内容）↩。 将来我们自定义一个类，实现Servlet接口，复写（重写Override）方法。 快速理解","text":"Servlet： server applet 概念：运行在服务器端的小程序 Servlet就是一个接口，定义了Java类被浏览器访问到（Tomcat识别）的规则（我是跳转内容）↩。 将来我们自定义一个类，实现Servlet接口，复写（重写Override）方法。 快速理解 快速入门 创建JavaEE项目 定义一个类，实现Servlet接口 /* ServletDemo1.java */ package cn.itcast.web.servlet; import javax.servlet.*; import java.io.IOException; public class ServletDemo1 implements Servlet { //TODO } ​ 实现接口中的抽象方法 /* ServletDemo1.java */ package cn.itcast.web.servlet; import javax.servlet.*; import java.io.IOException; public class ServletDemo1 implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } // 提供服务的方法 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"Hello Servlet\"); } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } 配置Servlet，在web.xml的&lt;web-app&gt;&lt;/web-app&gt;中添加： &lt;!--配置Servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; servlet-mapping是做一个映射，servlet-name对应servlet-class，url-pattern是资源路径（/开头） &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;，中的cn.itcast.web.servlet.ServletDemo1是全类名，这里涉及到反射。日后补充。 启动服务，看看结果 浏览器中是空白的， 但是IDEA控制台中显示“Hello Servlet” 每刷新一次页面，控制台就多一句“Hello Servlet”。 执行原理 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。 如果有，则在找到对应的&lt;servlet-class&gt;全类名（涉及到反射） tomcat会将字节码文件加载进内存，并且创建其对象 调用其方法 为什么能调用方法？ 因为实现了【规则】（点击我跳转）。实现规则，实现Servlet接口，实现了接口中的方法。 ServletDemo可以调试、运行，看看每个方法的执行次数。 import javax.servlet.*; import java.io.IOException; /** * Servlet的方法 */ public class ServletDemo1 implements Servlet { /** * 初始化的方法 * 在Servlet被创建时，执行，且只执行一次。 * @param servletConfig * @throws ServletException */ @Override public void init(ServletConfig servletConfig) throws ServletException { System.out.println(\"init...\"); } /** * 获取ServletConfig对象 * ServletConfig：Servlet的配置对象 * @return */ @Override public ServletConfig getServletConfig() { return null; } /** * 提供服务的方法 * 每一次Servlet被访问时，执行。可执行多次。 * @param servletRequest * @param servletResponse * @throws ServletException * @throws IOException */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"service...\"); } /** * 获取Servlet的一些信息（版本、作者……） * @return */ @Override public String getServletInfo() { return null; } /** * 销毁的方法 * 在服务器正常关闭时，执行。只执行一次。 * 非正关闭时，destroy方法不会执行。 */ @Override public void destroy() { System.out.println(\"destroy...\"); } } Servlet中的生命周期方法1.被创建：执行init方法，只执行一次 Servlet什么时候被创建？ 默认情况下，第一次被访问时，被创建。 在服务器启动时，被创建。 可以配置执行Servlet的创建时机，在&lt;servlet&gt;&lt;/servlet&gt;标签中配置&lt;load-on-startup&gt;整数值&lt;/load-on-startup&gt; 1.第一次被访问时，创建 负整数 2.在服务器启动时，创建 0或正整数(一般0~10) /** * 初始化的方法 * 在Servlet被创建时，执行，且只执行一次。 * @param servletConfig * @throws ServletException */ @Override public void init(ServletConfig servletConfig) throws ServletException { System.out.println(\"init...\"); // 定义局部变量，这样不存在多线程的安全问题 int number = 3; } Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的。 多个用户同时访问时，可能存在线程安全问题。 解决：尽量不要在Servlet中定义成员变量（定义局部变量就不存在安全问题了）。即使定义了成员变量，也不要对修改值。 2.提供服务：执行service方法，可执行多次 每次访问Servlet时，Service方法都会被调用一次。 /** * 提供服务的方法 * 每一次Servlet被访问时，执行。可执行多次。 * @param servletRequest * @param servletResponse * @throws ServletException * @throws IOException */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"service...\"); } 3.被销毁：执行destroy方法，只执行一次 Servlet被销毁时执行。服务器关闭时，Servlet被销毁 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源 /** * 销毁的方法 * 在服务器正常关闭时，执行。只执行一次。 * 非正关闭时，destroy方法不会执行。 */ @Override public void destroy() { System.out.println(\"destroy...\"); } Servlet 3.0 官方提供新的标准 Servlet 3.0 从 Java EE 6 开始支持 Servlet 3.0 好处 支持注解配置。可以不需要web.xml了 步骤 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 定义一个类，实现Servlet接口 复写方法 在类上使用@WebServlet注解，进行配置 @WebServlet(\"资源路径\") 比如：@WebServlet(urlPatterns = \"/demo2\") 或 @WebServlet(value = \"/demo2\") 或 @WebServlet(\"/demo2\") 访问：http://localhost:8080/Servlet3/demo2 @WebServlet注解 @WebServlet中有个很特殊的属性value 一般表示最重要的属性，就用value表示。 特性：如果只有一个属性，value可以省略不写。 除去value，最重要的属性是urlPatterns @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface WebServlet { String name() default \"\"; //相当于&lt;Servlet-name&gt; String[] value() default {}; //代表urlPatterns()属性配置 String[] urlPatterns() default {}; //相当于&lt;url-pattern&gt; int loadOnStartup() default -1; //相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default {}; boolean asyncSupported() default false; String smallIcon() default \"\"; String largeIcon() default \"\"; String description() default \"\"; String displayName() default \"\"; } Servlet 体系结构跳转到我得下一篇博文👉 [Servlet 体系结构](https://melodyjerry.gitee.io/blog/2020/02/20/Servlet 体系结构/) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"},{"name":"Servlet","slug":"Servlet","permalink":"https://melodyjerry.github.io/blog/tags/Servlet/"}]},{"title":"Tomcat简单修改虚拟目录实现访问多个项目","slug":"Tomcat简单修改虚拟目录实现访问多个项目","date":"2020-02-20T06:55:00.000Z","updated":"2020-04-23T11:40:36.769Z","comments":true,"path":"2020/02/20/Tomcat简单修改虚拟目录实现访问多个项目/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/Tomcat%E7%AE%80%E5%8D%95%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%8E%B0%E8%AE%BF%E9%97%AE%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/","excerpt":"可以通过 修改Application Contest（虚拟目录） 实现访问多个项目 修改项目名称作为对应的虚拟目录， 重启服务后，浏览器访问时， http://localhost:8080/项目a/资源5 例如：http://localhost:55555/ServletDemo/demo1.html","text":"可以通过 修改Application Contest（虚拟目录） 实现访问多个项目 修改项目名称作为对应的虚拟目录， 重启服务后，浏览器访问时， http://localhost:8080/项目a/资源5 例如：http://localhost:55555/ServletDemo/demo1.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"IDEA启动Tomcat报错","slug":"IDEA启动Tomcat报错","date":"2020-02-19T12:02:09.000Z","updated":"2020-04-23T11:40:36.759Z","comments":true,"path":"2020/02/19/IDEA启动Tomcat报错/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/IDEA%E5%90%AF%E5%8A%A8Tomcat%E6%8A%A5%E9%94%99/","excerpt":"问题 IDEA run的时候报错： Error running 'Tomcat 8.5.51': Address loaclhost:1099 is already in use","text":"问题 IDEA run的时候报错： Error running 'Tomcat 8.5.51': Address loaclhost:1099 is already in use 分析控制台提示1099端口已经被占用。 解决解决方法要么是杀死端口号1099对应的进程，要么就是修改IDEA中Tomcat的端口号。 建议优先选择杀死对应进程。 方法一 根据端口号查找对应的PID，可以通过在cmd中输入命令， netstat -ano | findstr 1099 找到该进程的进程号为7256 输入命令，杀死进程 tskill 7256 或 taskkill -f -pid 7256 方法二同方法一，知道进程的PID后，直接去进程管理器，直接右键结束进程。 方法三针对方法一、二均无效时，只能在IDEA中修改端口： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"IDEA 常用快捷键列表","slug":"IDEA输出打印System.out.println()的快捷键","date":"2020-02-19T09:02:00.000Z","updated":"2020-04-23T11:40:36.760Z","comments":true,"path":"2020/02/19/IDEA输出打印System.out.println()的快捷键/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/IDEA%E8%BE%93%E5%87%BA%E6%89%93%E5%8D%B0System.out.println()%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"IDEA输出打印System.out.println()的快捷键在eclipse中习惯了使用syso，开始用idea很不习惯。 在idea中直接输入sout，自动出现提示，不像eclipse中那样还要alt+/，这算是idea的一个优点了。 sout 看图： 按Tab或Enter都可以出现","text":"IDEA输出打印System.out.println()的快捷键在eclipse中习惯了使用syso，开始用idea很不习惯。 在idea中直接输入sout，自动出现提示，不像eclipse中那样还要alt+/，这算是idea的一个优点了。 sout 看图： 按Tab或Enter都可以出现 十大Intellij IDEA快捷键 for System.out、main快捷键 1 智能提示 Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。 最后要说一点，Intellij能够智能感知spring、hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。 2 重构 Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。 切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。 3 代码生成这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。 另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。 4 编辑编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+&lt;/&gt;折叠代码就不多说了。 关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。 5 查找打开类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。 类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。 要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。 Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。 6 其他辅助以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有： Ø 命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 Ø 新建：Alt+Insert可以新建类、方法等任何东西。 Ø 格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 Ø 切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 Ø 单元测试：Ctrl+Alt+T创建单元测试用例。 Ø 运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 Ø 调试：F7/F8/F9分别对应Step into，Step over，Continue。 此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。 7 最终榜单这榜单阵容太豪华了，后几名都是如此有用，毫不示弱。 Ø Top #10切来切去：Ctrl+Tab Ø Top #9选你所想：Ctrl+W Ø Top #8代码生成：Template/Postfix +Tab Ø Top #7发号施令：Ctrl+Shift+A Ø Top #6无处藏身：Shift+Shift Ø Top #5自动完成：Ctrl+Shift+Enter Ø Top #4创造万物：Alt+Insert 太难割舍，前三名并列吧！ Ø Top #1智能补全：Ctrl+Shift+Space Ø Top #1自我修复：Alt+Enter Ø Top #1重构一切：Ctrl+Shift+Alt+T ————————版权声明：本文为CSDN博主「Jenrey」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/jenrey/article/details/79961825 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"IDEA 常用快捷键列表","slug":"IDEA常用快捷键列表","date":"2020-02-19T09:00:00.000Z","updated":"2020-04-23T11:40:36.761Z","comments":true,"path":"2020/02/19/IDEA常用快捷键列表/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%88%97%E8%A1%A8/","excerpt":"IDEA 常用快捷键列表","text":"IDEA 常用快捷键列表 ——- IDEA中窗口最大化—-&gt;Windows 上： Ctrl+Shift+F12 ——– ctrl+z撤回代码 ——- ctrl+shift+z恢复撤回代码 ——- ctrl + Alt + V (返回属性变量) ——- shift+ctrl+u (大小写的切换) ——- Ctrl+Alt+L，格式化代码 ——- Ctrl+D 将当前行复制到下一行 ——- Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch 也可抛错误 ——- 快捷方式一（光标移到该代码行，Alt+Enter），可以异常外抛出，也可以try-catch： ——- Ctrl+Shift+Space，自动补全代码（提示） ——- Ctrl+O，重写方法 ——- Ctrl+I，实现方法 ——- ctrl + shift + enter 句末加； ——- 连安两下 shift 查找文件 ——- CtrL +shift +r 全局搜索： ——- ctrl +r 替换当前页的单词 ——- 代码格式化： shfit + G (自定义) //ctrl +alt +L —— 直接查看和进入接口实现类的快捷键 ： Ctrl+Alt+鼠标左键 —– 单机两下放大窗户： —– alt+capslk(大小写切换)+鼠标左键 或者：ALT + 鼠标左键 列编辑模式 ————- ctrl+shift+enter不只是用来行尾加分号的； idea进阶快捷键： 1 查看接口的实现类：Ctrl+Alt+B： 2：查看一个类中有什么方法：Alt+7 或 点左侧边栏Structure 2 返回上/下个光标地方:Alt+Ctrl+箭头(向左) 和 Alt+ Ctrl+箭头(向右)—（全键盘） 3： 查看Java方法调用树(被调/主调)：Ctrl+Alt+H 4 :查看类继承关系图：Ctrl+Alt+U 5:查看当前类的继承树：Ctrl+H 6: 查看定义的变量在哪里被调用：Ctrl+Alt+F7 7:查看一个类中有什么方法：Alt+7 或 点左侧边栏Structure 8:列编辑：alt +左键 9:自动生成not null判断语句 自动生成not null这种if判断，在IDEA里有很多种办法，其中一种办法你可能没想到。 upload successful 当我们使用rabbitTemplate. 后，直接输入notnull并回车，IDEA就好自动生成if判断了。 upload successful 编辑Ctrl+Shift + Enter，语句完成\" ！\"，否定完成，输入表达式时按 “！”键Ctrl+E，最近的文件Ctrl+Shift+E，最近更改的文件Shift+Click，可以关闭文件Ctrl+[ OR ]，可以跑到大括号的开头与结尾Ctrl+F12，可以显示当前文件的结构Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择Ctrl+N，可以快速打开类Ctrl+Shift+N，可以快速打开文件Alt+Q，可以看到当前方法的声明Ctrl+P，可以显示参数信息Ctrl+Shift+Insert，可以选择剪贴板内容并插入Alt+Insert，可以生成构造器/Getter/Setter等Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catchCtrl+Enter，导入包，自动修正Ctrl+Alt+L，格式化代码Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作Ctrl+Alt+O，优化导入的类和包Ctrl+R，替换文本Ctrl+F，查找文本Ctrl+Shift+Space，自动补全代码Ctrl+空格，代码提示（与系统输入法快捷键冲突）Ctrl+Shift+Alt+N，查找类中的方法或变量★Alt+Enter，快速修复错误提示、导入包、自动修正代码、解决出现的问题、生成返回值…… 详细见 最特殊的快捷键 Alt + Enter 介绍 Alt+Shift+C，最近的更改Alt+Shift+Up/Down，上/下移一行Shift+F6，重构 – 重命名Ctrl+X，删除行Ctrl+D，复制行Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）Ctrl+J，自动代码（例如：serr）Ctrl+Alt+J，用动态模板环绕Ctrl+H，显示类结构图（类的继承层次）Ctrl+Q，显示注释文档Alt+F1，查找代码所在位置Alt+1，快速打开或隐藏工程面板Ctrl+Alt+left/right，返回至上次浏览的位置Alt+left/right，切换代码视图Alt+Up/Down，在方法间快速移动定位Ctrl+Shift+Up/Down，向上/下移动语句F2 或 Shift+F2，高亮错误或警告快速定位Tab，代码标签输入完成后，按 Tab，生成代码Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失Alt+F3，逐个往下查找相同文本，并高亮显示Ctrl+Up/Down，光标中转到第一行或最后一行下Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）Ctrl+Alt+B，跳转到方法实现处Ctrl+Shift+Backspace，跳转到上次编辑的地方Ctrl+O，重写方法Ctrl+Alt+Space，类名自动完成Ctrl+Alt+Up/Down，快速跳转搜索结果Ctrl+Shift+J，整合两行Alt+F8，计算变量值Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本Ctrl+Alt+Shift+V，简单粘贴Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口F12，把焦点从编辑器移到最近使用的工具窗口Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器Ctrl+W，可以选择单词继而语句继而行继而函数Ctrl+Shift+W，取消选择光标所在词Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置Ctrl+I，实现方法Ctrl+Shift+U，大小写转化Ctrl+Y，删除当前行 Shift+Enter，向下插入新行psvm/sout，main/System.out.println();Ctrl+J，查看更多Ctrl+Shift+F，全局查找Ctrl+F，查找Shift+F3，向上查找F3，向下查找Ctrl+Shift+S，高级搜索Ctrl+U，转到父类Ctrl+Alt+S，打开设置对话框Alt+Shift+Inert，开启/关闭列选择模式Ctrl+Alt+Shift+S，打开当前项目/模块属性Ctrl+G，定位行Alt+Home，跳转到导航栏Ctrl+Enter，上插一行Ctrl+Backspace，按单词删除Ctrl+\"+/-\"，当前方法展开、折叠Ctrl+Shift+\"+/-\"，全部展开、折叠 调试、编译Ctrl+F2，停止Alt+Shift+F9，选择 DebugAlt+Shift+F10，选择 RunCtrl+Shift+F9，编译Ctrl+Shift+F10，运行Ctrl+Shift+F8，查看断点F8，步过F7，步入Shift+F7，智能步入Shift+F8，步出Alt+Shift+F8，强制步过Alt+Shift+F7，强制步入Alt+F9，运行至光标处Ctrl+Alt+F9，强制运行至光标处F9，恢复程序Alt+F10，定位到断点Ctrl+F8，切换行断点Ctrl+F9，生成项目Alt+1，项目Alt+2，收藏Alt+6，TODOAlt+7，结构Ctrl+Shift+C，复制路径Ctrl+Alt+Shift+C，复制引用，必须选择类名Ctrl+Alt+Y，同步Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）Shift+F12，还原默认布局Ctrl+Shift+F12，隐藏/恢复所有窗口Ctrl+F4，关闭Ctrl+Shift+F4，关闭活动选项卡Ctrl+Tab，转到下一个拆分器Ctrl+Shift+Tab，转到上一个拆分器 重构Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除Ctrl+Alt+N，内联 查找Ctrl+F，查找Ctrl+R，替换F3，查找下一个Shift+F3，查找上一个Ctrl+Shift+F，在路径中查找Ctrl+Shift+R，在路径中替换Ctrl+Shift+S，搜索结构Ctrl+Shift+M，替换结构Alt+F7，查找用法Ctrl+Alt+F7，显示用法Ctrl+F7，在文件中查找用法Ctrl+Shift+F7，在文件中高亮显示用法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"Tomcat启动时中文乱码的问题","slug":"Tomcat启动时中文乱码的问题","date":"2020-02-19T08:01:00.000Z","updated":"2020-04-23T11:40:36.767Z","comments":true,"path":"2020/02/19/Tomcat启动时中文乱码的问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/Tomcat%E5%90%AF%E5%8A%A8%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"问题Tomcat启动时中文乱码的问题 解决方法修改conf文件夹下的logging.properties文件 第47行代码： java.util.logging.ConsoleHandler.encoding = UTF-8 改为 java.util.logging.ConsoleHandler.encoding = GBK","text":"问题Tomcat启动时中文乱码的问题 解决方法修改conf文件夹下的logging.properties文件 第47行代码： java.util.logging.ConsoleHandler.encoding = UTF-8 改为 java.util.logging.ConsoleHandler.encoding = GBK 扩展如果IDEA中使用Tomcat也乱码，可以额为参考此方法。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"Tomcat：Web服务器软件","slug":"Tomcat：服务器软件","date":"2020-02-19T07:25:00.000Z","updated":"2020-04-23T11:40:36.770Z","comments":true,"path":"2020/02/19/Tomcat：服务器软件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/Tomcat%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AF%E4%BB%B6/","excerpt":"Tomcat：web服务器软件 Tomcat 是用纯Java语言编写的 安装下载 https://tomcat.apache.org/download-80.cgi 免安装，解压压缩包即可。 注意：安装目录建议不要有中文和空格 目录结构 启动 Windows：运行./bin/startup.bat Linux：运行./bin/startup.sh","text":"Tomcat：web服务器软件 Tomcat 是用纯Java语言编写的 安装下载 https://tomcat.apache.org/download-80.cgi 免安装，解压压缩包即可。 注意：安装目录建议不要有中文和空格 目录结构 启动 Windows：运行./bin/startup.bat Linux：运行./bin/startup.sh 可能遇到的问题中文乱码详细见博文 【Tomcat启动时中文乱码的问题】 黑窗口一闪而过 原因： 没有正确配置JAVA_HOME环境变量 解决方案：正确配置JAVA_HOME环境变量 启动报错暴力 找到占用的端口号，并且找到对应的进程，杀死该进程 cmd&gt;netstat -ano &gt; 查看进程id（PID）&gt;任务管理器（查看-选择列-PID）&gt;结束进程（对应PID） 温柔 修改自身的端口号 ./conf/server.xml `&lt;Connector port=”8888” protocol=”HTTP/1.1” connectionTimeout=\"20000\" redirectPort=\"8445\" /&gt;` 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 好处：在访问时，就不用输入端口号 该方式可实现单机多Tomcat并存 访问浏览器输入： 访问自己：http://localhost:8080 访问别人：http://别人的ip:8080 查看IP地址 cmd&gt;$ ipconfig &gt;IPv4地址 关闭 针对服务器本身，推荐使用“正常关闭” 但是后期是配合IDEA使用Tomcat 正常关闭 有两种方式： 手动运行./bin/shutdown.bat 在Tomcat窗口，按Ctrl+C 强制关闭 点击Tomcat窗口右上角的X 部署/配置项目的方式 有三种方式： 直接将项目放到webapps目录下即可 配置conf/server.xml文件 在conf\\Catalina\\localhost创建任意名称的xml文件 虚拟目录浏览器通过http://localhost:8080访问，需要访问到某一个项目时，需要在其随后加上/目录或路径（称作虚拟目录） 直接将项目放到webapps目录下即可 /项目(文件夹)名”：项目的访问路径，也称虚拟目录 简化部署 第一种方式还有一种简化部署的形式 将项目打成一个war包，再将war包放置到webapps目录下 war 包会自动解压缩 若删除项目，删除对应war包即可。自动会删除对应生产的项目文件夹。 配置conf/server.xml文件 在&lt;Host&gt;标签体中配置 &lt;Context docBase=\"D:\\hello\" path=\"/hehe\" /&gt; docBase：项目存放的路径 path：虚拟目录 缺点：需要修改配置文件，不太安全 在conf\\Catalina\\localhost创建任意名称的xml文件 在文件中编写 &lt;Context docBase=\"D:\\hello\" /&gt; 虚拟目录：xml文件的名称。比如localhost:8080/xml文件/index.html 热部署方式：删除或修改文件名后，不需要重启服务。 部署项目的类型 静态项目 动态项目 静态项目 只能存放静态资源 HTML、CSS、JavaScript、图片、音频、视频、文本等等 动态项目 不仅可存放静态资源，还有动态资源 目录结构(Java动态项目)项目根目录 ﹂-WEB-INF目录 ﹂web.xml：web项目的核心配置文件 ﹂classes目录：放置字节码文件的目录 ﹂lib目录：放置依赖的jar包 比如： IDEA中配合使用Tomcat集成到IDEA中 新建Web项目 运行项目 注意： 默认war打包部署 / ：默认虚拟目录设置当前项目为根目录 其他配置 重新部署项目时，不再重启Tomcat服务器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"Github提速","slug":"Github提速","date":"2020-02-18T09:00:00.000Z","updated":"2020-04-23T11:40:36.737Z","comments":true,"path":"2020/02/18/Github提速/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/18/Github%E6%8F%90%E9%80%9F/","excerpt":"经常要clone github中的一些项目，无奈如果不爬梯子的话速度实在是龟速，经常1k/s，于是献上改Hosts大法。 第一步：打开http://codeload.github.com.ipaddress.com/#ipinfo 找到你浏览器上实际显示的IP地址， 例图 ： 第二步：按win+r唤起运行框，输入cmd，然后再依次ping一下上面的地址 第三步：打开你C:\\Windows\\System32\\drivers\\etc\\hosts文件，在文件末尾追加如下一行即可 140.82.113.9 http://codeload.github.com","text":"经常要clone github中的一些项目，无奈如果不爬梯子的话速度实在是龟速，经常1k/s，于是献上改Hosts大法。 第一步：打开http://codeload.github.com.ipaddress.com/#ipinfo 找到你浏览器上实际显示的IP地址， 例图 ： 第二步：按win+r唤起运行框，输入cmd，然后再依次ping一下上面的地址 第三步：打开你C:\\Windows\\System32\\drivers\\etc\\hosts文件，在文件末尾追加如下一行即可 140.82.113.9 http://codeload.github.com 另外以下这些github hosts，可能对你所在地区来说不是最优版本，最优hosts的选择可以参考上面三个步骤 # GitHub Start 192.30.253.112 github.com 192.30.253.119 gist.github.com 151.101.100.133 assets-cdn.github.com 151.101.100.133 raw.githubusercontent.com 151.101.100.133 gist.githubusercontent.com 151.101.100.133 cloud.githubusercontent.com 151.101.100.133 camo.githubusercontent.com 151.101.100.133 avatars0.githubusercontent.com 151.101.100.133 avatars1.githubusercontent.com 151.101.100.133 avatars2.githubusercontent.com 151.101.100.133 avatars3.githubusercontent.com 151.101.100.133 avatars4.githubusercontent.com 151.101.100.133 avatars5.githubusercontent.com 151.101.100.133 avatars6.githubusercontent.com 151.101.100.133 avatars7.githubusercontent.com 151.101.100.133 avatars8.githubusercontent.com # GitHub End document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Github","slug":"Github","permalink":"https://melodyjerry.github.io/blog/tags/Github/"}]},{"title":"JavaScript：让页面元素动起来","slug":"JavaScript：让页面元素动起来","date":"2020-02-18T01:01:00.000Z","updated":"2020-04-23T11:40:36.763Z","comments":true,"path":"2020/02/18/JavaScript：让页面元素动起来/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/18/JavaScript%EF%BC%9A%E8%AE%A9%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%8A%A8%E8%B5%B7%E6%9D%A5/","excerpt":"概念一门客户端脚本语言 特点 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎 脚本语言：不需要编译，直接就可以被浏览器解析执行了 功能 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。","text":"概念一门客户端脚本语言 特点 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎 脚本语言：不需要编译，直接就可以被浏览器解析执行了 功能 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。 发展史 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C– ，后来更名为：ScriptEase 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript 1996年，微软抄袭JavaScript开发出JScript语言 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。 JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)ECMAScript：客户端脚本语言的标准基本语法与html结合方式内部JS 定义&lt;script&gt;，标签体内容就是js代码 外部JS 定义&lt;script&gt;，通过src属性引入外部的js文件 注意 &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。 &lt;script&gt;可以定义多个。 注释 单行注释：// 注释内容 多行注释：/* 注释内容 */ 数据类型详细见 JavaScript 数据类型 原始数据类型(基本数据类型) number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型) string：字符串。 字符串 “abc” “a” ‘abc’ boolean：布尔。 true和false null：一个对象为空的占位符 undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined Undefined 与 Null 的区别 Undefined 与 Null 的值相等，但类型不相等： typeof undefined // undefined typeof null // object null === undefined // false null == undefined // true 引用数据类型 对象（object） 数组（array） 变量 变量：一小块存储数据的内存空间 Java语言是强类型语言，而JavaScript是弱类型语言。 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。 语法var 变量名 = 初始化值; typeof运算符 获取变量的类型 注：null运算后得到的是object 更多见 《JavaScript中typeof知多少？》 运算符 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换。 其他类型转number： string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字） boolean转number：true转为1，false转为0 算数运算符算术运算符对数值（文字或变量）执行算术运算。 运算符 描述 + 加法 - 减法 * 乘法 ** 幂（将第一个操作数提升到第二个操作数的幂。ES2016） / 除法 % 系数（返回除法的余数） ++ 递增 – 递减 赋值运算符赋值运算符向 JavaScript 变量赋值。 运算符 特殊说明 例子 等同于 = x = y x = y += x += y x = x + y -= x -= y x = x - y *= x *= y x = x * y /= x /= y x = x / y %= 把余数赋值给变量 x %= y x = x % y &lt;&lt;= x &lt;&lt;= y x = x &lt;&lt; y &gt;&gt;= x &gt;&gt;= y x = x &gt;&gt; y &gt;&gt;&gt;= x &gt;&gt;&gt;= y x = x &gt;&gt;&gt; y &amp;= x &amp;= y x = x &amp; y ^= x ^= y x = x ^ y |= x |= y x = x | y **= x **= y x = x ** y 提示：****=** 运算符属于 ECMAScript 2016 proposal (ES7) 的实验部分。它的跨浏览器表现并不稳定。请勿使用。 比较运算符比较运算符在逻辑语句中使用，以判定变量或值是否相等。 我们给定 x = 5，下表中解释了比较运算符： 运算符 描述 比较 返回 == 等于 x == 8 false x == 5 true x == “5” true === 值相等并且类型相等 x === 5 true x === “5” false != 不相等 x != 8 true !== 值不相等或类型不相等 x !== 5 false x !== “5” true x !== 8 true &gt; 大于 x &gt; 8 false &lt; 小于 x &lt; 8 true &gt;= 大于或等于 x &gt;= 8 false &lt;= 小于或等于 x &lt;= 8 true 比较方式 类型相同：直接比较 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。 类型不同：先进行类型转换，再比较 ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false 逻辑运算符逻辑运算符用于判定变量或值之间的逻辑。 我们给定 x = 6 且 y = 3，下表解释了逻辑运算符： 运算符 描述 例子 &amp;&amp; 与 (x &lt; 10 &amp;&amp; y &gt; 1) 为 true || 或 (x == 5 || y == 5) 为 false ! 非 !(x == y) 为 true 其他类型转boolean： number：0或NaN为假，其他为真 string：除了空字符串(“”)，其他都是true null&amp;undefined：都是false 对象：所有对象都为true 条件（三元）运算符语法： 变量名=(表达式)? 值1:值2; 判断表达式的值，如果是true则取值1，如果是false则取值2； 示例： var voteable = (age &lt; 18) ? \"太年轻\":\"足够成熟\"; 字符串运算符+ 运算符也可用于对字符串进行相加（concatenate，级联）。+= 赋值运算符也可用于相加（级联）字符串： 实例：给定 text1 = “Good “, text2 = “Morning”, 及 text3 = “”, 下面的表格解释了字符串运算符的使用： 运算符 例子 text1 text2 text3或text1 + text3 = text1 + text2 “Good “ “Morning” “Good Morning” += text1 += text2 “Hello” “Kitty！” “Hello Kitty!” 字符串+数字=字符串 相加两个数字，将返回和。但对一个数字和一个字符串相加将返回一个字符串。 类型运算符 运算符 描述 typeof 返回变量的类型。 instanceof 返回 true，如果对象是对象类型的实例。 typeof 运算符您可以使用 typeof 运算符来确定 JavaScript 变量的数据类型。 typeof \"Bill\" // 返回 \"string\" typeof 3.14 // 返回 \"number\" typeof NaN // 返回 \"number\" typeof false // 返回 \"boolean\" typeof [1,2,3,4] // 返回 \"object\" typeof {name:'Bill', age:62} // 返回 \"object\" typeof new Date() // 返回 \"object\" typeof function () {} // 返回 \"function\" typeof myCar // 返回 \"undefined\" * typeof null // 返回 \"object\" 请注意： NaN 的数据类型是数值 数组的数据类型是对象 日期的数据类型是对象 null 的数据类型是对象 未定义变量的数据类型是 undefined 尚未赋值的变量的数据类型也是 undefined 无法使用 typeof 去判断 JavaScript 对象是否是数组（或日期）。 typeof 的数据类型： typeof 运算符不是变量。它属于运算符。运算符（比如 + - * /）没有数据类型。 但是，typeof 始终会返回字符串（包含运算数的类型）。 另外涉及到Number() 转换数值，String() 转换字符串，Boolean() 转换布尔值。 位运算符位运算符处理 32 位数。 该运算中的任何数值运算数都会被转换为 32 位的数。结果会被转换回 JavaScript 数。 运算符 描述 例子 等同于 结果 十进制 &amp; 与 (and) 5 &amp; 1 0101 &amp; 0001 0001 1 | 或 (or) 5 | 1 0101 | 0001 0101 5 ~ 非 (not) ~ 5 ~0101 1010 10 ^ 异或 (xor) 5 ^ 1 0101 ^ 0001 0100 4 &lt;&lt; 零填充左位移 5 &lt;&lt; 1 0101 &lt;&lt; 1 1010 10 &gt;&gt; 有符号右位移 5 &gt;&gt; 1 0101 &gt;&gt; 1 0010 2 &gt;&gt;&gt; 零填充右位移 5 &gt;&gt;&gt; 1 0101 &gt;&gt;&gt; 1 0010 2 上例使用 4 位无符号的例子。但是 JavaScript 使用 32 位有符号数。因此，在 JavaScript 中，~ 5 不会返回 10，而是返回 -6。~00000000000000000000000000000101 将返回 11111111111111111111111111111010。 JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数。执行按位操作后，结果将转换回 64 位 JavaScript 数。 运算符优先级值 值 运算符 描述 实例 20 ( ) 表达式分组 (3 + 4) 19 . 成员 person.name 19 [] 成员 person[“name”] 19 () 函数调用 myFunction() 19 new 创建 new Date() 17 ++ 后缀递增 i++ 17 – 后缀递减 i– 16 ++ 前缀递增 ++i 16 – 前缀递减 –i 16 ! 逻辑否 !(x==y) 16 typeof 类型 typeof x 15 ** 求幂 (ES7) 10 ** 2 14 * 乘 10 * 5 14 / 除 10 / 5 14 % 模数除法 10 % 5 13 + 加 10 + 5 13 - 减 10 - 5 12 &lt;&lt; 左位移 x &lt;&lt; 2 12 &gt;&gt; 右位移 x &gt;&gt; 2 12 &gt;&gt;&gt; 右位移（无符号） x &gt;&gt;&gt; 2 11 &lt; 小于 x &lt; y 11 &lt;= 小于或等于 x &lt;= y 11 &gt; 大于 x &gt; y 11 &gt;= 大于或等于 x &gt;= y 11 in 对象中的属性 “PI” in Math 11 instanceof 对象的实例 instanceof Array 10 == 相等 x == y 10 === 严格相等 x === y 10 != 不相等 x != y 10 !== 严格不相等 x !== y 9 &amp; 按位与 x &amp; y 8 ^ 按位 XOR x ^ y 7 | 按位或 x | y 6 &amp;&amp; 逻辑与 x &amp;&amp; y 5 || 逻辑否 x || y 4 ? : 条件 ? “Yes” : “No” 3 = 赋值 x = y 3 += 赋值 x += y 3 -= 赋值 x -= y 3 *= 赋值 x *= y 3 %= 赋值 x %= y 3 &lt;&lt;= 赋值 x &lt;&lt;= y 3 &gt;&gt;= 赋值 x &gt;&gt;= y 3 &gt;&gt;&gt;= 赋值 x &gt;&gt;&gt;= y 3 &amp;= 赋值 x &amp;= y 3 ^= 赋值 x ^= y 3 |= 赋值 x |= y 2 yield 暂停函数 yield x 1 , 逗号 7 , 8 注意：淡红色指示实验性或建议性的技术（ECMASScript 2016 或 ES7） 提示：括号中的表达式会在值在表达式的其余部分中被使用之前进行完全计算。 流程控制语句 if...else... switch: 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7) switch(变量): case 值: 在JS中,switch语句可以接受任意的原始数据类型 while for JS特殊语法 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议) 变量的定义使用var关键字，也可以不使用 用： 定义的变量是局部变量 不用：定义的变量是全局变量(不建议) 练习：99乘法表&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;99乘法表&lt;/title&gt; &lt;style&gt; td{ border: 1px solid; } &lt;/style&gt; &lt;script&gt; document.write(\"&lt;table align='center'&gt;\"); //1.完成基本的for循环嵌套，展示乘法表 for (var i = 1; i &lt;= 9 ; i++) { document.write(\"&lt;tr&gt;\"); for (var j = 1; j &lt;=i ; j++) { document.write(\"&lt;td&gt;\"); //输出 1 * 1 = 1 document.write(i + \" * \" + j + \" = \" + ( i*j) +\"&amp;nbsp;&amp;nbsp;&amp;nbsp;\"); document.write(\"&lt;/td&gt;\"); } /*//输出换行 document.write(\"&lt;br&gt;\");*/ document.write(\"&lt;/tr&gt;\"); } //2.完成表格嵌套 document.write(\"&lt;/table&gt;\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 基本对象Function：函数(方法)对象创建格式 function 方法名称(形式参数列表){ 方法体 } var 方法名 = function(形式参数列表){ 方法体 } 建议不用 var fun = new Function(形式参数列表,方法体); //忘掉吧 方法属性 length：代表形参的个数 特点 方法定义是，形参的类型不用写,返回值类型也不写。 方法是一个对象，如果定义名称相同的方法，会覆盖 在JS中，方法的调用只与方法的名称有关，和参数列表无关 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数 调用方法名称(实际参数列表); &lt;!-- 比如： var x = myFunction(4, 3); // 调用函数，返回值被赋值给 x --&gt; 函数中的代码将在其他代码调用该函数时执行： 当事件发生时（当用户点击按钮时） 当 JavaScript 代码调用时 自动的（自调用） 返回当 JavaScript 到达 return 语句，函数将停止执行。如果函数被某条语句调用，JavaScript 将在调用语句之后“返回”执行代码。函数通常会计算出返回值。这个返回值会返回给调用者： function myFunction(a, b) { return a * b; // 函数返回 a 和 b 的乘积 } Array：数组对象创建格式 var arr = new Array(元素列表); var arr = new Array(默认长度); var arr = [元素列表]; 方法 join(参数)：将数组中的元素按照指定的分隔符拼接为字符串 push()：向数组的末尾添加一个或更多元素，并返回新的长度 属性 lengh:数组的长度 特点1. JS中，数组元素的类型可变的。 2. JS中，数组长度可变的。Boolean：布尔布尔值只有两个值：true 或 false。 实例 var x = true; var y = false; 布尔值经常用在条件测试中。 Date：日期对象创建格式var date = new Date(); 方法 toLocaleString()：返回当前date对象对应的时间本地字符串格式 getTime()：获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差 Math：数学对象创建特点 Math对象不用创建，直接使用。 格式：Math.方法名(); 方法 random():返回 0 ~ 1 之间的随机数。 含0不含1 ceil(x)：对数进行上舍入 floor(x)：对数进行下舍入 round(x)：把数四舍五入为最接近的整数 属性 PI Number：数值JavaScript 只有一种数值类型。 写数值时用不用小数点均可： 实例 var x1 = 34.00; // 带小数点 var x2 = 34; // 不带小数点 超大或超小的数值可以用科学计数法来写： 实例 var y = 123e5; // 12300000 var z = 123e-5; // 0.00123 String：字符串字符串（或文本字符串）是一串字符（比如 “Bill Gates”）。 字符串被引号包围。您可使用单引号或双引号： 实例 var carName = \"Porsche 911\"; // 使用双引号 var carName = 'Porsche 911'; // 使用单引号 您可以在字符串内使用引号，只要这些引号与包围字符串的引号不匹配： 实例 var answer = \"It's alright\"; // 双引号内的单引号 var answer = \"He is called 'Bill'\"; // 双引号内的单引号 var answer = 'He is called \"Bill\"'; // 单引号内的双引号 RegExp：正则表达式对象正则表达式：定义字符串的组成规则。 单个字符:[]如： [a] [ab] [a-zA-Z0-9_] 特殊符号代表特殊含义的单个字符： \\d:单个数字字符 [0-9] \\w:单个单词字符 [a-zA-Z0-9_] 量词符号： ?：表示出现0次或1次 *：表示出现0次或多次 +：表示出现1次或多次 {m,n}:表示 m&lt;= 数量 &lt;= n m如果缺省：{,n}：最多n次n 如果缺省：{m,}：最少m次 开始结束符号 ^:开始 $:结束 正则对象创建有两种创建形式： var reg = new RegExp(\"正则表达式\"); var reg = /正则表达式/; 方法 test(参数):验证指定的字符串是否符合正则定义的规范 Global：全局对象特点 全局对象 这个Global中封装的方法不需要对象就可以直接调用：方法名(); 方法 encodeURI()：url编码 decodeURI()：url解码 encodeURIComponent()：url编码,编码的字符更多 decodeURIComponent()：url解码 parseInt()：将字符串转为数字 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number isNaN()：判断一个值是否是NaN NaN六亲不认，连自己都不认。NaN参与的==比较，全部都是false eval()：讲 JavaScript 字符串，并把它作为脚本代码来执行。 URL编码 传智播客 = %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2 BOM概念 Browser Object Model 浏览器对象模型 将浏览器的各个组成部分封装成对象。 浏览器对象模型（Browser Object Model (BOM)）不存在浏览器对象模型（BOM）的官方标准。 现代的浏览器已经（几乎）实现了 JavaScript 交互相同的方法和属性，因此它经常作为 BOM 的方法和属性被提到。 该部分笔记不全，详细见 JavaScript Window - 浏览器对象模型 组成 Window：窗口对象 Navigator：浏览器对象 Screen：显示器屏幕对象 History：历史记录对象 Location：地址栏对象 Navigator 浏览器对象 Navigator 对象获取一些浏览器的信息. 属性 appName 返回浏览器的名称。 相关文档 https://www.w3school.com.cn/jsref/dom_obj_navigator.asp Screen 屏幕对象 Screen 对象包含有关客户端显示屏幕的信息。 属性 width: 返回屏幕的宽度 height: 返回屏幕的高度 相关文档 https://www.w3school.com.cn/jsref/dom_obj_screen.asp Location 地址栏对象 Location 对象包含有关当前 URL 的信息。 创建(获取) window.location location 方法 reload(): 重新加载当前文档,刷新操作. 属性 href: 设置或返回完整的url. Demo&lt;body&gt; &lt;input id=\"btn\" type=\"button\" value=\"跳转\"&gt; &lt;script type=\"text/javascript\"&gt; // 获取input标签 var btn = document.getElementById(\"btn\"); // 设置事件 btn.onclick = function (){ location.href = \"https://www.baidu.com\"; } &lt;/script&gt; &lt;/body&gt; 相关文档 https://www.w3school.com.cn/jsref/dom_obj_location.asp History 对象 History 对象包含用户（在浏览器窗口中）访问过的 URL。 创建(获取) window.history history 方法 back() 加载 history 列表中的前一个 URL。 forward() 加载 history 列表中的下一个 URL。 go(参数)加载 history 列表中的某个具体页面。 参数：正数：前进几个历史记录负数：后退几个历史记录 属性 length: 返回当前窗口历史列表中的url数量. Window 窗口对象 Window 对象表示浏览器中打开的窗口。 方法 与弹出框有关的方法 alert(): 显示带有一段消息和一个确认按钮的警告框. confirm(): 显示带有一段消息,以及确认和取消两个按钮的对话框. 若点击确定,该方法返回true, 点击取消,返回false. 如果用户点击确定按钮，则方法返回true 如果用户点击取消按钮，则方法返回false prompt(): 显示可提示用户输入的对话框. 返回值为用户输入的内容. 与打开关闭有关的方法 close():关闭浏览器窗口。谁调用我 ，我关谁 open(arg1, arg2, arg3, arg4): 打开一个新的浏览器窗口，返回新的Window对象 注意: 这4个参数都是可选的, arg1 传入url, arg3传入窗口的特征(设置宽高等) window.open(\"https://www.baidu.com\",\"\",\"width=100,height=100\"); 与定时器有关的方法 setTimeout(code,millisec): 在指定的毫秒数后调用函数或计算表达式。 参数： js代码或者方法对象 毫秒值 返回值：唯一标识，用于取消定时器 clearTimeout(id_of_settimeout): 取消由 setTimeout() 方法设置的 timeout。传入某个定时器的id用来取消指定的定时器. setInterval(code,millisec): 按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval(id_of_settimeout): 取消由 setInterval() 设置的 timeout。 属性 获取其他BOM对象 History location Navigator Screen 获取DOM对象 document 特点 Window对象不需要创建可以直接使用： window.方法名() window引用可以省略：方法名(); DOM简单学习：为了满足案例要求 功能：控制html文档的内容 获取页面标签(元素)对象：Element* `document.getElementById(\"id值\")`:通过元素的id获取元素对象 操作Element对象： 修改属性值： 明确获取的对象是哪一个？ 查看API文档，找其中有哪些属性可以设置 修改标签体内容： 属性：``innerHTML` 获取元素对象 使用innerHTML属性修改标签体内容 概念 Document Object Model 文档对象模型 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作 功能 控制html文档的内容 W3C DOM 标准被分为 3 个不同的部分 核心 DOM — 针对任何结构化文档的标准模型 Document：文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 Node：节点对象，其他5个(D、E、A、T、C)的父对象 XML DOM — 针对 XML 文档的标准模型 HTML DOM — 针对 HTML 文档的标准模型 对象树当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM 模型被结构化为对象树： DOM: Document Object Model 文档对象模型 文档: 超文本文档(超文本标记文档) html, xml 对象: 提供了属性和方法. 模型: 使用属性和方法操作超文本标记文档 可以使用js里面的dom里面提供的对象,使用这些对象的属性和方法,对标记型文档进行操作. dom里面已经将html里面的标签,属性,文本内容都封装成了对象. 该部分笔记不全，详细见 JavaScript HTML DOM DOM解析html文档的过程 根据html的层级结构,在内存中分配一个树形结构, 需要把html中的每部分封装为对象. Document对象: 整个文档 Element对象: 标签对象 Attribute对象: 首先要获取标签对象 Text对象: 首先要获取标签对象 Comment对象: 注释对象 Node节点对象: 这个对象是上面这些对象的父对象, 如果在对象内找不到想要的方法, 此时可以在Node节点对象中去查找想要的方法. 核心DOM模型Document 文档对象创建(获取) 在html dom模型中可以使用window对象来获取 window.document document 方法write() 向页面输出变量/html代码 document.write(\"abc\"); document.write(\"&lt;hr&gt;\"); 获取Element对象getElementById() ： 根据id属性值获取元素对象,id属性值一般唯一getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组 创建其他的DOM对象 createAttribute(name) createComment() createElement() createTextNode() Element 元素对象(标签对象)创建(获取) 通过document来获取和创建 方法 首先通过document来获取元素,然后通过元素进行操作 getAttribute(attributename): 获取指定的属性 setAttribute(attributename,attributevalue): 给元素添加属性 removeAttribute(attributename): 移除指定名称的属性 注意: 不能删除 value 获取标签下面的子标签 childNodes: 这个属性兼容性很差 getElementsByTagName(标签名): 兼容性好,获取标签下面子标签的唯一有效方法. Node 节点对象特点 所有dom对象都可以被认为是一个节点. 属性 parentNode 返回节点的父节点 方法nodeName:获取节点的名称nodeType: 获取节点的类型nodeValue: 获取节点的value值因为dom在解析html的时候, html里面的标签,属性,文本都是一个节点,所以上面的三个属性对其都是不同的值. 标签节点对应的nodeType为1 属性节点对应的nodeType为2 文本节点对应的nodeType为3 parentNode: 获取父节点的属性childNodes: 得到所有子节点,兼容性差firstChild: 获取第一个子节点lastChild: 获取最后一个子节点nextSibling: 返回一个给定节点的下一个兄弟节点previousSibling: 返回一个给定节点的上一个兄弟节点 CRUD_DOM树查找节点 getElementById():通过节点的id属性,查找指定节点 添加节点 appendChild()：向节点的子节点列表的结尾添加新的子节点 插入节点 insertBefore(newNode, oldNode): 向oldNode节点前插入一个新节点.通过父节点添加 删除节点 removeChild()：删除（并返回）当前节点的指定子节点。 替换节点 replaceChild()：用新节点替换一个子节点。通过父节点替换 复制节点 cloneNode(true): 复制节点 innerHTML属性 innerHTML作用: 获取文本内容 向标签里面设置内容(可以是html代码) Demo&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div#div1 { width: 360px; height: 150px; border: 2px solid red; } div#div2 { width: 360px; height: 150px; border: 2px solid black; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"div1\"&gt; &lt;ul id=\"ul1\"&gt; &lt;li id=\"li1\"&gt;one&lt;/li&gt; &lt;li id=\"li2\"&gt;two&lt;/li&gt; &lt;li id=\"li3\"&gt;three&lt;/li&gt; &lt;li id=\"li4\"&gt;four&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=\"div2\"&gt;&lt;/div&gt; &lt;input id=\"input1\" type=\"button\" value=\"添加节点\"&gt; &lt;input id=\"input2\" type=\"button\" value=\"插入节点\"&gt; &lt;input id=\"input3\" type=\"button\" value=\"删除节点\"&gt; &lt;input id=\"input4\" type=\"button\" value=\"替换节点\"&gt; &lt;input id=\"input5\" type=\"button\" value=\"复制节点\"&gt; &lt;script type=\"text/javascript\"&gt; // 添加节点 /* 1.获取到ul 2.获取到div2 3.把ul添加到div2 */ var input1 = document.getElementById(\"input1\"); input1.onclick = function () { var ul = document.getElementById(\"ul1\"); var div = document.getElementById(\"div2\"); div.appendChild(ul); } // 插入节点 /* 1.获取到li3标签 2.创建li 3.创建文本 4.把文本添加到li下面 5.获取到ul 6.把li添加到ul下面 */ var input2 = document.getElementById(\"input2\"); input2.onclick = function () { var li3 = document.getElementById(\"li3\"); var li = document.createElement(\"li\"); var text = document.createTextNode(\"朝阳红\"); li.appendChild(text); var ul = document.getElementById(\"ul1\"); ul.insertBefore(li, li3); } // 删除节点 /* 1.获取到li标签 2.执行父节点ul标签 3.执行删除 */ var input3 = document.getElementById(\"input3\"); input3.onclick = function () { var li3 = document.getElementById(\"li3\"); var ul = document.getElementById(\"ul1\"); ul.removeChild(li3); } // 替换节点 /* 1.获取到li标签 2.创建标签li 3.创建文本 4.把文本添加到li下面 5.获取父节点Ul标签 6.执行替换 */ var input4 = document.getElementById(\"input4\"); input4.onclick = function () { var li3 = document.getElementById(\"li3\"); var li = document.createElement(\"li\"); var text = document.createTextNode(\"HelloWorld\"); li.appendChild(text); var ul = document.getElementById(\"ul1\"); ul.replaceChild(li, li3); } // 复制节点(把ul列表复制到另一个div中) /* 1.获取到ul 2.执行复制方法：cloneNode(true) 3.把复制后的内容放到div2中 获取div2 appendChild方法 */ var input5 = document.getElementById(\"input5\"); input5.onclick = function () { var ul = document.getElementById(\"ul1\"); var ulClone = ul.cloneNode(true); var div = document.getElementById(\"div2\"); div.appendChild(ulClone); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; HTML DOM 标签体的设置和获取：innerHTML 使用html元素对象的属性 控制元素样式 使用元素的style属性来设置 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。如：//修改样式方式1 div1.style.border = \"1px solid red\"; div1.style.width = \"200px\"; //font-size--&gt; fontSize div1.style.fontSize = \"20px\"; 控制样式 通过DOM来控制标签的样式 使用 style 属性来设置 提前定义好类选择器的样式，通过元素的 className 属性来设置其class属性值。 Demo&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .sun { font-weight: bold; font-size: 30px; color: skyblue; border: 2px dashed #000; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"zy\"&gt;桂朝阳&lt;/div&gt; &lt;div class=\"sun\"&gt;大太阳&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取类名为zy的标签 var zy = window.document.getElementsByClassName(\"zy\")[0]; // alert(zy.className); // 方式一(自己添加)给类名为zy的div添加样式 // zy.style.border = \"1px solid #ccc\"; // zy.style.fontSize = \"20px\"; // 方式二(调用已经写好的) zy.className = \"sun\"; &lt;/script&gt; &lt;/body&gt; 事件简单学习 功能： 某些组件被执行了某些操作后，触发某些代码的执行。 比如，造句： xxx被xxx,我就xxx。 我方水晶被摧毁后，我就责备对友。 敌方水晶被摧毁后，我就夸奖自己。 如何绑定事件 直接在html标签上，指定事件的属性(操作)，属性值就是 js 代码 事件：onclick — 单击事件 通过 js 获取元素对象，指定事件属性，设置一个函数 小案例： &lt;body&gt; &lt;img id=\"light\" src=\"img/off.gif\" onclick=\"fun();\"&gt; &lt;img id=\"light2\" src=\"img/off.gif\"&gt; &lt;script&gt; function fun(){ alert('我被点了'); alert('我又被点了'); } function fun2(){ alert('咋老点我？'); } //1.获取light2对象 var light2 = document.getElementById(\"light2\"); //2.绑定事件 light2.onclick = fun2; &lt;/script&gt; &lt;/body&gt; 功能些组件被执行了某些操作后，触发某些代码的执行 事件监听机制 概念: 某些组件被执行了某些操作后，触发某些代码的执行。 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了 事件源：组件。如： 按钮 文本输入框… 监听器：代码。 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。 常见的事件 点击事件： onclick：单击事件 ondblclick：双击事件 焦点事件 onfocus:元素获得焦点 onblur：失去焦点 一般用于表单验证 加载事件： onload：一张页面或一幅图像完成加载。 鼠标事件： onmousedown： 鼠标按钮被按下。 定义方法时，定义一个形参，接受event对象。 event对象的button属性可以获取鼠标按钮键被点击了。 onmouseup ：鼠标按键被松开。onmousemove ：鼠标被移动。onmouseover ：鼠标移到某元素之上。onmouseout ：鼠标从某元素移开。 键盘事件： onkeydown ：某个键盘按键被按下。 onkeyup ：某个键盘按键被松开。 onmouseout：某个键盘按键被按下并松开。 选择和改变 onchange ：域的内容被改变。 onselect ：文本被选中。 表单事件： onsubmit ：确认按钮被点击。 可以阻止表单的提交 方法返回false则表单被阻止提交。 onreset ：重置按钮被点击。 Demo:电灯开关&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;电灯开关&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=\"light\" src=\"img/off.gif\"&gt; &lt;script&gt; /* 分析： 1.获取图片对象 2.绑定单击事件 3.每次点击切换图片 * 规则： * 如果灯是开的 on,切换图片为 off * 如果灯是关的 off,切换图片为 on * 使用标记flag来完成 */ //1.获取图片对象 var light = document.getElementById(\"light\"); var flag = false;//代表灯是灭的。 off图片 //2.绑定单击事件 light.onclick = function(){ if(flag){//判断如果灯是开的，则灭掉 light.src = \"img/off.gif\"; flag = false; }else{ //如果灯是灭的，则打开 light.src = \"img/on.gif\"; flag = true; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 标记&gt;&gt;&gt;学习BOM和DOM时用的是CSDN博主「White Camel」的笔记，原文链接：https://blog.csdn.net/m0_37989980/article/details/103669620 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"}]},{"title":"歌《人命之河》","slug":"歌《人命之河》","date":"2020-02-17T14:49:52.000Z","updated":"2020-03-02T12:35:48.212Z","comments":true,"path":"2020/02/17/歌《人命之河》/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/17/%E6%AD%8C%E3%80%8A%E4%BA%BA%E5%91%BD%E4%B9%8B%E6%B2%B3%E3%80%8B/","excerpt":"","text":"记录昨天，2020-2-17，周日。 中午，老爸做了新菜，名叫“凉拌猪肉”（老爸自己起的名字），味道还不错 老弟“放假”（在家网上教学六天，周日放假hhh），下午我们去到外公外婆那。 外公外婆2人+二姨一家4人+我们一家3人=9人。 老爸又露了一手，一桌的饭菜，。结果留给我收尾，我也吃不完，实则太多了，嗝~~（太撑了hh） 看见外公的身体比之前还虚弱，很累的样子。保佑阿公身体健康🙆 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"[转]Git很慢怎么办","slug":"转-Git-很慢怎么办","date":"2020-02-17T11:35:47.000Z","updated":"2020-04-23T11:40:36.821Z","comments":true,"path":"2020/02/17/转-Git-很慢怎么办/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/17/%E8%BD%AC-Git-%E5%BE%88%E6%85%A2%E6%80%8E%E4%B9%88%E5%8A%9E/","excerpt":"","text":"it’s fucking slow, guess why当你想要解决一个问题的时候，最好先学会尽可能准确地描述你的问题，像「Git 很慢怎么办」之类的问题就是反面教材，这就像说「我的国家不行了」一样，这种模棱两可、似是而非的问题对出题人和答题人都是一种困扰，出题人把握不了自己的问题，便始终不会自查，答题人无法知晓出题人真正的问题，也只能一顿瞎猜。 如果你假以思考，结合实际情况，比如你操作的命令，是 git clone 还是 git checkout? 这样就能很快推断出真正的问题，即「Git clone 很慢怎么办」，如果更进一步，你想到你正在 clone 的是一个国外的地址，比如 github.com，你会想到这也许是网络问题。 当你做出更多的判断而不是用一个模糊的问题来让别人替你判断的时候，你的问题也就迎刃而解了。 现在这个模糊的问题变成了解决 Git 同步国外项目的网络问题了，这种情况你应该很熟悉，可以使用「代理」来解决。而 Git 支持两种网络传输协议，即 HTTP 和 SSH 协议，于是你只需要在 Google 搜索 Git 如何配置 HTTP 代理和 SSH 代理 就行了，当然也可以继续阅读，参考我用的配置。 配置 HTTP 代理如果你 git clone 时用的是 http 开头的地址，那就得配置 http 代理: git config --global http.proxy http://127.0.0.1:1087 # 或者 Socks5 代理 git config --global http.proxy socks5://127.0.0.1:1086 配置 SSH 代理如果你 git clone 时用的是 ssh 开头的地址，那就得配置 SSH 代理。 对 macOS 用户，你可以使用 connect，这是一个让 SSH 支持 SOCKS/HTTPS 代理的工具，这里我们用 homebrew 来安装: brew install connect 然后编辑你的 ~/.ssh/config 文件，加入以下代码: Host * User git ProxyCommand connect -S 127.0.0.1:1086 %h %p 这样 SSH 连接时就会使用位于 127.0.0.1:1086 的代理。 原文链接：https://egoist.moe/2019/08/15/git-is-slow/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://melodyjerry.github.io/blog/tags/Git/"}]},{"title":"制作一个简单的HTML登录页面","slug":"制作一个简单的HTML登录页面","date":"2020-02-17T10:20:00.000Z","updated":"2020-04-23T11:40:36.800Z","comments":true,"path":"2020/02/17/制作一个简单的HTML登录页面/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/17/%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84HTML%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/","excerpt":"需求制作一个HTML登录页面，包含邮箱，登录密码，立即注册，忘记密码等","text":"需求制作一个HTML登录页面，包含邮箱，登录密码，立即注册，忘记密码等 HTML部分&lt;div class=\"dowebok\"&gt; &lt;div class=\"dowebok\"&gt; &lt;div class=\"logo\"&gt;&lt;/div&gt; &lt;div class=\"form-item\"&gt; &lt;input id=\"username\" type=\"text\" autocomplete=\"off\" placeholder=\"邮箱\"&gt; &lt;/div&gt; &lt;div class=\"form-item\"&gt; &lt;input id=\"password\" type=\"password\" autocomplete=\"off\" placeholder=\"登录密码\"&gt; &lt;/div&gt; &lt;div class=\"form-item\"&gt;&lt;button id=\"submit\"&gt;登 录&lt;/button&gt;&lt;/div&gt; &lt;div class=\"reg-bar\"&gt; &lt;a class=\"reg\" href=\"javascript:\"&gt;立即注册&lt;/a&gt; &lt;a class=\"forget\" href=\"javascript:\"&gt;忘记密码&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; CSS部分* { margin: 0; padding: 0; } html { height: 100%; } body { height: 100%; background: #fff url(img/backgroud.png) 50% 50% no-repeat; background-size: cover;} .dowebok { position: absolute; left: 50%; top: 50%; width: 430px; height: 550px; margin: -300px 0 0 -215px; border: 1px solid #fff; border-radius: 20px; overflow: hidden;} .logo { width: 104px; height: 104px; margin: 50px auto 80px; background: url(img/login.png) 0 0 no-repeat; } .form-item { position: relative; width: 360px; margin: 0 auto; padding-bottom: 30px;} .form-item input { width: 288px; height: 48px; padding-left: 70px; border: 1px solid #fff; border-radius: 25px; font-size: 18px; color: #fff; background-color: transparent; outline: none;} .form-item button { width: 360px; height: 50px; border: 0; border-radius: 25px; font-size: 18px; color: #1f6f4a; outline: none; cursor: pointer; background-color: #fff; } #username { background: url(img/emil.png) 20px 14px no-repeat; } #password { background: url(img/password.png) 23px 11px no-repeat; } .tip { display: none; position: absolute; left: 20px; top: 52px; font-size: 14px; color: #f50; } .reg-bar { width: 360px; margin: 20px auto 0; font-size: 14px; overflow: hidden;} .reg-bar a { color: #fff; text-decoration: none; } .reg-bar a:hover { text-decoration: underline; } .reg-bar .reg { float: left; } .reg-bar .forget { float: right; } .dowebok ::-webkit-input-placeholder { font-size: 18px; line-height: 1.4; color: #fff;} .dowebok :-moz-placeholder { font-size: 18px; line-height: 1.4; color: #fff;} .dowebok ::-moz-placeholder { font-size: 18px; line-height: 1.4; color: #fff;} .dowebok :-ms-input-placeholder { font-size: 18px; line-height: 1.4; color: #fff;} @media screen and (max-width: 500px) { * { box-sizing: border-box; } .dowebok { position: static; width: auto; height: auto; margin: 0 30px; border: 0; border-radius: 0; } .logo { margin: 50px auto; } .form-item { width: auto; } .form-item input, .form-item button, .reg-bar { width: 100%; } } 效果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"CSS","slug":"CSS","permalink":"https://melodyjerry.github.io/blog/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"}]},{"title":"CSS：页面美化和布局控制","slug":"CSS页面美化和布局控制","date":"2020-02-17T08:20:00.000Z","updated":"2020-04-23T11:40:36.724Z","comments":true,"path":"2020/02/17/CSS页面美化和布局控制/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/17/CSS%E9%A1%B5%E9%9D%A2%E7%BE%8E%E5%8C%96%E5%92%8C%E5%B8%83%E5%B1%80%E6%8E%A7%E5%88%B6/","excerpt":"概念Cascading Style Sheets :层叠样式表 层叠：多个样式可以作用在同一个html的元素上，同时生效 好处 功能强大 将内容展示和样式控制分离 降低耦合度。解耦 让分工协作更容易 提高开发效率","text":"概念Cascading Style Sheets :层叠样式表 层叠：多个样式可以作用在同一个html的元素上，同时生效 好处 功能强大 将内容展示和样式控制分离 降低耦合度。解耦 让分工协作更容易 提高开发效率 使用方式CSS与html结合方式 1.内联样式（作用域最小） 在标签内使用style属性指定css代码 如：&lt;div style=\"color:red;\"&gt;hello css&lt;/div&gt; 2.内部样式 在head标签内，定义style标签，style标签的标签体内容就是css代码 如：&lt;style&gt; div{ color:blue; } &lt;/style&gt; &lt;div&gt;hello css&lt;/div&gt; 3.外部样式（作用域最大） 定义css资源文件。 在head标签内，定义link标签，引入外部的资源文件 如： &lt;!--a.css文件--&gt; div{ color:green; } &lt;!--html文件--&gt; &lt;link rel=\"stylesheet\" href=\"css/a.css\"&gt; &lt;div&gt;hello css&lt;/div&gt; &lt;div&gt;hello css&lt;/div&gt; 特别注意 1,2,3种方式 css作用范围越来越大 第1方式不常用，后期常用第2,3种 第3种格式可以写为：&lt;style&gt; @import \"css/a.css\"; &lt;/style&gt; 语法格式 格式：选择器 { 属性名1:属性值1; 属性名2:属性值2; ... } 选择器:筛选具有相似特征的元素 注意：每一对属性需要使用；隔开，最后一对属性可以不加； 选择器筛选具有相似特征的元素 分类选择器分两种： 基础选择器 扩展选择器 基础选择器id选择器选择具体的id属性值的元素.建议在一个html页面中id值唯一 语法：#id属性值{ 属性名1:属性值1; 属性名2:属性值2; ... } 元素选择器选择具有相同标签名称的元素 语法：标签名称{ 属性名1:属性值1; 属性名2:属性值2; ... } 注意：id选择器优先级高于元素选择器 类选择器选择具有相同的class属性值的元素。 语法：.class属性值{ 属性名1:属性值1; 属性名2:属性值2; ... } 注意：类选择器选择器优先级高于元素选择器 扩展选择器选择所有元素 语法： * { 属性名1:属性值1; 属性名2:属性值2; ... } 并集选择器选择多个元素 语法：选择器1, 选择器2 { 属性名1:属性值1; 属性名2:属性值2; ... } 子选择器筛选 选择器1下 的 选择器2 元素 语法： 选择器1 选择器2{ 属性名1:属性值1; 属性名2:属性值2; ... } 区别于 子选择器： 多个选择器之间的分隔符，一个是逗号，一个是空格。 父选择器筛选 选择器2 的 父元素选择器1 语法： 选择器1 &gt; 选择器2{ 属性名1:属性值1; 属性名2:属性值2; ... } 属性选择器选择元素名称，属性名=属性值的元素 语法： 元素名称 [属性名 = \"属性值\"] { 属性名1:属性值1; 属性名2:属性值2; ... } 伪类选择器选择一些元素具有的状态 语法： 元素: 状态{ 属性名1:属性值1; 属性名2:属性值2; ... } 比如： a:link{ color:red; } a:hover{ color: yellow; } a:visited{ color: blue; } a:active{ color: brown; } &lt;a&gt;的状态：link：初始化的状态visited：被访问过的状态active：正在访问状态hover：鼠标悬浮状态 属性属性有字体、文本、背景、边框、尺寸…… 字体、文本 font-size：字体大小 color：文本颜色 text-align：对其方式 line-height：行高 背景 background：设置背景 边框 border：设置边框，符合属性 尺寸 width：宽度 height：高度 盒子模型：控制布局 margin：外边距 padding：内边距 默认情况下内边距会影响整个盒子的大小 box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 float：浮动 left right 实践案例这里有 70个CSS实例 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"CSS","slug":"CSS","permalink":"https://melodyjerry.github.io/blog/tags/CSS/"}]},{"title":"MySQL中的约束","slug":"MySQL中的约束","date":"2020-02-16T09:24:41.000Z","updated":"2020-04-23T11:40:36.770Z","comments":true,"path":"2020/02/16/MySQL中的约束/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/16/MySQL%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F/","excerpt":"什么是约束 约束：constraintMySQL中的约束，实则是对数据表中数据的限制条件 约束的作用 约束保证数据的完整性和一致性 比如：设计数据表时，要求username字段不允许重复，这时候就需要在CREATE数据表时加入相应的约束。再比如注册时候必须填写邮箱、性别等。 约束的分类按约束定义的位置可分 列级约束 表级约束 按约束的作用可分 主键 约束 PRIMARY KEY 外键 约束 FOREIGN KEY 非空 约束 NOT NULL 唯一 约束 UNIQUE KEY 默认 约束 DEFAULT","text":"什么是约束 约束：constraintMySQL中的约束，实则是对数据表中数据的限制条件 约束的作用 约束保证数据的完整性和一致性 比如：设计数据表时，要求username字段不允许重复，这时候就需要在CREATE数据表时加入相应的约束。再比如注册时候必须填写邮箱、性别等。 约束的分类按约束定义的位置可分 列级约束 表级约束 按约束的作用可分 主键 约束 PRIMARY KEY 外键 约束 FOREIGN KEY 非空 约束 NOT NULL 唯一 约束 UNIQUE KEY 默认 约束 DEFAULT 列级约束、表级约束区别 列级约束：只能应用于一列上。 表级约束：可以应用于一列上，也可以应用在一个表中的多个列上。 即：如果你创建的约束涉及到该表的多个属性列，则必须创建的是表级约束（必须定义在表级上）；否则既可以定义在列级上也可以定义在表级上此时只是SQL语句格式不同而已。 列级约束：包含在列定义中，直接跟在该列的其它定义之后 ，用空格分隔；不必指定列名。 表级约束：与列定义相互独立，不包含在列定义中；与定义用‘，’分隔；必须指出要约束的列的名称。 注：因为在创建列级约束时，只需将创建列约束的语句添加到该字段（列）的定义子句后面；而在创建表级约束时，需要将创建表级约束的语句添加到各个字段（列）定义语句的后面，因为并不是每个定义的字段都要创建约束，所以必须指明需要创建的约束的列名。 举例说明Create Table project( 项目编号 INT CONSTRAINT pk_pno PRIMARY kEY， 项目名称 CHAR(20)， 项目负责人 CHAR(20)， CONSTRAINT un_pname_pm UNIQUE(项目名称，项目负责人) ); 分析：“项目编号”字段设置为主键，主键约束名为pk_pno，此主键约束为列主键约束。“项目名称”和“项目负责人”的组合字段设置唯一性约束，此约束为表级约束） 具体说明一：既可以创建列级约束又可以创建表级约束的： 1、主键约束（primary key constraint）： （1）定义列约束：CONSTRAINT &lt;约束名&gt; PRIMARY KEY （2）定义表约束：[CONSTRAINT &lt;约束名&gt;] PRIMARY KEY( &lt;列名&gt; [{&lt;列名&gt;}]) 2、唯一性约束（unique key constraint）： （1）定义列约束：[CONSTRAINT &lt;约束名&gt;] UNIQUE [KEY] （2）定义表约束：CONSTRAINT &lt;约束名&gt; UNIQUE [KEY] ( &lt;列名&gt; [{&lt;列名&gt;}]) 3、外键约束（foreign key constraint）： 定义 列级约束：[CONSTRAINT &lt;约束名&gt;] FOREIGN KEY REFERENCES &lt;外表名&gt; 定义表级约束：[CONSTRAINT &lt;约束名&gt;] FOREIGN KEY REFERENCES &lt;外表名&gt;( &lt;列名&gt; [{&lt;列名&gt;}]) 二：只能创建列级约束的： 1，缺省约束（default constraint）： [CONSTRAINT &lt;约束名&gt;] DEFAULT 约束条件 2，NULL 约束： [CONSTRAINT &lt;约束名&gt;] [NULL | NOT NULL] 主键约束 PRIMARY KEY“主键（PRIMARY KEY）”的完整称呼是“主键约束”。MySQL 主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。 涉及术语 主键约束 主键字段 主键值 三种术语的关系： 表中的某个字段添加主键约束后，该字段为主键字段，主键字段中出现的每一个数据都称为主键值 特点 保证数据的实体完整性 要求 一张表应该有主键字段，如果没有，表示该表无效 主键值：是当前行数据的唯一标识、是当前行数据的身份证号 即使表中两行记录相关数据相同，但由于主键值不同，所以也认为是两行不同的记录 按主键约束的字段数量分类 在MySQL的一个表中只有唯一的一个主键，不能有多列主键，但可以有复合主键。一个表中可以：单列做主键、多列做主键（复合主键）。 单一主键：给一个字段添加主键约束 复合主键：给多个字段联合添加一个主键约束(只能用表级定义) 单一主键（列级定义）mysql&gt; create table t_user( -&gt; id int(10) primary key, -&gt; name varchar(32) -&gt; ); Query OK, 0 rows affected (0.07 sec) 单一主键（表级定义）mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; constraint t_user_id_pk primary key(id) -&gt; ); Query OK, 0 rows affected (0.01 sec) 复合主键（表级定义） 一定要在表级定义。 mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; email varchar(128) unique, -&gt; primary key(id,name) -&gt; ); Query OK, 0 rows affected (0.05 sec) 配合AUTO_INCREMENT 在MySQL数据库提供了一个自增的数字，专门用来自动生成主键值，主键值不用用户维护，自动生成，自增数从1开始，以1递增(auto_increment) mysql&gt; create table t_user( -&gt; id int(10) primary key auto_increment, -&gt; name varchar(32) not null -&gt; ); Query OK, 0 rows affected (0.03 sec) /*插入两行记录，id主键值会自动增加*/ mysql&gt; insert into t_user(name) values('jay'); Query OK, 1 row affected (0.04 sec) mysql&gt; insert into t_user(name) values('man'); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from t_user; +----+------+ | id | name | +----+------+ | 1 | jay | | 2 | man | +----+------+ 2 rows in set (0.00 sec) 外键约束 FOREIGN KEY外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。 外键的主要作用是保持数据的一致性、完整性。例如，部门表 tb_dept 的主键是 id，在员工表 tb_emp5 中有一个键 deptId 与这个 id 关联。 主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表。 从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表。 快速理解之前创建表的时候都是在一张表中添加记录，比如如下表： 公司有3个部门，但是有1个亿的员工，那意味着部门这个字段需要重复存储，部门名字越长，越浪费。这个时候，解决方法：我们完全可以定义一个部门表，然后让员工信息表关联该表，如何关联，即foreign key。 我们可以将上表改为如下结构： 涉及到的术语 外键约束 外键字段 外键值 三种术语的关系： 某个字段添加外键约束之后，该字段称为外键字段，外键字段中每个数据都是外键值 特点 保持数据的一致性 完整性 实现一对一或者一对多关系 这也是为什么称为MySQL关系型数据库的原因 要求 ★父表（子表所参照的表）和子表（具有外键列的表）必须使用使用相同的存储引擎，而且禁止使用临时表。 ★外键对应的是参照完整性，一个表的外键可以为NULL，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。 ★定义外键时，创建先创建父表。定义外键后，插入先插入父表数据，同理，删除先删除子表数据。 数据表的存储引擎只能为InnoDB。（编辑数据库的默认存储引擎，修改完需要重启MySQL服务） 外键列（加FOREIGN KEY关键词的一列）和参照列（外键列参照的一列）必须具有相似的数据类型,如果是数字数据类型，则数字长度或者是否有符号位必须相同；如果为字符数据类型长度可以不同。 ★外键列和参照列（主键在创建的同时，会自动创建索引seq_in_index）必须创建索引。如果外键列不存在索引的话，MySQL将自动创建。 与主键的区别 一张表可以有多个外键，但是主键最多只有一个。 按外键约束的字段数量分类 单一外键：给一个字段添加外键约束 复合外键：给多个字段联合添加一个外键约束 表复合外键（表级定义）FOREIGN KEY(classno) REFERENCES t_class(cno); 非空约束用NOT NULL约束的字段不能为NULL值，必须给定具体的数据。 注意的是 NULL，表示空，并不是字符串中的空。两者需要区分开。 实例mysql&gt; CREATE TABLE t12(id INT NOT NULL); #设置字段id不为空 Query OK, 0 rows affected (0.03 sec) mysql&gt; DESC t12; +-------+---------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+---------+------+-----+---------+-------+ | id | int(11) | NO | | NULL | | +-------+---------+------+-----+---------+-------+ row in set (0.01 sec) 验证 mysql&gt; INSERT INTO t12 VALUES(); #不能插入空 ERROR 1364 (HY000): Field 'id' doesn't have a default value 唯一约束UNIQUE约束的字段，具有唯一性，不可重复，但可以为NULL。 列级约束mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; email varchar(128) unique -&gt; ); Query OK, 0 rows affected (0.03 sec) 表级约束mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; email varchar(128）， -&gt; unique(email) -&gt; ); 如果插入相同email会报错 mysql&gt; insert into t_user(id,name,email) values(1,'xlj','932834897@qq.com'); Query OK, 1 row affected (0.00 sec) mysql&gt; insert into t_user(id,name,email) values(2,'jay','932834897@qq.com'); ERROR 1062 (23000): Duplicate entry '932834897@qq.com' for key 'email' 扩展：联合唯一约束# 创建services表 mysql&gt; create table services( id int, ip char(15), port int, unique(id), unique(ip,port) ); Query OK, 0 rows affected (0.05 sec) mysql&gt; desc services; +-------+----------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+----------+------+-----+---------+-------+ | id | int(11) | YES | UNI | NULL | | | ip | char(15) | YES | MUL | NULL | | | port | int(11) | YES | | NULL | | +-------+----------+------+-----+---------+-------+ rows in set (0.01 sec) #联合唯一，只要两列记录，有一列不同，既符合联合唯一的约束 mysql&gt; insert into services values (1,'192,168,11,23',80), (2,'192,168,11,23',81), (3,'192,168,11,25',80); Query OK, 3 rows affected (0.01 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql&gt; select * from services; +------+---------------+------+ | id | ip | port | +------+---------------+------+ | 1 | 192,168,11,23 | 80 | | 2 | 192,168,11,23 | 81 | | 3 | 192,168,11,25 | 80 | +------+---------------+------+ rows in set (0.00 sec) mysql&gt; insert into services values (4,'192,168,11,23',80); ERROR 1062 (23000): Duplicate entry '192,168,11,23-80' for key 'ip' 更多可参考 mysql 给表添加唯一约束、联合唯一约束，指定唯一约束的名字 默认约束为某一字段提供默认值。 创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值 实例create table tb1( id int not null, sex char defalut 'b' ); 验证 mysql&gt; insert into tb1(id) values(1); #给t11表插一个空的值 Query OK, 1 row affected (0.00 sec) #查询结果如下 mysql&gt; select * from t11; +------+------+ | id | sex | +------+------+ | 1 | b | +------+------+ row in set (0.00 sec) 主要文献：[部分概念来自C语言中文网] http://c.biancheng.net/view/2440.html[大部分案例的代码块来自CSDN] https://blog.csdn.net/w_linux/article/details/79655073 注：案例中的SQL语句并非作者写的，存在规范问题，但不影响阅读。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[转]MySQL数据类型：UNSIGNED注意事项","slug":"转-MySQL数据类型：UNSIGNED注意事项","date":"2020-02-16T07:58:09.000Z","updated":"2020-04-23T11:40:36.822Z","comments":true,"path":"2020/02/16/转-MySQL数据类型：UNSIGNED注意事项/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/16/%E8%BD%AC-MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9AUNSIGNED%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"原文链接：https://www.cnblogs.com/blankqdb/archive/2012/11/03/blank_qdb.html","text":"原文链接：https://www.cnblogs.com/blankqdb/archive/2012/11/03/blank_qdb.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"HTML：基础网页开发语言","slug":"HTML基础网页开发语言","date":"2020-02-16T06:43:00.000Z","updated":"2020-04-23T11:40:36.735Z","comments":true,"path":"2020/02/16/HTML基础网页开发语言/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/16/HTML%E5%9F%BA%E7%A1%80%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/","excerpt":"概念HTML是最基础的网页开发语言 Hyper Text Markup Language 超文本标记语言 超文本 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本 标记语言 由标签构成的语言。 &lt;标签名称&gt; ,如 &lt;html&gt;，&lt;xml&gt; 标记语言不是编程语言 快速入门语法 html文档后缀名: .html 或者 .htm 标签分为 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt; 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt; 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 html的标签不区分大小写，但是建议使用小写html的标签 代码示例&lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color='red'&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color='green'&gt;Hello World&lt;/font&gt; &lt;/body&gt; &lt;/html&gt;","text":"概念HTML是最基础的网页开发语言 Hyper Text Markup Language 超文本标记语言 超文本 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本 标记语言 由标签构成的语言。 &lt;标签名称&gt; ,如 &lt;html&gt;，&lt;xml&gt; 标记语言不是编程语言 快速入门语法 html文档后缀名: .html 或者 .htm 标签分为 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt; 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt; 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 html的标签不区分大小写，但是建议使用小写html的标签 代码示例&lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color='red'&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color='green'&gt;Hello World&lt;/font&gt; &lt;/body&gt; &lt;/html&gt; 标签学习文件标签 构成html最基本的标签 html html文档的根标签 head 头标签。用于指定html文档的一些属性。引入外部的资源 title 标题标签。 body 体标签 html5中定义该文档是html文档 文本标签 和文本有关的标签 &lt;!-- --&gt;：注释 &lt;h1&gt;~&lt;h6&gt;：标题标签 h1~h6:字体大小逐渐递减 &lt;p&gt;：段落标签 &lt;br&gt;：换行标签 &lt;hr&gt;：展示一条水平线 属性： color：颜色 width：宽度 size：高度 align：对其方式 center：居中 left：左对齐 right：右对齐 &lt;b&gt;：字体加粗 &lt;i&gt;：字体斜体 &lt;center&gt;:文本居中 &lt;font&gt;:字体标签 属性： color：颜色 size：大小 face：字体 属性定义color 英文单词： red,green,blue rgb(值1，值2，值3)： 值的范围：0~255 如 rgb(0,0,255) #值1值2值3： 值的范围：00~FF之间。如： #FF00FF width 数值： width=’20’ ,数值的单位，默认是 px(像素) 数值% width=’20%’,占比相对于父元素的比例 图片标签&lt;img&gt;：展示图片 属性src：指定图片的位置 相对路径：以.开头的路径 ./:代表当前目录, 如 ./image/1.jpg ../:代表上一级目录 代码&lt;!--展示一张图片 img--&gt; &lt;img src=\"image/jingxuan_2.jpg\" align=\"right\" alt=\"古镇\" width=\"500\" height=\"500\"/&gt; &lt;img src=\"./image/jiangwai_1.jpg\"&gt; &lt;img src=\"../image/jiangwai_1.jpg\"&gt; 列表标签有序列表最外层用&lt;ol&gt;内层&lt;li&gt;：列表项 注意 默认为 数字1 开始排序。 可使用 type 属性，规定排序方式为“1/A/a/Ⅰ/ⅰ”。建议使用CSS样式。 也可以用 start 属性，规定起始位置。但是 HTML5 不赞成使用。建议使用CSS样式。 无序列表最外层用&lt;ul&gt;内层&lt;li&gt;：列表项 注意 默认列表项符号为 实心圆点· 。 可使用 type 属性，规定符号为“disc/square/circle” 。但是HTML5不支持。建议使用CSS样式。 链接标签&lt;a&gt;:定义一个超链接 属性 href：指定访问资源的URL(统一资源定位符) target：指定打开资源的方式 _self:默认值，在当前页面打开 _blank：在空白页面打开 代码&lt;!-- 文本 --&gt; &lt;a href=\"http://www.itcast.cn\"&gt;点我&lt;/a&gt; &lt;a href=\"http://www.itcast.cn\" target=\"_self\"&gt;点我&lt;/a&gt; &lt;a href=\"http://www.itcast.cn\" target=\"_blank\"&gt;点我&lt;/a&gt; &lt;!-- 图片 --&gt; &lt;a href=\"http://www.itcast.cn\"&gt;&lt;img src=\"image/jiangwai_1.jpg\"&gt;&lt;/a&gt; div&lt;div&gt;:每一个div占满一整行。块级标签 属性align left right center justify 不赞成使用。请使用样式取而代之。 代码示例&lt;div class=\"news\"&gt; &lt;h2&gt;News headline 1&lt;/h2&gt; &lt;p&gt;some text. some text. some text...&lt;/p&gt; ... &lt;/div&gt; 注意/提示 是一个块级元素，也就是说，浏览器通常会在 div 元素前后放置一个换行符。 如果用 id 或 class 来标记 &lt;div&gt;，那么该标签的作用会变得更加有效。 提示：请使用 元素来组合块级元素，这样就可以使用样式对它们进行格式化。 全局属性 标签支持 HTML 中的[全局属性](https://www.w3school.com.cn/tags/html_ref_standardattributes.asp)。 事件属性 标签支持 HTML 中的[事件属性](https://www.w3school.com.cn/tags/html_ref_eventattributes.asp)。 span&lt;span&gt;:文本信息在一行展示，行内标签 内联标签 代码示例&lt;p&gt;&lt;span&gt;some text.&lt;/span&gt;some other text.&lt;/p&gt; 注意/提示可以为 span 应用 id 或 class 属性，这样既可以增加适当的语义，又便于对 span 应用样式。 可以对同一个 元素应用 class 或 id 属性，但是更常见的情况是只应用其中一种。这两者的主要差异是，class 用于元素组（类似的元素，或者可以理解为某一类元素），而 id 用于标识单独的唯一的元素。 提示：事实上，您也许已经注意到了，W3School 站点上有一些文本的样式与其他文本是不同的。比如“提示”使用了粗体的橘红色。尽管实现这种效果的方法非常多，但是我们的做法是：使用“提示”使用 span 元素，然后对这个 span 元素的父元素，即 p 元素应用 class，这样就可以对这个类的子元素 span 应用相应的样式了。 HTML: &lt;p class=\"tip\"&gt;&lt;span&gt;提示：&lt;/span&gt;... ... ...&lt;/p&gt; CSS: p.tip span { font-weight:bold; color:#ff9955; } 全局属性 标签支持 HTML 中的全局属性。 事件属性 标签支持 HTML 中的事件属性。 语义化标签html5中为了提高程序的可读性，提供了一些标签。 &lt;header&gt;：页眉 &lt;footer&gt;：页脚 表格标签 &lt;table&gt;：定义表格 width：宽度 border：边框 cellpadding：定义内容和单元格的距离 cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、 bgcolor：背景色 align：对齐方式 &lt;tr&gt;：定义行 bgcolor：背景色 align：对齐方式 &lt;td&gt;：定义单元格 colspan：合并列 rowspan：合并行 &lt;th&gt;：定义表头单元格 &lt;caption&gt;：表格标题 &lt;thead&gt;：表示表格的头部分 &lt;tbody&gt;：表示表格的体部分 &lt;tfoot&gt;：表示表格的脚部分 表单标签 概念：用于采集用户输入的数据的。用于和服务器进行交互。 &lt;form&gt;：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围 &lt;form&gt;中的属性 action：指定提交数据的URL method:指定提交方式 分类：一共7种，2种比较常用 get： 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。 请求参数大小是有限制的。 不太安全。 post： 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解) 请求参数的大小没有限制。 较为安全。 注意表单项中的数据要想被提交：必须指定其name属性 表单项标签&lt;input&gt;可以通过type属性值，改变元素展示的样式 type属性 text：文本输入框，默认值 placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 password：密码输入框 radio:单选框 注意： 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 checkbox：复选框 注意： 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 file：文件选择框 hidden：隐藏域，用于提交一些信息。 按钮： submit：提交按钮。可以提交表单 button：普通按钮 image：图片提交按钮 src属性指定图片的路径 &lt;label&gt;指定输入项的文字描述信息 注意：label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。 &lt;select&gt;下拉列表select 元素可创建单选或多选菜单。 注意：&lt;select&amp;&gt; 元素中的 &lt;option&gt; 标签用于定义列表中的可用选项。 &lt;textarea&gt;文本域 属性： cols：指定列数，每一行有多少个字符 rows：默认多少行 表单案例&lt;!--定义表单 form--&gt; &lt;form action=\"#\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"username\"&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"username\" id=\"username\" placeholder=\"请输入用户名\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"password\"&gt;密码&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"password\" name=\"password\" id=\"password\" placeholder=\"请输入密码\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"email\"&gt;Email&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"email\" name=\"email\" id=\"email\" placeholder=\"请输入邮箱\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"name\"&gt;姓名&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"name\" id=\"name\" placeholder=\"请输入姓名\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"tel\"&gt;手机号&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"tel\" id=\"tel\" placeholder=\"请输入手机号\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt; &lt;input type=\"radio\" name=\"gender\" value=\"male\"&gt; 男 &lt;input type=\"radio\" name=\"gender\" value=\"female\"&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"birthday\"&gt;出生日期&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"date\" name=\"birthday\" id=\"birthday\" placeholder=\"请输入出生日期\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"checkcode\" &gt;验证码&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"checkcode\" id=\"checkcode\" placeholder=\"请输入验证码\"&gt; &lt;img id=\"img_check\" src=\"img/verify_code.jpg\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\" align=\"center\"&gt;&lt;input type=\"submit\" id=\"btn_sub\" value=\"注册\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"}]},{"title":"JavaWeb 概述","slug":"JavaWeb 概述","date":"2020-02-16T03:17:00.000Z","updated":"2020-04-23T11:40:36.766Z","comments":true,"path":"2020/02/16/JavaWeb 概述/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/16/JavaWeb%20%E6%A6%82%E8%BF%B0/","excerpt":"JavaWeb使用Java语言开发基于互联网的项目 今后主要使用B/S架构 软件架构C/S：Clien/Server 客服端/服务器端在用户本地有一个客户端程序，在远程有一个服务器端。如：QQ，讯雷…… 优点 用户体验好 缺点 开发、安装、部署、维护，麻烦 ★B/S：Browser/Server 浏览器/服务器端只需要一个浏览器，用户通过不同的网站（URL），客户访问不同的服务器端程序 优点： 开发、安装、部署、维护，简单 缺点 如果应用过大，用户的体验可能会受到影响 对硬件要求过高（带宽要高，……）","text":"JavaWeb使用Java语言开发基于互联网的项目 今后主要使用B/S架构 软件架构C/S：Clien/Server 客服端/服务器端在用户本地有一个客户端程序，在远程有一个服务器端。如：QQ，讯雷…… 优点 用户体验好 缺点 开发、安装、部署、维护，麻烦 ★B/S：Browser/Server 浏览器/服务器端只需要一个浏览器，用户通过不同的网站（URL），客户访问不同的服务器端程序 优点： 开发、安装、部署、维护，简单 缺点 如果应用过大，用户的体验可能会受到影响 对硬件要求过高（带宽要高，……） B/S架构详解客户端浏览器通过URL，向服务器端发送请求，请求一些资源，资源就包括“静态资源”和“动态资源”。服务器端就会响应，返回这些资源。 B/S架构是JavaWeb开发中重要的架构 资源分类静态资源使用静态网页开发技术发布的资源 特点 所有用户访问，得到的结果是一样的 如：文本，图片，音频，视频，HTML，CSS，JavaScript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎 静态资源可以直接被浏览器解析 1.HTML，CSS，JavaScript 统称：静态网页开发技术，也称静态网页三剑客2.经过解析引擎解析后，可以在浏览器中浏览图片、文字、超链接等3.不同浏览器的解析引擎不同，最终显示的网页可能不同 HTML用于搭建基础网页，展示页面的内容 CSS用于美化页面，布局页面 JavaScript控制页面的元素，让页面有一些动态的效果 ★动态资源使用动态网页技术发布的资源 动态资源是今后学习JavaWeb的重点之一 特点 所用用户访问，得到的结果可能不一样 如：jsp/servlet，php，asp…… 如果用户请求的是动态资源，那么服务器会执行动态资源转换为静态资源，再发送给用户 学习动态资源前，必须学习静态资源！ 网络通信三要素IP 电子设备(计算机)在网络中的唯一标识 端口 应用程序在计算机中的唯一标识。 值范围：0~65536 传输协议 规定了数据传输的规则 基础协议： tcp：安全协议，三次握手。 速度稍慢。 udp：不安全协议。 速度快。 Web服务器软件服务器 安装了服务器软件的计算机 服务器软件 接收用户的请求，处理请求，做出响应 Web服务器软件 接收用户的请求，处理请求，做出响应。 在Web服务器软件中，可以部署Web项目，让用户通过浏览器来访问这些项目 Web容器 常见的Java相关的Web服务器软件 WebLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 WebSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 三大组件 Servlet：服务器小程序 Filter：过滤器 Listener：监听器 参照 https://www.cnblogs.com/kefir/p/9426754.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Web","slug":"Web","permalink":"https://melodyjerry.github.io/blog/tags/Web/"}]},{"title":"Web 概述","slug":"Web 概述","date":"2020-02-16T03:17:00.000Z","updated":"2020-03-02T12:35:48.183Z","comments":true,"path":"2020/02/16/Web 概述/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/16/Web%20%E6%A6%82%E8%BF%B0/","excerpt":"JavaWeb使用Java语言开发基于互联网的项目 今后主要使用B/S架构 软件架构C/S：Clien/Server 客服端/服务器端在用户本地有一个客户端程序，在远程有一个服务器端。如：QQ，讯雷…… 优点 用户体验好 缺点 开发、安装、部署、维护，麻烦 ★B/S：Browser/Server 浏览器/服务器端只需要一个浏览器，用户通过不同的网站（URL），客户访问不同的服务器端程序 优点： 开发、安装、部署、维护，简单 缺点 如果应用过大，用户的体验可能会受到影响 对硬件要求过高（带宽要高，……）","text":"JavaWeb使用Java语言开发基于互联网的项目 今后主要使用B/S架构 软件架构C/S：Clien/Server 客服端/服务器端在用户本地有一个客户端程序，在远程有一个服务器端。如：QQ，讯雷…… 优点 用户体验好 缺点 开发、安装、部署、维护，麻烦 ★B/S：Browser/Server 浏览器/服务器端只需要一个浏览器，用户通过不同的网站（URL），客户访问不同的服务器端程序 优点： 开发、安装、部署、维护，简单 缺点 如果应用过大，用户的体验可能会受到影响 对硬件要求过高（带宽要高，……） B/S架构详解客户端浏览器通过URL，向服务器端发送请求，请求一些资源，资源就包括“静态资源”和“动态资源”。服务器端就会响应，返回这些资源。 B/S架构是JavaWeb开发中重要的架构 资源分类静态资源使用静态网页开发技术发布的资源 特点 所有用户访问，得到的结果是一样的 如：文本，图片，音频，视频，HTML，CSS，JavaScript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎 静态资源可以直接被浏览器解析 1.HTML，CSS，JavaScript 统称：静态网页开发技术，也称静态网页三剑客2.经过解析引擎解析后，可以在浏览器中浏览图片、文字、超链接等3.不同浏览器的解析引擎不同，最终显示的网页可能不同 HTML用于搭建基础网页，展示页面的内容 CSS用于美化页面，布局页面 JavaScript控制页面的元素，让页面有一些动态的效果 ★动态资源使用动态网页技术发布的资源 动态资源是今后学习JavaWeb的重点之一 特点 所用用户访问，得到的结果可能不一样 如：jsp/servlet，php，asp…… 如果用户请求的是动态资源，那么服务器会执行动态资源转换为静态资源，再发送给用户 学习动态资源前，必须学习静态资源！ 网络通信三要素IP 电子设备(计算机)在网络中的唯一标识 端口 应用程序在计算机中的唯一标识。 值范围：0~65536 传输协议 规定了数据传输的规则 基础协议： tcp：安全协议，三次握手。 速度稍慢。 udp：不安全协议。 速度快。 Web服务器软件服务器 安装了服务器软件的计算机 服务器软件 接收用户的请求，处理请求，做出响应 Web服务器软件 接收用户的请求，处理请求，做出响应。 在Web服务器软件中，可以部署Web项目，让用户通过浏览器来访问这些项目 Web容器 常见的Java相关的Web服务器软件 WebLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 WebSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Web","slug":"Web","permalink":"https://melodyjerry.github.io/blog/tags/Web/"}]},{"title":"MySQL的数据类型","slug":"MySQL的数据类型","date":"2020-02-15T12:42:25.000Z","updated":"2020-02-15T03:21:21.247Z","comments":true,"path":"2020/02/15/MySQL的数据类型/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/15/MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"MySQL的数据类型数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。 如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。 MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持所有标准SQL数值数据类型。 MySQL支持多种类型，大致可以分为三类： 数值 日期/时间 字符(串)类型。 数据类型分类 数值类型（整数类型和小数类型） 整数类型：包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT。 小数类型： 浮点数类型包括 FLOAT 和 DOUBLE。 定点数类型为 DECIMAL。 日期/时间类型 包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。 字符类型（文本字符串和二进制字符串） 字符串类型：包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。 二进制类型：包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。","text":"MySQL的数据类型数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。 如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。 MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持所有标准SQL数值数据类型。 MySQL支持多种类型，大致可以分为三类： 数值 日期/时间 字符(串)类型。 数据类型分类 数值类型（整数类型和小数类型） 整数类型：包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT。 小数类型： 浮点数类型包括 FLOAT 和 DOUBLE。 定点数类型为 DECIMAL。 日期/时间类型 包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。 字符类型（文本字符串和二进制字符串） 字符串类型：包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。 二进制类型：包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 数值类型MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值(整数)数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值(小数)数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 整数类型 整数类型又称数值型数据，数值型数据类型主要用来存储数字。 MySQL提供了多种数值型数据类型，不同的数据类型提供不同的取值范围，可以存储的值范围越大，所需的存储空间也会越大。 MySQL 主要提供的整数类型有 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，其属性字段可以添加 AUTO_INCREMENT 自增约束条件。下表中列出了 MySQL 中的数值类型。 类型名称 说明 存储需求 TINYINT 很小的整数 1个字节 SMALLINT 小的整数 2个宇节 MEDIUMINT 中等大小的整数 3个字节 INT (INTEGHR) 普通大小的整数 4个字节 BIGINT 大整数 8个字节 从上表中可以看到，不同类型的整数存储所需的字节数不相同，占用字节数最小的是 TINYINT 类型，占用字节最大的是 BIGINT 类型，占用的字节越多的类型所能表示的数值范围越大。 根据占用字节数可以求出每一种数据类型的取值范围。例如，TINYINT 需要 1 个字节（8bit）来存储，那么 TINYINT 无符号数的最大值为 28-1，即 255；TINYINT 有符号数的最大值为 27-1，即 127。其他类型的整数的取值范围计算方法相同，如下表所示。 类型名称 有符号值 无符号值 字节数 TINYINT -128〜127(-2^7 ~ 2^7-1) 0 〜255(0 ~ 2^8-1) 1 SMALLINT -32768〜32767(-2^15 ~ 2^15-1) 0〜65535(0 ~ 2^16-1) 2 MEDIUMINT -8388608〜8388607(-2^23 ~ 2^23-1) 0〜16777215(0 ~ 2^24-1) 3 INT (INTEGER) -2147483648〜2147483647(-2^31 ~ 2^31-1) 0〜4294967295(0 ~ 2^32-1) 4 BIGINT -9223372036854775808〜9223372036854775807(-2^63 ~ 2^63-1) 0〜18446744073709551615(0 ~ 2^64-1) 8 提示：显示宽度和数据类型的取值范围是无关的。显示宽度只是指明 MySQL 最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充。如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，year 字段插入 19999，当使用 SELECT 查询该列值的时候，MySQL 显示的将是完整的带有 5 位数字的 19999，而不是 4 位数字的值。 其他整型数据类型也可以在定义表结构时指定所需的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。 不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。 小数类型MySQL 中使用浮点数和定点数来表示小数。 浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL。 浮点类型和定点类型都可以用(M, D)来表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。 浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2），分别表示显示宽度和小数位数。M 和 D 在 FLOAT 和DOUBLE 中是可选的，FLOAT 和 DOUBLE 类型将被保存为硬件所支持的最大精度。DECIMAL 的默认 D 值为 0、M 值为 10。 下表中列出了 MySQL 中的小数类型和存储需求。 类型名称 说明 存储范围 存储需求 FLOAT 单精度浮点数，精确到大约7位小数位 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 DECIMAL 类型不同于 FLOAT 和 DOUBLE。DOUBLE 实际上是以字符串的形式存放的，DECIMAL 可能的最大取值范围与 DOUBLE 相同，但是有效的取值范围由 M 和 D 决定。如果改变 M 而固定 D，则取值范围将随 M 的变大而变大。 从上表中可以看到，DECIMAL 的存储空间并不是固定的，而由精度值 M 决定，占用 M+2 个字节。 FLOAT 类型的取值范围如下： 有符号的取值范围：-3.402823466E+38～-1.175494351E-38。 无符号的取值范围：0 和 -1.175494351E-38～-3.402823466E+38。 DOUBLE 类型的取值范围如下： 有符号的取值范围：-1.7976931348623157E+308～-2.2250738585072014E-308。 无符号的取值范围：0 和 -2.2250738585072014E-308～-1.7976931348623157E+308。 提示：不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。 FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。 浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。 最后再强调一下：在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。 日期/时间类型MySQL 中有多处表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。 每个时间类型有一个有效值范围和一个”零”值。当指定不合法的MySQL不能表示的值时，系统将“零”值插入数据库中。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP（时间戳） YYYY-MM-DD HH:MM:SS 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 4 个字节 YEAR 类型YEAR 类型是一个单字节类型，用于表示年，在存储时只需要 1 个字节。可以使用各种格式指定 YEAR，如下所示： 以 4 位字符串或者 4 位数字格式表示的 YEAR，范围为 ‘1901’～’2155’。输入格式为 ‘YYYY’ 或者 YYYY，例如，输入 ‘2010’ 或 2010，插入数据库的值均为 2010。 以 2 位字符串格式表示的 YEAR，范围为 ‘00’ 到 ‘99’。’00’～’69’ 和 ‘70’～’99’ 范围的值分别被转换为 2000～2069 和 1970～1999 范围的 YEAR 值。’0’ 与 ‘00’ 的作用相同。插入超过取值范围的值将被转换为 2000。 以 2 位数字表示的 YEAR，范围为 1～99。1～99 和 70～99 范围的值分别被转换为 2001～2069 和 1970～1999 范围的 YEAR 值。注意，在这里 0 值将被转换为 0000，而不是 2000。 提示：两位整数范围与两位字符串范围稍有不同。例如，插入 3000 年，读者可能会使用数字格式的 0 表示 YEAR，实际上，插入数据库的值为 0000，而不是所希望的 3000。只有使用字符串格式的 ‘0’ 或 ‘00’，才可以被正确解释为 3000，非法 YEAR值将被转换为 0000。 TIME 类型TIME 类型用于只需要时间信息的值，在存储时需要 3 个字节。格式为 HH:MM:SS。HH 表示小时，MM 表示分钟，SS 表示秒。 TIME 类型的取值范围为 -838：59：59～838：59：59，小时部分如此大的原因是 TIME 类型不仅可以用于表示一天的时间（必须小于 24 小时），还可能是某个事件过去的时间或两个事件之间的时间间隔（可大于 24 小时，或者甚至为负）。 可以使用各种格式指定 TIME 值，如下所示。 ‘D HH：MM：SS’ 格式的字符串。还可以使用这些“非严格”的语法：’HH：MM：SS’、’HH：MM’、’D HH’ 或 ‘SS’。这里的 D 表示日，可以取 0～34 之间的值。在插入数据库时，D 被转换为小时保存，格式为 “D*24+HH”。 ‘HHMMSS’ 格式、没有间隔符的字符串或者 HHMMSS 格式的数值，假定是有意义的时间。例如，’101112’ 被理解为’10：11：12’，但是 ‘106112’ 是不合法的（它有一个没有意义的分钟部分），在存储时将变为 00：00：00。 提示：为 TIME 列分配简写值时应注意：如果没有冒号，MySQL 解释值时，假定最右边的两位表示秒。（MySQL 解释 TIME 值为过去的时间而不是当前的时间）。例如，读者可能认为 ‘1112’ 和 1112 表示 11：12：00（即 11 点过 12 分钟），但MySQL 将它们解释为 00：11：12（即 11 分 12 秒）。同样 ‘12’ 和 12 被解释为00：00：12。相反，TIME 值中如果使用冒号则肯定被看作当天的时间，也就是说，’11：12’ 表示 11：12：00，而不是 00：11：12。 DATE 类型DATE 类型用于仅需要日期值时，没有时间部分，在存储时需要 3 个字节。日期格式为 ‘YYYY-MM-DD’，其中 YYYY 表示年，MM 表示月，DD 表示日。 在给 DATE 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATE 的日期格式即可。如下所示： 以 ‘YYYY-MM-DD’ 或者 ‘YYYYMMDD’ 字符中格式表示的日期，取值范围为 ‘1000-01-01’～’9999-12-3’。例如，输入 ‘2015-12-31’ 或者 ‘20151231’，插入数据库的日期为2015-12-31。 以 ‘YY-MM-DD’ 或者 ‘YYMMDD’ 字符串格式表示日期，在这里YY表示两位的年值。MySQL 解释两位年值的规则：’00～69’ 范围的年值转换为 ‘20002069’，’7099’ 范围的年值转换为 ‘1970～1999’。例如，输入 ‘15-12-31’，插入数据库的日期为 2015-12-31；输入 ‘991231’，插入数据库的日期为 1999-12-31。 以 YYMMDD 数字格式表示的日期，与前面相似，00~69 范围的年值转换为 2000～2069，80～99 范围的年值转换为 1980～1999。例如，输入 151231，插入数据库的日期为 2015-12-31，输入 991231，插入数据库的日期为 1999-12-31。 使用 CURRENT_DATE 或者 NOW()，插入当前系统日期。 提示：MySQL 允许“不严格”语法：任何标点符号都可以用作日期部分之间的间隔符。例如，’98-11-31’、’98.11.31’、’98/11/31’和‘98@11@31’ 是等价的，这些值也可以正确地插入数据库。 DATETIME 类型DATETIME 类型用于需要同时包含日期和时间信息的值，在存储时需要 8 个字节。日期格式为 ‘YYYY-MM-DD HH：MM：SS’，其中 YYYY 表示年，MM 表示月，DD 表示日，HH 表示小时，MM 表示分钟，SS 表示秒。 在给 DATETIME 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATETIME 的日期格式即可，如下所示。 以 ‘YYYY-MM-DD HH：MM：SS’ 或者 ‘YYYYMMDDHHMMSS’ 字符串格式表示的日期，取值范围为 ‘1000-01-01 00：00：00’～’9999-12-3 23：59：59’。例如，输入 ‘2014-12-31 05：05：05’ 或者 ‘20141231050505’，插入数据库的 DATETIME 值都为 2014-12-31 05：05：05。 以 ‘YY-MM-DD HH：MM：SS’ 或者 ‘YYMMDDHHMMSS’ 字符串格式表示的日期，在这里 YY 表示两位的年值。与前面相同，’00～79’ 范围的年值转换为 ‘2000～2079’，’80～99’ 范围的年值转换为 ‘1980～1999’。例如，输入 ‘14-12-31 05：05：05’，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。 以 YYYYMMDDHHMMSS 或者 YYMMDDHHMMSS 数字格式表示的日期和时间。例如，输入 20141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 140505050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。 提示：MySQL 允许“不严格”语法：任何标点符号都可用作日期部分或时间部分之间的间隔符。例如，’98-12-31 11：30：45’、’98.12.31 11+30+35’、’98/12/31 113045’ 和 ‘98@12@31 11^30^45’ 是等价的，这些值都可以正确地插入数据库。 TIMESTAMP 类型TIMESTAMP 的显示格式与 DATETIME 相同，显示宽度固定在 19 个字符，日期格式为 YYYY-MM-DD HH：MM：SS，在存储时需要 4 个字节。但是 TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，为 ‘1970-01-01 00：00：01’UTC～’2038-01-19 03：14：07’UTC。在插入数据时，要保证在合法的取值范围内。 提示：协调世界时（英：Coordinated Universal Time，法：Temps Universel Coordonné）又称为世界统一时间、世界标准时间、国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。 TIMESTAMP 与 DATETIME 除了存储字节和支持的范围不同外，还有一个最大的区别是： DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关； 而 TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。 提示：如果为一个 DATETIME 或 TIMESTAMP 对象分配一个 DATE 值，结果值的时间部分被设置为 ‘00：00：00’，因此 DATE 值未包含时间信息。如果为一个 DATE 对象分配一个 DATETIME 或 TIMESTAMP 值，结果值的时间部分被删除，因此DATE 值未包含时间信息。 字符类型MySQL 支持两类字符型数据：字符串类型和二进制类型 包括CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小/存储需求 说明/用途 CHAR 0-255字节 定长字符串 CHAR(M) M 字节，1&lt;=M&lt;=255 固定长度非二进制字符串 VARCHAR 0-65535 字节 变长字符串 1VARCHAR(M) L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255 变长非二进制字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 ENUM（枚举值） 1或2个字节，取决于枚举值的数目 (最大值为65535) 枚举类型，只能有一个枚举字符串值。一次从中只选择一个。 SET（集合） 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） 一个设置，字符串对象可以有零个或 多个SET成员。在集合中做任意的排列组合（任取一个或几个数据） CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 字符串类型 又称“文本字符串类型”。 字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据。字符串可以区分或者不区分大小写的串比较，还可以进行正则表达式的匹配查找。 MySQL 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。 下表中列出了 MySQL 中的字符串数据类型，括号中的M表示可以为其指定长度。 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1&lt;=M&lt;=255 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255 TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L&lt;2^8 TEXT 小的非二进制字符串 L+2字节，在此，L&lt;2^16 MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L&lt;2^24 LONGTEXT 大的非二进制字符串 L+4字节，在此，L&lt;2^32 ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） VARCHAR 和 TEXT 类型是变长类型，其存储需求取决于列值的实际长度（在前面的表格中用 L 表示），而不是取决于类型的最大可能尺寸。 例如，一个 VARCHAR(10) 列能保存一个最大长度为 10 个字符的字符串，实际的存储需要字符串的长度 L 加上一个字节以记录字符串的长度。对于字符 “abcd”，L 是 4，而存储要求 5 个字节。 CHAR 和 VARCHAR 类型CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255 个字符。 例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当检索到 CHAR 值时，尾部的空格将被删除。 VARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0～65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。 例如，VARCHAR(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。VARCHAR 在值保存和检索时尾部的空格仍保留。 【实例】下面将不同的字符串保存到 CHAR(4) 和 VARCHAR(4) 列，说明 CHAR 和 VARCHAR 之间的差别，如下表所示。 插入值 CHAR(4) 存储需求 VARCHAR(4) 存储需求 ‘ ‘ ‘ ‘ 4字节 ‘’ 1字节 ‘ab’ ‘ab ‘ 4字节 ‘ab’ 3字节 ‘abc’ ‘abc ‘ 4字节 ‘abc’ 4字节 ‘abcd’ ‘abcd’ 4字节 ‘abcd’ 5字节 ‘abcdef’ ‘abcd’ 4字节 ‘abcd’ 5字节 对比结果可以看到，CHAR(4) 定义了固定长度为 4 的列，无论存入的数据长度为多少，所占用的空间均为 4 个字节。VARCHAR(4) 定义的列所占的字节数为实际长度加 1。 TEXT 类型TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。 TEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。 TINYTEXT 表示长度为 255（28-1）字符的 TEXT 列。 TEXT 表示长度为 65535（216-1）字符的 TEXT 列。 MEDIUMTEXT 表示长度为 16777215（224-1）字符的 TEXT 列。 LONGTEXT 表示长度为 4294967295 或 4GB（232-1）字符的 TEXT 列。 ENUM 类型ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下： &lt;字段名&gt; ENUM( '值1', '值1', …, '值n' ) 字段名指将要定义的字段，值 n 指枚举列表中第 n 个值。 ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。 ENUM 值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号，枚举最多可以有 65535 个元素。 例如，定义 ENUM 类型的列（’first’，’second’，’third’），该列可以取的值和每个值的索引如下表所示。 值 索引 NULL NULL ‘’ 0 ’first 1 second 2 third 3 ENUM 值依照列索引顺序排列，并且空字符串排在非空字符串前，NULL 值排在其他所有枚举值前。 提示：ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。 SET 类型SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下： SET( '值1', '值2', …, '值n' ) 与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。 但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。 提示：如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。 二进制类型 二进制字符串类型有时候也直接被称为“二进制类型”。 MySQL 中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 下表中列出了 MySQL 中的二进制数据类型，括号中的M表示可以为其指定长度。 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)/8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L&lt;2^8 BLOB (M) 小 BLOB L+2 字节，在此，L&lt;2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L&lt;2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L&lt;2^32 BIT 类型位字段类型。M 表示每个值的位数，范围为 1～64。如果 M 被省略，默认值为 1。如果为 BIT(M) 列分配的值的长度小于 M 位，在值的左边用 0 填充。例如，为 BIT(6) 列分配一个值 b’101’，其效果与分配 b’000101’ 相同。 BIT 数据类型用来保存位字段值，例如以二进制的形式保存数据 13，13 的二进制形式为 1101，在这里需要位数至少为 4 位的 BIT 类型，即可以定义列类型为 BIT(4)。大于二进制 1111 的数据是不能插入 BIT(4) 类型的字段中的。 提示：默认情况下，MySQL 不可以插入超出该列允许范围的值，因而插入数据时要确保插入的值在指定的范围内。 BINARY 和 VARBINARY 类型BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字节字符串。使用的语法格式如下： 列名称 BINARY(M) 或者 VARBINARY(M) BINARY 类型的长度是固定的，指定长度后，不足最大长度的，将在它们右边填充 “\\0” 补齐，以达到指定长度。例如，指定列数据类型为 BINARY(3)，当插入 a 时，存储的内容实际为 “\\a0\\0”，当插入 ab 时，实际存储的内容为“ab\\0”，无论存储的内容是否达到指定的长度，存储空间均为指定的值 M。 VARBINARY 类型的长度是可变的，指定好长度之后，长度可以在 0 到最大值之间。例如，指定列数据类型为 VARBINARY(20)，如果插入的值长度只有 10，则实际存储空间为 10 加 1，实际占用的空间为字符串的实际长度加 1。 BLOB 类型BLOB 是一个二进制的对象，用来存储可变数量的数据。BLOB 类型分为 4 种：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB，它们可容纳值的最大长度不同，如下表所示。 数据类型 存储范围 TINYBLOB 最大长度为255 (28-1)字节 BLOB 最大长度为65535 (216-1)字节 MEDIUMBLOB 最大长度为16777215 (224-1)字节 LONGBLOB 最大长度为4294967295或4GB (231-1)字节BLOB 列存储的是二进制字符串（字节字符串），TEXT 列存储的是非进制字符串（字符字符串）。BLOB 列是字符集，并且排序和比较基于列值字节的数值；TEXT 列有一个字符集，并且根据字符集对值进行排序和比较。 以上笔记部分来自 C语言中文网 、百度知道、CSDN。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"hexo d后，网页出现乱码？","slug":"hexo d连后，网页出现乱码？","date":"2020-02-15T05:49:36.000Z","updated":"2020-04-23T11:40:36.781Z","comments":true,"path":"2020/02/15/hexo d连后，网页出现乱码？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/15/hexo%20d%E8%BF%9E%E5%90%8E%EF%BC%8C%E7%BD%91%E9%A1%B5%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81%EF%BC%9F/","excerpt":"问题如平时一样hexo d部署我的博客，但是当我去浏览时候，竟发现乱码。 解决重新hexo三连即可。","text":"问题如平时一样hexo d部署我的博客，但是当我去浏览时候，竟发现乱码。 解决重新hexo三连即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"![rejected]master->master(fetch first)问题的解决方案","slug":"rejected-master-master-fetch-first-问题的解决方案","date":"2020-02-14T11:08:32.000Z","updated":"2020-04-23T11:40:36.793Z","comments":true,"path":"2020/02/14/rejected-master-master-fetch-first-问题的解决方案/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/rejected-master-master-fetch-first-%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"今天在做git push -u origin master时出现了如下错误： ! [rejected] master -&gt; master (fetch first) 分析原因，基本上可以确定是因为github上的远程库与本地库版本不一致（我对github上的文件做了编辑操作，且未更新到本地，当然也可能还有其他原因…），通过一番研究，找到了两种解决方案： 温柔型方案： 通过git pull先将本地库更新到与远程库一致的版本，但要注意本地库后来做的修改可能被覆盖，最好使用git fetch(不会自动合并)，查看更新情况再有选择合并，或者先将本地库修改过的文件备份，git pull后再重新修改； 再运行git push即可成功。 暴力型方案：git提供了一种强制上传的方式：git push -f，它会忽略版本不一致等问题，强制将本地库上传的远程库，但是一定要谨慎使用，因为-f会用本地库覆盖掉远程库，如果远程库上有重要更新，或者有其他同伴做的修改，也都会被覆盖，所以一定要在确定无严重后果的前提下使用此操作。","text":"今天在做git push -u origin master时出现了如下错误： ! [rejected] master -&gt; master (fetch first) 分析原因，基本上可以确定是因为github上的远程库与本地库版本不一致（我对github上的文件做了编辑操作，且未更新到本地，当然也可能还有其他原因…），通过一番研究，找到了两种解决方案： 温柔型方案： 通过git pull先将本地库更新到与远程库一致的版本，但要注意本地库后来做的修改可能被覆盖，最好使用git fetch(不会自动合并)，查看更新情况再有选择合并，或者先将本地库修改过的文件备份，git pull后再重新修改； 再运行git push即可成功。 暴力型方案：git提供了一种强制上传的方式：git push -f，它会忽略版本不一致等问题，强制将本地库上传的远程库，但是一定要谨慎使用，因为-f会用本地库覆盖掉远程库，如果远程库上有重要更新，或者有其他同伴做的修改，也都会被覆盖，所以一定要在确定无严重后果的前提下使用此操作。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"}]},{"title":"[转]使用Cmder替换cmd,让开发更高效","slug":"转-使用Cmder替换cmd-让开发更高效","date":"2020-02-14T08:40:25.000Z","updated":"2020-04-23T11:40:36.823Z","comments":true,"path":"2020/02/14/转-使用Cmder替换cmd-让开发更高效/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/%E8%BD%AC-%E4%BD%BF%E7%94%A8Cmder%E6%9B%BF%E6%8D%A2cmd-%E8%AE%A9%E5%BC%80%E5%8F%91%E6%9B%B4%E9%AB%98%E6%95%88/","excerpt":"","text":"第一篇文章https://segmentfault.com/a/1190000021029858?utm_source=tag-newest 以下为第二篇文章的内容 一、为什么要更换为cmder在做项目时，有些时候我想复制控制台上面的代码时，cmd有的时候复制粘贴很麻烦，Cmder则不会，并且Cmder可以分屏多开窗口，可以设置窗口颜色,字体大小，并且很多快捷键和谷歌浏览器操作类似,等等很多功能。 二、官网下载地址: http://cmder.net/ 关于下载进入官网以后，有mini版和完整版，建议完整版，完整版功能更齐全，还可以使用git，下载好解压文件包以后就可以使用。 Cmder界面展示启动Cmder界面如下，当然我设置了背景色，透明度，字体样式，隐藏标签栏栏，增加底部的状态栏，以及分屏功能。 Cmder界面展示 三、关于cmder的一些配置1. 配置环境变量:在系统属性里面配置环境变量，将Cmder.exe所在文件路径添加至Path里 2. 配置右键快捷启动:以管理员身份打开cmd，执行以下命令即可，完了以后在任意地方点击右键即可使用cmder // 设置任意地方鼠标右键启动Cmder Cmder.exe /REGISTER ALL 鼠标右键启动Cmder 3. 界面效果的设置首先使用windows+alt+p进入界面设置 背景色设置 字体设置 背景透明度 隐藏标签栏 显示底部状态栏 将Cmder默认的命令提示符\"λ\"改为“$”， 在cmder\\vendor中的clink.lua内做如下修改”λ”替换成”$” 四、关于Cmder的一些常用快捷键Tab 自动路径补全 Ctrl+T 建立新页签 Ctrl+W 关闭页签 Ctrl+Tab 切换页签 Alt+F4 关闭所有页签 Alt+Shift+1 开启cmd.exe Alt+Shift+2 开启powershell.exe Alt+Shift+3 开启powershell.exe (系统管理员权限) Ctrl+1 快速切换到第1个页签 Ctrl+n 快速切换到第n个页签( n值无上限) Alt + enter 切换到全屏状态 Ctr+r 历史命令搜索 Tab 自动路径补全 Ctrl+T 建立新页签 Ctrl+W 关闭页签 Ctrl+Tab 切换页签 Alt+F4 关闭所有页签 Alt+Shift+1 开启cmd.exe Alt+Shift+2 开启powershell.exe Alt+Shift+3 开启powershell.exe (系统管理员权限) Ctrl+1 快速切换到第1个页签 Ctrl+n 快速切换到第n个页签( n值无上限) Alt + enter 切换到全屏状态 Ctr+r 历史命令搜索 Win+Alt+P 开启工具选项视窗 五、关于中文乱码问题：将下面的4行命令添加到cmder/config/aliases文件末尾,如果还是不行参考前面字体设置，将前面提到的字体设置里面的Monospace的复选框不选中。还有就是养成良好的编码习惯文件命名最好不要有中文。 l=ls --show-control-chars la=ls -aF --show-control-chars ll=ls -alF --show-control-chars 作者：_123hhh链接：https://www.jianshu.com/p/5b7c985240a7来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"删除磁盘管理中的OEM分区","slug":"删除磁盘管理中的OEM分区","date":"2020-02-14T08:13:08.000Z","updated":"2020-04-23T11:40:36.797Z","comments":true,"path":"2020/02/14/删除磁盘管理中的OEM分区/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/%E5%88%A0%E9%99%A4%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84OEM%E5%88%86%E5%8C%BA/","excerpt":"用windows自带的工具-DISKPART来实现，而且不会破坏其他分区的数据，具体操作如下： 首先打开CMD，输入 diskpart.exe 回车 提示转入DISKPART 然后输入 rescan 回车 （扫描硬盘） 接着输入 list disk 回车 （硬盘列表，可以看到连接到该主机的硬盘列表） 选择一个磁盘： select disk 磁盘号 回车 显示磁盘中的分区： list partition 回车 选择一个分区： select partition 分区号 回车 删除分区： delete partition override 回车 基本就能删除OEM分区了。","text":"用windows自带的工具-DISKPART来实现，而且不会破坏其他分区的数据，具体操作如下： 首先打开CMD，输入 diskpart.exe 回车 提示转入DISKPART 然后输入 rescan 回车 （扫描硬盘） 接着输入 list disk 回车 （硬盘列表，可以看到连接到该主机的硬盘列表） 选择一个磁盘： select disk 磁盘号 回车 显示磁盘中的分区： list partition 回车 选择一个分区： select partition 分区号 回车 删除分区： delete partition override 回车 基本就能删除OEM分区了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"系统","slug":"系统","permalink":"https://melodyjerry.github.io/blog/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"[工具]ScreenToGif:一款小而实用的屏幕录制生成gif工具","slug":"工具-ScreenToGif-一款小而实用的屏幕录制生成gif工具","date":"2020-02-14T07:27:31.000Z","updated":"2020-04-23T11:40:36.812Z","comments":true,"path":"2020/02/14/工具-ScreenToGif-一款小而实用的屏幕录制生成gif工具/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/%E5%B7%A5%E5%85%B7-ScreenToGif-%E4%B8%80%E6%AC%BE%E5%B0%8F%E8%80%8C%E5%AE%9E%E7%94%A8%E7%9A%84%E5%B1%8F%E5%B9%95%E5%BD%95%E5%88%B6%E7%94%9F%E6%88%90gif%E5%B7%A5%E5%85%B7/","excerpt":"因为写博客或工作等原因，经常需要录制屏幕并制作gif图。ScreenToGif使用了小半年了，给我的感觉就是“小而实用”，大小仅2M多（压缩后才几百K），但却包含了录制及常用的gif处理功能。 ScreenToGif：仅从名字就可以了解到它是一款屏幕转gif图的软件。而事实上，它不仅可以录制屏幕，同时也包含了摄像头录制，白板书写录制等功能，并且在录制后，可以对录制内容进行增删、修改、压缩等处理。 ScreenToGif是一款免安装软件，下载并解压缩后，双击exe文件就可以运行。ScreenToGif还支持打开多次，以上Gif就是用一个ScreenToGif来录制另一个ScreenToGif界面。 上图是ScreenToGif编辑器主页，ScreenToGif分两大功能，录制和编辑，从上图可以看到其编辑功能还是蛮强大的，至少在常规gif制作的功能都包含了： 在编辑中有很多对帧的操作如:增加删除、循环、反转，特别是移除重复帧功能，能很好的减小gif占用内存大小； 而在图片选项中则包含了水印、微动、模糊、字幕、自由文本、自由绘制等功能； ScreenToGif还支持简单的过渡动画； 统计功能则提供了总帧数、总时长、帧大小、延时、帧分辨率等数据的统计； 如下图：在编辑结束后，我们可以根据需求选择适合的类型及编码进行保存； 到目前为止，ScreenToGif已适配20多种语言，并提供上传服务。 ScreenToGif是一个开源项目ScreenToGif Github，本文下方也提供目前最新的2.14.1版本免安装exe程序。 版本2.14.1下载地址 作者：ThinkinLiu_IT老五链接：https://www.jianshu.com/p/17121d0587fc来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","text":"因为写博客或工作等原因，经常需要录制屏幕并制作gif图。ScreenToGif使用了小半年了，给我的感觉就是“小而实用”，大小仅2M多（压缩后才几百K），但却包含了录制及常用的gif处理功能。 ScreenToGif：仅从名字就可以了解到它是一款屏幕转gif图的软件。而事实上，它不仅可以录制屏幕，同时也包含了摄像头录制，白板书写录制等功能，并且在录制后，可以对录制内容进行增删、修改、压缩等处理。 ScreenToGif是一款免安装软件，下载并解压缩后，双击exe文件就可以运行。ScreenToGif还支持打开多次，以上Gif就是用一个ScreenToGif来录制另一个ScreenToGif界面。 上图是ScreenToGif编辑器主页，ScreenToGif分两大功能，录制和编辑，从上图可以看到其编辑功能还是蛮强大的，至少在常规gif制作的功能都包含了： 在编辑中有很多对帧的操作如:增加删除、循环、反转，特别是移除重复帧功能，能很好的减小gif占用内存大小； 而在图片选项中则包含了水印、微动、模糊、字幕、自由文本、自由绘制等功能； ScreenToGif还支持简单的过渡动画； 统计功能则提供了总帧数、总时长、帧大小、延时、帧分辨率等数据的统计； 如下图：在编辑结束后，我们可以根据需求选择适合的类型及编码进行保存； 到目前为止，ScreenToGif已适配20多种语言，并提供上传服务。 ScreenToGif是一个开源项目ScreenToGif Github，本文下方也提供目前最新的2.14.1版本免安装exe程序。 版本2.14.1下载地址 作者：ThinkinLiu_IT老五链接：https://www.jianshu.com/p/17121d0587fc来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"[随笔]相信自己","slug":"随笔-相信自己","date":"2020-02-14T06:55:11.000Z","updated":"2020-03-02T12:35:48.222Z","comments":true,"path":"2020/02/14/随笔-相信自己/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/%E9%9A%8F%E7%AC%94-%E7%9B%B8%E4%BF%A1%E8%87%AA%E5%B7%B1/","excerpt":"下午，起兴想整理笔记本里的数据时，发现了一些有趣的东西，拿出一部分来记作随笔。 相信自己在个人文件夹中，发现一个名为“相信自己”的Word文档，点开来，里面就一句话，简简单单的一句“如果有时候怀疑了，觉得不知道自己为什么一开始要做这个选择，或者觉得自己付出太多不值得，那就想想当初自己做这个决定的初心。或许一切就能释然了”。 一起玩耍吧18年，在网上看到一个视频，教用一些简单VB代码来制作的小程序。 只有连续点击确定/是，才能结束程序。 用来表白/坑人，挺不错的hh 猜猜我用来干嘛呢 ( ͡° ͜ʖ ͡°)✧ ~ 演示👇 制作过程很简单，新建一个txt文本，粘贴我写好的代码，保存后修改后缀为.vbs，完事。 代码👇 msgbox \"我们可以一起玩吗？\",vbQuestion,\"在吗？\" msgbox (\"可以吗？\") dim j do while j&lt;1 Select Case msgbox(\"真的真的真的可以吗？\",68,\"请郑重的回答我\") Case 6 j=1 Case 7 msgbox(\"别嘛，我就是要和你一起玩\") end Select loop msgbox(\"我就知道你会同意的，啦啦啦\")","text":"下午，起兴想整理笔记本里的数据时，发现了一些有趣的东西，拿出一部分来记作随笔。 相信自己在个人文件夹中，发现一个名为“相信自己”的Word文档，点开来，里面就一句话，简简单单的一句“如果有时候怀疑了，觉得不知道自己为什么一开始要做这个选择，或者觉得自己付出太多不值得，那就想想当初自己做这个决定的初心。或许一切就能释然了”。 一起玩耍吧18年，在网上看到一个视频，教用一些简单VB代码来制作的小程序。 只有连续点击确定/是，才能结束程序。 用来表白/坑人，挺不错的hh 猜猜我用来干嘛呢 ( ͡° ͜ʖ ͡°)✧ ~ 演示👇 制作过程很简单，新建一个txt文本，粘贴我写好的代码，保存后修改后缀为.vbs，完事。 代码👇 msgbox \"我们可以一起玩吗？\",vbQuestion,\"在吗？\" msgbox (\"可以吗？\") dim j do while j&lt;1 Select Case msgbox(\"真的真的真的可以吗？\",68,\"请郑重的回答我\") Case 6 j=1 Case 7 msgbox(\"别嘛，我就是要和你一起玩\") end Select loop msgbox(\"我就知道你会同意的，啦啦啦\") 💗我爱你们，爸妈！💗看到，我才发现我原来备份了一部分19年七八两月的一些照片。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"IDEA添加jar包的三种方式(小结)","slug":"IDEA 添加jar包的三种方式(小结)","date":"2020-02-13T09:36:53.000Z","updated":"2020-04-23T11:40:36.754Z","comments":true,"path":"2020/02/13/IDEA 添加jar包的三种方式(小结)/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/13/IDEA%20%E6%B7%BB%E5%8A%A0jar%E5%8C%85%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F(%E5%B0%8F%E7%BB%93)/","excerpt":"相关文章： 1、https://www.jb51.net/article/145327.htm 2、https://blog.csdn.net/wangxinyao1997/article/details/87527391 3、https://blog.csdn.net/simple_start/article/details/92422833 4、https://blog.csdn.net/yogima/article/details/81186092?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task","text":"相关文章： 1、https://www.jb51.net/article/145327.htm 2、https://blog.csdn.net/wangxinyao1997/article/details/87527391 3、https://blog.csdn.net/simple_start/article/details/92422833 4、https://blog.csdn.net/yogima/article/details/81186092?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"绚丽彩虹播放器","slug":"绚丽彩虹播放器","date":"2020-02-13T08:16:30.000Z","updated":"2020-04-23T11:40:36.817Z","comments":true,"path":"2020/02/13/绚丽彩虹播放器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/13/%E7%BB%9A%E4%B8%BD%E5%BD%A9%E8%99%B9%E6%92%AD%E6%94%BE%E5%99%A8/","excerpt":"","text":"代码来自绚丽彩虹播放器 &lt;!-- Your XlchPlayerKey --&gt; &lt;script&gt;XlchKey=\"O7NQ6f6YIg\";&lt;/script&gt; &lt;!-- font-awesome 4.2.0 --&gt; &lt;link href=\"https://lib.baomitu.com/font-awesome/4.2.0/css/font-awesome.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt; &lt;!-- JQuery 2.2.4 --&gt; &lt;script src=\"https://lib.baomitu.com/jquery/2.2.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- JQuery-mousewheel 3.1.9 --&gt; &lt;script src=\"https://lib.baomitu.com/jquery-mousewheel/3.1.9/jquery.mousewheel.min.js\"&gt;&lt;/script&gt; &lt;!-- Scrollbar --&gt; &lt;script src=\"https://static.https.badapple.top/BadApplePlayer/js/scrollbar.js\"&gt;&lt;/script&gt; &lt;!-- BadApplePlayer --&gt; &lt;script src=\"https://static.https.badapple.top/BadApplePlayer/Player.js\"&gt;&lt;/script&gt; 教程：https://www.liaofuzhan.com/posts/2636059693.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"动态时钟","slug":"动态时钟","date":"2020-02-13T05:28:19.000Z","updated":"2020-02-13T05:51:42.682Z","comments":true,"path":"2020/02/13/动态时钟/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/13/%E5%8A%A8%E6%80%81%E6%97%B6%E9%92%9F/","excerpt":"效果：","text":"效果： 在相应位置添加如下代码： &lt;center&gt; &lt;div&gt;&lt;canvas id=\"canvas\" style=\"width:20%\" width=\"820\" height=\"250\"&gt;&lt;/canvas&gt;&lt;/div&gt; &lt;script async=\"\"&gt;!function(){function t(t){var r=[];a.fillStyle=\"#1bc3fb\";var h=new Date,u=70,s=30,v=h.getHours(),g=Math.floor(v/10),m=v%10;r.push({num:g}),r.push({num:m}),r.push({num:10});var c=h.getMinutes(),g=Math.floor(c/10),m=c%10;r.push({num:g}),r.push({num:m}),r.push({num:10});var M=h.getSeconds(),g=Math.floor(M/10),m=M%10;r.push({num:g}),r.push({num:m});for(var p=0;p&lt;r.length;p++)r[p].offsetX=u,u=f(u,s,r[p].num,t),p&lt;r.length-1&amp;&amp;10!=r[p].num&amp;&amp;10!=r[p+1].num&amp;&amp;(u+=l);if(0==i.length)i=r;else for(var C=0;C&lt;i.length;C++)i[C].num!=r[C].num&amp;&amp;(n(r[C]),i[C].num=r[C].num);return e(t),o(),h}function n(t){for(var n=t.num,e=m[n],o=0;o&lt;e.length;o++)for(var f=0;f&lt;e[o].length;f++)if(1==e[o][f]){var a={offsetX:t.offsetX+u+2*u*f,offsetY:30+u+2*u*o,color:g[Math.floor(Math.random()*g.length)],g:1.5+Math.random(),vx:4*Math.pow(-1,Math.ceil(10*Math.random()))+Math.random(),vy:-5};v.push(a)}}function e(t){for(var n=0;n&lt;v.length;n++)t.beginPath(),t.fillStyle=v[n].color,t.arc(v[n].offsetX,v[n].offsetY,u,0,2*Math.PI),t.fill()}function o(){for(var t=0,n=0;n&lt;v.length;n++){var e=v[n];e.offsetX+=e.vx,e.offsetY+=e.vy,e.vy+=e.g,e.offsetY&gt;h-u&amp;&amp;(e.offsetY=h-u,e.vy=-e.vy*s),e.offsetX&gt;u&amp;&amp;e.offsetX&lt;r-u&amp;&amp;(v[t]=v[n],t++)}for(;t&lt;v.length;t++)v.pop()}function f(t,n,e,o){for(var f=m[e],a=0;a&lt;f.length;a++)for(var r=0;r&lt;f[a].length;r++)1==f[a][r]&amp;&amp;(o.beginPath(),o.arc(t+u+2*u*r,n+u+2*u*a,u,0,2*Math.PI),o.fill());return o.beginPath(),t+=f[0].length*u*2}var a,r=820,h=250,u=7,l=10,s=.65,v=[];const g=[\"#33B5E5\",\"#0099CC\",\"#AA66CC\",\"#9933CC\",\"#99CC00\",\"#669900\",\"#FFBB33\",\"#FF8800\",\"#FF4444\",\"#CC0000\"];var i=[],m=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]],c=document.getElementById(\"canvas\");c.width=r,c.height=h,a=c.getContext(\"2d\");new Date;setInterval(function(){a.clearRect(0,0,a.canvas.width,a.canvas.height),t(a)},50)}()&lt;/script&gt; &lt;/center&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"[转]Hexo主题使用Valine-Admin管理评论和评论提醒","slug":"转-Hexo主题使用Valine-Admin管理评论和评论提醒","date":"2020-02-12T16:31:06.000Z","updated":"2020-02-12T17:20:04.551Z","comments":true,"path":"2020/02/13/转-Hexo主题使用Valine-Admin管理评论和评论提醒/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/13/%E8%BD%AC-Hexo%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8Valine-Admin%E7%AE%A1%E7%90%86%E8%AF%84%E8%AE%BA%E5%92%8C%E8%AF%84%E8%AE%BA%E6%8F%90%E9%86%92/","excerpt":"原文链接：https://segmentfault.com/a/1190000021474516?utm_source=tag-newest 前言原本今天在写文章，然后没事就去博客看了一下。突然发现有人在文章下面评论。是早上评论的但是我晚上才看到。 我的留言系统使用的是Valine,发现留言并没有提醒，只有回复了才会有提醒。 这不能忍。毕竟好不容易来个朋友竟然没有交流上你说难受不难受😡 然后我就去百度了一下Valine-Admin Valine-Admin 是一个对 Valine 评论系统的拓展应用，可增强 Valine 的邮件通知功能。基于 Leancloud 的云引擎与云函数。可以提供邮件 通知站长 和 @ 通知 的功能，而且还支持自定义邮件通知模板。 发现这个插件很不错我就研究了一下。下面是整合教程。","text":"原文链接：https://segmentfault.com/a/1190000021474516?utm_source=tag-newest 前言原本今天在写文章，然后没事就去博客看了一下。突然发现有人在文章下面评论。是早上评论的但是我晚上才看到。 我的留言系统使用的是Valine,发现留言并没有提醒，只有回复了才会有提醒。 这不能忍。毕竟好不容易来个朋友竟然没有交流上你说难受不难受😡 然后我就去百度了一下Valine-Admin Valine-Admin 是一个对 Valine 评论系统的拓展应用，可增强 Valine 的邮件通知功能。基于 Leancloud 的云引擎与云函数。可以提供邮件 通知站长 和 @ 通知 的功能，而且还支持自定义邮件通知模板。 发现这个插件很不错我就研究了一下。下面是整合教程。 使用首先其他的不错说了，在阅读本篇文章之前你最好已经整合了Valine留言。 由于我已经整合过了所以前面几个步骤的图片来源自@Valine-Admin 首先登陆账号，找到云引擎在点击设置。 复制仓库地址：https://github.com/zhaojun199… 把git仓库地址房子代码库输入框中。 切换到部署标签页，分支使用 master，点击部署。 接下来输入分支为master 部署完成之后就是设置环境变量 环境变量点击设置，找到自定义环境变量点击新增变量 SITE_NAME : 网站名称。 SITE_URL : 网站地址, 最后不要加 / 。 SMTP_USER : SMTP 服务用户名，一般为邮箱地址。 SMTP_PASS : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式 SMTP_SERVICE : 邮件服务提供商，支持 QQ、163、126、Gmail、\"Yahoo\"、...... ，全部支持请参考 : Nodemailer Supported services。 — 如这里没有你使用的邮件提供商，请查看自定义邮件服务器 SENDER_NAME : 寄件人名称。 TO_EMAIL：这个是填收邮件提醒的邮箱地址，若没有这个字段，则将邮件发到SMTP_USER。 TEMPLATE_NAME：设置提醒邮件的主题，目前内置了两款主题，分别为 default 与 rainbow。默认为 default 设置好以上变量之后 点击实例 然后重启项目，注意任何变动都要重启项目 然后看一下效果 还不错 自定义后台点击设置然后点击Web主机域名找到自己的后台地址 然后在存储-数据-_User表中增加账号， 只需要填写 email、password、username 其中邮箱必须设置为你的上面环境变量的邮箱 设置完之后登录就能在你的后台管理评论 解决休眠免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行： 每天必须休眠 6 个小时 30 分钟内没有外部请求，则休眠。 休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。 也就是如果服务器休眠了的话用户第一次评论是提醒不了的。 参考了Valine-Admin官网找到了解决办法。 首先在环境变量ADMIN_URL增加服务器地址，就是你的后台服务器地址 下面是你的服务器地址，可以自定义 同样登录后台 找到定时任务 然后点击创建任务，上面是我创建好的 选择self_wake函数，然后运行时间使用cron表达式 0 0/30 7-23 ? 表示每天6点到11点 每30分钟叫醒服务器一次 这样就完美的解决了服务器休眠的问题 那如果用户不在时间范围内发留言了怎么办？我们也可以创建一个捡漏的定时任务 创建捡漏定时任务 然后运行函数选择resend_mails,同样使用cron表达式 0 0 8 ? 表示每八个小时进行捡漏一次，这样如果有留言遗漏的话就能即使的提醒。 附 crontab 定时器代码：** */20 7-23 * * * curl https://你配置的域名前缀.leanapp.cn 结语有人会说了不久一个破博客吗？都不知道有没有人看干嘛还要这么麻烦。其实并不麻烦，这只是一个态度而已。 欢迎关注我的公众号，也可在公众号进行留言会及时回复 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}],"author":{"name":"乱敲代码","url":"https://segmentfault.com/a/1190000021474516?utm_source=tag-newest"}},{"title":"一些关于halo博客的资源","slug":"一些关于halo博客的资源","date":"2020-02-11T08:23:57.000Z","updated":"2020-04-23T11:40:36.794Z","comments":true,"path":"2020/02/11/一些关于halo博客的资源/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/11/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8Ehalo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%B5%84%E6%BA%90/","excerpt":"https://github.com/halo-dev/halo-app/releases halo教程https://ryanc.cc/tags/halo Docker Compose 部署Halo教程https://ryanc.cc/archives/docker-compose-run-halo halo替换hexohttps://wenthywang.cn/archives/2019070217154001586/ halo替换hexohttps://www.shizuri.net/Z-Turn/halo.html","text":"https://github.com/halo-dev/halo-app/releases halo教程https://ryanc.cc/tags/halo Docker Compose 部署Halo教程https://ryanc.cc/archives/docker-compose-run-halo halo替换hexohttps://wenthywang.cn/archives/2019070217154001586/ halo替换hexohttps://www.shizuri.net/Z-Turn/halo.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"halo","slug":"halo","permalink":"https://melodyjerry.github.io/blog/tags/halo/"}]},{"title":"任正非:唯一有愧的是对不起父母","slug":"任正非-唯一有愧的是对不起父母","date":"2020-02-11T05:58:08.000Z","updated":"2020-02-13T05:16:48.084Z","comments":true,"path":"2020/02/11/任正非-唯一有愧的是对不起父母/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/11/%E4%BB%BB%E6%AD%A3%E9%9D%9E-%E5%94%AF%E4%B8%80%E6%9C%89%E6%84%A7%E7%9A%84%E6%98%AF%E5%AF%B9%E4%B8%8D%E8%B5%B7%E7%88%B6%E6%AF%8D/","excerpt":"前言​ 前几天，弟在做高考语文预测卷时，突然跟我说“老哥，你去看看任正非的文章《我的父亲母亲》，很有深意”。在看完文章后还有一篇作者是柳传志的读后感。对这两篇文章深有感触，所以专门开设并记录在博文里。","text":"前言​ 前几天，弟在做高考语文预测卷时，突然跟我说“老哥，你去看看任正非的文章《我的父亲母亲》，很有深意”。在看完文章后还有一篇作者是柳传志的读后感。对这两篇文章深有感触，所以专门开设并记录在博文里。 《我的父亲母亲》—— 任正非 《我的父亲母亲》 任正非 【一】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;上世纪末最后一天，我总算良心发现，在公务结束之后，买了一张从北京去昆明的机票，去看看妈妈。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;买好机票后，我没有给她打电话，我知道一打电话她一下午都会忙碌，不管多晚到达，都会给我做一些我小时候喜欢吃的东西。直到飞机起飞，我才告诉她，让她不要告诉别人，不要车来接，我自己坐出租车回家，目的就是好好陪陪她。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;前几年我每年也去看看妈妈，但一下飞机就给办事处接走了，说这个客户很重要，要拜见一下，那个客户很重要，要陪他们吃顿饭，忙来忙去，忙到上飞机时回家取行李，与父母匆匆告别。妈妈盼星星、盼月亮，盼唠唠家常，却一次又一次地落空。 【二】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;一个普通的早上，妈妈从菜市场出来，提着两小包菜，被汽车撞成重伤。我身在伊朗，飞机要多次中转才能回来，在巴林转机要待6.5个小时，真是心如煎熬，又遇巴林雷雨，飞机延误两个小时，到曼谷时又晚了10分钟，没有及时赶上回昆明的飞机，直到深夜才赶到昆明。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;回到昆明，就知道妈妈不行了，她的头部全部给撞坏了，当时的心跳、呼吸全是靠药物和机器维持，之所以在电话上不告诉我，是怕我在旅途中出事。我看见妈妈一声不响地安详地躺在病床上，不用操劳、烦心，好像她一生也没有这么休息过。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我真后悔没有在伊朗给妈妈打一个电话。因为以前不管我在国内、国外给她打电话时，她都唠叨：“你又出差了”，“非非你的身体还不如我好呢”，“非非你的皱纹比妈妈还多呢”，“非非你走路还不如我呢，你这么年纪轻轻就这么多病”，“非非，糖尿病参加宴会多了，坏得更快呢，你的心脏又不好”…… &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我想伊朗条件这么差，我一打电话，妈妈又唠叨，反正过不了几天就见面了，就没有打，而这是我一生中最大的憾事。如果我真打了，拖延她一两分钟出门，也许妈妈就躲过了这场灾难。这种悔恨的心情，真是难以形容。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我看了妈妈最后一眼，妈妈溘然去世。 【三】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1995年，我父亲在昆明街头的小摊上买了一瓶塑料包装的软饮料，喝后拉肚子，一直到全身衰竭去世。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;父亲任摩逊，尽职尽责一生，可以说是一个乡村教育家。妈妈程远昭，是一个陪伴父亲在贫困山区与穷孩子厮混了一生的一个普通得不能再普通的园丁。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;父亲穿着土改工作队的棉衣，随解放军剿匪部队一同进入贵州少数民族山区去筹建一所民族中学。一头扎进去就是几十年，他培养的学生不少成为党和国家的高级干部，有些还是中央院校的校级领导，而父亲还是那么位卑言微。 【四】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我与父母相处的青少年时代，印象最深的就是度过三年自然灾害的困难时期。今天想来还历历在目。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我们兄妹七个，加上父母共九人。全靠父母微薄的工资来生活，毫无其他来源。本来生活就十分困难，儿女一天天在长大，衣服一天天在变短，而且都要读书，开支很大，每个学期每人要交2-3元的学费，到交费时，妈妈每次都发愁。我经常看到妈妈月底就到处向人借钱度饥荒，而且常常走了几家都未必借到。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;直到高中毕业我没有穿过衬衣。有同学看到很热的天，我还穿着厚厚的外衣，就让我向妈妈要一件衬衣，我不敢，因为我知道做不到。我上大学时妈妈一次送我两件衬衣，我真想哭，因为，我有衬衣了，弟妹们就会更难了。我家当时是2-3人合用一条被盖，而且破旧的被单下面铺的是稻草。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;上大学我要拿走一条被子，就更困难了，因为那时还实行布票、棉花票管制，最少的一年，每人只发0.5米布票。没有被单，妈妈捡了毕业学生丢弃的几床破被单缝缝补补，洗干净，这条被单就在重庆陪我度过了五年的大学生活。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我们家当时每餐实行严格分饭制，控制所有人欲望的配给制，保证人人都能活下来。如果不是这样，总会有一个、两个弟妹活不到今天。我真正能理解活下去这句话的含义。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;高三快高考时，我有时在家复习功课，实在饿得受不了了，用米糠和菜合一下，烙着吃，被父亲碰上几次，他心疼了。其实那时我家穷得连一个可上锁的柜子都没有，粮食是用瓦缸装着，我也不敢去随便抓一把。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;高考前三个月，妈妈经常在早上塞给我一个小小的玉米饼，要我安心复习功课，我能考上大学，小玉米饼功劳巨大。如果不是这样，也许我就进不了华为这样的公司，社会上多了一名养猪能手，或街边多了一名能工巧匠而已。这个小小的玉米饼，是从父母与弟妹的口中抠出来的，我无以报答他们。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;“记住知识就是力量，别人不学，你要学，不要随大流。”“以后有能力要帮助弟妹。”背负着这种重托，我在当时的环境下，将樊映川的高等数学习题集从头到尾做了两遍，学习了逻辑、哲学。还自学了三门外语，当时已到可以阅读大学课本的程度，终因我不是语言天才，加之在军队服务时用不上，20多年荒废，完全忘光了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我当年穿走父亲的皮鞋，没念及父亲那时是做苦工的，泥里水里，冰冷潮湿，他更需要鞋子。现在回忆起来，感觉自己太自私了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;回顾我自己已走过的历史，唯一有愧的是对不起父母，没条件时没有照顾他们，有条件时也没有照顾他们。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;爸爸，妈妈，千声万声呼唤你们，千声万声唤不回。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;逝者已经逝去，活着的还要前行。 ​ ——2001年2月8日 于深圳 《要想富就要知道为何穷》——柳传志 《要想富就要知道为何穷》 柳传志 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;在手机上读着一篇任正非写的怀念他的父母亲的文章，而脑子里却想起了另一件事。那是2013年9月，我接到了一个邀请函。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;那天我是真的有事，但出于对老任发自内心的敬佩和尊重，我尽力挤开了别的事情，花了一个半小时的车程赶到了会场。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;老任的面子确实大，那天是贵州都匀一中的“校训研讨会”，真请来了不少领导和知名的企业家。他看见我来了显得非常高兴。我也高兴，那是因为在企业工作者里面，我们都是属于少有的“老家伙”序列里的人，相互都比较了解，然而又极少见面，所以紧紧的握手不愿松开。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;原来都匀一中就是任正非的母校，他的父亲在此曾任过三年校长，他毕生从事教育工作，50多年来倾注了全部的心血。在现任学校领导介绍学校的历史，介绍老任的父亲任摩逊先生事迹的时候，我注意盯着任正非，我想这样的内容他应该听过无数遍了，他却依然听得那么专注，那么动情! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;此刻我正在读他写的怀念他的父母的文章，我认真读这篇文章，是因为深深引起了我的共鸣。我和他是同年生人，我们的出生背景有所不同，但是上一辈在政治上受到的磨难和考验几乎是相同的。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;任正非谈到他的父亲在这考验的重压之下，依旧勤勤恳恳拼力地工作，为他自己后来在华为拼命地工作做出了表率，而父辈的榜样在他身上打下了深深的烙印。我的父亲也是我的榜样。给我最深刻的印象是在强大的政治压力下，他能够像以前教导我的那样，用行动做出表率-做一个正直的人。正直，这是一个多么平常的词藻，然而在特殊的考验面前，这个词就超过了千钧的分量。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1966年文化革命爆发的第一个年头，我亲眼看到我的父亲在威逼面前不肯诬陷当年的战友，被开除党籍。当时的气氛紧张惊恐。这深深地印在了我的脑海中，而我的父亲以身教的方式告诉了我如何做人，什么叫正直! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;联想发展到今天的三十年中，经过的风险无其数，尤其在早期还有一定的政策风险，我自诩是个敢担当的人，而在联想结出胜利果实时，我也以为自己是个舍得让利的人，这对联想能发展到今天也许有一定的影响。和任正非一样，我们能以身作则地把企业利益放在个人利益的前面。追根溯源，是我们的父辈给我们打下了如何做人的基础。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当我读到任正非的母亲是因为意外车祸辞世的，我的心一下子揪了起来。我能想象对他那是一种什么样的撕心裂肺! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;任正非讲到他在高三那年(也应该是我高三的那年吧，就是最困难的1961年)，母亲经常早上塞给他一个小小的玉米饼，他说我能考上大学，小玉米饼的功劳巨大，这个小小的玉米饼是从父母与弟妹的口中抠出来的，我无以报答他们。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我相信绝大多数的80后、90后的朋友是读不出玉米饼的感觉的，因为他们不懂什么叫饥饿。61年，我是北京25中的一名高三学生，我们中学生是早上8、9点钟的太阳，所以享受着最高待遇，一个月32斤粮，半斤油，半斤肉。知道什么叫一个月半斤油吗? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;那是在一锅熬白菜煮熟的时候，油瓶口顺着筷子点入几滴油，使锅里漂着油花，一个月下来，这半斤油就用完了。知道什么叫饿吗?那就是耗干净你身上的脂肪，然后再耗你的肌肉。有一天夜里，我饿的实在受不了，想起抽屉里有一盒中药是羚翘解毒丸，我就吃了两颗，几小时后药性发作，抽筋断肠，头痛欲裂。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;经过饥饿的人才知道什么叫从父母弟妹的嘴里面抠出的玉米饼。任正非想念着母亲，我何尝不想念自己的母亲、不想起在那最艰难的岁月里，母亲对我的慈爱。我的父母都已经去世了，我和老任一样也是老大，我会永远记住父母的恩德慈爱。我有兄弟姐妹四人，我们会永远相亲相爱。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我在想，读了老任的文章，是什么让我会拿起笔说了上边这段话，我想说给谁听呢? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;说给老任?让他知道我是他的知音?说给我的亲人、朋友、同学、同事?让我们更加珍惜今天的生活? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;好像是，但也不是。我明白，我最想说给那些年青、年少的，甚至是儿童，让他们长大了听。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我一直告诫自己不要成为一个碎嘴唠叨的老头。而说这些话，我估计孩子们是不爱听的。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;前些天，我看了一部叫“归来”的电影，写的是我亲眼看见过的年代，亲眼看见过的事情，电影演毕，潸然泪下。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;问过几个年青人是否看过这部片子，都说没有。有一个对我说：人总是要向前看么，老说那些老话，凄凄惨惨有什么意思?!他们爱看光鲜亮丽、富有、任性的电影，那是他们的追求。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;他们不爱看“归来”，不爱听我碎嘴唠叨，但我还是忍不住想对他们说，到底为了什么? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;因为我们这个民族就在不久以前还很苦，很凄惨，很窝囊。你要想今后过得富有光鲜亮丽，你就要知道过去为什么穷，为什么苦，为什么受人欺负。你就要懂得历史，你就要从中学到教训，我们已经是为数不多的见过那段历史的尾巴的人了，尽量还原真实的历史是我们的责任。不管你是哪国国籍，但你和你的子孙血管中流的是中国人的血，这是无法改变的事实! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我谈不上是高尚的人，更谈不上是纯粹的人。但我努力在做一个知恩图报的人，做一个懂廉耻、要自强的人。我希望几十年以后，今天年青、年少的人们能凭追求、凭团结、凭实力让中国富强，让自己过上光鲜亮丽富有的生活。 重要文献[1] 题目《任正非：唯一有愧的是对不起父母》，摘自百家号“金融界”， https://baijiahao.baidu.com/s?id=1644249222074823165&amp;wfr=spider&amp;for=pc [2] 原文，转自凤凰网，http://news.ifeng.com/c/7nKjN9F2Uy0 [3] 插图，来自网络 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"文章","slug":"文章","permalink":"https://melodyjerry.github.io/blog/tags/%E6%96%87%E7%AB%A0/"}]},{"title":"解决bash: hexo: command not found","slug":"解决bash-hexo-command-not-found","date":"2020-02-10T13:28:02.000Z","updated":"2020-02-11T10:56:14.938Z","comments":true,"path":"2020/02/10/解决bash-hexo-command-not-found/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/10/%E8%A7%A3%E5%86%B3bash-hexo-command-not-found/","excerpt":"记录一次离奇的车祸现场。 问题今天用hexo新建文章hexo new时git报错： bash: hexo: command not found 解决办法将G:\\blog_gitee\\node_modules\\.bin添加进PATH。 原因可能是因为我今天更新npm了？","text":"记录一次离奇的车祸现场。 问题今天用hexo新建文章hexo new时git报错： bash: hexo: command not found 解决办法将G:\\blog_gitee\\node_modules\\.bin添加进PATH。 原因可能是因为我今天更新npm了？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"[转]CentOS 7镜像下载","slug":"转-CentOS-7镜像下载","date":"2020-02-10T13:26:37.000Z","updated":"2020-02-11T10:56:14.946Z","comments":true,"path":"2020/02/10/转-CentOS-7镜像下载/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/10/%E8%BD%AC-CentOS-7%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD/","excerpt":"官网下载链接：http://isoredirect.centos.org/centos/7/isos/x86_64/ step1: 进入下载页，选择阿里云站点进行下载 Actual Country 国内资源 Nearby Countries 周边国家资源 阿里云站点：http://mirrors.aliyun.com/centos/7/isos/x86_64/ 每个链接都包括了镜像文件的地址、类型及版本号等信息 选择当前国家资源区站点下载，获取资源速度比较快 step1: 进入阿里云站点，选择 CentOS-7-x86_64-DVD-1804.iso下载 各个版本的ISO镜像文件说明： CentOS-7-x86_64-DVD-1708.iso 标准安装版（推荐） CentOS-7-x86_64-Everything-1708.iso 完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像） CentOS-7-x86_64-LiveGNOME-1708.iso GNOME桌面版 CentOS-7-x86_64-LiveKDE-1708.iso KDE桌面版 CentOS-7-x86_64-Minimal-1708.iso 精简版，自带的软件最少 CentOS-7-x86_64-NetInstall-1708.iso 网络安装版（从网络安装或者救援系统） 作者：Ada54链接：https://www.jianshu.com/p/a63f47e096e8来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","text":"官网下载链接：http://isoredirect.centos.org/centos/7/isos/x86_64/ step1: 进入下载页，选择阿里云站点进行下载 Actual Country 国内资源 Nearby Countries 周边国家资源 阿里云站点：http://mirrors.aliyun.com/centos/7/isos/x86_64/ 每个链接都包括了镜像文件的地址、类型及版本号等信息 选择当前国家资源区站点下载，获取资源速度比较快 step1: 进入阿里云站点，选择 CentOS-7-x86_64-DVD-1804.iso下载 各个版本的ISO镜像文件说明： CentOS-7-x86_64-DVD-1708.iso 标准安装版（推荐） CentOS-7-x86_64-Everything-1708.iso 完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像） CentOS-7-x86_64-LiveGNOME-1708.iso GNOME桌面版 CentOS-7-x86_64-LiveKDE-1708.iso KDE桌面版 CentOS-7-x86_64-Minimal-1708.iso 精简版，自带的软件最少 CentOS-7-x86_64-NetInstall-1708.iso 网络安装版（从网络安装或者救援系统） 作者：Ada54链接：https://www.jianshu.com/p/a63f47e096e8来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"镜像","slug":"镜像","permalink":"https://melodyjerry.github.io/blog/tags/%E9%95%9C%E5%83%8F/"}]},{"title":"给Hexo博客添加不蒜子统计","slug":"给Hexo博客添加不蒜子统计","date":"2020-02-10T05:46:31.000Z","updated":"2020-04-23T11:40:36.817Z","comments":true,"path":"2020/02/10/给Hexo博客添加不蒜子统计/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/10/%E7%BB%99Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1/","excerpt":"","text":"引入不蒜子&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 这段代码可以写在footer.ejs里或者header.ejs里或者layout.ejs里 添加站点访问量通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里加上如下标签： &lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次 &lt;/span&gt; 计算访问量的方法有两种： 算法a：pv的方式，单个用户连续点击n篇文章，记录 n次访问量。 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 添加文章访问量文章的访问量显示在文章里面，所以在article.ejs里加上文章访问量的标签： &lt;span id=\"busuanzi_container_page_pv\"&gt; 本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次 &lt;/span&gt; 这个标签里的汉字可以自行修改，还可以给标签写上你想要的样式。 参考： 不蒜子|不如 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"到博客里养鱼","slug":"到博客里养鱼","date":"2020-02-09T11:32:03.000Z","updated":"2020-04-23T11:40:36.801Z","comments":true,"path":"2020/02/09/到博客里养鱼/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E5%88%B0%E5%8D%9A%E5%AE%A2%E9%87%8C%E5%85%BB%E9%B1%BC/","excerpt":"鱼🐟","text":"鱼🐟 &lt;!-- 底部加了小鱼&lt;・)))&gt;&lt;&lt;~ --&gt; &lt;a name=\"top\"&gt;&lt;/a&gt; &lt;div id=\"page_begin_html\"&gt;&lt;marquee hspace=\"20\" vspace=\"20\" width=\"220\" bgcolor=\"White\"&gt;公告：欢迎访问我的博客😘，希望你在这里可以找到你需要的东西！本站内容为个人经验之谈，如有错误，欢迎指正！&lt;/marquee&gt; &lt;script type=\"text/javascript\"&gt;window['__document_write_ajax_callbacks__']['2']();&lt;/script&gt;&lt;script&gt;window['__document_write_ajax_callbacks__']['1']();&lt;/script&gt; &lt;/div&gt; &lt;!--done--&gt; &lt;!--end: home 自定义的最大容器 --&gt; &lt;div id=\"page_end_html\"&gt; &lt;script type=\"text/javascript\" src=\"https://js.users.noscript.cnitblog.com/20537745.js\"&gt;&lt;/script&gt; &lt;!-- 鼠标点击特效 --&gt; &lt;script src=\"https://example.com/cursor-effects.js\"&gt;&lt;/script&gt; &lt;!-- 鼠标点击特效end --&gt; &lt;!-- 页面点击小红心 --&gt; &lt;script&gt;!function(e,t,a){function n(){c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)}function o(){var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(\"div\");a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(\"style\");a.type=\"text/css\";try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(\"head\")[0].appendChild(a)}function s(){return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);&lt;/script&gt; &lt;!-- 底部加了小鱼&lt;・)))&gt;&lt;&lt;~ --&gt; &lt;script src=\"https://common.cnblogs.com/scripts/jquery-2.2.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 底部加了小鱼&lt;・)))&gt;&lt;&lt;~ --&gt; &lt;div id=\"jsi-flying-fish-container\" class=\"container\"&gt;&lt;canvas width=\"1010\" height=\"153\"&gt;&lt;/canvas&gt;&lt;/div&gt; &lt;script src=\"https://blog-static.cnblogs.com/files/elkyo/fish.js\"&gt;&lt;/script&gt; &lt;script src=\"https://common.cnblogs.com/scripts/jquery-2.2.0.min.js\"&gt;&lt;/script&gt; &lt;div id=\"jsi-flying-fish-container\" class=\"container\"&gt;&lt;canvas width=\"1058\" height=\"158\"&gt;&lt;/canvas&gt;&lt;/div&gt; &lt;script&gt; var RENDERER = { POINT_INTERVAL : 5, FISH_COUNT : 3, MAX_INTERVAL_COUNT : 50, INIT_HEIGHT_RATE : 0.5, THRESHOLD : 50, init : function(){ this.setParameters(); this.reconstructMethods(); this.setup(); this.bindEvent(); this.render(); }, setParameters : function(){ this.$window = $(window); this.$container = $('#jsi-flying-fish-container'); this.$canvas = $('&lt;canvas /&gt;'); this.context = this.$canvas.appendTo(this.$container).get(0).getContext('2d'); this.points = []; this.fishes = []; this.watchIds = []; }, createSurfacePoints : function(){ var count = Math.round(this.width / this.POINT_INTERVAL); this.pointInterval = this.width / (count - 1); this.points.push(new SURFACE_POINT(this, 0)); for(var i = 1; i &lt; count; i++){ var point = new SURFACE_POINT(this, i * this.pointInterval), previous = this.points[i - 1]; point.setPreviousPoint(previous); previous.setNextPoint(point); this.points.push(point); } }, reconstructMethods : function(){ this.watchWindowSize = this.watchWindowSize.bind(this); this.jdugeToStopResize = this.jdugeToStopResize.bind(this); this.startEpicenter = this.startEpicenter.bind(this); this.moveEpicenter = this.moveEpicenter.bind(this); this.reverseVertical = this.reverseVertical.bind(this); this.render = this.render.bind(this); }, setup : function(){ this.points.length = 0; this.fishes.length = 0; this.watchIds.length = 0; this.intervalCount = this.MAX_INTERVAL_COUNT; this.width = this.$container.width(); this.height = this.$container.height(); this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500; this.$canvas.attr({width : this.width, height : this.height}); this.reverse = false; this.fishes.push(new FISH(this)); this.createSurfacePoints(); }, watchWindowSize : function(){ this.clearTimer(); this.tmpWidth = this.$window.width(); this.tmpHeight = this.$window.height(); this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL)); }, clearTimer : function(){ while(this.watchIds.length &gt; 0){ clearTimeout(this.watchIds.pop()); } }, jdugeToStopResize : function(){ var width = this.$window.width(), height = this.$window.height(), stopped = (width == this.tmpWidth &amp;&amp; height == this.tmpHeight); this.tmpWidth = width; this.tmpHeight = height; if(stopped){ this.setup(); } }, bindEvent : function(){ this.$window.on('resize', this.watchWindowSize); this.$container.on('mouseenter', this.startEpicenter); this.$container.on('mousemove', this.moveEpicenter); this.$container.on('click', this.reverseVertical); }, getAxis : function(event){ var offset = this.$container.offset(); return { x : event.clientX - offset.left + this.$window.scrollLeft(), y : event.clientY - offset.top + this.$window.scrollTop() }; }, startEpicenter : function(event){ this.axis = this.getAxis(event); }, moveEpicenter : function(event){ var axis = this.getAxis(event); if(!this.axis){ this.axis = axis; } this.generateEpicenter(axis.x, axis.y, axis.y - this.axis.y); this.axis = axis; }, generateEpicenter : function(x, y, velocity){ if(y &lt; this.height / 2 - this.THRESHOLD || y &gt; this.height / 2 + this.THRESHOLD){ return; } var index = Math.round(x / this.pointInterval); if(index &lt; 0 || index &gt;= this.points.length){ return; } this.points[index].interfere(y, velocity); }, reverseVertical : function(){ this.reverse = !this.reverse; for(var i = 0, count = this.fishes.length; i &lt; count; i++){ this.fishes[i].reverseVertical(); } }, controlStatus : function(){ for(var i = 0, count = this.points.length; i &lt; count; i++){ this.points[i].updateSelf(); } for(var i = 0, count = this.points.length; i &lt; count; i++){ this.points[i].updateNeighbors(); } if(this.fishes.length &lt; this.fishCount){ if(--this.intervalCount == 0){ this.intervalCount = this.MAX_INTERVAL_COUNT; this.fishes.push(new FISH(this)); } } }, render : function(){ requestAnimationFrame(this.render); this.controlStatus(); this.context.clearRect(0, 0, this.width, this.height); this.context.fillStyle = 'hsl(0, 0%, 95%)'; for(var i = 0, count = this.fishes.length; i &lt; count; i++){ this.fishes[i].render(this.context); } this.context.save(); this.context.globalCompositeOperation = 'xor'; this.context.beginPath(); this.context.moveTo(0, this.reverse ? 0 : this.height); for(var i = 0, count = this.points.length; i &lt; count; i++){ this.points[i].render(this.context); } this.context.lineTo(this.width, this.reverse ? 0 : this.height); this.context.closePath(); this.context.fill(); this.context.restore(); } }; var SURFACE_POINT = function(renderer, x){ this.renderer = renderer; this.x = x; this.init(); }; SURFACE_POINT.prototype = { SPRING_CONSTANT : 0.03, SPRING_FRICTION : 0.9, WAVE_SPREAD : 0.3, ACCELARATION_RATE : 0.01, init : function(){ this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE; this.height = this.initHeight; this.fy = 0; this.force = {previous : 0, next : 0}; }, setPreviousPoint : function(previous){ this.previous = previous; }, setNextPoint : function(next){ this.next = next; }, interfere : function(y, velocity){ this.fy = this.renderer.height * this.ACCELARATION_RATE * ((this.renderer.height - this.height - y) &gt;= 0 ? -1 : 1) * Math.abs(velocity); }, updateSelf : function(){ this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height); this.fy *= this.SPRING_FRICTION; this.height += this.fy; }, updateNeighbors : function(){ if(this.previous){ this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height); } if(this.next){ this.force.next = this.WAVE_SPREAD * (this.height - this.next.height); } }, render : function(context){ if(this.previous){ this.previous.height += this.force.previous; this.previous.fy += this.force.previous; } if(this.next){ this.next.height += this.force.next; this.next.fy += this.force.next; } context.lineTo(this.x, this.renderer.height - this.height); } }; var FISH = function(renderer){ this.renderer = renderer; this.init(); }; FISH.prototype = { GRAVITY : 0.4, init : function(){ this.direction = Math.random() &lt; 0.5; this.x = this.direction ? (this.renderer.width + this.renderer.THRESHOLD) : -this.renderer.THRESHOLD; this.previousY = this.y; this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1); if(this.renderer.reverse){ this.y = this.getRandomValue(this.renderer.height * 1 / 10, this.renderer.height * 4 / 10); this.vy = this.getRandomValue(2, 5); this.ay = this.getRandomValue(0.05, 0.2); }else{ this.y = this.getRandomValue(this.renderer.height * 6 / 10, this.renderer.height * 9 / 10); this.vy = this.getRandomValue(-5, -2); this.ay = this.getRandomValue(-0.2, -0.05); } this.isOut = false; this.theta = 0; this.phi = 0; }, getRandomValue : function(min, max){ return min + (max - min) * Math.random(); }, reverseVertical : function(){ this.isOut = !this.isOut; this.ay *= -1; }, controlStatus : function(context){ this.previousY = this.y; this.x += this.vx; this.y += this.vy; this.vy += this.ay; if(this.renderer.reverse){ if(this.y &gt; this.renderer.height * this.renderer.INIT_HEIGHT_RATE){ this.vy -= this.GRAVITY; this.isOut = true; }else{ if(this.isOut){ this.ay = this.getRandomValue(0.05, 0.2); } this.isOut = false; } }else{ if(this.y &lt; this.renderer.height * this.renderer.INIT_HEIGHT_RATE){ this.vy += this.GRAVITY; this.isOut = true; }else{ if(this.isOut){ this.ay = this.getRandomValue(-0.2, -0.05); } this.isOut = false; } } if(!this.isOut){ this.theta += Math.PI / 20; this.theta %= Math.PI * 2; this.phi += Math.PI / 30; this.phi %= Math.PI * 2; } this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY); if(this.vx &gt; 0 &amp;&amp; this.x &gt; this.renderer.width + this.renderer.THRESHOLD || this.vx &lt; 0 &amp;&amp; this.x &lt; -this.renderer.THRESHOLD){ this.init(); } }, render : function(context){ context.save(); context.translate(this.x, this.y); context.rotate(Math.PI + Math.atan2(this.vy, this.vx)); context.scale(1, this.direction ? 1 : -1); context.beginPath(); context.moveTo(-30, 0); context.bezierCurveTo(-20, 15, 15, 10, 40, 0); context.bezierCurveTo(15, -10, -20, -15, -30, 0); context.fill(); context.save(); context.translate(40, 0); context.scale(0.9 + 0.2 * Math.sin(this.theta), 1); context.beginPath(); context.moveTo(0, 0); context.quadraticCurveTo(5, 10, 20, 8); context.quadraticCurveTo(12, 5, 10, 0); context.quadraticCurveTo(12, -5, 20, -8); context.quadraticCurveTo(5, -10, 0, 0); context.fill(); context.restore(); context.save(); context.translate(-3, 0); context.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)); context.beginPath(); if(this.renderer.reverse){ context.moveTo(5, 0); context.bezierCurveTo(10, 10, 10, 30, 0, 40); context.bezierCurveTo(-12, 25, -8, 10, 0, 0); }else{ context.moveTo(-5, 0); context.bezierCurveTo(-10, -10, -10, -30, 0, -40); context.bezierCurveTo(12, -25, 8, -10, 0, 0); } context.closePath(); context.fill(); context.restore(); context.restore(); this.controlStatus(context); } }; $(function(){ RENDERER.init(); }); &lt;/script&gt; &lt;style&gt; @media only screen and (max-width: 767px){ #sidebar_search_box input[type=text]{width:calc(100% - 24px)} } &lt;/style&gt; &lt;/div&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"[转]MySQL数据库引擎","slug":"转-MySQL数据库引擎","date":"2020-02-09T10:43:52.000Z","updated":"2020-02-11T10:56:14.918Z","comments":true,"path":"2020/02/09/转-MySQL数据库引擎/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E8%BD%AC-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/","excerpt":"接下来介绍一下存储引擎的基本概念、MySQL支持的存储引擎、存储引擎的选择以及操作默认存储引擎。","text":"接下来介绍一下存储引擎的基本概念、MySQL支持的存储引擎、存储引擎的选择以及操作默认存储引擎。 什么是存储引擎数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。 现在许多数据库管理系统都支持多种不同的存储引擎。MySQL 的核心就是存储引擎。 提示：InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎。 MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。 MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。 MySQL 5.7 支持的存储引擎MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 SHOW ENGINES 语句来显示可用的数据库引擎和默认引擎。 MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。 MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。可以使用SHOW ENGINES语句查看系统所支持的引擎类型，结果如图所示。 Support 列的值表示某种引擎是否能使用，YES表示可以使用，NO表示不能使用，DEFAULT表示该引擎为当前默认的存储引擎。 如何选择 MySQL 存储引擎不同的存储引擎都有各自的特点，以适应不同的需求，如表所示。为了做出选择，首先要考虑每一个存储引擎提供了哪些不同的功能。 功能 MylSAM MEMORY InnoDB Archive 存储限制 256TB RAM 64TB None 支持事务 No No Yes No 支持全文索引 Yes No No No 支持树索引 Yes Yes Yes No 支持哈希索引 No Yes No No 支持数据缓存 No N/A Yes No 支持外键 No No Yes No 可以根据以下的原则来选择 MySQL 存储引擎： 如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。 如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。 如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。 如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎。 提示：使用哪一种引擎要根据需要灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。 MySQL 默认存储引擎InnoDB 是系统的默认引擎，支持可靠的事务处理。 使用下面的语句可以修改数据库临时的默认存储引擎 SET default_storage_engine=&lt; 存储引擎名 &gt; 例如，将 MySQL 数据库的临时默认存储引擎修改为 MyISAM，输入的 SQL 语句和运行结果如图所示。 此时，可以发现 MySQL 的默认存储引擎已经变成了 MyISAM。但是当再次重启客户端时，默认存储引擎仍然是 InnoDB。 原文链接：http://c.biancheng.net/view/2418.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[转]MySQL区别大小写字母的问题","slug":"转-MySQL区别大小写的问题","date":"2020-02-09T08:29:12.000Z","updated":"2020-03-22T05:27:07.243Z","comments":true,"path":"2020/02/09/转-MySQL区别大小写的问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E8%BD%AC-MySQL%E5%8C%BA%E5%88%AB%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"如果直接使用MYSQL客户端用SQL语句查询数据库中的数据，SQL语句中字段的大写或小写查出的数据是一样的，说明查询条件对字段的大小写是不敏感（默认）。 怎样让MYSQL对大小字母写敏感？","text":"如果直接使用MYSQL客户端用SQL语句查询数据库中的数据，SQL语句中字段的大写或小写查出的数据是一样的，说明查询条件对字段的大小写是不敏感（默认）。 怎样让MYSQL对大小字母写敏感？ 解决方案一MYSQL区别大小写需要设置collate（校对） 。 collate规则： *_bin: 表示的是 binary casesensitive collation，也就是说是区分大小写的 *_cs: 表示的是 casesensitive collation，区分大小写 *_ci: 表示的是 caseinsensitive collation，不区分大小写 解决方法 可以将查询条件用binary()括起来。 比如： select * from emp where binary username= 'jack'; 可以修改该字段的collation 为 binary。比如： ALTER TABLE TABLENAME MODIFY COLUMN COLUMNNAME VARCHAR(50) BINARY CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL; 解决方案二mysql查询默认是不区分大小写的 如: select * from emp where username=‘jack'; select * from emp where username='JACK'; 得到的结果是一样的，如果我们需要进行区分的话可以按照如下方法来做： 第一种方法要让mysql查询区分大小写，可以： select * from emp where binary username='jack' select * from emp where binary username='JACK' 第二种方法在建表时时候加以标识 create table emp( username varchar(20) binary ) 原理：对于CHAR、VARCHAR和TEXT类型，BINARY属性可以为列分配该列字符集的校对规则。BINARY属性是指定列字符集的二元校对规则的简写。排序和比较基于数值字符值,因此也就自然区分了大小写。 原文链接：https://blog.csdn.net/qq_15160079/article/details/100976519 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}],"author":{"name":"曼巴进化者","url":"https://blog.csdn.net/qq_15160079/article/details/100976519"}},{"title":"Navicat Premium连接MySQL失败？","slug":"Navicat-Premium连接MySQL失败？","date":"2020-02-09T07:42:25.000Z","updated":"2020-02-11T10:56:14.881Z","comments":true,"path":"2020/02/09/Navicat-Premium连接MySQL失败？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/Navicat-Premium%E8%BF%9E%E6%8E%A5MySQL%E5%A4%B1%E8%B4%A5%EF%BC%9F/","excerpt":"问题描述使用Navicat Premium连接MySQL失败，并弹窗提示👇 分析从错误信息可知caching_sha2_password不能加载。 以上报错是由于目前已有的客户端连接软件还不支持Mysql8新增加的加密方式caching_sha2_password，所以我们需要修改用户的加密方式，将其改为老的加密验证方式。 大安装Mysql数据库的主机上登录Mysql对应的用户，上面连接时用的用户为root，所以我们登录root用户。 解决 执行命令，查看当前用户的加密方式： use mysql; select user,plugin from user where user='root'; 可以看到当前用户的加密方式为caching_sha2_password。 登录MySQL后输入，执行命令： ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'YourPassword'; FLUSH PRIVILEGES; 将用户的加密方式改为mysql_native_password。 再次尝试连接Mysql，连接成功。","text":"问题描述使用Navicat Premium连接MySQL失败，并弹窗提示👇 分析从错误信息可知caching_sha2_password不能加载。 以上报错是由于目前已有的客户端连接软件还不支持Mysql8新增加的加密方式caching_sha2_password，所以我们需要修改用户的加密方式，将其改为老的加密验证方式。 大安装Mysql数据库的主机上登录Mysql对应的用户，上面连接时用的用户为root，所以我们登录root用户。 解决 执行命令，查看当前用户的加密方式： use mysql; select user,plugin from user where user='root'; 可以看到当前用户的加密方式为caching_sha2_password。 登录MySQL后输入，执行命令： ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'YourPassword'; FLUSH PRIVILEGES; 将用户的加密方式改为mysql_native_password。 再次尝试连接Mysql，连接成功。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"文章内跳转","slug":"文章内跳转","date":"2020-02-09T07:19:00.000Z","updated":"2020-04-23T11:40:36.813Z","comments":true,"path":"2020/02/09/文章内跳转/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E6%96%87%E7%AB%A0%E5%86%85%E8%B7%B3%E8%BD%AC/","excerpt":"点击我跳转 1. 跳转起点 [点击我跳转](#jump) 2.跳转终点 &lt;span id=\"jump\"&gt;&lt;font color='blue'&gt;[我是跳转内容]&lt;/font&gt;&lt;/span&gt;&lt;a href=\"#jump\" class=\"footnote-backref\"&gt;↩&lt;/a&gt; [我是跳转内容]↩ 参考文章： https://www.jianshu.com/p/4898c2e9a36d https://blog.csdn.net/qq_38276669/article/details/86748936","text":"点击我跳转 1. 跳转起点 [点击我跳转](#jump) 2.跳转终点 &lt;span id=\"jump\"&gt;&lt;font color='blue'&gt;[我是跳转内容]&lt;/font&gt;&lt;/span&gt;&lt;a href=\"#jump\" class=\"footnote-backref\"&gt;↩&lt;/a&gt; [我是跳转内容]↩ 参考文章： https://www.jianshu.com/p/4898c2e9a36d https://blog.csdn.net/qq_38276669/article/details/86748936 内容 在MarkDown中是通过 链接 和 标题 来实现页面内跳转的，所以先讲下MarkDown中 链接 和 标题 的语法，然后再讲 MarkDown 中实现页面内跳转的方法； 一. 链接的定义Markdown 支持两种形式的链接语法： 行内式 和 参考式 两种形式。 1. 行内式链接语法： 行内式链接 = [内容](地址 \"标题\") 说明： 标题 是可选的，可以用单引号 或 双引号； 转换成HTML后，会生成如下标签： &lt;a href=\"地址\" title=\"标题\"&gt;内容&lt;/a&gt; 示例： [我的博客](https://www.jianshu.com/u/7ecaba2d594c \"郭斌勇的主页\") 渲染成HTML后，会生成如下标签： &lt;a href=\"https://www.jianshu.com/u/7ecaba2d594c\" title=\"郭斌勇的主页\"&gt;我的博客&lt;/a&gt; 效果如下： 我的博客 2. 参考式链接语法： 参考式链接 = [内容][参考标识符] 参考标识符 = [标识符]: 地址 \"标题\" 说明： 参考式链接 和 参考标识符 的定义没有先后顺序； [内容] 和 [参考标识符] 之间可以有一个空格，也可以没有空格； 如果 内容 和 参考标识符 一样，也可简写成 [参考标识符][] ; 标题 是可选的，可以用单引号、双引号或是圆括弧包着； 转换成HTML后，会生成如下标签： &lt;a href=\"地址\" title=\"标题\"&gt;内容&lt;/a&gt; 示例： [博客]: https://www.jianshu.com/u/7ecaba2d594c \"郭斌勇的主页\" [我的博客][博客] [博客][] 渲染成HTML后，会生成如下标签： &lt;a href=\"https://www.jianshu.com/u/7ecaba2d594c\" title=\"郭斌勇的主页\"&gt;我的博客&lt;/a&gt; &lt;a href=\"https://www.jianshu.com/u/7ecaba2d594c\" title=\"郭斌勇的主页\"&gt;博客&lt;/a&gt; 效果如下： 我的博客 博客 三.页面内跳转MarkDown中是通过定义链接的方式来定义跳转的，在这里，跳转也称为锚点，跳转的目标称为锚点目标； 所以，在 MarkDown 中实现页面内跳转的方法就是：定义一个 锚点目标 和 对应的 锚点 ，用户点击 锚点 便可跳转到对应的 锚点目标 位置处； 锚点 和 锚点目标 的定义格式如下： 1. 锚点的定义锚点就是一个链接，另外，由于在MarkDown中可以直接写HTML，所以在MarkDown中实现锚点有两种方式：MarkDown方式 和 HTML方式； 1.1 MarkDown锚点MarkDown锚点本质上就是一个MarkDown链接，只是链接地址的格式为： 链接地址 = #目标内容 所以 MarkDown锚点 的定义也有两种方式 行内式语法： 锚点 = [内容](#目标内容 \"标题\") 说明： 标题 是可选的，可以用单引号 或 双引号； 转换成HTML后，会生成如下标签： &lt;a href=\"#目标内容\" title=\"标题\"&gt;内容&lt;/a&gt; 示例： [MarkDown方式的锚点](#MarkDown锚点) 渲染成HTML后，会生成如下标签： &lt;a href=\"#MarkDown锚点\" &gt;MarkDown方式的锚点&lt;/a&gt; 效果如下：点击下面的锚点 MarkDown方式的锚点 参考式语法： 锚点 = [内容][参考标识符] 参考标识符 = [标识符]: #目标内容 \"标题\" 说明： 锚点 和 参考标识符 的定义没有先后顺序； [内容] 和 [参考标识符] 之间可以有一个空格，也可以没有空格； 如果 内容 和 参考标识符 一样，也可简写成 [参考标识符][] ; 标题 是可选的，可以用单引号、双引号或是圆括弧包着； 转换成HTML后，会生成如下标签： &lt;a href=\"#目标内容\" title=\"标题\"&gt;内容&lt;/a&gt; 示例： [MarkDown方式的锚点]: #MarkDown锚点 [MD锚点][MarkDown方式的锚点] [MarkDown方式的锚点][] 渲染成HTML后，会生成如下标签： &lt;a href=\"#MarkDown锚点\"&gt;MD锚点&lt;/a&gt; &lt;a href=\"#MarkDown锚点\"&gt;MarkDown方式的锚点&lt;/a&gt; 效果如下： MD锚点 MarkDown方式的锚点 1.2 HTML锚点HTML锚点本质上就是一个a链接，格式为： &lt;a href=\"#目标内容\"&gt;内容&lt;/a&gt; 注意： HTML锚点 的目标锚点只能是 标签形式的锚点目标 示例： &lt;a href=\"#html锚点\"&gt;HTML方式的锚点&lt;/a&gt; 效果如下：点击下面的锚点 HTML方式的锚点 2. 锚点目标的定义锚点目标有2种定义方式：MarkDown形式 和 标签形式； MarkDown形式的锚点目标MarkDown形式的锚点目标的定义其实就是标题的定义，即：任何级别的标题可以直接作为锚点目标； 标题内容 = 目标内容 所以，类Setext形式 和 类atx形式 的标题都可作为 锚点目标 ； 锚点目标定义的示例： 这是一个锚点目标 ==== 这是一个锚点目标 --- # 这是一个锚点目标 ## 这是一个锚点目标 ### 这是一个锚点目标 #### 这是一个锚点目标 ##### 这是一个锚点目标 ###### 这是一个锚点目标 注意： 锚点的 目标内容 中不能有大家字母和空格，所以如果锚点目标的 目标内容 中有大写字母或空格，则需要在定义锚点中的 目标内容 时，把大写字母改成小写字母，把空格改成 -； 锚点 的 目标内容 中不能含有以下字符： 半角点(即英文中的句号). 标签形式的锚点目标因为MarkDown链接会被转成a标签，并且MarkDown中也可以写标签，所以可以利用HTML的锚点机制直接定义一个带 id 特性的任意标签 或 带 name 特性的 a 标签（注意：在HTML5中，a标签已经不再支持 name 特性）作为锚点目标，然后把MarkDown中的锚点地址的目标内容设置为 id 或 name 特性的值；这样便可以实现页面内跳转； 这种形式的锚点目标的定义格式为： &lt;标签名 id=\"目标内容\"&gt;元素内容&lt;/标签名&gt; 或 &lt;a name=\"目标内容\"&gt;元素内容&lt;/a&gt; 注意： 标签形式的锚点目标的id特性值中是不能含有中文字符； name 特性只能应用在 a 标签上； HTML5不支持通过a标签的 name 特性来定义锚点目标； 示例： &lt;div id=\"这是锚点目标\"&gt;跳转到这里&lt;/div&gt; 或 &lt;a name=\"这是锚点目标\"&gt;跳转到这里&lt;/a&gt; 四. 总结MarkDown中实现页面跳转的方法如下： 定义锚点目标；锚点目标的定义方式有4种：类Setext形式的标题、类atx形式的标题、带id特性的HTML标签（id特性的值为目标内容）、带name特性的a标签（name特性的值为目标内容）； 定义锚点；锚点的定义方式有3种：行内式链接、参考式链接、HTML的a链接； 说明： 锚点 和 锚点目标 的定义不分先后顺序； 注意： 锚点的 目标内容 中不能有大家字母和空格，所以如果锚点目标的 目标内容 中有大写字母或空格，则需要在定义锚点中的 目标内容 时，把大写字母改成小写字母，把空格改成 -； 锚点 的 目标内容 中不能含有以下字符： 半角点(即英文中的句号). 标签形式的锚点目标的id特性值中是不能含有中文字符； name 特性只能应用在 a 标签上； HTML5不支持通过a标签的 name 特性来定义锚点目标； HTML锚点 的目标锚点只能是 标签形式的锚点目标 五. 示例示例1锚点： [跳转到个人简介](#个人简介) 锚点目标： # 个人简介 示例2锚点： [跳转到个人简介]: #个人简介 [跳转到个人简介][] 锚点目标： 个人简介 ===== 示例3锚点： [跳转到个人简介](#个人简介) 锚点目标： &lt;p id=\"个人简介\"&gt;这是个人简介&lt;/p&gt; 示例4锚点： [跳转到个人简介](#个人简介) 锚点目标： &lt;a name=\"个人简介\"&gt;这是个人简介&lt;/a&gt; 示例5锚点： &lt;a href=\"#个人简介\"&gt;跳转到个人简介&lt;/a&gt; 锚点目标： 个人简介 ---- 示例6锚点： &lt;a href=\"#个人简介\"&gt;跳转到个人简介&lt;/a&gt; 锚点目标： &lt;h1 id=\"个人简介\"&gt;这是个人简介&lt;/h1&gt; 示例7锚点： &lt;a href=\"#个人简介\"&gt;跳转到个人简介&lt;/a&gt; 锚点目标： &lt;a name=\"个人简介\"&gt;这是个人简介&lt;/a&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"输入密码后登录不上MySQL？","slug":"输入密码后登录不上MySQL？","date":"2020-02-09T07:08:37.000Z","updated":"2020-02-11T10:56:14.924Z","comments":true,"path":"2020/02/09/输入密码后登录不上MySQL？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E5%90%8E%E7%99%BB%E5%BD%95%E4%B8%8D%E4%B8%8AMySQL%EF%BC%9F/","excerpt":"昨晚安装好MySQL后，可以登录。但是今天输入密码后，总是没办法登录。 刚开始我是用DOS窗口的，我检查了命令，命令也没输错啊。 接着转去MySQL Command Line Client试试，一直没反应。 我突然想到“是不是MySQL服务没有启动？” 果然！看了一下，这个时候MySQL需要手动启动，于是我把MySQL服务设置成开机自动启动，以后就省去手动启动这个麻烦。 回到DOS，输入mysql -h localhost -u root -p试试，可以正常登录MySQL了hh o(￣▽￣)o 除了上面这种到【服务】手动开启MySQL服务的方法外，也可以用PowerShell(管理员)来启动。 输入命令net start mysql，启动MySQL服务。启动成功会在左下角弹窗提示👇 一定是要带有管理员权限的PowerShell，否者只会是这个样子👇 输入net start mysql，按回车键，就能启动 MySQL 服务，停止服务的命令为net stop mysql。","text":"昨晚安装好MySQL后，可以登录。但是今天输入密码后，总是没办法登录。 刚开始我是用DOS窗口的，我检查了命令，命令也没输错啊。 接着转去MySQL Command Line Client试试，一直没反应。 我突然想到“是不是MySQL服务没有启动？” 果然！看了一下，这个时候MySQL需要手动启动，于是我把MySQL服务设置成开机自动启动，以后就省去手动启动这个麻烦。 回到DOS，输入mysql -h localhost -u root -p试试，可以正常登录MySQL了hh o(￣▽￣)o 除了上面这种到【服务】手动开启MySQL服务的方法外，也可以用PowerShell(管理员)来启动。 输入命令net start mysql，启动MySQL服务。启动成功会在左下角弹窗提示👇 一定是要带有管理员权限的PowerShell，否者只会是这个样子👇 输入net start mysql，按回车键，就能启动 MySQL 服务，停止服务的命令为net stop mysql。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[工具]文件加密软件","slug":"工具-文件加密软件","date":"2020-02-09T05:40:26.000Z","updated":"2020-02-11T10:56:14.889Z","comments":true,"path":"2020/02/09/工具-文件加密软件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E5%B7%A5%E5%85%B7-%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E8%BD%AF%E4%BB%B6/","excerpt":"Folder-locker这是一个小巧的文件上锁软件，没有压缩和加密过程，方便快捷。 功能展示 在想加密的文件夹上，右键则可呼出加密面板，输入两次密码确认加密。 在已加密的文件夹上，右键，输入密码，则取消加密 项目介绍项目分了两个目录： DButility 用于通过轻量极数据库SQLite 保存密码。 通过Md5算法对密码加密，通过SQL参数防止SQL注入。 folderLocker 用于实现业务逻辑。 软件使用 下载软件安装包 Folder Locker.exe 进行安装，建议安装在D盘。 可以右键使用，也可以打开软件主页面使用。 注意事项 密码保存在本机数据库，没有上传任何服务器。 删除软件会同时删除数据库，因而删除密码。 如果忘记密码： 如果密码遗失，文件被锁，可以通过命令行工具重命名： cd C:\\Users\\91991\\Music ren \"Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\" \"Test1\" 或者把文件复制出来。 cd C:\\Users\\91991\\Music cd '.\\Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\\' ls mv .\\* ..\\Test1\\ 项目地址： https://github.com/Albert-W/Folder-locker 项目展示： https://albert-w.github.io/Folder-locker/","text":"Folder-locker这是一个小巧的文件上锁软件，没有压缩和加密过程，方便快捷。 功能展示 在想加密的文件夹上，右键则可呼出加密面板，输入两次密码确认加密。 在已加密的文件夹上，右键，输入密码，则取消加密 项目介绍项目分了两个目录： DButility 用于通过轻量极数据库SQLite 保存密码。 通过Md5算法对密码加密，通过SQL参数防止SQL注入。 folderLocker 用于实现业务逻辑。 软件使用 下载软件安装包 Folder Locker.exe 进行安装，建议安装在D盘。 可以右键使用，也可以打开软件主页面使用。 注意事项 密码保存在本机数据库，没有上传任何服务器。 删除软件会同时删除数据库，因而删除密码。 如果忘记密码： 如果密码遗失，文件被锁，可以通过命令行工具重命名： cd C:\\Users\\91991\\Music ren \"Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\" \"Test1\" 或者把文件复制出来。 cd C:\\Users\\91991\\Music cd '.\\Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\\' ls mv .\\* ..\\Test1\\ 项目地址： https://github.com/Albert-W/Folder-locker 项目展示： https://albert-w.github.io/Folder-locker/ 教程这是国人开发的一款开源加密小程序，它只有一个功能，就是给文件夹上密码。 下载后安装，需要注意的是，软件默认安装到D盘，你可以改成其他盘，但不建议安装到C盘，因为可能导致数据库丢失，影响解密； 加密过程也很简单，右键需要加密的文件夹 – Folder locker – 输入密码– lock 即可； 加密后文件夹图标会变成锁，无法双击打开，需要解密的话，右键已加密文件夹 – Folder locker – 输入密码– unlock 即可； 整个过程没有任何数据上传，你的密码会通过Md5算法加密，并保存在本机数据库，卸载软件会同时删除数据库，导致密码丢失。 这个小程序原理非常简单，就是利用 Windows 的注册表修改了文件夹属性，使其不能直接已文件夹的形式打开，就像「上帝模式」一样，小程序并没有对文件夹内的文件做任何修改，没有压缩和加密过程，所以速度非常快。 但也正因为其简单，知道原理的话不需要程序也能解密。 忘记密码的解密方法： 以上就是使用这个小程序所有的方法，它的安全系数不高，不适用来加密非常重要的机密文件，但保护普通用户的小秘密应该是搓搓有余的。 目前这款软件好像在 Windows 2004 版本上失效了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}],"author":{"name":"Albert-W","url":"https://github.com/Albert-W/Folder-locker","avatar":"https://avatars0.githubusercontent.com/u/21038139?s=460&v=4"}},{"title":"登录MySQL","slug":"登录MySQL","date":"2020-02-08T14:54:46.000Z","updated":"2020-02-11T10:56:14.892Z","comments":true,"path":"2020/02/08/登录MySQL/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E7%99%BB%E5%BD%95MySQL/","excerpt":"安装好MySQL后，默认启动服务，这时候开始尝试登录MySQL数据库。 有两种登录方式： Power Shell 或 CMD（DOS窗口） 命令行客户端（MySQL Command Line Client）【安装软件时，一般会安装的】 Power Shell 启动 Power Shell 。 输入命令cd C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin（cd+空格+安装目录/bin），回车。 输入登录命令，回车。登录命令有4中，选其一即可： #第一种 服务器主机地址+不接密码 mysql -h localhost -u root -p #第二种 服务器主机地址+密码 mysql -h localhost -u root -proot #第三种 省略服务器主机地址+不接密码，默认localhost mysql -u root -p #第四种 省略服务器主机地址+密码，默认localhost mysql -u root -proot 提示：mysql 为登录命令，-h 后面的参数是服务器的主机地址，在这里客户端和服务器在同一台机器上，所以输入 localhost 或者 IP 地址；-u 后面跟登录数据库的用户名称，在这里为 root；-p 后面是用户登录密码。 在 DOS 窗口下运行该命令后，系统会提示输入密码。密码输入正确以后，即可登录到 MySQL 数据库。 可以在 mysql 命令中直接加上密码，该命令为 mysql -h localhost -u root -proot。这里的 -p 后面的 root 就是密码。此处特别注意 -p 和密码之间没有空格。如果出现空格，系统将不会把后面的字符串当成密码来对待。 系统提示输入密码。（若选用第二/四种方式进行登录，则跳过本步骤） 成功登录到MySQL数据库。登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，如下图所示。 登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，然后下面还有一些说明性的语句，如图所示。 这些说明性语句介绍如下： Commands end with; or\\g：说明 mysql 命令行下的命令是以分号（;）或“\\g”来结束的，遇到这个结束符就开始执行命令。 Your MySQL connection id is 3：id 表示 MySQL 数据库的连接次数。 Server version: 5. 7.29-log MySQL Community Server（GPL）：Server version 后面说明数据库的版本，这个版本为 5.7.29。Community 表示该版本是社区版。 Type ‘help;’ or ‘\\h’ for help：表示输入”help;“或者”\\h“可以看到帮助信息。 Type ‘\\c’ to clear the current input statement：表示遇到”\\c“就清除前面的命令。 提示：当窗口中出现如上图所示的说明信息，命令提示符变为“mysql&gt;”时，表明已经成功登录 MySQL 服务器，可以开始对数据库进行操作了。 输入命令exit，即可退出MySQL。 MySQL Command Line Client打开 MySQL Command Line Client 进入提示输入密码的界面，如图所示。 输入正确的密码后，登录到 MySQL 软件。如果以这种方式登录 MySQL，需要保证 MySQL 服务处于启动状态。","text":"安装好MySQL后，默认启动服务，这时候开始尝试登录MySQL数据库。 有两种登录方式： Power Shell 或 CMD（DOS窗口） 命令行客户端（MySQL Command Line Client）【安装软件时，一般会安装的】 Power Shell 启动 Power Shell 。 输入命令cd C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin（cd+空格+安装目录/bin），回车。 输入登录命令，回车。登录命令有4中，选其一即可： #第一种 服务器主机地址+不接密码 mysql -h localhost -u root -p #第二种 服务器主机地址+密码 mysql -h localhost -u root -proot #第三种 省略服务器主机地址+不接密码，默认localhost mysql -u root -p #第四种 省略服务器主机地址+密码，默认localhost mysql -u root -proot 提示：mysql 为登录命令，-h 后面的参数是服务器的主机地址，在这里客户端和服务器在同一台机器上，所以输入 localhost 或者 IP 地址；-u 后面跟登录数据库的用户名称，在这里为 root；-p 后面是用户登录密码。 在 DOS 窗口下运行该命令后，系统会提示输入密码。密码输入正确以后，即可登录到 MySQL 数据库。 可以在 mysql 命令中直接加上密码，该命令为 mysql -h localhost -u root -proot。这里的 -p 后面的 root 就是密码。此处特别注意 -p 和密码之间没有空格。如果出现空格，系统将不会把后面的字符串当成密码来对待。 系统提示输入密码。（若选用第二/四种方式进行登录，则跳过本步骤） 成功登录到MySQL数据库。登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，如下图所示。 登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，然后下面还有一些说明性的语句，如图所示。 这些说明性语句介绍如下： Commands end with; or\\g：说明 mysql 命令行下的命令是以分号（;）或“\\g”来结束的，遇到这个结束符就开始执行命令。 Your MySQL connection id is 3：id 表示 MySQL 数据库的连接次数。 Server version: 5. 7.29-log MySQL Community Server（GPL）：Server version 后面说明数据库的版本，这个版本为 5.7.29。Community 表示该版本是社区版。 Type ‘help;’ or ‘\\h’ for help：表示输入”help;“或者”\\h“可以看到帮助信息。 Type ‘\\c’ to clear the current input statement：表示遇到”\\c“就清除前面的命令。 提示：当窗口中出现如上图所示的说明信息，命令提示符变为“mysql&gt;”时，表明已经成功登录 MySQL 服务器，可以开始对数据库进行操作了。 输入命令exit，即可退出MySQL。 MySQL Command Line Client打开 MySQL Command Line Client 进入提示输入密码的界面，如图所示。 输入正确的密码后，登录到 MySQL 软件。如果以这种方式登录 MySQL，需要保证 MySQL 服务处于启动状态。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"博客中的icon","slug":"博客中的icon","date":"2020-02-08T13:45:34.000Z","updated":"2020-04-23T11:40:36.802Z","comments":true,"path":"2020/02/08/博客中的icon/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84icon/","excerpt":"在主题的配置文件中的 icon 是 fontawesome 图标名，你要显示什么图标，去 fontawesome.com 找免费版的就可以了。","text":"在主题的配置文件中的 icon 是 fontawesome 图标名，你要显示什么图标，去 fontawesome.com 找免费版的就可以了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"MySQL基础教学","slug":"MySQL基础教学","date":"2020-02-08T13:25:58.000Z","updated":"2020-02-11T10:56:14.874Z","comments":true,"path":"2020/02/08/MySQL基础教学/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/MySQL%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/","excerpt":"两个学习MySQL基础的网站： C语言中文网 菜鸟教程","text":"两个学习MySQL基础的网站： C语言中文网 菜鸟教程 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[转]MySQL安装","slug":"转-MySQL安装","date":"2020-02-08T12:58:45.000Z","updated":"2020-03-22T04:42:24.376Z","comments":true,"path":"2020/02/08/转-MySQL安装/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E8%BD%AC-MySQL%E5%AE%89%E8%A3%85/","excerpt":"转载一份非常详细的【MySQL】的安装教程。","text":"转载一份非常详细的【MySQL】的安装教程。 进入官网找到自己所需的安装包：https://dev.mysql.com/ ，路径：DOWNLOAD–&gt;MYSQL Community Edition(GRL)–&gt;MYSQL on Windows (Installer &amp; Tool) 找到所需的安装包: 这里提供了直链下载【MySQL-5.7.20】：https://downloads.mysql.com/archives/get/p/25/file/mysql-installer-community-5.7.20.0.msi 点击download。这里选择的是安装版（mysql -install-community） 选择不登陆下载。 双击运行下载好的mysql-installer-community-5.7.19.0.msi，程序运行需要一些时间，请等待一下。 运行成功之后，进入欢迎的界面.选择我同意协议，不然无法进行下一步。 进入类型选择页面，本人需要mysql云服务就选择了developer default（7.1是默认安装的步骤），如果只想安装mysql server的就选择custom模式（7.2步骤是选择自己需要的服务器类型，所选择的用于做一些数据分析） developer default（开发者默认）：安装mysql开发所需的所有产品 server only（服务器）：只安装mysql服务器产品 client only（客户端）：只安装没有服务器的mysql客户端产品 full（完全）：安装所有包含的mysql产品和功能 custom（手动）：手动选择系统上应安装的产品 7.1 开发者默认模式检测以下程序会安装不成功，点击下一步进入下一个安装流程—&gt;跳到第八步。 check requirements：以下产品的请求失败，安装程序将自动尝试解决其中一些问题。标记为手动的要求无法自动解决。单击这些项目以尝试手动恢复。 检测到不可安装的程序说明： Visual Studio：是一款代码编辑工具（可编写C#、Visual Basic、C++、TypeScript、F# ），如果你安装的话就安装要求去安装Visual Studio version：2012.2013.2015.2017其中一个版本 Connector/pyton 3.4：电脑有python3.6了就没选择3.4版本的。如果你没安装有python可按要求去安装一些内容。 7.2 选择mysql server（服务） 5.7.19 x64 选择mysql workbench(mysql 的工作薄) 6.3.9 x64 选择mysql notiyier(通知) 1.1.7 x86(因为这里只有一个选择所以选择了86)点击下一步进入下一个安装流程—&gt;跳到第九步。 当我们点击下一步的时候安装程序出现了提示：（一个或者移动产品要求没有得到满足，那些符合要求的产品将不会安装/升级。你想要继续吗），这里我选择的是：YES 在安装所选界面能看到我们接下来所需要安装的程序，点击execute 安装程序进度界面，安装需要一些时间。点击dide tails能看到安装日志 程序安装完成之后，点击next 在product configutration（产品配置）页面能看到需要配置的程序，点击next（页面英语介绍：现在我们将逐一介绍以下产品的配置向导。您可以随时取消，如果您希望离开此向导，而不必配置所有产品） 先配置mysql server的类型以及网络：type and networking（类型和网络），这里有两种mysql server类型，选择第一种类型点击next。 有两种类型简单介绍 1.standalone mysql server/classic mysql replication：独立的mysql服务器/经典的mysql复制 choose this option if you want to run the mysql server either standalone with the opportunity to later configure classic mysql replication：选择这个选项，如果你想运行mysql服务器是独立的，有机会以后配置经典的mysql复制 2. innodb cluster sandbox thst setup(for testing only)： innodb集群沙箱thst设置（仅用于测试） 设置服务器配置类型以及连接端口：继续next Config Type:选择Development Machine，用于小型以及学习所用足够了。 Port number：输入3306，也可以输入其他最好是3306-3309之间。 配置root的密码（该密码要记住），系统提示这密码虚弱 添加其他管理员，点击add user 输入账号密码点击ok（如果添加的管理员只允许在本地登录就将host改成local），回到界面之后点击next 配置mysql在windows系统中的名字，是否选择开机启动mysql服务，其它的没进行修改，点击“Next”. 配置插件和扩展页面没进行修改直接下一步： Mysql server :apply configuration（应用配置页面），选择execute进行安装配置 mysql server应用配置的log，选择finish 安装程序又回到了product configutration（产品配置）页面，此时我们看到mysql server安装成功的显示，继续下一步： 配置mysql router：勾选configure mysql route for innoDB cluster之后输入密码。（如果不想输入密码可直接点击点一下）点击下一步 Mysql router :apply configuration（应用配置页面）点击execute, 安装完成之后点击选择finish 检测root密码 安装一些server，老规矩点击execute，完成之后点击finish 程序回到产品配置页面。继续下一步： 安装程序完成界面。 双击运行之前下载的安装包，能看到我们所安装的产品。 配置mysql环境变量 上面安装的是时候我们看到mysql默认安装路径是：C:\\Program Files\\MySQL\\MySQL Server 5.7 我的电脑右键—&gt;属性à高级系统设置à环境变量à新建MYSQL_HOME,将安装目录输入： 找到path编辑：输入%MYSQL_HOME%\\bin 打开cmd输入mysql –u root –p 输入root的密码 原文链接：https://www.cnblogs.com/xiaodingdong/p/7223245.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}],"author":{"name":"叮咚丶哈哈","url":"https://www.cnblogs.com/xiaodingdong/p/7223245.html"}},{"title":"元宵团圆饭","slug":"元宵团圆饭","date":"2020-02-08T09:13:43.000Z","updated":"2020-02-08T09:37:50.898Z","comments":true,"path":"2020/02/08/元宵团圆饭/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E5%85%83%E5%AE%B5%E5%9B%A2%E5%9C%86%E9%A5%AD/","excerpt":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！”","text":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"第一个元宵","slug":"第一个元宵","date":"2020-02-08T09:13:43.000Z","updated":"2020-02-08T10:52:37.428Z","comments":true,"path":"2020/02/08/第一个元宵/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E5%AE%B5/","excerpt":"🌸于我们，这是妈走后的第一个元宵。 🎈这次没有汤圆…… 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” 👍附上老爸的新作(暂时想不出名字来hh，反正好吃hh)","text":"🌸于我们，这是妈走后的第一个元宵。 🎈这次没有汤圆…… 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” 👍附上老爸的新作(暂时想不出名字来hh，反正好吃hh) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"[转]jsdelivr的使用","slug":"转-jsdelivr的使用","date":"2020-02-08T06:22:39.000Z","updated":"2020-02-11T10:56:14.933Z","comments":true,"path":"2020/02/08/转-jsdelivr的使用/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E8%BD%AC-jsdelivr%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"本文链接：https://blog.csdn.net/qq_36910987/article/details/89562291","text":"本文链接：https://blog.csdn.net/qq_36910987/article/details/89562291 jsdelivr https://www.jsdelivr.com/ 下面就以举例子的方式说明 我是用 jsdelivr 来访问 github的资源，做博客来着 我的github https://github.com/yuDuChen/yuduchen 下面直接说怎么用jsdelivr，就不提如何创建github了 首先需要创建 releases 创建完,随便进入到一个文件,注意地址名 1 https://github.com/yuDuChen/yuduchen/blob/v1.5.6/layui/layui.js 这个地址用jsdelivr来访问 https://cdn.jsdelivr.net/gh/yuDuChen/yuduchen@v1.5.6/layui/layui.js 对比一下就发现怎么用了吧 注* 不使用jsdelivr直接引用github的文件 content-type 是 text/plain 页面无法解析 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"jQuery","slug":"jQuery","permalink":"https://melodyjerry.github.io/blog/tags/jQuery/"}],"author":{"name":"羽渡尘","url":"https://blog.csdn.net/qq_36910987/article/details/89562291"}},{"title":"蓝桥杯-基础练习-01字串","slug":"蓝桥杯-基础练习-01字串","date":"2020-02-07T13:24:17.000Z","updated":"2020-02-08T10:53:52.613Z","comments":true,"path":"2020/02/07/蓝桥杯-基础练习-01字串/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-01%E5%AD%97%E4%B8%B2/","excerpt":"在刷蓝桥杯试题时候，有一道很意思又有丶烧脑的题目👇 资源限制时间限制：1.0s 内存限制：256.0MB 问题描述对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是： 00000 00001 00010 00011 00100 请按从小到大的顺序输出这32种01串。 输入格式本试题没有输入。 输出格式输出32行，按从小到大的顺序每行一个长度为5的01串。 样例输出00000000010001000011&lt;以下部分省略&gt;","text":"在刷蓝桥杯试题时候，有一道很意思又有丶烧脑的题目👇 资源限制时间限制：1.0s 内存限制：256.0MB 问题描述对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是： 00000 00001 00010 00011 00100 请按从小到大的顺序输出这32种01串。 输入格式本试题没有输入。 输出格式输出32行，按从小到大的顺序每行一个长度为5的01串。 样例输出00000000010001000011&lt;以下部分省略&gt; 提交代码（Java）暴力输出刚开始想不出什么好办法，就直接把32个都写出来。抱着玩的心态，试试暴力输出看看系统给不给过，但是没想到，还真给我过了hhh public class Main { public static void main(String[] args) { System.out.println(\"00000\"); System.out.println(\"00001\"); System.out.println(\"00010\"); System.out.println(\"00011\"); System.out.println(\"00100\"); System.out.println(\"00101\"); System.out.println(\"00110\"); System.out.println(\"00111\"); System.out.println(\"01000\"); System.out.println(\"01001\"); System.out.println(\"01010\"); System.out.println(\"01011\"); System.out.println(\"01100\"); System.out.println(\"01101\"); System.out.println(\"01110\"); System.out.println(\"01111\"); System.out.println(\"10000\"); System.out.println(\"10001\"); System.out.println(\"10010\"); System.out.println(\"10011\"); System.out.println(\"10100\"); System.out.println(\"10101\"); System.out.println(\"10110\"); System.out.println(\"10111\"); System.out.println(\"11000\"); System.out.println(\"11001\"); System.out.println(\"11010\"); System.out.println(\"11011\"); System.out.println(\"11100\"); System.out.println(\"11101\"); System.out.println(\"11110\"); System.out.println(\"11111\"); } } 五层循环这是我想到的第二个方法，就类似说的“逢二进一”吧 public class Main { public static void main(String[] args) { int a,b,c,d,e; for(a=0;a&lt;2;++a) for(b=0;b&lt;2;++b) for(c=0;c&lt;2;++c) for(d=0;d&lt;2;++d) for(e=0;e&lt;2;++e) System.out.printf(\"%d%d%d%d%d\\n\",a,b,c,d,e); } } 以下两种方法均来自网络。 十进制转换二进制public class Main { public static void main(String[] args) { for(int i=0;i&lt;32;i++){ int a,b,c,d,e; a = i%32/16; b = i%16/8; c = i%8/4; d = i%4/2; e = i%2; System.out.printf(\"%d%d%d%d%d\\n\",a,b,c,d,e); } } } 以下标求1一共是32个串，给每个串设置0-31的下标。根据下标，寻找对应串中1出现的位置。👇 比如，下标3表示的串是“00011”，利用while循环可以找到出现1的下标是1、2 public class Main { public static void main(String[] args) { for(int i=0;i&lt;=31;i++){ int a[]= new int[5];// 默认初始化值为0 //或 int a[]= {0,0,0,0,0}; int temp=i; int index=0; while(temp!=0) { a[index]=temp%2; index++; temp/=2; } for(int idx=4;idx&gt;=0;idx--) System.out.print(a[idx]); System.out.println(); } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://melodyjerry.github.io/blog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"使用fancybox标签实现图片浏览器","slug":"使用-fancybox-标签实现图片浏览器","date":"2020-02-07T12:42:55.000Z","updated":"2020-02-07T15:20:51.233Z","comments":true,"path":"2020/02/07/使用-fancybox-标签实现图片浏览器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/%E4%BD%BF%E7%94%A8-fancybox-%E6%A0%87%E7%AD%BE%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E5%99%A8/","excerpt":"使用&lt;fancybox&gt;&lt;/fancybox&gt;标签实现图片浏览器 单张图，只提供放大🔍关闭❌两个按钮，见黄色标记👇 多张图，可幻灯片播放，见红色标记👇","text":"使用&lt;fancybox&gt;&lt;/fancybox&gt;标签实现图片浏览器 单张图，只提供放大🔍关闭❌两个按钮，见黄色标记👇 多张图，可幻灯片播放，见红色标记👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"蓝桥杯-入门训练-Fibonacci数列","slug":"蓝桥杯—-入门训练-Fibonacci数列","date":"2020-02-07T11:48:54.000Z","updated":"2020-02-07T15:20:51.243Z","comments":true,"path":"2020/02/07/蓝桥杯—-入门训练-Fibonacci数列/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E2%80%94-%E5%85%A5%E9%97%A8%E8%AE%AD%E7%BB%83-Fibonacci%E6%95%B0%E5%88%97/","excerpt":"资源限制时间限制：1.0s 内存限制：256.0MB 问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 样例输入10 样例输出55 样例输入22 样例输出7704 数据规模与约定1 &lt;= n &lt;= 1,000,000。","text":"资源限制时间限制：1.0s 内存限制：256.0MB 问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 样例输入10 样例输出55 样例输入22 样例输出7704 数据规模与约定1 &lt;= n &lt;= 1,000,000。 提交代码（Java）第一次提交第一次时候，我想使用递归的方式👇 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(F(n)%10007); sc.close(); } private static int F(int n) { if(n==1||n==2) return 1; else return F(n-1)+F(n-2); } } 提交后，系统提示【运行超时】👇 第二次提交使用递归来处理，比较耗时。 而且这次我按照题目的提示【说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。】来处理，就改用数组来实现👇 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int F[] = new int[n+2]; F[1] = F[2] = 1; if(n &gt; 2) { for(int i=3; i&lt;=n; i++) // F[i]直接计算到求余数的值，即保存余数 F[i]=(F[i-1]+F[i-2])%10007; } //F[n]即所求值 System.out.println(F[n]); sc.close(); } } 这次直接通过👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://melodyjerry.github.io/blog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"Java之printf格式化输出的例子","slug":"Java之printf格式化输出的例子","date":"2020-02-07T09:46:23.000Z","updated":"2020-02-07T15:20:51.226Z","comments":true,"path":"2020/02/07/Java之printf格式化输出的例子/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/Java%E4%B9%8Bprintf%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%9A%84%E4%BE%8B%E5%AD%90/","excerpt":"转载自菜鸟教程","text":"转载自菜鸟教程 import java.util.Date; /** * 使用printf输出 */ /**关键技术点 * 使用java.io.PrintStream的printf方法实现C风格的输出 * printf 方法的第一个参数为输出的格式,第二个参数是可变长的,表示待输出的数据对象 */ public class Printf { public static void main(String[] args) { /*** 输出字符串 ***/ // %s表示输出字符串，也就是将后面的字符串替换模式中的%s System.out.printf(\"%s\", new Integer(1212)); // %n表示换行 System.out.printf(\"%s%n\", \"end line\"); // 还可以支持多个参数 System.out.printf(\"%s = %s%n\", \"Name\", \"Zhangsan\"); // %S将字符串以大写形式输出 System.out.printf(\"%S = %s%n\", \"Name\", \"Zhangsan\"); // 支持多个参数时，可以在%s之间插入变量编号，1$表示第一个字符串，3$表示第3个字符串 System.out.printf(\"%1$s = %3$s %2$s%n\", \"Name\", \"san\", \"Zhang\"); /*** 输出boolean类型 ***/ System.out.printf(\"true = %b; false = \", true); System.out.printf(\"%b%n\", false); /*** 输出整数类型***/ Integer iObj = 342; // %d表示将整数格式化为10进制整数 System.out.printf(\"%d; %d; %d%n\", -500, 2343L, iObj); // %o表示将整数格式化为8进制整数 System.out.printf(\"%o; %o; %o%n\", -500, 2343L, iObj); // %x表示将整数格式化为16进制整数 System.out.printf(\"%x; %x; %x%n\", -500, 2343L, iObj); // %X表示将整数格式化为16进制整数，并且字母变成大写形式 System.out.printf(\"%X; %X; %X%n\", -500, 2343L, iObj); /*** 输出浮点类型***/ Double dObj = 45.6d; // %e表示以科学技术法输出浮点数 System.out.printf(\"%e; %e; %e%n\", -756.403f, 7464.232641d, dObj); // %E表示以科学技术法输出浮点数，并且为大写形式 System.out.printf(\"%E; %E; %E%n\", -756.403f, 7464.232641d, dObj); // %f表示以十进制格式化输出浮点数 System.out.printf(\"%f; %f; %f%n\", -756.403f, 7464.232641d, dObj); // 还可以限制小数点后的位数 System.out.printf(\"%.1f; %.3f; %f%n\", -756.403f, 7464.232641d, dObj); /*** 输出日期类型***/ // %t表示格式化日期时间类型，%T是时间日期的大写形式，在%t之后用特定的字母表示不同的输出格式 Date date = new Date(); long dataL = date.getTime(); // 格式化年月日 // %t之后用y表示输出日期的年份（2位数的年，如99） // %t之后用m表示输出日期的月份，%t之后用d表示输出日期的日号 System.out.printf(\"%1$ty-%1$tm-%1$td; %2$ty-%2$tm-%2$td%n\", date, dataL); // %t之后用Y表示输出日期的年份（4位数的年）， // %t之后用B表示输出日期的月份的完整名， %t之后用b表示输出日期的月份的简称 System.out.printf(\"%1$tY-%1$tB-%1$td; %2$tY-%2$tb-%2$td%n\", date, dataL); // 以下是常见的日期组合 // %t之后用D表示以 \"%tm/%td/%ty\"格式化日期 System.out.printf(\"%1$tD%n\", date); //%t之后用F表示以\"%tY-%tm-%td\"格式化日期 System.out.printf(\"%1$tF%n\", date); /*** 输出时间类型***/ // 输出时分秒 // %t之后用H表示输出时间的时（24进制），%t之后用I表示输出时间的时（12进制）， // %t之后用M表示输出时间的分，%t之后用S表示输出时间的秒 System.out.printf(\"%1$tH:%1$tM:%1$tS; %2$tI:%2$tM:%2$tS%n\", date, dataL); // %t之后用L表示输出时间的秒中的毫秒 System.out.printf(\"%1$tH:%1$tM:%1$tS %1$tL%n\", date); // %t之后p表示输出时间的上午或下午信息 System.out.printf(\"%1$tH:%1$tM:%1$tS %1$tL %1$tp%n\", date); // 以下是常见的时间组合 // %t之后用R表示以\"%tH:%tM\"格式化时间 System.out.printf(\"%1$tR%n\", date); // %t之后用T表示以\"%tH:%tM:%tS\"格式化时间 System.out.printf(\"%1$tT%n\", date); // %t之后用r表示以\"%tI:%tM:%tS %Tp\"格式化时间 System.out.printf(\"%1$tr%n\", date); /*** 输出星期***/ // %t之后用A表示得到星期几的全称 System.out.printf(\"%1$tF %1$tA%n\", date); // %t之后用a表示得到星期几的简称 System.out.printf(\"%1$tF %1$ta%n\", date); // 输出时间日期的完整信息 System.out.printf(\"%1$tc%n\", date); } } /** *printf方法中,格式为\"%s\"表示以字符串的形式输出第二个可变长参数的第一个参数值; *格式为\"%n\"表示换行;格式为\"%S\"表示将字符串以大写形式输出;在\"%s\"之间用\"n$\"表示 *输出可变长参数的第n个参数值.格式为\"%b\"表示以布尔值的形式输出第二个可变长参数 *的第一个参数值. */ /** * 格式为\"%d\"表示以十进制整数形式输出;\"%o\"表示以八进制形式输出;\"%x\"表示以十六进制 * 输出;\"%X\"表示以十六进制输出,并且将字母(A、B、C、D、E、F)换成大写.格式为\"%e\"表 * 以科学计数法输出浮点数;格式为\"%E\"表示以科学计数法输出浮点数,而且将e大写;格式为 * \"%f\"表示以十进制浮点数输出,在\"%f\"之间加上\".n\"表示输出时保留小数点后面n位. */ /** * 格式为\"%t\"表示输出时间日期类型.\"%t\"之后用y表示输出日期的二位数的年份(如99)、用m * 表示输出日期的月份,用d表示输出日期的日号;\"%t\"之后用Y表示输出日期的四位数的年份 * (如1999)、用B表示输出日期的月份的完整名,用b表示输出日期的月份的简称.\"%t\"之后用D * 表示以\"%tm/%td/%ty\"的格式输出日期、用F表示以\"%tY-%tm-%td\"的格式输出日期. */ /** * \"%t\"之后用H表示输出时间的时(24进制),用I表示输出时间的时(12进制),用M表示输出时间 * 分,用S表示输出时间的秒,用L表示输出时间的秒中的毫秒数、用 p 表示输出时间的是上午还是 * 下午.\"%t\"之后用R表示以\"%tH:%tM\"的格式输出时间、用T表示以\"%tH:%tM:%tS\"的格式输出 * 时间、用r表示以\"%tI:%tM:%tS %Tp\"的格式输出时间. */ /** * \"%t\"之后用A表示输出日期的全称,用a表示输出日期的星期简称. */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}],"author":{"name":"菜鸟教程","url":"https://www.runoob.com/"}},{"title":"给博客添加一些挂件","slug":"转-给博客添加一些挂件","date":"2020-02-05T14:40:27.000Z","updated":"2020-04-23T06:23:01.981Z","comments":true,"path":"2020/02/05/转-给博客添加一些挂件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/%E8%BD%AC-%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E6%8C%82%E4%BB%B6/","excerpt":"阅读了官方文档 和 TRHX‘S BLOG 等文档/文章后，搜集了一部分教程","text":"阅读了官方文档 和 TRHX‘S BLOG 等文档/文章后，搜集了一部分教程 自定义鼠标指针样式在 \\themes\\material-x\\source\\less\\_base.less 文件 body 样式里写入如下代码： body { cursor: url(https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur),auto; background-color: @theme_background; ...... ...... } 鼠标指针可以用 Axialis CursorWorkshop 这个软件自己制作，不同主题具体放的文件有所不同，确保在博客主体 body 的 CSS 文件中即可，其中的鼠标指针链接可替换成自己的，首先尝试加载 https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur ，如果该文件不存在或由于其他原因无效，那么 auto 会被使用，也就是自动默认效果，图片格式为.ico、.ani、.cur，建议使用.cur，如果使用.ani或者其他格式无效，原因是浏览器兼容问题，请阅读参考文档或者参考以下兼容表： 浏览器 最低版本 格式 Internet Explorer 6.0 .cur / .ani Firefox (Gecko), Windows and Linux 1.5 (1.8) .cur / .png / .gif / .jpg Firefox (Gecko) 4.0 (2.0) .cur / .png / .gif / .jpg / .svg Opera — — Safari (Webkit) 3.0 (522-523) .cur / .png / .gif / .jpg 拓展阅读：《CSS 鼠标样式 cursor属性》 （By：歪脖先生的博客） 打字特效（蓝色）&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.11\"&gt;&lt;/script&gt; &lt;script&gt;var typed = new Typed(\"#subtitle\", { strings: [\"Live a good life, write some good code !!!\", \"愿自己的努力终将获得回报。\", \"花开不是为了花落，而是为了开的更加灿烂。\", \"没有伞的孩子必须努力奔跑！\", \"欲望以提升热忱，毅力以磨平高山。\", \"如果放弃太早，你永远都不知道自己会错过什么。\", \"没有礁石，就没有美丽的浪花；没有挫折，就没有壮丽的人生。\"], startDelay: 1000, typeSpeed: 100, loop: !0, backSpeed: 60, backDelay: 2000, showCursor: !0 })&lt;/script&gt; &lt;div style=\"text-align: center;font-weight: bold;color: #1BC3FB;\"&gt; &lt;span id=\"subtitle\"&gt;没有伞的孩子必须努力奔跑！&lt;/span&gt;&lt;span class=\"typed-cursor typed-cursor--blink\"&gt;|&lt;/span&gt; &lt;span id=\"typed-cursor\"&gt;&lt;/span&gt; &lt;/div&gt; 效果 👇 var typed = new Typed(\"#subtitle\", { strings: [\"Live a good life, write some good code !!!\", \"愿自己的努力终将获得回报。\", \"花开不是为了花落，而是为了开的更加灿烂。\", \"没有伞的孩子必须努力奔跑！\", \"欲望以提升热忱，毅力以磨平高山。\", \"如果放弃太早，你永远都不知道自己会错过什么。\", \"没有礁石，就没有美丽的浪花；没有挫折，就没有壮丽的人生。\"], startDelay: 1000, typeSpeed: 100, loop: !0, backSpeed: 60, backDelay: 2000, showCursor: !0 }) 没有伞的孩子必须努力奔跑！| 网站访客地理信息 在.\\themes\\material-x\\layout\\layout.ejs中加入以下代码： &lt;!--网站访客地理信息--&gt; &lt;script type=\"text/javascript\" src=\"//rf.revolvermaps.com/0/0/8.js?i=5eqiqb8vl6p&amp;amp;m=2&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=33&amp;amp;z=17&amp;amp;rx=-40&amp;amp;lx=-540&amp;amp;ly=520&amp;amp;hi=60\" async=\"async\"&gt;&lt;/script&gt; 效果 👇 天气挂件 JS代码，用于将插件插入到网页内 &lt;div id=\"tp-weather-widget\"&gt;&lt;/div&gt; &lt;script&gt; (function(a,h,g,f,e,d,c,b){b=function(){d=h.createElement(g);c=h.getElementsByTagName(g)[0];d.src=e;d.charset=\"utf-8\";d.async=1;c.parentNode.insertBefore(d,c)};a[\"SeniverseWeatherWidgetObject\"]=f;a[f]||(a[f]=function(){(a[f].q=a[f].q||[]).push(arguments)});a[f].l=+new Date();if(a.attachEvent){a.attachEvent(\"onload\",b)}else{a.addEventListener(\"load\",b,false)}}(window,document,\"script\",\"SeniverseWeatherWidget\",\"//cdn.sencdn.com/widget2/static/js/bundle.js?t=\"+parseInt((new Date().getTime() / 100000000).toString(),10))); window.SeniverseWeatherWidget('show', { flavor: \"bubble\", location: \"WS0E9D8WN298\", geolocation: true, language: \"zh-Hans\", unit: \"c\", theme: \"auto\", token: \"5fd5b254-57fe-4f8a-8a13-f92485efeb0b\", hover: \"enabled\", container: \"tp-weather-widget\" }) &lt;/script&gt; 插件网页版链接，用于嵌入到iframe或webview中 &lt;iframe&gt;weather.seniverse.com/?token=5fd5b254-57fe-4f8a-8a13-f92485efeb0b&lt;/iframe&gt; 效果：见本博客页面左上角 背景添加动态线条效果在 .\\themes\\hexo-theme-spfk\\layout\\layout.ejs文件中添加如下代码： &lt;!--动态线条背景--&gt; &lt;script type=\"text/javascript\" color=\"220,220,220\" opacity='0.7' zIndex=\"-2\" count=\"200\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt; &lt;/script&gt; 其中： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0） opacity：表示线条透明度（0~1），默认：0.5 count：表示线条的总数量，默认：150 zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1 人体时钟无意中发现了个有趣的人体时钟 HONE HONE CLOCK，作者是个日本人，点击此处访问作者博客，点击此处在作者原博客上查看动态样式，点击此处查看动态大图，如果你的博客上有合适的地方，加上一个人体时钟会很有趣的 实现代码： &lt;!--人体时钟背景透明--&gt; &lt;script charset=\"Shift_JIS\" src=\"http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.js\"&gt;&lt;/script&gt; &lt;!--人体时钟背景白--&gt; &lt;script charset=\"Shift_JIS\" src=\"http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.js\"&gt;&lt;/script&gt; 背景动态彩带效果样式一是鼠标点击后彩带自动更换样式，样式二是飘动的彩带： 实现方法：在 \\themes\\material-x\\layout\\layout.ejs 文件的body前面添加如下代码： &lt;!-- 样式一（鼠标点击更换样式） --&gt; &lt;script src=\"https://g.joyinshare.com/hc/ribbon.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;!-- 样式二（飘动的彩带） --&gt; &lt;script src=\"https://g.joyinshare.com/hc/piao.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 樱花特效canvas樱花飘落动画特效 &lt;script&gt; var RENDERER = { INIT_CHERRY_BLOSSOM_COUNT : 30, MAX_ADDING_INTERVAL : 10, init : function(){ this.setParameters(); this.reconstructMethods(); this.createCherries(); this.render(); }, setParameters : function(){ this.$container = $('#jsi-cherry-container'); this.width = this.$container.width(); this.height = this.$container.height(); this.context = $('&lt;canvas /&gt;').attr({width : this.width, height : this.height}).appendTo(this.$container).get(0).getContext('2d'); this.cherries = []; this.maxAddingInterval = Math.round(this.MAX_ADDING_INTERVAL * 1000 / this.width); this.addingInterval = this.maxAddingInterval; }, reconstructMethods : function(){ this.render = this.render.bind(this); }, createCherries : function(){ for(var i = 0, length = Math.round(this.INIT_CHERRY_BLOSSOM_COUNT * this.width / 1000); i &lt; length; i++){ this.cherries.push(new CHERRY_BLOSSOM(this, true)); } }, render : function(){ requestAnimationFrame(this.render); this.context.clearRect(0, 0, this.width, this.height); this.cherries.sort(function(cherry1, cherry2){ return cherry1.z - cherry2.z; }); for(var i = this.cherries.length - 1; i &gt;= 0; i--){ if(!this.cherries[i].render(this.context)){ this.cherries.splice(i, 1); } } if(--this.addingInterval == 0){ this.addingInterval = this.maxAddingInterval; this.cherries.push(new CHERRY_BLOSSOM(this, false)); } } }; var CHERRY_BLOSSOM = function(renderer, isRandom){ this.renderer = renderer; this.init(isRandom); }; CHERRY_BLOSSOM.prototype = { FOCUS_POSITION : 300, FAR_LIMIT : 600, MAX_RIPPLE_COUNT : 100, RIPPLE_RADIUS : 100, SURFACE_RATE : 0.5, SINK_OFFSET : 20, init : function(isRandom){ this.x = this.getRandomValue(-this.renderer.width, this.renderer.width); this.y = isRandom ? this.getRandomValue(0, this.renderer.height) : this.renderer.height * 1.5; this.z = this.getRandomValue(0, this.FAR_LIMIT); this.vx = this.getRandomValue(-2, 2); this.vy = -2; this.theta = this.getRandomValue(0, Math.PI * 2); this.phi = this.getRandomValue(0, Math.PI * 2); this.psi = 0; this.dpsi = this.getRandomValue(Math.PI / 600, Math.PI / 300); this.opacity = 0; this.endTheta = false; this.endPhi = false; this.rippleCount = 0; var axis = this.getAxis(), theta = this.theta + Math.ceil(-(this.y + this.renderer.height * this.SURFACE_RATE) / this.vy) * Math.PI / 500; theta %= Math.PI * 2; this.offsetY = 40 * ((theta &lt;= Math.PI / 2 || theta &gt;= Math.PI * 3 / 2) ? -1 : 1); this.thresholdY = this.renderer.height / 2 + this.renderer.height * this.SURFACE_RATE * axis.rate; this.entityColor = this.renderer.context.createRadialGradient(0, 40, 0, 0, 40, 80); this.entityColor.addColorStop(0, 'hsl(330, 70%, ' + 50 * (0.3 + axis.rate) + '%)'); this.entityColor.addColorStop(0.05, 'hsl(330, 40%,' + 55 * (0.3 + axis.rate) + '%)'); this.entityColor.addColorStop(1, 'hsl(330, 20%, ' + 70 * (0.3 + axis.rate) + '%)'); this.shadowColor = this.renderer.context.createRadialGradient(0, 40, 0, 0, 40, 80); this.shadowColor.addColorStop(0, 'hsl(330, 40%, ' + 30 * (0.3 + axis.rate) + '%)'); this.shadowColor.addColorStop(0.05, 'hsl(330, 40%,' + 30 * (0.3 + axis.rate) + '%)'); this.shadowColor.addColorStop(1, 'hsl(330, 20%, ' + 40 * (0.3 + axis.rate) + '%)'); }, getRandomValue : function(min, max){ return min + (max - min) * Math.random(); }, getAxis : function(){ var rate = this.FOCUS_POSITION / (this.z + this.FOCUS_POSITION), x = this.renderer.width / 2 + this.x * rate, y = this.renderer.height / 2 - this.y * rate; return {rate : rate, x : x, y : y}; }, renderCherry : function(context, axis){ context.beginPath(); context.moveTo(0, 40); context.bezierCurveTo(-60, 20, -10, -60, 0, -20); context.bezierCurveTo(10, -60, 60, 20, 0, 40); context.fill(); for(var i = -4; i &lt; 4; i++){ context.beginPath(); context.moveTo(0, 40); context.quadraticCurveTo(i * 12, 10, i * 4, -24 + Math.abs(i) * 2); context.stroke(); } }, render : function(context){ var axis = this.getAxis(); if(axis.y == this.thresholdY &amp;&amp; this.rippleCount &lt; this.MAX_RIPPLE_COUNT){ context.save(); context.lineWidth = 2; context.strokeStyle = 'hsla(0, 0%, 100%, ' + (this.MAX_RIPPLE_COUNT - this.rippleCount) / this.MAX_RIPPLE_COUNT + ')'; context.translate(axis.x + this.offsetY * axis.rate * (this.theta &lt;= Math.PI ? -1 : 1), axis.y); context.scale(1, 0.3); context.beginPath(); context.arc(0, 0, this.rippleCount / this.MAX_RIPPLE_COUNT * this.RIPPLE_RADIUS * axis.rate, 0, Math.PI * 2, false); context.stroke(); context.restore(); this.rippleCount++; } if(axis.y &lt; this.thresholdY || (!this.endTheta || !this.endPhi)){ if(this.y &lt;= 0){ this.opacity = Math.min(this.opacity + 0.01, 1); } context.save(); context.globalAlpha = this.opacity; context.fillStyle = this.shadowColor; context.strokeStyle = 'hsl(330, 30%,' + 40 * (0.3 + axis.rate) + '%)'; context.translate(axis.x, Math.max(axis.y, this.thresholdY + this.thresholdY - axis.y)); context.rotate(Math.PI - this.theta); context.scale(axis.rate * -Math.sin(this.phi), axis.rate); context.translate(0, this.offsetY); this.renderCherry(context, axis); context.restore(); } context.save(); context.fillStyle = this.entityColor; context.strokeStyle = 'hsl(330, 40%,' + 70 * (0.3 + axis.rate) + '%)'; context.translate(axis.x, axis.y + Math.abs(this.SINK_OFFSET * Math.sin(this.psi) * axis.rate)); context.rotate(this.theta); context.scale(axis.rate * Math.sin(this.phi), axis.rate); context.translate(0, this.offsetY); this.renderCherry(context, axis); context.restore(); if(this.y &lt;= -this.renderer.height / 4){ if(!this.endTheta){ for(var theta = Math.PI / 2, end = Math.PI * 3 / 2; theta &lt;= end; theta += Math.PI){ if(this.theta &lt; theta &amp;&amp; this.theta + Math.PI / 200 &gt; theta){ this.theta = theta; this.endTheta = true; break; } } } if(!this.endPhi){ for(var phi = Math.PI / 8, end = Math.PI * 7 / 8; phi &lt;= end; phi += Math.PI * 3 / 4){ if(this.phi &lt; phi &amp;&amp; this.phi + Math.PI / 200 &gt; phi){ this.phi = Math.PI / 8; this.endPhi = true; break; } } } } if(!this.endTheta){ if(axis.y == this.thresholdY){ this.theta += Math.PI / 200 * ((this.theta &lt; Math.PI / 2 || (this.theta &gt;= Math.PI &amp;&amp; this.theta &lt; Math.PI * 3 / 2)) ? 1 : -1); }else{ this.theta += Math.PI / 500; } this.theta %= Math.PI * 2; } if(this.endPhi){ if(this.rippleCount == this.MAX_RIPPLE_COUNT){ this.psi += this.dpsi; this.psi %= Math.PI * 2; } }else{ this.phi += Math.PI / ((axis.y == this.thresholdY) ? 200 : 500); this.phi %= Math.PI; } if(this.y &lt;= -this.renderer.height * this.SURFACE_RATE){ this.x += 2; this.y = -this.renderer.height * this.SURFACE_RATE; }else{ this.x += this.vx; this.y += this.vy; } return this.z &gt; -this.FOCUS_POSITION &amp;&amp; this.z &lt; this.FAR_LIMIT &amp;&amp; this.x &lt; this.renderer.width * 1.5; } }; $(function(){ RENDERER.init(); });&lt;/script&gt; 或者 &lt;div id=\"jsi-cherry-container\" class=\"container\"&gt;&lt;canvas width=\"1536\" height=\"80\"&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var RENDERER = { INIT_CHERRY_BLOSSOM_COUNT : 30, MAX_ADDING_INTERVAL : 10, init : function(){ this.setParameters(); this.reconstructMethods(); this.createCherries(); this.render(); }, setParameters : function(){ this.$container = $('#jsi-cherry-container'); this.width = this.$container.width(); this.height = this.$container.height(); this.context = $('&lt;canvas /&gt;').attr({width : this.width, height : this.height}).appendTo(this.$container).get(0).getContext('2d'); this.cherries = []; this.maxAddingInterval = Math.round(this.MAX_ADDING_INTERVAL * 1000 / this.width); this.addingInterval = this.maxAddingInterval; }, reconstructMethods : function(){ this.render = this.render.bind(this); }, createCherries : function(){ for(var i = 0, length = Math.round(this.INIT_CHERRY_BLOSSOM_COUNT * this.width / 1000); i &lt; length; i++){ this.cherries.push(new CHERRY_BLOSSOM(this, true)); } }, render : function(){ requestAnimationFrame(this.render); this.context.clearRect(0, 0, this.width, this.height); this.cherries.sort(function(cherry1, cherry2){ return cherry1.z - cherry2.z; }); for(var i = this.cherries.length - 1; i &gt;= 0; i--){ if(!this.cherries[i].render(this.context)){ this.cherries.splice(i, 1); } } if(--this.addingInterval == 0){ this.addingInterval = this.maxAddingInterval; this.cherries.push(new CHERRY_BLOSSOM(this, false)); } } }; var CHERRY_BLOSSOM = function(renderer, isRandom){ this.renderer = renderer; this.init(isRandom); }; CHERRY_BLOSSOM.prototype = { FOCUS_POSITION : 300, FAR_LIMIT : 600, MAX_RIPPLE_COUNT : 100, RIPPLE_RADIUS : 100, SURFACE_RATE : 0.5, SINK_OFFSET : 20, init : function(isRandom){ this.x = this.getRandomValue(-this.renderer.width, this.renderer.width); this.y = isRandom ? this.getRandomValue(0, this.renderer.height) : this.renderer.height * 1.5; this.z = this.getRandomValue(0, this.FAR_LIMIT); this.vx = this.getRandomValue(-2, 2); this.vy = -2; this.theta = this.getRandomValue(0, Math.PI * 2); this.phi = this.getRandomValue(0, Math.PI * 2); this.psi = 0; this.dpsi = this.getRandomValue(Math.PI / 600, Math.PI / 300); this.opacity = 0; this.endTheta = false; this.endPhi = false; this.rippleCount = 0; var axis = this.getAxis(), theta = this.theta + Math.ceil(-(this.y + this.renderer.height * this.SURFACE_RATE) / this.vy) * Math.PI / 500; theta %= Math.PI * 2; this.offsetY = 40 * ((theta &lt;= Math.PI / 2 || theta &gt;= Math.PI * 3 / 2) ? -1 : 1); this.thresholdY = this.renderer.height / 2 + this.renderer.height * this.SURFACE_RATE * axis.rate; this.entityColor = this.renderer.context.createRadialGradient(0, 40, 0, 0, 40, 80); this.entityColor.addColorStop(0, 'hsl(330, 70%, ' + 50 * (0.3 + axis.rate) + '%)'); this.entityColor.addColorStop(0.05, 'hsl(330, 40%,' + 55 * (0.3 + axis.rate) + '%)'); this.entityColor.addColorStop(1, 'hsl(330, 20%, ' + 70 * (0.3 + axis.rate) + '%)'); this.shadowColor = this.renderer.context.createRadialGradient(0, 40, 0, 0, 40, 80); this.shadowColor.addColorStop(0, 'hsl(330, 40%, ' + 30 * (0.3 + axis.rate) + '%)'); this.shadowColor.addColorStop(0.05, 'hsl(330, 40%,' + 30 * (0.3 + axis.rate) + '%)'); this.shadowColor.addColorStop(1, 'hsl(330, 20%, ' + 40 * (0.3 + axis.rate) + '%)'); }, getRandomValue : function(min, max){ return min + (max - min) * Math.random(); }, getAxis : function(){ var rate = this.FOCUS_POSITION / (this.z + this.FOCUS_POSITION), x = this.renderer.width / 2 + this.x * rate, y = this.renderer.height / 2 - this.y * rate; return {rate : rate, x : x, y : y}; }, renderCherry : function(context, axis){ context.beginPath(); context.moveTo(0, 40); context.bezierCurveTo(-60, 20, -10, -60, 0, -20); context.bezierCurveTo(10, -60, 60, 20, 0, 40); context.fill(); for(var i = -4; i &lt; 4; i++){ context.beginPath(); context.moveTo(0, 40); context.quadraticCurveTo(i * 12, 10, i * 4, -24 + Math.abs(i) * 2); context.stroke(); } }, render : function(context){ var axis = this.getAxis(); if(axis.y == this.thresholdY &amp;&amp; this.rippleCount &lt; this.MAX_RIPPLE_COUNT){ context.save(); context.lineWidth = 2; context.strokeStyle = 'hsla(0, 0%, 100%, ' + (this.MAX_RIPPLE_COUNT - this.rippleCount) / this.MAX_RIPPLE_COUNT + ')'; context.translate(axis.x + this.offsetY * axis.rate * (this.theta &lt;= Math.PI ? -1 : 1), axis.y); context.scale(1, 0.3); context.beginPath(); context.arc(0, 0, this.rippleCount / this.MAX_RIPPLE_COUNT * this.RIPPLE_RADIUS * axis.rate, 0, Math.PI * 2, false); context.stroke(); context.restore(); this.rippleCount++; } if(axis.y &lt; this.thresholdY || (!this.endTheta || !this.endPhi)){ if(this.y &lt;= 0){ this.opacity = Math.min(this.opacity + 0.01, 1); } context.save(); context.globalAlpha = this.opacity; context.fillStyle = this.shadowColor; context.strokeStyle = 'hsl(330, 30%,' + 40 * (0.3 + axis.rate) + '%)'; context.translate(axis.x, Math.max(axis.y, this.thresholdY + this.thresholdY - axis.y)); context.rotate(Math.PI - this.theta); context.scale(axis.rate * -Math.sin(this.phi), axis.rate); context.translate(0, this.offsetY); this.renderCherry(context, axis); context.restore(); } context.save(); context.fillStyle = this.entityColor; context.strokeStyle = 'hsl(330, 40%,' + 70 * (0.3 + axis.rate) + '%)'; context.translate(axis.x, axis.y + Math.abs(this.SINK_OFFSET * Math.sin(this.psi) * axis.rate)); context.rotate(this.theta); context.scale(axis.rate * Math.sin(this.phi), axis.rate); context.translate(0, this.offsetY); this.renderCherry(context, axis); context.restore(); if(this.y &lt;= -this.renderer.height / 4){ if(!this.endTheta){ for(var theta = Math.PI / 2, end = Math.PI * 3 / 2; theta &lt;= end; theta += Math.PI){ if(this.theta &lt; theta &amp;&amp; this.theta + Math.PI / 200 &gt; theta){ this.theta = theta; this.endTheta = true; break; } } } if(!this.endPhi){ for(var phi = Math.PI / 8, end = Math.PI * 7 / 8; phi &lt;= end; phi += Math.PI * 3 / 4){ if(this.phi &lt; phi &amp;&amp; this.phi + Math.PI / 200 &gt; phi){ this.phi = Math.PI / 8; this.endPhi = true; break; } } } } if(!this.endTheta){ if(axis.y == this.thresholdY){ this.theta += Math.PI / 200 * ((this.theta &lt; Math.PI / 2 || (this.theta &gt;= Math.PI &amp;&amp; this.theta &lt; Math.PI * 3 / 2)) ? 1 : -1); }else{ this.theta += Math.PI / 500; } this.theta %= Math.PI * 2; } if(this.endPhi){ if(this.rippleCount == this.MAX_RIPPLE_COUNT){ this.psi += this.dpsi; this.psi %= Math.PI * 2; } }else{ this.phi += Math.PI / ((axis.y == this.thresholdY) ? 200 : 500); this.phi %= Math.PI; } if(this.y &lt;= -this.renderer.height * this.SURFACE_RATE){ this.x += 2; this.y = -this.renderer.height * this.SURFACE_RATE; }else{ this.x += this.vx; this.y += this.vy; } return this.z &gt; -this.FOCUS_POSITION &amp;&amp; this.z &lt; this.FAR_LIMIT &amp;&amp; this.x &lt; this.renderer.width * 1.5; } }; $(function(){ RENDERER.init(); });&lt;/script&gt; 其他： H5樱花掉落背景动画特效 ：https://www.17sucai.com/pins/36303.html 添加背景代码雨特效新建 DigitalRain.js，写入以下代码： 复制window.onload = function(){ //获取画布对象 var canvas = document.getElementById(\"canvas\"); //获取画布的上下文 var context =canvas.getContext(\"2d\"); var s = window.screen; var W = canvas.width = s.width; var H = canvas.height; //获取浏览器屏幕的宽度和高度 //var W = window.innerWidth; //var H = window.innerHeight; //设置canvas的宽度和高度 canvas.width = W; canvas.height = H; //每个文字的字体大小 var fontSize = 12; //计算列 var colunms = Math.floor(W /fontSize); //记录每列文字的y轴坐标 var drops = []; //给每一个文字初始化一个起始点的位置 for(var i=0;i&lt;colunms;i++){ drops.push(0); } //运动的文字 var str =\"WELCOME TO WWW.ITRHX.COM\"; //4:fillText(str,x,y);原理就是去更改y的坐标位置 //绘画的函数 function draw(){ context.fillStyle = \"rgba(238,238,238,.08)\";//遮盖层 context.fillRect(0,0,W,H); //给字体设置样式 context.font = \"600 \"+fontSize+\"px Georgia\"; //给字体添加颜色 context.fillStyle = [\"#33B5E5\", \"#0099CC\", \"#AA66CC\", \"#9933CC\", \"#99CC00\", \"#669900\", \"#FFBB33\", \"#FF8800\", \"#FF4444\", \"#CC0000\"][parseInt(Math.random() * 10)];//randColor();可以rgb,hsl, 标准色，十六进制颜色 //写入画布中 for(var i=0;i&lt;colunms;i++){ var index = Math.floor(Math.random() * str.length); var x = i*fontSize; var y = drops[i] *fontSize; context.fillText(str[index],x,y); //如果要改变时间，肯定就是改变每次他的起点 if(y &gt;= canvas.height &amp;&amp; Math.random() &gt; 0.99){ drops[i] = 0; } drops[i]++; } }; function randColor(){//随机颜色 var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return \"rgb(\"+r+\",\"+g+\",\"+b+\")\"; } draw(); setInterval(draw,35); }; 在主题文件的相关css文件中（以 Material X 1.2.1 主题为例，在\\themes\\material-x-1.2.1\\source\\less_main.less 文件末尾）添加以下代码： 复制canvas { position: fixed; right: 0px; bottom: 0px; min-width: 100%; min-height: 100%; height: auto; width: auto; z-index: -1; } 然后在主题的 layout.ejs 文件中引入即可： 复制&lt;!-- 数字雨 --&gt; &lt;canvas id=\"canvas\" width=\"1440\" height=\"900\" &gt;&lt;/canvas&gt; &lt;script type=\"text/javascript\" src=\"/js/DigitalRain.js\"&gt;&lt;/script&gt; 最终效果： 自定义一个不使用主题模板渲染的独立页面 有时候我们需要新建一个独立的页面，这个页面不使用主题的渲染，具有自己独立的样式，可以放一些自己的作品，相册什么的，以下就介绍这种独立页面的实现方法。 方法一： 使用 Hexo 提供的跳过渲染配置，在博客根目录的配置文件 _config.yml 里找到 skip_render 关键字，在后面添加想要跳过渲染的页面，比如我们创建 \\source\\about\\index.html， 配置文件填写：skip_render: about\\**，那么就表示 \\source\\about 里所有的文件将跳过渲染，里面的文件将会被直接复制到 public 文件夹，此时就会得到一个独立的 about 页面；官方文档：https://hexo.io/docs/configuration 方法二： 在文章头部的 Front-matter 里添加配置 layout: false 来跳过渲染配置，比如我们要使 about 页面跳过渲染，创建 \\source\\about\\index.md，将这个页面的相关 HTML 代码写进.md文件并保存，然后在 index.md 的头部写入： --- layout: false --- {% raw %} 这里是 HTML 代码 {% endraw %} PS：Front-matter 是 .md 文件最上方以 — 分隔的区域，用于指定个别文件的变量，官方文档：https://hexo.io/docs/front-matter 效果可以对比我的博客主页和关于页面 更改本地预览端口号hexo博客在执行 hexo s 进行本地预览的时候，默认端口号是4000，当该端口号被占用时会报错 Error: listen EADDRINUSE 0.0.0.0:4000 ，此时可以关闭占用该端口的进程，也可以更换端口号，更换端口号可以通过以下两种方法实现： 方法一：在根目录的 _config.yml 配置文件内加上如下代码更改 hexo s 运行时的端口号： server: port: 5000 compress: true header: true 方法二：通过 hexo server -p 5000 命令来指定端口，这种方法只是本次执行有效 其他网页小挂件推荐 http://abowman.com/ 里面有很多有趣的小挂件，可以养养鱼、龟、狗、仓鼠等各式各样的虚拟宠物，能根据你的鼠标指针位置移动，直接复制代码就可以用 http://www.revolvermaps.com/ 它提供网站访客地理信息，可以以2D、3D等形式显示 http://www.amazingcounters.com/ 免费网站计数器，有非常多的样式供你选择，可以设置计数器初始数值，可以设置按访问量计数，也可以按独立访问者计数 https://www.seniverse.com/widget/get 心知天气提供基于Web的免费天气插件，可以为你的网站添加一项简洁美观的天气预报功能，并自动适配PC和手机上的浏览 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"[转]使用Hexo-Git-Backup插件备份你的Hexo博客","slug":"转-使用Hexo-Git-Backup插件备份你的Hexo博客","date":"2020-02-05T12:20:43.000Z","updated":"2020-02-07T15:20:51.244Z","comments":true,"path":"2020/02/05/转-使用Hexo-Git-Backup插件备份你的Hexo博客/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/%E8%BD%AC-%E4%BD%BF%E7%94%A8Hexo-Git-Backup%E6%8F%92%E4%BB%B6%E5%A4%87%E4%BB%BD%E4%BD%A0%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/","excerpt":"欢迎关注我的 CSDN 专栏：《个人博客搭建：Hexo+Github Pages》，从搭建到美化一条龙，帮你解决 Hexo 常见问题！ 由于 Hexo 博客是静态托管的，所有的原始数据都保存在本地，如果哪一天电脑坏了，或者是误删了本地数据，那就是叫天天不应叫地地不灵了，此时定时备份就显得比较重要了，常见的备份方法有：打包数据保存到U盘、云盘或者其他地方，但是早就有大神开发了备份插件：hexo-git-backup ，只需要一个命令就可以将所有数据包括主题文件备份到 github 了","text":"欢迎关注我的 CSDN 专栏：《个人博客搭建：Hexo+Github Pages》，从搭建到美化一条龙，帮你解决 Hexo 常见问题！ 由于 Hexo 博客是静态托管的，所有的原始数据都保存在本地，如果哪一天电脑坏了，或者是误删了本地数据，那就是叫天天不应叫地地不灵了，此时定时备份就显得比较重要了，常见的备份方法有：打包数据保存到U盘、云盘或者其他地方，但是早就有大神开发了备份插件：hexo-git-backup ，只需要一个命令就可以将所有数据包括主题文件备份到 github 了 首先进入你博客目录，输入命令 hexo version 查看 Hexo 版本，如图所示，我的版本是 3.7.1： 安装备份插件，如果你的 Hexo 版本是 2.x.x，则使用以下命令安装： $ npm install hexo-git-backup@0.0.91 --save 如果你的 Hexo 版本是 3.x.x，则使用以下命令安装： $ npm install hexo-git-backup --save 到 Hexo 博客根目录的 _config.yml 配置文件里添加以下配置： backup: type: git theme: material-x-1.2.1 message: Back up my www.itrhx.com blog repository: github: git@github.com:TRHX/TRHX.github.io.git,backup coding: git@git.dev.tencent.com:TRHX/TRHX.git,backup 参数解释： theme：你要备份的主题名称 message：自定义提交信息 repository：仓库名，注意仓库地址后面要添加一个分支名，比如我就创建了一个 backup 分支 最后使用以下命令备份你的博客： $ hexo backup 或者使用以下简写命令也可以： $ hexo b 备份成功后可以在你的仓库分支下看到备份的原始文件： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"}],"author":{"name":"TRHX","avatar":"https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.9/images/trhx.png","url":"https://www.itrhx.com/"}},{"title":"RSS订阅(含转载内容)","slug":"RSS订阅-含转载内容","date":"2020-02-05T12:06:45.000Z","updated":"2020-02-07T15:20:51.229Z","comments":true,"path":"2020/02/05/RSS订阅-含转载内容/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/RSS%E8%AE%A2%E9%98%85-%E5%90%AB%E8%BD%AC%E8%BD%BD%E5%86%85%E5%AE%B9/","excerpt":"添加RSS订阅RSS订阅是站点用来和其他站点之间共享内容的一种简易方式，即Really Simple Syndication（简易信息聚合），如果不会使用，可以参见百度百科：https://baike.baidu.com/item/RSS%E8%AE%A2%E9%98%85/663114 ；首先我们安装feed插件，在本地hexo目录下右键git bash here，输入以下命令： $ npm install hexo-generator-feed 等待安装完成后，打开hexo目录下配置文件的_config.yml，在末尾添加以下配置： # Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 随后打开主题配置文件_config.yml，添加以下配置： rss: /atom.xml 至此，RSS订阅功能添加完成 【注】以下内容转载自互联网，其作者：奔跑中的奶酪 《可能是目前最全的RSS订阅源了》导读继上一篇文章《当我们谈论RSS时，我们在谈论什么？ 》发布后，阅读甚少，反响也是平平。奶酪不得不承认一个事实，RSS 做为一种“上古神器”，如果你经历过 RSS 的风光时期，你会一直喜欢它。但如果你对它了解甚少，尽管我再如何推荐，高使用门槛还是很难让你对RSS喜欢得起来。 RSS 高门槛的主要原因在于，优质RSS阅读器选择少，以及订阅源的缺失。上一期我极力推荐了一款在线 RSS 阅读器 Feeder.co，它已经足够的优秀了。所以接下来的问题，就是解决如何寻找订阅源的问题了，而本期内容正是解决如何查找RSS 订阅源的问题。","text":"添加RSS订阅RSS订阅是站点用来和其他站点之间共享内容的一种简易方式，即Really Simple Syndication（简易信息聚合），如果不会使用，可以参见百度百科：https://baike.baidu.com/item/RSS%E8%AE%A2%E9%98%85/663114 ；首先我们安装feed插件，在本地hexo目录下右键git bash here，输入以下命令： $ npm install hexo-generator-feed 等待安装完成后，打开hexo目录下配置文件的_config.yml，在末尾添加以下配置： # Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 随后打开主题配置文件_config.yml，添加以下配置： rss: /atom.xml 至此，RSS订阅功能添加完成 【注】以下内容转载自互联网，其作者：奔跑中的奶酪 《可能是目前最全的RSS订阅源了》导读继上一篇文章《当我们谈论RSS时，我们在谈论什么？ 》发布后，阅读甚少，反响也是平平。奶酪不得不承认一个事实，RSS 做为一种“上古神器”，如果你经历过 RSS 的风光时期，你会一直喜欢它。但如果你对它了解甚少，尽管我再如何推荐，高使用门槛还是很难让你对RSS喜欢得起来。 RSS 高门槛的主要原因在于，优质RSS阅读器选择少，以及订阅源的缺失。上一期我极力推荐了一款在线 RSS 阅读器 Feeder.co，它已经足够的优秀了。所以接下来的问题，就是解决如何寻找订阅源的问题了，而本期内容正是解决如何查找RSS 订阅源的问题。 一、万物皆可RSS如果你细心观察就会发现，提供 RSS 相关服务的网站都是国外的，国内与 RSS 相关的网站都相继宣布关闭了。你会发现国内提供 RSS 相关服务的网站都是个人或者小机构，这其中有一个叫 RSSHub 的网站，是这其中的集大成者，它的作用是可以给任何奇奇怪怪的内容生成 RSS 订阅源。 一般网站和博客： 1). 通常在顶部菜单、右侧菜单、底部菜单等地方会有RSS图标。 2). 如果没有，可以尝试在网站地址后面加上/rss或者/feed，有时会出现在二级域名里。 3). 如果还没有，可以使用奶酪制作的小书签来自动查找RSS订阅源，订阅到Feeder ，订阅到Inoreader ，订阅到Feedly 4). 如果还是没有，可能网站没有提供RSS订阅。可以借用 Fivefilters.org 或者 Feedity.com来制作订阅源。 5). 对于一些只提供了摘要RSS的网站，可以使用 FeedEx.Net 来制作全文RSS。 论坛： 一般会有 RSS 图标，如果没有，在网址后面加上 ?mod=rss。 比如网址 http://bbs.kafan.cn/forum-215-1.html ，其 rss 地址为 http://bbs.kafan.cn/forum-215-1.html?mod=rss 微博： https://rsshub.app/weibo/user2/博主ID，比如 https://rsshub.app/weibo/user2/1195230310 微信公众号： 在 瓦斯阅读 搜索要订阅的公众号名称，就会有专门的RSS订阅地址。 简书： https://rsshub.app/jianshu/user/作者ID，比如 https://rsshub.app/jianshu/user/yZq3ZV B站： https://rsshub.app/bilibili/user/video/UP主ID，比如 https://rsshub.app/bilibili/user/video/2267573 贴吧： 精品贴订阅：https://rsshub.app/tieba/forum/good/贴吧吧名（支持中文）， 比如 https://rsshub.app/tieba/forum/good/哲学 知乎： 知乎热榜： https://rsshub.app/zhihu/hotlist 用户动态：https://rsshub.app/zhihu/people/activities/用户ID， 比如 https://rsshub.app/zhihu/people/activities/runningcheese 知乎专栏：https://rsshub.app/zhihu/zhuanlan/专栏ID， 比如 https://rsshub.app/zhihu/zhuanlan/methodology 知乎日报： 订阅： https://rsshub.app/zhihu/daily 分栏订阅： http://zhihurss.miantiao.me/section 豆瓣小组： https://www.douban.com/feed/group/豆瓣小组ID/discussion， 比如 https://www.douban.com/feed/group/beijing/discussion Twiter： https://rsshub.app/twitter/user/用户ID，比如 https://rsshub.app/twitter/user/runningcheese Instagram： https://rsshub.app/instagram/user/用户ID，比如 https://rsshub.app/instagram/user/runningcheeselive U2B： https://rsshub.app/youtube/user/用户ID，比如 https://rsshub.app/youtube/user/JFlaMusic/ https://rsshub.app/youtube/channel/频道ID，比如 https://rsshub.app/youtube/channel/UCDwDMPOZfxVV0x_dz0eQ8KQ Reddit： 在当前链接后面加入.rss，比如 https://www.reddit.com/r/nba/top/ 改成 https://www.reddit.com/r/nba/top/.rss 抖音： https://rsshub.app/douyin/user/用户ID，比如 https://rsshub.app/douyin/user/93610979153 网易云音乐： 1). 歌单歌曲https://rsshub.app/ncm/playlist/歌单ID，比如 https://rsshub.app/ncm/playlist/1523069432). 用户歌单https://rsshub.app/ncm/user/playlist/用户ID，比如 https://rsshub.app/ncm/user/playlist/709382423). 电台节目https://rsshub.app/ncm/djradio/电台ID，比如 https://rsshub.app/ncm/djradio/347317067 喜马拉雅： https://rsshub.app/ximalaya/album/专辑ID，比如 https://rsshub.app/ximalaya/album/299146 Github： 1). 用户动态: 地址 + .atom，比如 https://github.com/runningcheese.atom2). 仓库releases: 地址 + .atom，比如 https://github.com/soimort/you-get/releases.atom3). 仓库commits: 地址 + .atom，比如 https://github.com/runningcheese/RunningCheese-Firefox/commits/master.atom4). 仓库issues：https://rsshub.app/github/issue/用户名/仓库名，比如 https://rsshub.app/github/issue/runningcheese/RunningCheese-Firefox V2EX： 周报： http://vdaily.iu.vc/old-weekly.xml Dribble： https://rsshub.app/dribbble/user/用户ID，比如 https://rsshub.app/dribbble/user/google二、RSS的一些其他玩用法1、监视网页内任意内容的变化。 有一款叫 Distill Web Monitor 的拓展 （支持 Firefox / Chrome），可以让你监视网页某处内容的变化，并在第一时间通知你。 使用的场景非常多，比如监控某商城网站商品是否有货是否有降价，某网站上的房价涨跌提醒，某个页面是否有内容更新，某视频网站Po主发布新视频的提醒，再比如你是做运营的，想要监视竞争对手产品的动态，这款拓展都能做到。更加强大的地方在于它可以自定义提醒的条件，比如价格变化超过10%才提醒你。 2，指定新闻内容动态提醒。 Google Alerts 可以让用户指定监控的关键词，Google 会在第一时间内向用户推送新内容更新提醒，支持邮件提醒，也支持RSS提醒，非常方便，用户可以用这个功能来跟踪一些新闻报道，业界动态，获取最新的国际事件等等。 Google Alerts的最大作用就是：让用户能迅速而方便地获得其所关注的信息。Google Alerts能将有价值的信息主动推给用户，大大减少了用户获取信息的时间。实现了“不上网而知天下事”。百度也有类似产品。 3，RSS 配合 IFTTT IFTTT是“if this then that”的缩写，可以让你的网络行为能够引发连锁反应。以RSS为例，比如在你的RSS订阅源里出现了有关于”iPhone8”的信息，联接上IFTTT后就可以在手机上弹窗通知我们了。 结尾1，整理RSS订阅源是一件有趣的事情，上一期奶酪说过不推荐使用本地RSS阅读器，但本地RSS阅读器在整理RSS订阅源的时候非常方便（推荐使用拓展Feedbro，支持 Firefox / Chrome），你可以把订阅源在本地RSS阅读器里整理好后导出为 opml文件，再导入到在线RSS阅读器中去。2，下载链接如若失效，关注奶酪公众号（ID：runningcheese01）回复关键字“RSS”获取奶酪的opml文件，可一键导入。 高效方法论(8) 注：本文由 奔跑中的奶酪 作者：奔跑中的奶酪 发表，其版权均为作者所有，如需转载，请注明作者名字以及文章来源。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"将本地文件上传到GitHub","slug":"将本地文件上传到Github","date":"2020-02-05T11:28:23.000Z","updated":"2020-02-08T09:22:16.587Z","comments":true,"path":"2020/02/05/将本地文件上传到Github/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0Github/","excerpt":"百度“如何将文件上传到Github”，其中发现两篇很有用的教程： 使用git将项目上传到github（最简单方法）如何使用git把本地代码上传（更新）到github上","text":"百度“如何将文件上传到Github”，其中发现两篇很有用的教程： 使用git将项目上传到github（最简单方法）如何使用git把本地代码上传（更新）到github上 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"}]},{"title":"浏览器网页标签页图标显示","slug":"浏览器网页标签页图标显示","date":"2020-02-04T12:20:00.000Z","updated":"2020-02-07T15:20:51.240Z","comments":true,"path":"2020/02/04/浏览器网页标签页图标显示/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E9%A1%B5%E6%A0%87%E7%AD%BE%E9%A1%B5%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA/","excerpt":"","text":"对于IE浏览器：把需要显示的16x16像素的ICO图标命名为favicon.ICO放置在网站根目录下，浏览器会自动检索 对于其他浏览器通用的在标签页加入指定图标的方法：把favicon.ico图标放到网站根目录下，在网页的``&lt;head&gt;&lt;/head&gt;``中加入 &lt;!-- 地址栏显示 --&gt; &lt;link rel=\"Shortcut Icon\" href=\"./favicon.ico\" type=\"image/x-icon\" /&gt; &lt;!-- 收藏栏也显示 --&gt; &lt;link rel=\"Bookmark\" href=\"./favicon.ico\" type=\"image/x-icon\" /&gt; 火狐浏览器对图标格式没有那么严格，GIF和PNG格式的图标也可以显示，图标名称也可以不是favcion 链接在线的图片 &lt;link rel=\"Shortcut Icon\" href=\"http://csdnimg.cn/www/images/favicon.ico\"&gt; 获取ico图标的资源网 http://sc.chinaz.com/ favicon在线制作网站 https://tool.lu/favicon/ 图标制作，经常搞一些图标替换桌面图标 http://www.faviconico.org/ 或者在html的head表头中加 &lt;link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\" /&gt; 如果icon是gif动态图需要修改type属性 &lt;link rel=\"icon\" href=\"gif_favicon.gif\" type=\"image/gif\" &gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"}]},{"title":"文章作者","slug":"文章作者","date":"2020-02-03T09:36:53.000Z","updated":"2020-02-08T09:37:28.999Z","comments":true,"path":"2020/02/03/文章作者/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E4%BD%9C%E8%80%85/","excerpt":"由于支持多作者共同维护一个博客，所以可以设置单独一篇文章的作者： --- author: name: 作者 avatar: https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png url: https://baidu.com ---","text":"由于支持多作者共同维护一个博客，所以可以设置单独一篇文章的作者： --- author: name: 作者 avatar: https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png url: https://baidu.com --- document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"文章置顶","slug":"文章置顶","date":"2020-02-03T09:34:15.000Z","updated":"2020-02-08T09:36:28.899Z","comments":true,"path":"2020/02/03/文章置顶/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6/","excerpt":"在Front-matter中设置以下值： top: true 如果想自定义置顶标签的文字，可以直接设置为字符串，例如： top: 近期更新","text":"在Front-matter中设置以下值： top: true 如果想自定义置顶标签的文字，可以直接设置为字符串，例如： top: 近期更新 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"文章分类","slug":"文章分类","date":"2020-02-03T09:34:05.000Z","updated":"2020-02-08T09:36:28.898Z","comments":true,"path":"2020/02/03/文章分类/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/","excerpt":"多个分类有两种关系，一种是层级（等同于文件夹），一种是并列（等同于标签）。 多级分类 categories: [分类A, 分类B] 或者 categories: - 分类A - 分类B 并列分类 categories: - [分类A] - [分类B] 多级+并列分类 categories: - [分类A, 分类B] - [分类C, 分类D]","text":"多个分类有两种关系，一种是层级（等同于文件夹），一种是并列（等同于标签）。 多级分类 categories: [分类A, 分类B] 或者 categories: - 分类A - 分类B 并列分类 categories: - [分类A] - [分类B] 多级+并列分类 categories: - [分类A, 分类B] - [分类C, 分类D] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"文章音乐bgm","slug":"文章音乐bgm","date":"2020-02-03T09:14:27.000Z","updated":"2020-02-29T12:08:45.168Z","comments":true,"path":"2020/02/03/文章音乐bgm/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E9%9F%B3%E4%B9%90bgm/","excerpt":"标题右边显示迷你音乐播放器，支持的字段有：server、type、id，取值详见【进阶设定 -&gt; 第三方服务 -&gt; APlayer】。 示例--- music: enable: true # true（文章内和文章列表都显示） internal（只在文章内显示） autoplay: true # 自动播放。默认：false server: netease # netease（网易云音乐）tencent（QQ音乐） xiami（虾米） kugou（酷狗） type: song # song （单曲） album （专辑） playlist （歌单） search （搜索） id: 26664345 # 歌曲/专辑/歌单 ID volume: 0.3 #声音大小 --- 实际效果见：《文章专属BGM》","text":"标题右边显示迷你音乐播放器，支持的字段有：server、type、id，取值详见【进阶设定 -&gt; 第三方服务 -&gt; APlayer】。 示例--- music: enable: true # true（文章内和文章列表都显示） internal（只在文章内显示） autoplay: true # 自动播放。默认：false server: netease # netease（网易云音乐）tencent（QQ音乐） xiami（虾米） kugou（酷狗） type: song # song （单曲） album （专辑） playlist （歌单） search （搜索） id: 26664345 # 歌曲/专辑/歌单 ID volume: 0.3 #声音大小 --- 实际效果见：《文章专属BGM》 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"添加CNZZ统计代码","slug":"添加CNZZ统计代码","date":"2020-02-03T08:13:53.000Z","updated":"2020-02-07T15:20:51.245Z","comments":true,"path":"2020/02/03/添加CNZZ统计代码/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%B7%BB%E5%8A%A0CNZZ%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/","excerpt":"先在博客主题配置文件themes\\material-x_config.yml添加代码： #添加CNZZ统计 cnzz: true 这里这个cnzz的名字可以自己取；然后在themes\\material-x\\layout_partial里面创建一个 cnzz.ejs文件；把cnzz给的代码复制进去； &lt;% if (theme.cnzz){ %&gt; //这里添加复制的CNZZ代码 &lt;% } %&gt; 然后再在footer.ejs的后面添加上一行代码就可以显示了（这里的位置可以换，可以不是scripts.ejs，或者是head.ejs，看自己的喜好） &lt;!--CNZZ统计--&gt; &lt;%- partial('cnzz') %&gt; 对百度统计也可以进行同样的处理； &lt;% if (theme.cnzz){ %&gt;//前面要添加的代码 //百度统计的代码 &lt;% } %&gt; 与上面的操作基本一致只是取得名字不一样。 上面的是一种方法； 如果嫌麻烦的话直接就在footer.ejs的后面添加cnzz的代码；直接就可以显示了（同理，可以添加在其他位置），貌似添加在这里速度最快。 &lt;% if (theme.cnzz){ %&gt; //前面要添加的代码 //这里添加复制的CNZZ代码 &lt;% } %&gt; //后面要添加的 参考链接：https://blog.csdn.net/whjkm/article/details/37884563","text":"先在博客主题配置文件themes\\material-x_config.yml添加代码： #添加CNZZ统计 cnzz: true 这里这个cnzz的名字可以自己取；然后在themes\\material-x\\layout_partial里面创建一个 cnzz.ejs文件；把cnzz给的代码复制进去； &lt;% if (theme.cnzz){ %&gt; //这里添加复制的CNZZ代码 &lt;% } %&gt; 然后再在footer.ejs的后面添加上一行代码就可以显示了（这里的位置可以换，可以不是scripts.ejs，或者是head.ejs，看自己的喜好） &lt;!--CNZZ统计--&gt; &lt;%- partial('cnzz') %&gt; 对百度统计也可以进行同样的处理； &lt;% if (theme.cnzz){ %&gt;//前面要添加的代码 //百度统计的代码 &lt;% } %&gt; 与上面的操作基本一致只是取得名字不一样。 上面的是一种方法； 如果嫌麻烦的话直接就在footer.ejs的后面添加cnzz的代码；直接就可以显示了（同理，可以添加在其他位置），貌似添加在这里速度最快。 &lt;% if (theme.cnzz){ %&gt; //前面要添加的代码 //这里添加复制的CNZZ代码 &lt;% } %&gt; //后面要添加的 参考链接：https://blog.csdn.net/whjkm/article/details/37884563 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"即日起，博客双平台同步发布","slug":"即日起，博客双平台同步发布","date":"2020-02-03T05:36:56.000Z","updated":"2020-02-20T11:08:20.206Z","comments":true,"path":"2020/02/03/即日起，博客双平台同步发布/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E5%8D%B3%E6%97%A5%E8%B5%B7%EF%BC%8C%E5%8D%9A%E5%AE%A2%E5%8F%8C%E5%B9%B3%E5%8F%B0%E5%90%8C%E6%AD%A5%E5%8F%91%E5%B8%83/","excerpt":"为了确保博客网站的连接，经历6h的打造，现新增Gitee版，目前两个可用博客如下： Hexo+Github 版 https://melodyhub.ltd/ Hexo+Gitee 版 https://melodyjerry.gitee.io/（新增） 值得注意的是，除去连接速度的差异外，两个网站的区别： 后增的Gitee版暂无HomePage（动画主页），后续会计划加入 计划加入一些新的动画、特效等 优化部分cdn 调整卡片的透明度，计划值：80% 其他，略","text":"为了确保博客网站的连接，经历6h的打造，现新增Gitee版，目前两个可用博客如下： Hexo+Github 版 https://melodyhub.ltd/ Hexo+Gitee 版 https://melodyjerry.gitee.io/（新增） 值得注意的是，除去连接速度的差异外，两个网站的区别： 后增的Gitee版暂无HomePage（动画主页），后续会计划加入 计划加入一些新的动画、特效等 优化部分cdn 调整卡片的透明度，计划值：80% 其他，略 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"[转]Hexo 博客主题个性化","slug":"[转]Hexo 博客主题个性化","date":"2020-02-02T06:25:47.000Z","updated":"2020-02-07T15:20:51.231Z","comments":true,"path":"2020/02/02/[转]Hexo 博客主题个性化/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/02/[%E8%BD%AC]Hexo%20%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96/","excerpt":"permalink: https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/ 以下为原文的摘要： 本文将讲述一些博客主题的美化、实用功能的添加，本文以作者 luuman 的 spfk 主题和作者 xaoxuu 的 Material X 主题为例，文章会不定时进行更新。文章涉及有关参考资料、教程、链接如有侵权请联系我删除！ 本文在CSDN的链接：《Hexo 博客优化之博客美化》、《Hexo 博客优化之实用功能添加》，Hexo 博客专栏，从前期搭建到后期美化，帮您解决常见问题：《Github/Coding Pages + Hexo》，对您有帮助就点个赞吧❤️ 请注意：不同主题可能方法有些不同，相同主题不同版本，配置方法也有所差异！ 博客美化前提条件：有一定的前端基础，了解 HTML、CSS、JS，了解 CSS 预处理语言 Sass、Less、Stylus，搞懂 hexo 的目录结构。 博客美化通用步骤：选定主题，认真阅读主题文档，分析主题目录结构，了解每个文件是对应网页哪个部分的，认真阅读美化教程，美化教程本质上只为你提供核心代码和思路，具体代码要添加到哪个地方，需要你自己搞懂主题结构，添加到需要的、合适的位置！ 博客美化终极奥秘：创作第一，体验第二，避免繁杂，简洁为上！","text":"permalink: https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/ 以下为原文的摘要： 本文将讲述一些博客主题的美化、实用功能的添加，本文以作者 luuman 的 spfk 主题和作者 xaoxuu 的 Material X 主题为例，文章会不定时进行更新。文章涉及有关参考资料、教程、链接如有侵权请联系我删除！ 本文在CSDN的链接：《Hexo 博客优化之博客美化》、《Hexo 博客优化之实用功能添加》，Hexo 博客专栏，从前期搭建到后期美化，帮您解决常见问题：《Github/Coding Pages + Hexo》，对您有帮助就点个赞吧❤️ 请注意：不同主题可能方法有些不同，相同主题不同版本，配置方法也有所差异！ 博客美化前提条件：有一定的前端基础，了解 HTML、CSS、JS，了解 CSS 预处理语言 Sass、Less、Stylus，搞懂 hexo 的目录结构。 博客美化通用步骤：选定主题，认真阅读主题文档，分析主题目录结构，了解每个文件是对应网页哪个部分的，认真阅读美化教程，美化教程本质上只为你提供核心代码和思路，具体代码要添加到哪个地方，需要你自己搞懂主题结构，添加到需要的、合适的位置！ 博客美化终极奥秘：创作第一，体验第二，避免繁杂，简洁为上！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}],"author":{"name":"TRHX","avatar":"https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.9/images/trhx.png","url":"https://www.itrhx.com/"}},{"title":"[转]如何搭建基于Hexo的独立博客","slug":"[转]如何搭建基于Hexo的独立博客","date":"2020-02-01T06:25:47.000Z","updated":"2020-02-07T15:20:51.230Z","comments":true,"path":"2020/02/01/[转]如何搭建基于Hexo的独立博客/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/01/[%E8%BD%AC]%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/","excerpt":"permalink: https://xaoxuu.com/blog/2017-07-05-hexo-blog/","text":"permalink: https://xaoxuu.com/blog/2017-07-05-hexo-blog/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}],"author":{"name":"xaoxuu","avatar":"https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png","url":"https://xaoxuu.com"}},{"title":"第一个除夕","slug":"第一个除夕","date":"2020-01-24T10:15:53.000Z","updated":"2020-02-08T09:30:11.038Z","comments":true,"path":"2020/01/24/第一个除夕/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/01/24/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%99%A4%E5%A4%95/","excerpt":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！”","text":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"再见2019，你好2020","slug":"再见，2019；你好，2020","date":"2019-12-31T16:00:00.000Z","updated":"2020-02-23T09:18:28.382Z","comments":true,"path":"2020/01/01/再见，2019；你好，2020/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/01/01/%E5%86%8D%E8%A7%81%EF%BC%8C2019%EF%BC%9B%E4%BD%A0%E5%A5%BD%EF%BC%8C2020/","excerpt":"# 前言 这是作为我2019年最后一年博客，同时是2020的第一篇博客。 起手写这篇博客时候是2019年12月晚上8点57分，距离2019的结束约3个小时👇","text":"# 前言 这是作为我2019年最后一年博客，同时是2020的第一篇博客。 起手写这篇博客时候是2019年12月晚上8点57分，距离2019的结束约3个小时👇 概括用一个词来概括我的2019年，我想到的是“酸甜苦辣咸”。 没错，我整一年的经历就和这五种味道一样，多而杂…… 我在成长的路上，一步一步地，独自前进…… 没错，独自，我甚至是常常自己对自己聊天。 我的微信置顶是自己，把想说的就发给自己，这样舒服些了👇 基本每天都有，随笔、想说的话、计划、临时的想法……👇 这一年来到现在，因为经历、看清一些事情后，我性格有所改变，为人处事有了较大的变化。 最为突出的就是暑假和国庆这两段时间，我对我自己“重新洗牌”了。 思考是我最常做的事情之一，思考什么呢？ 我现在到底在做什么？ 我为什么做？ 我想做什么？ 我要做什么？ 我还有多少时间做？ 未来我会往哪里去，往哪里回？ 现在的我我是不是我要的那个“我”？ …… …… 还有很多，为什么呢？ “好好做人”“好好做人“ 是我从小听到大，被唠叨最多次的话之一就是它。 除了经常被爸妈唠叨，我最近一次看见听见是在一部网剧《一起同过窗》（背景是大一大二），里面的叶老师是班主任，他的口头禅就是“好好做人”，学生惹没惹事，他都挂嘴上。 可是，真的明白“好好做人”吗？ “好好”在这是副词，用来修饰动词“做人”。 今年经历了太多太多难以忘记的事情，我似乎开始懂得为什么爸妈在我七岁时候就开始教导我要“好好做人”。 想必他们可能花费了几十年的阅历才懂得为什么吧…… 感动、感谢、感恩初略地把涉及到”感动“、”感恩“、”感谢“的人列在这里~ “因为感动，所以感谢，更要感恩！”这是爸妈教育我的。 我凭我的记忆最大限度地检索了这些人，但一定还是会有漏的…… 家人：爸和妈、弟弟（妮）、外公外婆、奶奶、大姨一家人、二姨一家人、小姨、小姨丈、大舅一家人、小舅、奕剑叔、文燕姑姑姑、还有很多不记得称呼的亲戚…… 朋友：廖鑫圣、陈波、赖洁莹、何庆钊、冼俊贤、张桂源、刘千瑜、朱茜妍、吴嘉隆、蔡泽佳、钟叶茂、杨迎、杨天瑞、谢佳豪、冯皓明、梁大浩、袁舒恩、欧芝妍、陈晓霞、吴森、陈子平…… 师兄姐（归属于朋友）：邱海燕、纪秋荣、卢情波、海英姐（李海英）、海雯师姐、王梁兴、张康、林逸豪、何庄芸、键林、林金翼、王景华、钟榴炜、吴丹婷（广外）、周卓颖、陈庆鸿…… 老师：倪宇班主任、老罗（罗智杰老师）、陈鑫老师、廖老师（勤工网络中心）、郭世仁老师、史婷婷老师、曾宪贵老师、古笑珍老师（小学班数学兼两年班主任）、陈彩玉老师（初中三年数学老师）…… 愿望我在日记本、便签等等上写了很多愿望，其中有些是想在2020年实现的。 我直接copy了，会有重复的，以下是我对自己微信聊天中的部分愿望👇 2020我想当个好儿子、好哥哥、好朋友、好学生、好人。 希望能有人能了解、能理解并接受我的人。 秉承信念，好好做人。 常回家看看，多陪陪家人 我想做自己，我想做“吴锐杰” 不想做那些不符合我风格的事 想拿到国家励志奖学金 希望找到一个人来填补我内心的空白 2020年我要来考驾照了 改变自己，让自己多一些坚硬、刚正、远谋、顾己 好好赚钱、好好学习、好好生活 希望每个人都平安、健康、幸福、好运、快乐 珍惜当下、好好做人、万事生意 找到能陪伴、鼓励、支持我的人 我想拿奖助学金，很想要 还掉所有欠别人的钱 给老弟预留一万的存款，供9月份上大学 好好勤工、挣多点钱，多吃些肉，长胖些 学更多的知识、技能，听更多的歌 想要一副好的身体，能不能搞好我的皮肤病呢 …… …… END文字没法完全表述我想表达的，其他的就存在我的心、记忆里吧 我可以忘记很多东西，也可以记得很多东西 2019年发生的一些事我不会忘🧡…… 2020年，Jerry加油，给我冲冲冲💪…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"绚丽彩虹同学录V1.4公测版","slug":"绚丽彩虹同学录V1-4公测版","date":"2019-12-28T06:34:01.000Z","updated":"2020-02-13T08:17:13.188Z","comments":true,"path":"2019/12/28/绚丽彩虹同学录V1-4公测版/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/28/%E7%BB%9A%E4%B8%BD%E5%BD%A9%E8%99%B9%E5%90%8C%E5%AD%A6%E5%BD%95V1-4%E5%85%AC%E6%B5%8B%E7%89%88/","excerpt":"","text":"部分截图 版本更新 自动更新(推荐): 管理员登陆后，进入控制台，点击检查更新，如有新版本点击“一键更新”等待更新完成即可。 手动更新流程: 更新包地址: http://cdn.badapple.top/PHP/XlchClassbook/UpdatePack下载对应版本的更新包,手动解压覆盖更新包到同学录安装目录。 更新日志☆ 1.4 公测版 (1004) 更新内容： 重要提示：更新完毕后请到 管理员控制台-&gt;站点配置-&gt;保存，以刷新数据！ 修复:手机上传图片打开相机 修复:“对我留言”功能 修复:无法删除相册 修复:允许空名相册 修复:权限组配置错误导致的安全漏洞 修复:验证码大小写问题 增加:可选绚丽彩虹播放器 增加:自定义导航栏功能 增加:教师、班长等权限组 增加:畅言图床、sm.ms、七牛云存储上传 增加:评论回复支持表情 增加:导入似水年华V3数据 优化:图片流设计 优化:同学录页面卡片设计 优化:管理员可设置用户是否允许上传相册 优化:安装时自动修复数据表结构 优化:配置文件结构变更 优化:做了一点微小的工作(细节优化) 更新时间：2018-07-03 23:39:54 ☆ 1.3 公测版 (1003) 更新内容： 修复:后台修改用户组 提示“用户名已被使用” 修复:“对TA留言”功能 修复:验证码大小写问题 修复:代码逻辑错误导致的安全隐患 修复:代码逻辑错误导致的无法在后台更新到新版本 更新时间：2018-04-22 21:20:20 文章附件蓝奏网盘 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"文章内长图","slug":"文章内长图","date":"2019-12-23T09:36:53.000Z","updated":"2020-03-02T12:35:48.209Z","comments":true,"path":"2019/12/23/文章内长图/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/23/%E6%96%87%E7%AB%A0%E5%86%85%E9%95%BF%E5%9B%BE/","excerpt":"文章内长图，使用html来实现 &lt;center&gt;&lt;div style=\"position:relative;width:400px; height:400px; overflow:auto\"&gt;&lt;img src =\"https://i.loli.net/2019/12/31/LiP98f6XqgoHmla.png\"&gt;&lt;/div&gt;&lt;/center&gt; 效果👇","text":"文章内长图，使用html来实现 &lt;center&gt;&lt;div style=\"position:relative;width:400px; height:400px; overflow:auto\"&gt;&lt;img src =\"https://i.loli.net/2019/12/31/LiP98f6XqgoHmla.png\"&gt;&lt;/div&gt;&lt;/center&gt; 效果👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"2019冬至","slug":"2019冬至","date":"2019-12-22T09:57:04.000Z","updated":"2020-02-03T08:31:36.470Z","comments":true,"path":"2019/12/22/2019冬至/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/22/2019%E5%86%AC%E8%87%B3/","excerpt":"😄2019.12.20-22，三天，在小姨家度过了一个冬至小长假。 🧡周五下午从学校出发，骑着小蓝到地铁站乘地铁，经过3条（2、3、9线）地铁线、18（13+3+2）个站、2次（嘉禾望岗、 高增）换乘，来到花都的小姨家。 以下为20号下午抵达花都时发的随笔 #生活 #记录三个月来，第一次出学校出趟远门. ᶘ ͡°ᴥ͡°ᶅ 今天的天气真不错，音乐、风、云……都陪伴着我，特别轻松 (୨୧•͈ᴗ•͈) 因为想家了，但回深圳有些麻烦，先来趟花都吧 ( ´◔ ‸◔`) 海珠来花都，还是有丶远。到了花都就变得有丶冷了 💛","text":"😄2019.12.20-22，三天，在小姨家度过了一个冬至小长假。 🧡周五下午从学校出发，骑着小蓝到地铁站乘地铁，经过3条（2、3、9线）地铁线、18（13+3+2）个站、2次（嘉禾望岗、 高增）换乘，来到花都的小姨家。 以下为20号下午抵达花都时发的随笔 #生活 #记录三个月来，第一次出学校出趟远门. ᶘ ͡°ᴥ͡°ᶅ 今天的天气真不错，音乐、风、云……都陪伴着我，特别轻松 (୨୧•͈ᴗ•͈) 因为想家了，但回深圳有些麻烦，先来趟花都吧 ( ´◔ ‸◔`) 海珠来花都，还是有丶远。到了花都就变得有丶冷了 💛 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"phpEnv一款优雅强大的php集成开发环境","slug":"phpEnv一款优雅强大的php集成开发环境 (1)","date":"2019-12-21T05:47:34.000Z","updated":"2020-04-23T11:40:36.783Z","comments":true,"path":"2019/12/21/phpEnv一款优雅强大的php集成开发环境 (1)/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/21/phpEnv%E4%B8%80%E6%AC%BE%E4%BC%98%E9%9B%85%E5%BC%BA%E5%A4%A7%E7%9A%84php%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%20(1)/","excerpt":"","text":"phpEnv一款优雅强大的php集成开发环境php集成开发环境有很多种，例如phpstudy，wamp，xmapp等等，各有各的优点和缺点，本文并不是对各个 IDE 的使用和调试进行详细的对比和评测，因为每一款 IDE 均提供了大同小异的功能，只是在细节方面有所差异罢了，phpStudy程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+Zend Loader，一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境。该程序绿色小巧简易迷你仅有13M，有专门的控制面板。总之学习PHP只需一个包。但是当最近phpstudy爆出重大漏洞后门后，相信很多人都在寻找可替代品，这里推荐给大家一款希望能对大家的参考和选择有所助益： phpEnv软件界面颜值超高，简洁优雅，完全绿色化，不需要安装vc环境，在同等软件中清新脱俗。 突破端口限制，更有管理员模式解除Windows Service服务端口占用。 运行服务错误提示，快速定位错误，提高开发效率。 自带软件商店，PHP和MySQL版本应有尽有，还有Redis和其他工具等。 功能强大的站点管理，为每个网站配置不同的PHP版本，不同PHP版本的网站共存，可视化配置https等。 简洁优雅而不失强大的软件设置，大大提高了开发效率。 功能强大的cmd命令行，无须你再繁琐的配置环境变量。 可视化TCP端口进程列表，功能强大，快速查看端口监听情况。 能够和phpstudy媲美，和wamp相互比对， 本文分享自微信公众号 - 风帆（wdswhf） 原文出处及转载信息见文内详细说明，如有侵权，请联系 yunjia_community@tencent.com 删除。 原始发表时间：2019-09-23 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"[转]分享几款不错的浪漫素材","slug":"转-分享几款不错的浪漫素材","date":"2019-12-13T10:58:22.000Z","updated":"2020-04-23T11:40:36.824Z","comments":true,"path":"2019/12/13/转-分享几款不错的浪漫素材/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/13/%E8%BD%AC-%E5%88%86%E4%BA%AB%E5%87%A0%E6%AC%BE%E4%B8%8D%E9%94%99%E7%9A%84%E6%B5%AA%E6%BC%AB%E7%B4%A0%E6%9D%90/","excerpt":"原文链接：https://www.liaofuzhan.com/posts/3564551888.html 双旦将至，快找个暖冬又暖心的 TA 一起跨年吧！如果你还是一枚单身汪，那么再过几天的时间，又到了别人狂欢你孤单的圣诞之夜！再再再过几天时间，又双叒叕到了别人狂欢你孤单的跨年之夜！落单的人往往最怕过节，更何况双旦佳节的连环暴击，别人疯狂撒着狗粮，而你只能接受着来自情侣们的亿万点伤害，SO，与其不甘寂寞，何不为爱情放纵一次？撩个对象一起过双旦吧，2019 年最后一个脱单的机会，为你呈现 ！ 感谢 leafjame 和 EnfangZhong 提供的素材！ 本站只集成了以下四种，其它效果可下载源码后查看 表白专场","text":"原文链接：https://www.liaofuzhan.com/posts/3564551888.html 双旦将至，快找个暖冬又暖心的 TA 一起跨年吧！如果你还是一枚单身汪，那么再过几天的时间，又到了别人狂欢你孤单的圣诞之夜！再再再过几天时间，又双叒叕到了别人狂欢你孤单的跨年之夜！落单的人往往最怕过节，更何况双旦佳节的连环暴击，别人疯狂撒着狗粮，而你只能接受着来自情侣们的亿万点伤害，SO，与其不甘寂寞，何不为爱情放纵一次？撩个对象一起过双旦吧，2019 年最后一个脱单的机会，为你呈现 ！ 感谢 leafjame 和 EnfangZhong 提供的素材！ 本站只集成了以下四种，其它效果可下载源码后查看 表白专场 hexo 跳过渲染Hexo 默认会对根目录 /source/ 下所有页面应用主题模板渲染，但有一些前端作品或 demo 页我们不希望经过渲染，而是能保持完全自定义的样子，那该怎么用 Hexo 添加自定义的 web 页面呢？下面介绍两种方法 skip_render使用 Hexo 提供的跳过渲染配置。在站点 _config.yml 中找到 skip_render，这项是用来配置 /source/ 下需要跳过渲染的文件或目录，例如希望跳过 /source/love/ 里的所有文件，可以配置为 skip_render: love/** 如果有多项，可以这样配置 skip_render: - README.md - love/** - test1/*.html 或者 skip_render: [README.md, love/**, test1/*.html] 可参考 如何不处理 source 目录下某个子目录的所有文件 layout使用 layout 给单个文件添加不应用模板的标记。适用于个别需特殊处理的文件，可在文件头部添加 --- layout: false --- 这个文件就不会经过模板渲染，最终发布到 /public/ 里的文件就是去掉标记后的文件的样子。本站使用的是第一种配置方式，源码目录截图如下 访问域名 + 文件目录名即可出现效果，Enjoy ！ 表白专场 相关文章点击查看表白神器—JS生成的玫瑰花Hexo Next主题「哈林摇」特效Hexo NexT主题美化1.0随笔—过节那点事 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"素材","slug":"素材","permalink":"https://melodyjerry.github.io/blog/tags/%E7%B4%A0%E6%9D%90/"}],"author":{"name":"北宸","avatar":"https://www.liaofuzhan.com/images/beichen.png","url":"https://www.liaofuzhan.com/"}},{"title":"[工具]ASCII字符画制作工具","slug":"工具-ASCII-字符画制作工具","date":"2019-12-12T11:48:31.000Z","updated":"2020-04-23T11:40:36.803Z","comments":true,"path":"2019/12/12/工具-ASCII-字符画制作工具/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/12/%E5%B7%A5%E5%85%B7-ASCII-%E5%AD%97%E7%AC%A6%E7%94%BB%E5%88%B6%E4%BD%9C%E5%B7%A5%E5%85%B7/","excerpt":"想为自己的博客设计一个专属的ASCII字符画，便找到以下三款工具（含线上）","text":"想为自己的博客设计一个专属的ASCII字符画，便找到以下三款工具（含线上） 工具 http://patorjk.com/software/taag/ https://www.degraeve.com/img2txt.php 使用Ascii Generator 2制作，下载地址：https://sourceforge.net/projects/ascgen2/ 展示 _ooOoo_ o8888888o 88\" · \"88 (| ^.^ |) O\\ = /O ____/`---'\\____ . ' \\\\| |// `. / \\\\||| : |||// \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | \\_| ''\\---/'' | | \\ .-\\__ `-` ___/-. / ___`. .' /--.--\\ `. . __ .\"\" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'\"\". | | : `- \\`.;`\\ _ /`;.`/ - `: | | \\ \\ `-. \\_ __\\ /__ _/ .-` / / `.____`-.___\\_____/___.-`____.-' ⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒ ............................................. 佛 祖 保 佑 代 码 无 BUG &lt;!-- s&amp;@@@@@@@@@@@#HX9hr: ;GM@@@@@@@@@@@@@@@@#MBA85i .G@@@@@@@@@@@@@@@@@@@@@@@@@@M9: .&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#1 h@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@, .;rssr, ,sA@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@88B@@@@@#5 .rHHA#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: rB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@i ,5B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X is&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X#@@@@@@@A ,s8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Hr M@@@@@@@B. .,1&amp;M@@@@@@@B#@@@@@@@@@@@@@@@@@@@8 ;@@@@@@@Hi. :1991: ,s9&amp;81;. , sA@@@@@@BG8XHB#@@@@@@@@@@@@@HS: 5@@@@@@@@i .;13XM@@#H#@H91;. :s3&amp;##A&amp;#@@MA8Ss: .5HAX#@M@#BHHBM#@@@@@@@@#&amp;Ah.. G@@@@@@@@G ,s9AMM@@@Xh;. .i9@@@BX9hr, .,ih9&amp;B@@@#s. :hM@@HBMBXSi. ..ShSM@@@@@@&amp;XBHsHMHS: .: 3@@@@@@@@8 ,;19H#BG5irB@@H3. r#@@@@@#@@ B@@@BB@@@@M; 5H@@@9 ,r3ABM&amp;8Shsrii;;i;ir1h1. .iM@@@@@@@@91, ;S, sGXH@@@@@@@@X&amp;HM@@@9: X@@@@@#s &amp;@@@@@@G:s @A;.hM@@@@@A G@@@@@@h s#@@AXXXGGXGX#@@#@@Bs .r58&amp;HM@@@@@@@@@@@#BA8Sr. ,8@@#X@@@@@@Ariii5M@@H3. 8@@@@@@9 1B@@@@@@: H; &amp;@@@@@#h &amp;@@@@@Mi ,G@@@@X ;8#@#hrX@@X8M@@@@@@@@@@@@@@@@@@@@@@@M8SM@Hh.3@@@@M8. .H@@@@@Hi S@@@@@5 .SM@@@@S . H@@@@X: 5@@@@M; &amp;@@@@@@9 s#@@@@#r.9@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#3:9@@@@@@9 :M@@@@@@s 1@@@@s ,9#@@H ,M@@#h i@@@M; 3@@@@@Mi X@@@@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8 ;M@@@@M, rM@@i :G@@i i@@X: .B@M; :#@@@@r :#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M. ;M@@@X :B@: i&amp;S hMh GM; X@@@h S@@@@B#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B8@@@@h i#@@h ,1 ., ,: s@@3 .H@@MB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;A@@H r#@; HG r@#r&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S B@r s9 , 95G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@h;S 3@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@i r@@@@@@@H8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B. H@@@@@@#:;@@@@@@@@@@@@@@@@@@@@@@@@@@B8@@@@@@@S .;S@@@@@@@r ,M@@@@@@@@@@@@@@@@@@@@@@@@@X 9@@@@@@Mhi, .. ;831: .iSXM@@@@@@@#s .M@@@@@@@@@@@@@@@@@@@@@@@@@X 9@@@@@@@@#A91: i8AA1 :h, iBH. .5B@#8i. .iS&amp;M@@@@@@@@@@Ai i@@@@@@@@@@@@@@@@@@@@@@@@@@M, hB@@@@@@@@@@@H8h; ;9@@#s :&amp;@X, .B@@H359GX&amp;XGGM@@@@B9:,rSXM@@@@@@@@@@@B8s h@@@@@@@@@@@@@@@@@@@@@@@@@@@s .1GB@@@@@@@@@@@@BX5r,sA@@@@@MHAHBHHA&amp;#@@@9 iG@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@#H8h; S@@@@@@@@@@@@@@@@@@@@@@@@@@#s :19AM@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@h. 1B@@@@@@@@@@@@@@@@@@@@@@@@BXSr, 5#@@@@@@@@@@@@@@@@@@@@@@@@@@@#h .ih8A#@@@@@@@@@@@@@@@@@@@@@@M@@8 ,,,595i:i1S9G&amp;AHBMBAGSr, 9@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3 :13XHM###MMBHAX95SXBMGii, --&gt; 参考文章 让console充满情怀Chrome 控制台新玩法Tools for Web Developers浏览器控制台个性化输出 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Java—替换字符串右侧出现的第一个子串","slug":"Java—替换字符串右侧出现的第一个子串","date":"2019-12-08T04:46:08.000Z","updated":"2019-12-08T09:18:36.934Z","comments":true,"path":"2019/12/08/Java—替换字符串右侧出现的第一个子串/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/08/Java%E2%80%94%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%B3%E4%BE%A7%E5%87%BA%E7%8E%B0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%90%E4%B8%B2/","excerpt":"🔺需求 👇 编程实现一个方法，能把一个字符串src的右侧出现的第一个olds子串替换为news，并把替换后的结果返回。","text":"🔺需求 👇 编程实现一个方法，能把一个字符串src的右侧出现的第一个olds子串替换为news，并把替换后的结果返回。 🔺代码 👇 public class StringReplaceLast { public static String replaceLast(String src, String olds, String news){ /* 实现一个尾部替换方法 */ System.out.println(src); StringBuffer sbsrc = new StringBuffer(src); int lenolds = olds.length(); int tail = src.lastIndexOf(olds); sbsrc = sbsrc.replace(tail,tail+lenolds, news); src = sbsrc.toString(); return src; } public static void main(String[] args) { System.out.println(replaceLast(\"goodJava,I love it, very good,Truly.\", \"good\", \"yes\" )); } } 🔺截图 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"文章视频（B站）","slug":"文章视频","date":"2019-12-07T16:00:00.000Z","updated":"2020-03-02T12:35:48.210Z","comments":true,"path":"2019/12/08/文章视频/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/08/%E6%96%87%E7%AB%A0%E8%A7%86%E9%A2%91/","excerpt":"目前博文主要引用的是B站视频👇 小窗口版、修改src即可👇 &lt;iframe src=\"//player.bilibili.com/player.html?aid=76560081&amp;cid=130958803&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"&gt; &lt;/iframe&gt;&lt;br&gt; 浏览测试效果👇 大窗口版👇 &lt;div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"&gt;&lt;iframe src=\"//player.bilibili.com/player.html?aid=76560081&amp;amp;page=0\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"&gt;&lt;/iframe&gt;&lt;/div&gt; 浏览测试效果👇","text":"目前博文主要引用的是B站视频👇 小窗口版、修改src即可👇 &lt;iframe src=\"//player.bilibili.com/player.html?aid=76560081&amp;cid=130958803&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"&gt; &lt;/iframe&gt;&lt;br&gt; 浏览测试效果👇 大窗口版👇 &lt;div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"&gt;&lt;iframe src=\"//player.bilibili.com/player.html?aid=76560081&amp;amp;page=0\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"&gt;&lt;/iframe&gt;&lt;/div&gt; 浏览测试效果👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"Java—转置数组","slug":"Java—转置数组","date":"2019-12-07T13:43:33.000Z","updated":"2019-12-08T14:07:45.921Z","comments":true,"path":"2019/12/07/Java—转置数组/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/07/Java%E2%80%94%E8%BD%AC%E7%BD%AE%E6%95%B0%E7%BB%84/","excerpt":"🔺需求 👇 编写一个程序，其功能是能随机生成一个数组、同时完成对该数组的转置并打印输出转置后的数组。","text":"🔺需求 👇 编写一个程序，其功能是能随机生成一个数组、同时完成对该数组的转置并打印输出转置后的数组。 🔺代码 👇 import static java.lang.System.out; import java.util.Random; public class Reverse2dArray { static int[][] a; // 存放两位随机整数的int二维数组a /** * 构造方法，初始化数组a，r和c分别是行数和列数row column */ public Reverse2dArray(int r, int c){ a = new int[r][c]; buildRandArray(); } /** * 构造随机数组 */ public void buildRandArray(){ Random random = new Random(); for(int i = 0; i &lt; a.length; i++) for(int j = 0; j &lt; a[i].length; j++) a[i][j] = random.nextInt(100); } /** * 转置本类成员的二维数组a，并返回一个新的二维数组 * @return */ public int[][] reverse2dArray(){ int [][] b = new int [a[0].length] [a.length] ; for (int i = 0; i &lt; a.length; i++) { for (int j = 0; j &lt; a[0].length; j++) { b[j][i] = a[i][j] ; } } return b ; } /* 显示二维数组 */ public void showArray(int[][] c){ out.printf(\"=========%2d×%-2d=========%n\", c.length, c[0].length); for(int[] cr : c){ for(int cc : cr){ out.printf(\"%5d \", cc); } out.println(); } out.println(\"=======================\"); } public static void main(String[] args) { int row = 3, col = 4; Reverse2dArray me = new Reverse2dArray(row, col); me.showArray(a); // 显示原数组 int[][] r = me.reverse2dArray(); me.showArray(r); // 显示转置的数组 } } 🔺截图 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"【纪念】我的博客上线一个月","slug":"【纪念】我的博客上线一个月","date":"2019-12-06T16:41:29.000Z","updated":"2019-12-06T17:20:33.920Z","comments":true,"path":"2019/12/07/【纪念】我的博客上线一个月/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/07/%E3%80%90%E7%BA%AA%E5%BF%B5%E3%80%91%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E6%9C%88/","excerpt":"大致写完这文章时，已是2019年12月7日的夜晚00时41分。 从最简单的纯粹的文字，到文字加粗，到用图床（SM.MS）来插入图片，到利用HTML来丰富博客，等等……本小白的博客之旅早已开始，学习、生活，图文、视频、音乐，想写想分享的都不会少。 今天这篇文章，一是回顾这一个多月来写博客的点滴，二是对未来的一些期望、想法，三是纪念一个人！！！","text":"大致写完这文章时，已是2019年12月7日的夜晚00时41分。 从最简单的纯粹的文字，到文字加粗，到用图床（SM.MS）来插入图片，到利用HTML来丰富博客，等等……本小白的博客之旅早已开始，学习、生活，图文、视频、音乐，想写想分享的都不会少。 今天这篇文章，一是回顾这一个多月来写博客的点滴，二是对未来的一些期望、想法，三是纪念一个人！！！ 尝试 &amp; 第一篇博客2019十月的最后一天，那是我写博客的第一天。 第一篇博客，同时用来纪念我的开始。 https://blog.csdn.net/weixin_43438052/article/details/102841961 那篇博客的标签我给的是#尝试#。 没错，这是我第一次尝试写博客，一次伟大的尝试和开始。 博客的内容也很简单。 当然，这也是我人生以来 第一次全面地接触 MarkDown 语言。 又迈出一步 &amp; 小小的收获之后，先后在CSDN和简书上，又发表共5篇文章（含重复）。 我的CDSN主页：https://blog.csdn.net/weixin_43438052 我的简书主页： https://www.jianshu.com/u/a75808cbb13e 经过写这几篇博客，对于MD（Markdown）的使用越来越熟练。 这也让我收获一些东西，比如点击量、评论量、点赞数、收藏数等等。 虽然和那些大佬比起来微不足道，不过我还是很开心。 尤其是我合计了（双平台）全部文章的浏览量是1726。 截止到写这篇博客，有1726‬人看过我的文章。1726啊啊啊，大数字了hhhh 于是，我傻乎乎地打开计算器，用1726除了30，得到这个数‭57.53。 忍不住说了句 卧槽 ，平均每天有57人看我的文章。 57人啊，我也算是个小网红 (不算，那我自个变红) 了吧？！！ 此刻的我👉一时自恋+持续傻笑ing 大胆地想法 &amp; 勇敢地再尝试2019.11.1 我突然有个 大想法 ，和这三个字那么大的想法——我要搭建自己Blog（博客）。 那又是为什么呢？ 很简单，还是 尝试 。 然而，想法是好，实践起来，不容易啊。 起初是使用 Gridea 来撰写、发布博客。 不过，没多久被我舍弃了这个方案。并不是说Gridea不好，而是缺少了自定义。 我说的自定义是，可以给自己的博客加入一些其他的东西，比如页面动画之类的。 于是，在朋友的推荐下，我接触了 Hexo 。这是一个专门用来搭建博客的框架。 没错，就是框架。因为是框架，所以能直接、便利地搭建、撰写、发布博客文章。 更重要的是，Hexo提供现成的主题模板，你可以直接利用，甚至对其二次加工。 就这样，前前后后，在没课的时候、还有半夜，大概花了四天左右来研究Hexo，从命令行开始。 终于在2019.11.6初步搭建完成，隔天7号发布了第一篇文章。 同时也是记录我搭建博客的大致过程。 人生第一个域名 &amp; 一写小坎坷2019.11.6 也是我获取人生第一个专属域名【melodyhub.ltd】的日子。 43买了五年，真的很值很划算。 不过，在接下的两三天也遇到点麻烦。 第一个是DNS解析，这个还好办，查ip、到阿里云控制台改一下就好。 第二个是，每次``hexo d` 后，用域名总是404。每次都要到GitHub仓库里修改CNAME，太麻烦了。于是，我干脆就直接在Hexo的框架中写入CNAME文件，这样每次更新到远端（仓库）时，都会有正确的CNAME。机智的我 ( ͡° ͜ʖ ͡°)✧ 第三个，也是最麻烦的一个，浏览器打开我的网站，总是提示“证书失效 / 危险链接”等字段。这个懊恼了我两天，反复查了一堆东西，最后发现原来是主题模板中重定向到一个外国授权认证的网站去了。 真的是，整的我发愁，好在最后能够解决了。 进一步尝试优化到目前为止，我的网站一共经历两次大变化，一次是在11.8，另一次是11.24。 主要就是优化了主题模板中存在的一些问题，然后加入了一点自己想要的东西，还有一些待以后再实现。 具体的，主要的，大致在【博客v1.4上线】这篇博客中提到了。 其实，这个过程很难，一个是我对Hexo内部的设计的了解不是很深，另一个是对HTML语言不是精通。主要是前者，后者可以通过百度、书籍来学习。 反反复复，查阅各个文档、修改一堆文件、增删改n次代码。 总算是，得到了一个较为满意的博客。 期间，还丢失过几次代码和文件，折腾死我了。😂 奋笔疾书（敲键盘）写写写截至到写这篇博客，一共在自己的网站上发布了26篇正式博客。 但是由于目前还没不会使用“不蒜子” 的接口来显示浏览量，所以我页没法知道有多少人看过我的文章。 我就假装每天就一共吧，那就是我哈哈哈。 26篇博客文章，不仅提升为了我的打字速度，还让我更加地想搞IT。** 当然，我一向对IT感兴趣。** 写 ，这个过程让我在不断地遇到困难，然后解决它。 不懂的，就琢磨它。再不懂，找大佬、问大佬。 也就一步步地，收获了知识、也认识了几位大佬。 期望 &amp; 未来我的目标是成为以为IT技术大佬，目前的想法是能熟练Java+一种数据库+HTML+其他语言/技术。 这几个月来，因为一件事、一些人，重新洗牌了我的生活，同时也让我有了全新的目标、计划。 现如今，我有新的顾虑，我有家、有朋友的期望，我必须自强自立。放眼到以前，熟悉我的人也知道我一向比较执着于想做的事，虽然现在我也也是，不过更多了一些热情、勇气、认识。 这一个多月来，得到很多人的帮助、指导、建议。朋友啊、老师啊、师兄师姐啊…… 人总要向前看向前走，无论是失去某样东西，或者某个人，都得向前。 我在博客中用到一句话当【归档页】的副标题“生命不过三天：昨天、今天、明天”。 反思昨天，珍惜今天，把握明天。所以，但看到别人在向前走时，我就要跑、向前跑。 就这样，我也才给我的网站的主页设置了 “你用走 可是我用跑” . 我希望这句话能够在关键时候提醒我，你不能停还得跑。 同时我也希望，能够看到这里的你，也要向前向前再向前。 晚安计划分享截止到现在的所有【晚安计划】 👇 END😊 最后，希望 健康、平安、简单、快乐、好运。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"用JDBC连接数据库","slug":"用JDBC连接数据库","date":"2019-12-03T04:12:50.000Z","updated":"2020-02-09T16:02:16.381Z","comments":true,"path":"2019/12/03/用JDBC连接数据库/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/03/%E7%94%A8JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"简单理解JDBC（Java DataBase Connectivity）是 Java 和 数据库 之前的一座桥。 实则，JDBC 是用于Java编程语言和数据库之间的标准Java API。 三者之间的关系就如下图 👇","text":"简单理解JDBC（Java DataBase Connectivity）是 Java 和 数据库 之前的一座桥。 实则，JDBC 是用于Java编程语言和数据库之间的标准Java API。 三者之间的关系就如下图 👇 JDBC介绍官方文档：https://www.oracle.com/technetwork/java/javase/jdbc/index.htmlJava 原文👇 译文（可能有偏差）👇 数据库连接 （JDBC） Java 数据库连接 （JDBC） API 是 Java 编程语言与各种数据库 SQL 数据库和其他表格数据源（如电子表格或平面文件）之间的独立于数据库的连接的行业标准。JDBC API 为基于 SQL 的数据库访问提供了调用级 API。 JDBC 技术允许您使用 Java 编程语言来利用需要访问企业数据的应用程序的”一次写入，随处运行”功能。借助支持 JDBC 技术的驱动程序，即使在异构环境中，您也可以连接所有企业数据。 教程本文环境 OS IDE 数据库 Windows 10 专业版 Eclipse(v4.11.0)—jdk8 SQL server 2017 SQL Server 2017 设置【SQL 身份验证登录】 设置【登录名 sa】 的状态为【授予】和【启用】 关闭程序 SQL Server 配置管理器==因为SQL Server 2012装好后，默认协议是没有开启的，所以要打开SQL Server配置管理器中开启。== 打开【SQL server2017配置管理器】 启用【Named Pipes】 修改 【TCP/IP 属性】： 将【IP1 、IP10】中的【IP地址】改成【 127.0.0.1】，并将所有的【IPx】的【已启用】设置为【是】，将 【IPAII】中的【TCP端口】设成 【1433】，其余不变。 重启【SQL Server服务】 【win+r】打开【运行】，键入【cmd】，打开命令行，键入以下命令👇 telnet 127.0.0.1 1433 提示【talent不是内部命令】，则【打开控制面版】-&gt;【程序】-&gt;【启用或关闭Windows功能】-&gt;【勾选talent】-&gt;【确定】。 重新【步骤4】，进入【telnet】。 JDBC驱动 下载驱动包：http://www.microsoft.com/zh-cn/download/details.aspx?id=11774 选择、下载【 sqljdbc_6.0.8112.200_chs.tar.gz】 解压上述压缩包，得到目录文件夹 复制【”sqljdbc_6.0\\chs\\jre8”】中的包【sqljdbc42.jar】，粘贴到IDE【Eclipse目录】下的【jdk1.8\\jre\\lib\\ext】中。 右键【我的电脑】-&gt;【高级系统设置】-&gt;【系统属性】-&gt;【高级】-&gt;【环境变量】，编辑【系统变量】中的【CLASSPATH】的【变量值】，加入【;路径】（该路径为步骤4中包的完整路径，注意路径前一定要加 ;）-&gt;【确定】。 Eclipse 【右键】工程项目-&gt;【Build Path】-&gt;【Configure Build Path】 选择【Libraries】页-&gt;【Add External JARs…】-&gt;【添加】前面粘贴jar包的路径-&gt;【Apply and Close】 实践新建一个class，复制粘贴一下代码👇 import java.sql.*; public class JDBC_Demo { // MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL //static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; //static final String DB_URL = \"jdbc:mysql://localhost:3306/数据库名\"; // MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL //static final String JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\"; //static final String DB_URL = \"jdbc:mysql://localhost:3306/数据库名?useSSL=false&amp;serverTimezone=UTC\"; // SQL Server数据库引擎 static final String JDBC_DRIVER = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\"; // 数据源！！！注意若出现加载或者连接数据库失败一般是这里出现问题 static final String DB_URL = \"dbc:sqlserver://localhost:1433;DatabaseName=数据库名\"; //【1】修改 数据库名 // 数据库的用户名与密码，需要根据自己的设置 static final String Name=\"登录名\";//【2】修改 登录名 static final String Pwd=\"密码\";//【3】修改 密码 public static void main(String[] args) { try { Class.forName(JDBC_DRIVER); Connection conn=DriverManager.getConnection(DB_URL,Name,Pwd); System.out.println(\"连接数据库成功\"); }catch(Exception e){ e.printStackTrace(); System.out.println(\"连接失败\"); } } } 运行截图👇 心得体会前前后后，总计花了差不多三天的时间来研究怎么用JDBC连接数据库。 期间，遇到好多问题。问过指导老师，老师说可能是SQL Server版本的问题。 实验要求是2014，而我的是2017。但我觉得这不是问题。 反反复复地，其他都配置好了，但是总是连接不上数据库。 后来关注点放在了Eclipse的Path上，注意到我用的是jdk12，于是我想换成jdk8。 一换、一 run ……咦，可以了哈哈哈哈。 期间参考了很多人的博客，但是那些都没有强调 IDE中的环境要设置为【jdk8】。 写博客不易，如果本文对你有帮助，可以考虑给我 打赏 哦 *( ͡° ͜ʖ ͡°)✧ * 2020.2.10 补充：关于JDBC连接MySQL的具体实例，可以前往 这里 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"https://melodyjerry.github.io/blog/tags/SQL-Server/"}]},{"title":"Java——API中文手册","slug":"Java-API中文手册","date":"2019-12-01T12:00:15.000Z","updated":"2019-12-02T12:56:16.300Z","comments":true,"path":"2019/12/01/Java-API中文手册/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/01/Java-API%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/","excerpt":"【Java 8中文版开发文档，Java 8中文版 API手册中文版】( http://www.matools.com/api/java8 )","text":"【Java 8中文版开发文档，Java 8中文版 API手册中文版】( http://www.matools.com/api/java8 ) L2Dwidget.init({\"model\":{\"jsonPath\":\"/blog/live2dw/assets/assets/haruto.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"tagMode\":false,\"debug\":false,\"mobile\":{\"show\":true},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\"}); 为了避免版权问题，再次声明：移植该文档，仅供学习交流，别无其它目的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"2019的最后一个月","slug":"2019年的最后一个月","date":"2019-12-01T05:32:39.000Z","updated":"2019-12-31T14:16:35.253Z","comments":true,"path":"2019/12/01/2019年的最后一个月/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/01/2019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88/","excerpt":"","text":"💛今天，2019年12月01日，是 今年最后一个月的第一天。 🔺回想去年的12月，经历了很多，一切都是从 【晚安计划】的短信 开始。时至今天，我仍保存着去年的“晚安计划”短信。 💙今晚开始，又是新的一轮【晚安计划】。不知道你有没有呢？ 🧡从国庆回到学校后，课多了、要处理的事情多了，总之这两个月来搞的东西太多了。 💚不过呢，也是有收哦的哦！像比如，现在这个博客(2019.11.07)就是之一。还有自己写的小玩意，以后会放出来。 💜忙完这最后的12月，也该是时候让自己出去走走了。总是待在宿舍、教学楼，会傻的hh。 💛最近很想家，很想回家。不过也要等到2020元旦之后啦，也快了快了。 最后，祝我自己和大家12月健康、平安、快乐、好运…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Java—(递归+非递归)阶层","slug":"Java—（递归-非递归）阶层","date":"2019-11-30T08:08:51.000Z","updated":"2019-12-01T01:01:56.156Z","comments":true,"path":"2019/11/30/Java—（递归-非递归）阶层/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94%EF%BC%88%E9%80%92%E5%BD%92-%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89%E9%98%B6%E5%B1%82/","excerpt":"递归阶层算法、非递归阶层算法 扩展①：求阶层的和 扩展②：寻找最高阶、打印阶层的计算过程","text":"递归阶层算法、非递归阶层算法 扩展①：求阶层的和 扩展②：寻找最高阶、打印阶层的计算过程 非递归阶层算法import java.util.Scanner; public class UnRecurrenceFactorial { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"input:\"); int n = sc.nextInt(); int a = 1; while(n != 1){ a = a*n; n--; } System.out.println(a); sc.close(); } } 递归阶层算法public class RecurrenceFactorial { public static void main(String[] args) { long fac = fac(k);//修改k的值即可 System.out.println(\"n的阶乘为:\" + fac); } public static long fac(int n){ if(n == 1){ return 1; }else{ return fac(n-1) * n; } } } 扩展①：求阶层的和🔺计算 1!+2!+3!+···+k! 的值： public static void main(String[] args) { int i,j; long sum = 0; for(i = 1; i &lt;= k; i++){ //修改k的值即可 int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } sum += t; } System.out.println(sum); } 扩展②：寻找最高阶、打印阶层的计算过程🔺题目： 指定一个整型数MAX，试编写一个程序求满足1!+2!+3!…+n!&lt;=MAX 的最大整数n。并把满足条件的求和式子和找到的最大整数n打印输出。 示例1：MAX=111时，输出 1!+2!+3!+4!=33 满足条件的最大整数:4 示例2：MAX=9876 1!+2!+3!+4!+5!+6!+7!=5,913 满足条件的最大整数:7 🔺代码： import java.util.Scanner; public class Du { public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.println(\"the value of MAX:\"); int MAX; MAX=input.nextInt(); System.out.println(\"满足条件的最大整数：\"+SUM(MAX)); input.close(); } public static int SUM(int MAX) { int i = 0,j; long sum = 0; for(i = 1; i &lt;= 10; i++){ int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } sum += t; if(sum&gt;MAX) break; } Print(i-1); return i-1; } /*打印阶层的计算过程*/ public static void Print(int k) { int i,j; long sum = 0; for(i = 1; i &lt;= k; i++){ //修改k的值即可 int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } System.out.printf(\"%d! + \",i); sum += t; } System.out.print(\"\\b\\b= \"+ sum);//退两个，删去最后一个+ System.out.println(); } } 🔺截图： 我的文章、代码简单，这里有更详细文章，见大佬👉Java实现n阶阶乘的计算 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java—向下/上取整","slug":"Java—-向下-上取整","date":"2019-11-30T05:44:08.000Z","updated":"2019-12-01T00:58:39.448Z","comments":true,"path":"2019/11/30/Java—-向下-上取整/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94-%E5%90%91%E4%B8%8B-%E4%B8%8A%E5%8F%96%E6%95%B4/","excerpt":"Java中对数的舍入也分有 向上舍入（向上取整） 向下舍入（向下取整） Java的Math类中包含数舍入的方法： ceil() floor() ceil()和floor() ceil() floor() 向上取整 向下取整 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 返回小于等于（&lt;=）给定参数的最大整数 。","text":"Java中对数的舍入也分有 向上舍入（向上取整） 向下舍入（向下取整） Java的Math类中包含数舍入的方法： ceil() floor() ceil()和floor() ceil() floor() 向上取整 向下取整 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 返回小于等于（&lt;=）给定参数的最大整数 。 看个栗子👇 关于Math类的说明，参考 Number &amp; Math 类方法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java—打印字母表","slug":"Java—打印字母表","date":"2019-11-30T03:46:31.000Z","updated":"2019-12-02T15:24:50.647Z","comments":true,"path":"2019/11/30/Java—打印字母表/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94%E6%89%93%E5%8D%B0%E5%AD%97%E6%AF%8D%E8%A1%A8/","excerpt":"A到Z的ASCII码值是65到90 a到z的ASCII码值是97到122","text":"A到Z的ASCII码值是65到90 a到z的ASCII码值是97到122 Demopublic class AlphabetDemo { public static void main(String[] args) { /*char和int类型能够相互转换，相信大家都明白 */ //A到Z的ASCII码是65到90，a到z的ASCII码值是97到122 for (char c = 0; c &lt; 128; c++) { //java里包装类的一个静态方法，确定c是字母还是小写！！！） if (Character.isLowerCase(c)) { System.out.printf(\"value: %3d char: %c\\n\", (int)c, c); //同上，判断c是大写 } else if (Character.isUpperCase(c)) { System.out.printf(\"value: %3d char: %c\\n\", (int)c, c); } } } } 注：关于isLowerCase和isUpperCase在文末有进一步的说明。 扩展 ①🔺题目： 🔺参考代码： import java.util.Scanner; public class Alphabet { public static void main(String[] args) { Scanner input=new Scanner(System.in); int n,level; System.out.println(\"the value of n:\"); n=input.nextInt(); level=(int)Math.ceil(26/n);//向上取整 System.out.println(\"======Upper========\"); char CH=65; for(int i=0;i&lt;=level;i++) { for(int j=0;j&lt;n;j++) { System.out.printf(\"%c \",CH); ++CH; if(CH&gt;=90) break; } System.out.println(); } System.out.println(); /* 另一个版本，这就看个人理解了！ System.out.println(\"======Upper========\"); char CH=65; for(int i=1;i&lt;=26;i++) { System.out.print(CH+\" \"); CH++; if(i%n==0) { System.out.println(); } } System.out.println(); */ System.out.println(\"======Lower========\"); char ch=97; for(int i=0;i&lt;=level;i++) { for(int j=0;j&lt;n;j++) { System.out.printf(\"%c \",ch); ++ch; if(ch&gt;=123) break; } System.out.println(); } System.out.println(); input.close(); } } 注意：Math.ceil();//向上取整 参考：我的另一篇博客：Java—向下/上取整 🔺执行截图： 扩展 ②上面常规思考题中的第6题是自左往右从上往下的水平顺序输出大写堆和小写堆字母表。假如想要按照自上而下从左往右的垂直顺序输出大写堆，该如何实现程序？ 即假如每列输出N=5个，则程序的输出情况如下： = = = Upper = = = A F K P U Z B G L Q V C H M R W D I N S X E J O T Y 试用一重循环编写程序，指定一个整型数N(1&lt;=N&lt;=26)，按示例规格输出列优先排序的大写字母表。 🔺代码： import java.util.Scanner; public class Aphabet { public static void main(String[] args) { System.out.println(\"======Upper========\"); Scanner input = new Scanner(System.in); int n,level; System.out.println(\"the value of n:\"); n = input.nextInt(); level = (int)Math.ceil(26/n);//向上取整 int j = 0; char ch = 65; p(1, n, ch); } public static void p(int x,int n,char ch) { if(x &gt; n) return; for(int i = x;i &lt;= 26;i += n){ ch = (char)(i + 64); System.out.print(ch + \" \"); } System.out.println(); ++x; p(x, n, ch); } } 下午做了半个多小时都没做出来，晚上玩了会游戏突然想到用递归，下午怎么就没想到呢？然后游戏就挂机被举报了，但一气呵成搞定了这题。说明思想不够灵活hhh 🔺截图： 补充：Java Character 类isLowerCase() 方法🔺作用：用于判断指定字符是否为小写字母。 🔺语法 boolean isLowerCase(char ch) 🔺参数 ch – 要测试的字符。 🔺返回值 如果字符为小写，则返回 true；否则返回 false。 🔺实例 public class Test { public static void main(String args[]) { System.out.println( Character.isLowerCase('a')); System.out.println( Character.isLowerCase('A')); } } 🔺以上程序执行结果为： true false isUpperCase() 方法 🔺作用：用于判断指定字符是否为大写字母。 🔺语法 boolean isUpperCase(char ch) 🔺参数 ch – 要测试的字符。 🔺返回值 如果字符为大写，则返回 true；否则返回 false。 🔺实例 public class Test { public static void main(String args[]) { System.out.println( Character.isUpperCase('b')); System.out.println( Character.isUpperCase('B')); } } 🔺以上程序执行结果为： false true document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java—5种生成随机数的方法","slug":"Java—5种生成随机数的方法","date":"2019-11-30T02:33:25.000Z","updated":"2019-12-01T01:53:18.885Z","comments":true,"path":"2019/11/30/Java—5种生成随机数的方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%945%E7%A7%8D%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"5种生成随机数的简单方法 和一篇大佬的文章👇","text":"5种生成随机数的简单方法 和一篇大佬的文章👇 方法①🔺 通过java.Math包的random方法得到1-10的int随机数 🔺 公式： 最小值—最大值（整数）的随机数 (类型) 最小值+Math.random()*最大值 import java.util.Random; public class RandomDemo { public static void main(String[] args) { for (int i=0;i&lt;5;i++) { System.out.println((int)(1+Math.random()*10)); int k; k=(int)(1+Math.random()*10); } } } 方法②🔺借助java.util.Random类来产生一个随机数发生器，也是最常用的一种，构造函数有两个，Random()和Random(long seed)。第一个就是以当前时间为默认种子，第二个是以指定的种子值进行。产生之后，借助不同的语句产生不同类型的数。 🔺种子就是产生随机数的第一次使用值,机制是通过一个函数,将这个种子的值转化为随机数空间中的某一个点上,并且产生的随机数均匀的散布在空间中。以后产生的随机数都与前一个随机数有关 import java.util.Random; public class RandomDemo { public static void main(String[] args) { Random r = new Random(); for(int i=0 ; i&lt;5 ; i++) { int ran1 = r.nextInt(100);//种子：100 System.out.println(ran1); } } } 注：类似的方法可参考 利用Random类来产生5个20~50之间的随机整数 方法③ 生成随机数需要使用到Java工具类中的Random类。 要求是随机x到y之间的整数，即指定范围，则使用Random类中的nextInt(int n)方法。 该方法生成从0（包括）到n（不包括）之间的随机整数，是一个伪随机数，并不是真正的随机数。 若x不为0，则需要在随机结果后加上x。参数n的值也需要加上1后减去x。最后结果才符合要求的范围。 import java.util.Random; public class RandomDemo { public static final int START = 50; //定义范围开始数字 public static final int END = 99; //定义范围结束数字 public static void main(String[] args) { //创建Random类对象 Random random = new Random(); //产生随机数 int number = random.nextInt(END - START + 1) + START; //打印随机数 System.out.println(\"产生一个\"+START+\"到\"+END+\"之间的随机整数：\"+number); } } 注：更多方法可参考【Java工具类】—-产生随机数 方法④🔺 返回的数值是 [ 0.0 , 1.0 ) 的double型数值，由于double类数的精度很高，可以在一定程度下看做随机数，借助（int）来进行类型转换就可以得到整数随机数了 public static void main(String[] args) { for (int i = 1; i &lt;= 10; i++) { int max=99,min=10;//生成两位随机正整数 int ran2 = (int) (Math.random()*(max-min)+min); System.out.println(ran2); } } 方法⑤🔺 返回从1970年1月1日0时0分0秒（这与OS有关）到现在的一个long型的毫秒数，取模之后即可得到所需范围内的随机数 public static void main(String[] args) { int max=100,min=1; long randomNum = System.currentTimeMillis(); int ran3 = (int) (randomNum%(max-min)+min); System.out.println(ran3); } 大佬的文章这个大佬【peabits】的文章贼详细，可以好好琢磨琢磨 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java中的<<、>>和>>>","slug":"Java中的、-和","date":"2019-11-29T16:33:38.000Z","updated":"2019-11-29T17:14:55.054Z","comments":true,"path":"2019/11/30/Java中的、-和/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E4%B8%AD%E7%9A%84%E3%80%81-%E5%92%8C/","excerpt":"左移 左移运算符 &lt;&lt; 👉使指定值的所有位都左移规定的次数 左移m&lt;&lt;n，代表把数字m在无溢出的前提下乘以2的n次方 右移 右移运算符 &gt;&gt; 👉 使指定值的所有位都右移规定的次数 右移m&gt;&gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数 注意，如果是单数，也就是二进制末位为1，则结果是将m除以2的n次方的整数商 无符号右移 无符号右移运算符 &gt;&gt;&gt; 👉同右移，但是结果全变正数","text":"左移 左移运算符 &lt;&lt; 👉使指定值的所有位都左移规定的次数 左移m&lt;&lt;n，代表把数字m在无溢出的前提下乘以2的n次方 右移 右移运算符 &gt;&gt; 👉 使指定值的所有位都右移规定的次数 右移m&gt;&gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数 注意，如果是单数，也就是二进制末位为1，则结果是将m除以2的n次方的整数商 无符号右移 无符号右移运算符 &gt;&gt;&gt; 👉同右移，但是结果全变正数 Demo 以下内容转载于 Java中的&lt;&lt; 和 &gt;&gt; 和 &gt;&gt;&gt; 详细分析 详细分析&lt;&lt;表示左移，不分正负数，低位补0； 注：以下数据类型默认为byte-8位 左移时不管正负，低位补0 正数：r = 20 &lt;&lt; 2 20的二进制补码：0001 0100 向左移动两位后：0101 0000 结果：r = 80 负数：r = -20 &lt;&lt; 2 -20 的二进制原码 ：1001 0100 -20 的二进制反码 ：1110 1011 -20 的二进制补码 ：1110 1100 左移两位后的补码：1011 0000 反码：1010 1111 原码：1101 0000 结果：r = -80 &gt;&gt;表示右移，如果该数为正，则高位补0，若为负数，则高位补1； 注：以下数据类型默认为byte-8位 正数：r = 20 &gt;&gt; 2 20的二进制补码：0001 0100 向右移动两位后：0000 0101 结果：r = 5 负数：r = -20 &gt;&gt; 2 -20 的二进制原码 ：1001 0100 -20 的二进制反码 ：1110 1011 -20 的二进制补码 ：1110 1100 右移两位后的补码：1111 1011 反码：1111 1010 原码：1000 0101 结果：r = -5 &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0 正数： r = 20 &gt;&gt;&gt; 2 的结果与 r = 20 &gt;&gt; 2 相同； 负数： r = -20 &gt;&gt;&gt; 2 注：以下数据类型默认为int 32位 -20:源码：10000000 00000000 00000000 00010100 反码：11111111 11111111 11111111 11101011 补码：11111111 11111111 11111111 11101100 右移：00111111 11111111 11111111 11111011 结果：r = 1073741819 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java用最有效率的方法计算2乘以8","slug":"Java—用最有效率的方法计算2乘以8","date":"2019-11-29T16:24:00.000Z","updated":"2019-12-01T01:58:23.398Z","comments":true,"path":"2019/11/30/Java—用最有效率的方法计算2乘以8/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%972%E4%B9%98%E4%BB%A58/","excerpt":"","text":"最有效率的方法 👉 2 &lt;&lt; 3 其中，左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方 再比如，31 * num 等价于( num &lt;&lt; 5 ) – num 左移5位相当于乘以2的5次方（32），再减去自身（-1），这一过程就相当于乘以31 注：关于移位运算符，可参考我的下一篇博客 Java中的&lt;&lt;、&gt;&gt;和&gt;&gt;&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java笔记—static关键字","slug":"Java笔记—static关键字","date":"2019-11-28T09:24:41.000Z","updated":"2020-02-15T14:06:51.884Z","comments":true,"path":"2019/11/28/Java笔记—static关键字/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/28/Java%E7%AC%94%E8%AE%B0%E2%80%94static%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"static 关键字static类型，又叫类类型。 修饰目标 (成员数据/方法/成员内部类/代码块)属于类的 静态类 静态块 静态方法 静态变量 static 成员内部类 static 代码块 static 成员方法 static 成员变量 直接通过类就可以访问。所有对象共享该类 只能出现在类中不能出现方法体中，类加载后初始化时被执行一次。注意:区分构造代码块，每次构造都被执行 直接通过类就可以调用。不用等创建了实例后 类加载时在Java方法区分配空间，所有对象共享 区别：无static关键字成员属于具体的对象实例： 实例变量、实例方法(只能通过对象调用)、实例成员内部类(只能通过对象引用) 静态的特点 随着类的加载而加载 也就是，说静态会随着类的消失而消失，说明静态的生命周期最长。 优先于对象的存在 明确一点：静态是先存在的，对象是后存在的。 被所有对象共享。 可以直接被类名多调用。 static 成员的访问格式一般要通过 *“ 类名. ” * 的形式来访问 静态变量 静态方法 静态成员内部类 类名.静态变量 类名.静态方法 类名.静态成员内部类 注意事项🔺 static成员方法/代码块：静态方法 只能 使用静态成员变量(或内部类)或调用静态方法。（任课老师称： 静者恒静） 🔺非静态方法可以访问静态、也可以访问非静态。 🔺 static成员方法/代码块：方法体中不能出现this(当前对象)或super(基类对象)。因为静态优先于对象存在，所以静态方法中不可以出现this、super关键字。 实例变量和类变量的区别 存放位置 类变量随着类的加载存在于方法区中，实例变量随着对象的对象的建立存在于堆内存里 生命周期 类变量生命周期最长，随着“类”的加载而加载，随着类的消失而消失 实例变量随着“对象”的消失而消失 静态的利弊 利：1、对对象的共享数据进行单独空间的存储，节省空间，没有必要没一个对象中都存储一份。2、可以直接被类名所调用。 弊：生命周期过长，访问出现局限性（只能访问静态）","text":"static 关键字static类型，又叫类类型。 修饰目标 (成员数据/方法/成员内部类/代码块)属于类的 静态类 静态块 静态方法 静态变量 static 成员内部类 static 代码块 static 成员方法 static 成员变量 直接通过类就可以访问。所有对象共享该类 只能出现在类中不能出现方法体中，类加载后初始化时被执行一次。注意:区分构造代码块，每次构造都被执行 直接通过类就可以调用。不用等创建了实例后 类加载时在Java方法区分配空间，所有对象共享 区别：无static关键字成员属于具体的对象实例： 实例变量、实例方法(只能通过对象调用)、实例成员内部类(只能通过对象引用) 静态的特点 随着类的加载而加载 也就是，说静态会随着类的消失而消失，说明静态的生命周期最长。 优先于对象的存在 明确一点：静态是先存在的，对象是后存在的。 被所有对象共享。 可以直接被类名多调用。 static 成员的访问格式一般要通过 *“ 类名. ” * 的形式来访问 静态变量 静态方法 静态成员内部类 类名.静态变量 类名.静态方法 类名.静态成员内部类 注意事项🔺 static成员方法/代码块：静态方法 只能 使用静态成员变量(或内部类)或调用静态方法。（任课老师称： 静者恒静） 🔺非静态方法可以访问静态、也可以访问非静态。 🔺 static成员方法/代码块：方法体中不能出现this(当前对象)或super(基类对象)。因为静态优先于对象存在，所以静态方法中不可以出现this、super关键字。 实例变量和类变量的区别 存放位置 类变量随着类的加载存在于方法区中，实例变量随着对象的对象的建立存在于堆内存里 生命周期 类变量生命周期最长，随着“类”的加载而加载，随着类的消失而消失 实例变量随着“对象”的消失而消失 静态的利弊 利：1、对对象的共享数据进行单独空间的存储，节省空间，没有必要没一个对象中都存储一份。2、可以直接被类名所调用。 弊：生命周期过长，访问出现局限性（只能访问静态） Demo：类内使用import static java.lang.System.*; //静态导入静态方法或对象 public class StaticDemo1 { static int a = 3, b, i = 0; // 静态变量 char ch = 'Y'; // 实例变量 static void meth(int x) { // 静态方法 out.println(\"x = \" + x); //out.println(\"ch = \" + ch);//【1】Error! } static { // 静态代码块-类加载时只执行1次 out.println(\"静态块初始化：仅1次\"); b = a * 4; //out.println(\"ch = \" + ch);//【1】Error! } public static void main(String[] args) { meth(42); //静态方法调用静态方法 new StaticDemo1(); //创建匿名对象1 new StaticDemo1(); //创建匿名对象2 } { out.println(\"ch = \" + ch);//【2】OK! out.printf(\"构造代码块：第%d次构造第%1$d次执行\\n\", (++i)); } } } 注意： 🔺特别注意：类的静态代码块仅在类在加载后初始化时被执行1次 🔺第一次new一个类时才加载该类 🔺静态方法、静态块不能访问非静态的成员（即，静者恒静）。如上述代码中的注释【1】 🔺静态块初始化：仅1次 Demo：类外使用和静态块执行时机import static java.lang.System.out; class MyD{ private static int m; public static int n; static{ // 静态代码块【2】 m = n = 0; out.println(\"仅1次\"); } public static void callMe(){ out.printf(\"m=%d,n=%d\", m, n); } } public class StaticDemo2 { public static void main(String[] args) { MyD d; //【0】MyD被加载，但未主动使用 d = new MyD(); //【1】这里才【主动使用】MyD，于是执行其静态代码块【2】 MyD.n++; //最佳：类名.静态变量 MyD.callMe(); //最佳：类名.静态方法 } } 特别留意： 🔺用一个类声明一个类对象变量，至多会加载该类，但还未主动使用🔺老师说：【主动使用】，是一个比较高级的专题，暂不深入 DEMO：静态方法的声明class Person{ String name; //定义name属性 private static String nation = \"中国\"; //定义静态属性nation int age; //定义age属性 public Person(String name, int age){//声明一个有参的构造方法 this.name = name; this.age = age; } public String talk(){ //声明了一个talk()方法 return \"我是：\" + this.name + \"，今年：\" + this.age + \"岁，来自：\" + nation; } public static void setNation(String nat){//声明一个静态方法，给静态变量赋值 nation = nat; } } public class StaticMethod{ public static void main(String[] args){ Person p1 = new Person(\"张三\", 25); Person p2 = new Person(\"李四\", 30); Person p3 = new Person(\"王五\", 35); System.out.println(\"修改之前信息：\" + p1.talk()); System.out.println(\"修改之前信息：\" + p2.talk()); System.out.println(\"修改之前信息：\" + p3.talk()); System.out.println(\" ***********修改之后信息***********\"); // 修改后的信息 Person.setNation(\"美国\"); System.out.println(\"修改之后信息：\" + p1.talk()); System.out.println(\"修改之后信息：\" + p2.talk()); System.out.println(\"修改之后信息：\" + p3.talk()); } } DEMO：调用外部类定义的方法（有static+无static）首先定义方法 public class Dy { public int Add(int x,int y) { //定义Add(),该方法没有被static修饰 return x+y; } public static int Sub(int x,int y) {//定义Sub(),该方法被static修饰 return x-y; } } 调用方法 public class Test { public static void main(String[] args){ int a=5; int b=4; int result=0; //通过实例化调用外部类的Add方法 Dy dy=new Dy(); result=dy.Add(a, b); System.out.println(result); //直接调用外部类的Sub方法 result=Dy.Sub(a, b); System.out.println(result); } } 🔺static main方法调用外部方法/成员变量： 有static：“类名.”形式调用 无static：“对象.”形式调用 综上 什么时候使用静态？ 因为静态修饰的内容有成员变量和方法。 什么时候定义静态变量（类变量）呢？ 当对象中出现共享数据时，该数据被静态所修饰，对象中的特有数据要定义成非静态存在于堆内存中。 什么时候定义静态函数？ 当功能内部没有访问到非静态数据（或者称为对象的特有数据） 那么该功能可以定义成静态的。 注：前面的几篇Java笔记中也有提到static，后来上课老师再小结static关键词，结合前面的笔记食用效果更佳。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java笔记—this关键字","slug":"Java笔记—this关键字","date":"2019-11-28T09:11:18.000Z","updated":"2019-11-29T17:36:57.692Z","comments":true,"path":"2019/11/28/Java笔记—this关键字/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/28/Java%E7%AC%94%E8%AE%B0%E2%80%94this%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"this 关键字三个形式上的用途，但本质上就两个： 调用重载的其他构造方法：放置在构造方法体首行的this()或this(实参列表) 作为当前对象，引用成员（数据、方法等）：区分同名变量等 作为当前对象，方法返回当前对象的引用，形成链式调用","text":"this 关键字三个形式上的用途，但本质上就两个： 调用重载的其他构造方法：放置在构造方法体首行的this()或this(实参列表) 作为当前对象，引用成员（数据、方法等）：区分同名变量等 作为当前对象，方法返回当前对象的引用，形成链式调用 案 例 ： public class ThisDemo { private int a = 1; private String name = \"good\"; private int i = 0; public ThisDemo(){ System.out.println(\"无参构造子\" + this); } public ThisDemo(int a, String name){ this(); // 【1】调用无参构造子 this.a = a; // 【2】当前对象，引用成员 this.name = name; } public ThisDemo setA(int a){ this.a = a; return this; // 【3】返回当前对象 } public ThisDemo setName(String name){ this.name = name; return this; } public ThisDemo inc(){ i++; return this; } public static void main(String[] args) { ThisDemo t1 = new ThisDemo(); t1.setA(100).setName(\"guo\").inc().inc(); System.out.println(t1.i); ThisDemo t2 = new ThisDemo(2, \"Tom\"); t2.inc().setA(8).inc().inc(); //【4】链式调用 System.out.println(t2.i); } } 特别注意，案例中的【3】和【4】。 注：前面的几篇Java笔记中也有提到this，后来上课老师再小结this关键词，结合前面的笔记食用效果更佳。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"对SQL的触发器的浅理解","slug":"浅谈SQLServer触发器","date":"2019-11-26T05:08:18.000Z","updated":"2019-11-28T11:22:43.203Z","comments":true,"path":"2019/11/26/浅谈SQLServer触发器/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/26/%E6%B5%85%E8%B0%88SQLServer%E8%A7%A6%E5%8F%91%E5%99%A8/","excerpt":"","text":"个人理解如果需要做一些特定的增删改操作，就可以使用触发器。 触发 ，当做了某种预设的操作时才会执行触发器的命令。 栗子：假设现在有个员工基础信息表，里面有员工的身份证号码，手机等基本信息。那么，当你换了身份证或手机，需要修改号码的时候，肯定是去修改员工的基础资料表。假设你现在有别的地方，比如人事档案啊之类的，同样使用了员工的手机等信息，难道还要再去修改一次档案表么？那么如果还有其他地方使用了呢？而在这种时候有触发器就好解决了。如果设置一个触发器来判断，如果修改了基础表的信息，那么就同步把其他使用了基础表的关联信息也更改成最新的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"SQL Server","slug":"SQL-Server","permalink":"https://melodyjerry.github.io/blog/tags/SQL-Server/"}]},{"title":"G.E.M.邓紫棋《句号》MV首播！","slug":"G.E.M.邓紫棋《句号》MV首播！","date":"2019-11-25T14:21:12.000Z","updated":"2019-11-29T04:53:27.657Z","comments":true,"path":"2019/11/25/G.E.M.邓紫棋《句号》MV首播！/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/25/G.E.M.%E9%82%93%E7%B4%AB%E6%A3%8B%E3%80%8A%E5%8F%A5%E5%8F%B7%E3%80%8BMV%E9%A6%96%E6%92%AD%EF%BC%81/","excerpt":"G.E.M.邓紫棋《句号》MV首播！ 🧡点击破亿『全创作天后』G.E.M.邓紫棋和过去告别，向未来大步迈开，开启音乐版图新起点的一个“句号”。 这是华语乐坛前所未见的真实披露之作，她用&lt;句号&gt;这首歌，预告了全新的音乐篇章，翻页之后，就要开始。 榜单Top 1 💗邓紫棋新歌《句号》上线颇有波折，国内几大音乐平台推迟上线，但在唯一上线的Apple Music平台，已经超过霉霉新歌《lover》，一举拿下 榜单 Top1！ 官方MV视频第一发布于微博： GEM鄧紫棋 2019.11.28更换 1 网页视频源： B站官方合作发布","text":"G.E.M.邓紫棋《句号》MV首播！ 🧡点击破亿『全创作天后』G.E.M.邓紫棋和过去告别，向未来大步迈开，开启音乐版图新起点的一个“句号”。 这是华语乐坛前所未见的真实披露之作，她用&lt;句号&gt;这首歌，预告了全新的音乐篇章，翻页之后，就要开始。 榜单Top 1 💗邓紫棋新歌《句号》上线颇有波折，国内几大音乐平台推迟上线，但在唯一上线的Apple Music平台，已经超过霉霉新歌《lover》，一举拿下 榜单 Top1！ 官方MV视频第一发布于微博： GEM鄧紫棋 2019.11.28更换 1 网页视频源： B站官方合作发布 ( ͡° ͜ʖ ͡°)✧我已经 循环 MV几天了，等待网易云上架。 听说 “连Siri都被圈粉？有网友发现现在向Siri提出“播放世界第一的歌曲”，结果直接是《句号》” 有iPhone的，赶紧试试看吧 ( ͡° ͜ʖ ͡°)✧ 1.第一次发这篇文章的第二天发现视频链接失效，研究了一下，发现微博视频用的是临时链接，就是生命周期只有1天的临时链接，于是我改由B站的视频 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"音乐","slug":"音乐","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"[电影]《Ladybird》演绎完整18岁的青春","slug":"电影-《Ladybird》演绎完整18岁的青春","date":"2019-11-23T13:33:12.000Z","updated":"2020-02-11T06:44:37.415Z","comments":true,"path":"2019/11/23/电影-《Ladybird》演绎完整18岁的青春/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/23/%E7%94%B5%E5%BD%B1-%E3%80%8ALadybird%E3%80%8B%E6%BC%94%E7%BB%8E%E5%AE%8C%E6%95%B418%E5%B2%81%E7%9A%84%E9%9D%92%E6%98%A5/","excerpt":"《LadyBird》，2017年的青春轻喜剧，烂番茄指数高达99%！","text":"《LadyBird》，2017年的青春轻喜剧，烂番茄指数高达99%！ ​ 该电影讲的是一个入不敷出的家庭，强势严厉的Mom，慈祥宽容却患有抑郁症的Dad，自称LadyBird的叛逆少女Christian克里斯汀，从高中步入大学时期所经历的亲情、友情、爱情，酸甜苦辣。 ​ 虽然欧美家庭的相处方式离我们很远，但影片展现的青春经历却与我们都有可对照之处。 ​ Christian不喜欢父母取的名字，自己取名为LadyBird，盼望自己化身为鸟，渴望获得自由。她横冲直撞，怼哥哥，怼老师，怼修女，公然挑衅和搞恶作剧。18岁的第一天，就去买了骆驼香烟，一张彩票，一本成人杂志，站在家乡萨克拉门托的阳光下，体会成长放纵的快感。她想逃离家乡，去纽约，去外面的世界闯荡，瞒着妈妈偷偷申请纽约的学校。 ​ 她不去考虑别人地感受，想要的太多，对得到的总是不够满足。当然，她也有自卑虚荣的一面。会纠结自己不够出众的长相，“为什么我看起来不像是杂志里的女孩？”，不喜欢贫寒的出身，把男朋友外婆家的dreamhouse说成是自己家；为了接近乐队的凯尔，成为同样酷酷的类型，她和珍娜套近乎而疏远了自己最好的朋友。 ​ 两次恋爱纷纷落空。第一次是个贴心男友，交往顺利，却被发现是个同性恋。第二次是个俊俏阴郁乐队选手（是有点帅），但性生活不够严肃，上完床两人就分了一半了吧。直到在去舞会的路上，男友和他的朋友们想中途逃出来，LadyBird却对舞会充满期待。其实就是三观不合啊！她开始同意，却也意识到，坚持自己内心的感受，不适合跟这些人做朋友。生活就是这样啊，我们期待、努力、相信又落空。谁的青春没遇上过渣男，只是帅不帅而已。 ​ LadyBird和老妈的冲突贯穿影片。强势得老妈常常扮演成长中的“黑脸角色”，总是试图把自己的意念强加给孩子：上一秒还被广播感动的母女二人，下一秒迅速争执起来，LadyBird用跳车的方式宣扬自己的逃离和叛逆；衣服不叠会被老妈骂，走路的姿势会被嫌弃，穿什么衣服都得不到赞扬，浴室不能反锁门，进屋从来不敲门……青春期的孩子都渴望自由，太想脱离大人的管教——“告诉我你抚养花了多少钱！等我长大了努力赚钱都还给你！这样我就再也不用和你讲话！” ​ 这份冲突的亲情在最后得到了和解。平安夜不在家过看得出妈妈最难过；会在半夜为女儿修剪裙边；暗自用没有语法韵律的信件记录下对女儿的冲突和爱意；当LadyBird真的去上大学，表面保持冷漠严肃，车都不下，实际内心有满满地不舍。一切地情感在试衣间前得到合理地解释： “I want you to be the best version of yourself you can be.” “What if this is the best version?” ​ 这也是每个家长对我们地期待吧。然而，对于家长地对我们地改变，我们总是无意识就反驳，就对抗。你有你的唠叨，我有我的骄傲！ ​ 失业、并长期患有抑郁症的老爸是影片温情的存在，是家里的“好人角色”担当。记得在女儿十八岁生日时送上生日蛋糕；瞒着妈妈帮女儿申请纽约的学校，是女儿地‘同党’；问是否要和门外那个按喇叭的男孩走，虽然爸爸内心是不喜欢的，但依然会尊重女儿；影片最后，悄悄把妈妈写的信放进Ladybird书包，告诉她，妈妈其实是多么爱她——这也是促进母女关系和解的重要一环。 ​ 这是一个与自己、与家人和解的故事，像极了青春期的我们。影片的最后，她真的到达纽约。在家乡，这个女孩给自己取名为LadyBird，向所有人宣称自己的叛逆，想像鸟一样自由挣脱；而到了纽约，她要像鸟一样开始漂泊时，又叫回Christian。因未来而出走，因出走而怀乡。 影片的最后，她在电话里说“妈妈，我发现我从来没有意识到，萨克拉门托是那么美的地方。似乎每一处细节，每一个弯道，都是那么的美丽。” ​ 我们总想为逃离自己的家庭出身而奋斗，终有一天会觉得，走得再远，都想再回到最初的地方。蜷局于母体时的安全是最安全。 大二上学期《英语影视鉴赏》课结作业。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"电影","slug":"电影","permalink":"https://melodyjerry.github.io/blog/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"Java笔记—包","slug":"Java笔记—包","date":"2019-11-23T05:54:59.000Z","updated":"2019-11-29T17:36:24.562Z","comments":true,"path":"2019/11/23/Java笔记—包/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/23/Java%E7%AC%94%E8%AE%B0%E2%80%94%E5%8C%85/","excerpt":"Java笔记——包创建时间：2019.11.23 说明：持续更新ing 概念 包(package) 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 ✔ 用来组织和管理类、接口、枚举和注解✔ 有三方面作用：1)便于组织,比如按功能、按团队等；2)解决命名冲突；3)进行访问权限控制(同包可用，包外不可见等) 如同类似OS的文件夹(或目录或路径)一样，包也采用了树形目录的存储方式。","text":"Java笔记——包创建时间：2019.11.23 说明：持续更新ing 概念 包(package) 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 ✔ 用来组织和管理类、接口、枚举和注解✔ 有三方面作用：1)便于组织,比如按功能、按团队等；2)解决命名冲突；3)进行访问权限控制(同包可用，包外不可见等) 如同类似OS的文件夹(或目录或路径)一样，包也采用了树形目录的存储方式。 作用 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 🔺 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 同一个包中类名字是不同的，不同包中类的名字可以相同，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 语法格式 package 包名 或 package 父包名[.子包名][.孙包名][.层次下去] 🔸包名符合标识符命名规范，一般由小写字母组成🔹必须出现在源文件的第一行(忽略注释语句)🔸每个源文件至多只能出现一个package语句🔹如果没有package语句，那就使用无名包(或称默认包:所在的当前目录)🔸包的背后对应着操作系统的路径名称 示例： package ch08.web.sample; public class Person { String name; int age; //省略部分代码 } class Dog { String name; int age; //省略部分代码 } 🔺package ch08.web.sample; 这个层级的文件夹必须先存在：即ch08/web/sample 包的使用 🔺import 关键字 为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。 为了使用另外一个包中的成员(主要是类)，可以明确import该成员。 避免重复使用完整路径的类名。 语法格式： import package1[.package2…].(classname|*); 注意： 必须紧跟在package语句之后(若有的话，若无package，则import出现在源文件头部)。 可以使用 * 来表示导入当前一层包中的所有类。但是* 不可以连续使用。 import java.*.*; // Error! 不表示可以继续导入当前包的子包。如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。 类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。 Java常用包 🔵JavaAPI的类库也是按照包的方式组织的 包名 描述 备注 Java.lang Java语言进行程序设计的基础类(核心类库)，它是默认导入的包 Runnable接口和Object、Math、String、StringBuffer、System、Thread、Throwable类 Java.util 实用工具类包 定义系统特性、随机数、日期时间、日历、集合类等 Java.io IO类包 包含能提供多种输入输出的文件读写类 Java.net 网络编程API Java.sql 数据库操作包 Java.text 文本处理相关类 包含了一些用来处理文本、数字和消息的类和接口 Java.awt 提供创建界面和绘制图形图像的所有类 Javax.asing awt上封装的GUI包 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"推荐3款文本编辑器","slug":"文本编辑器","date":"2019-11-22T02:34:04.000Z","updated":"2019-11-29T17:38:00.468Z","comments":true,"path":"2019/11/22/文本编辑器/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/22/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/","excerpt":"前言今天作者推荐两款文本编辑器。 我先后使用的Notepad 3、Sublime、Atom、VS Code、Vim。 这里作者就只推荐Notepad 3、Sublime和Atom。 关于VS Code和Vim，文末有两篇教程供大家入手。","text":"前言今天作者推荐两款文本编辑器。 我先后使用的Notepad 3、Sublime、Atom、VS Code、Vim。 这里作者就只推荐Notepad 3、Sublime和Atom。 关于VS Code和Vim，文末有两篇教程供大家入手。 //截断文章 Notepad 3 虽然 Windows 操作系统在过去几年中有了显著变化，但是，默认的 Windows 记事本却鲜有更新。如果您需要一个简单且适于编程的文本编辑器，Notepad3 将是一个不错的选择！ Notepad3是一款轻便快捷的基于 Scintilla 的文本编辑器，具有语法高亮、代码折叠、括号匹配、自动缩进、编码转换、换行格式转换、多次撤销或重做、书签、基于正则表达式的查找和替换等实用功能。它占用的内存很小，但功能强大，足以处理大多数编程工作。 Notepad 3 的界面 可能 是我见过所有主流文本编辑器里最最最简单清爽的吧？ 蓝奏云：下载链接（作者提供了已经汉化过的便携版本） （注意：Notepad 3和Notepad++没有关系 ） Sublime官方的介绍简单又粗暴 一款用于代码、标记和散文的精致文本编辑器 Sublime支持 Windows 、Mac 平台。插件是程序员的灵魂，Sublime不失这点。类似于 Eclipse，IDEA，它有着丰富的插件系统，完全可以满足各种开发编辑需求。1）安装 官网关于Sublime的介绍语下就是win版的下载入口或者点击这里快速下载最新版==Sublime Text 3 (Build 3207)== 下载得到的是exe，双击开始安装。 安装导向界面，点击【Next】继续安装。选择Sublime Text 3安装位置，您可以点击【Next】，软件会自动安装。或者您可以单击【Browse】，在弹出的安装位置窗口中，您可以自己选择Sublime Text安装位置，选择完成后点击【Next】。这里可选择 添加到资源管理器上下文菜单 。 安装完后可以在桌面或者开始菜单中找到Sublime。 2）使用Sublime的界面特别简洁，让人看着很舒服。这里，作者已经汉化过了。初始语言是English。 3）汉化 sublime 的插件的强大之处，sublime 通过 package control来统一管理安装的插件。现版本sublime 3自带package control功能。 将English变成Chinese，也可以通过Sublime的插件实现。 作者已经汉化过。为了教程，故在win7虚拟机上教大家如何实现汉化。 官网下载，并安装好, 刚安装好的是没有 Package Control 选项 找到 Tools-&gt;Install Package Control 选项，即可调出 Package Contro 不能直接找到 Install Package Control，去找“Tools-&gt;Command Palette…”选项 输入 ipc ,点击 Install Package Control，即可调出 Package Control 等待完成 找到 Preferences-&gt;Package Control 选项弹出命令行输入框，输入ip，点击“install Package 弹出命令行输入框，输入clz，点击“ChineseLocalizations” 搞定，设置成中文了 开开心心地食用汉化地Sublime吧 o(￣▽￣)o Atom Atom 是 Github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持CSS，HTML，JavaScript等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。 官网在这里👈友情链接：w3school之Atom教程Atom 中文社区 1）安装官网地Downloa或者点击这里快速下载最新版==Atom (1.41.0)== 下载得到exe，双击开始安装。安装过程很简单，直接省略。 2）使用Atom 的界面也比较简洁。Atom提供了侧栏、标签栏，可提高效率。Atom还能链接到GitHub，这真是GitHub用户的福利。(当然，Atom本来就是Github推出的hhhh)3）汉化Atom的汉化有两种方法： 方法一 打开软件后，点击 File&gt; Settings&gt; install 搜索 chinese，安装两个插件 重启软件因为插件托管在国外，可能因为网速原因，会非常慢，因此推荐下载中文插件包，请看方法二👇 方法二 打开https://atom.io/packages/去官网下载中文包，搜索【Chinese】，找到【atom-simplified-chinese-menu】点击进入主页（如上图），然后再点【Verions】，之后，找到最新版本，点【zip】包下载即可。。作者在这已经准备好中文包了，点击这里下载 将下载好了的压缩包解压到 C:/user/&lt;用户名&gt;/.atom/packages/目录下面 打开Atom，发现已经Chinese了。 综上主流的文本编辑器有很多。每个人的需求不一样，找到合适自己的才是好的。Notepad 3、Sublime、Atom、VS Code、Vim、Notepad++（前段时间闹事，作者不方便再提） VS Code：传送门 Vim：传送门 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Java笔记—继承","slug":"Java笔记—继承","date":"2019-11-21T09:54:59.000Z","updated":"2019-11-29T17:36:14.410Z","comments":true,"path":"2019/11/21/Java笔记—继承/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/21/Java%E7%AC%94%E8%AE%B0%E2%80%94%E7%BB%A7%E6%89%BF/","excerpt":"Java笔记——继承 创建时间：2019.11.21 说明：持续更新ing 继承源于自然 就比如：兔子和羊属于食草动物类，狮子和豹属于食肉动物类。食草动物和食肉动物又是属于动物类。虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以 子类会具有父类的一般特性也会具有自身的特性。","text":"Java笔记——继承 创建时间：2019.11.21 说明：持续更新ing 继承源于自然 就比如：兔子和羊属于食草动物类，狮子和豹属于食肉动物类。食草动物和食肉动物又是属于动物类。虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以 子类会具有父类的一般特性也会具有自身的特性。 //截断文章 概念、目的、本质、特性 概念 它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 其主要作用在于，在已有基础上继续进行功能的扩充。（即，以存在的类为基础定义新的类，新类即拥有基类的数据成员和成员方法） 目的 继承的目的是代码重用 本质 描述了自然界中广泛存在的一种关系——类属关系（is-a），对应还有一种has-a关系即组合（聚合）关系。 特性 Java 继承的特性 子类拥有父类非private的属性，方法 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展 子类可以用自己的方式实现父类的方法 Java的继承是单继承，【但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性】 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系） 继承的关键字 继承可以使用 extends(单继承) 和 implements（变相的多继承）， 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 （1）extends关键字 Java只支持单继承，即：一个子类只能有一个父类.但可以有多个间接祖先类。 语法格式： 权限修饰符 class 父类名 { //父类体 } 权限修饰符 class 子类名 extends 父类名 { //子类体 } 实例： public class Animal { private String name; private int id; public Animal(String myName, String myid) { //初始化属性值 } public void eat() { //吃东西方法的具体实现 } public void sleep() { //睡觉方法的具体实现 } } public class Penguin extends Animal{ } —————————————————————— 我 是 分 割 线 ——————————————————————— （2）implements关键字 变相地使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 public interface A { public void eat(); public void sleep(); } public interface B { public void show(); } public class C implements A,B { } &lt;!--￼2--&gt; 执行结果： &lt;!--￼3--&gt; —————————————————————— 我 是 分 割 线 ——————————————————————— （4）this关键字 指向”自己的引用“。 实例： class Animal { void eat() { System.out.println(\"animal : eat\"); } } class Dog extends Animal { void eat() { System.out.println(\"dog : eat\"); } void eatTest() { this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 } } public class Test { public static void main(String[] args) { Animal a = new Animal(); a.eat(); Dog d = new Dog(); d.eatTest(); } } 输出结果： animal : eat dog : eat animal : eat ——————————————————————————— 我 是 分 割 线 ———————————————————————————— （5）final关键字 声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。 继承类型 Java 不支持多继承，但支持多重继承 （ 一般不会超过三层 ）。 继承的限制 🔺 Java只允许单继承、不允许多继承（一个子类继承一个父类）。 🔺 子类对象在进行实例化前首先调用父类构造方法，再调用子类构造方法实例化子类对象。 🔺 在继承时，子类会继承父类的所有结构。 在进行继承的时候，子类会继承父类的所有结构（包括私有属性、构造方法、普通方法）显示继承：所有非私有操作属于显示继承（可以直接调用）。隐式继承：所有私有操作属于隐式继承（不可以直接调用，需要通过其它形式调用（get或者set））。 子类能够使用的是所有非private操作，而所有的private操作无法被直接使用，所以称为隐式继承。 继承中“域的隐藏” 在子类中重新定义( 同 名 )继承自父类的域. 🔺子类继承父类非私域。 🔺子类定义与从父类继承下来的同名域，在子类中用该名直接访问就只能访问到子类定义的域，即隐藏了同名的继承下来的父类域。 🔺如果要访问同名父类域：通过父类方法，或者使用“*super . *” 实例： import static java.lang.System.*; class Super{ private int v1 = 1; int v2 = 2; public int getV1() { return v1; } } class Sub extends Super{ int v1 = 11; int v2 = 22; public void show() { out.println(v1); //out.println(super.v1); out.println(getV1()); out.println(v2); out.println(super.v2); } } public class FHTest{ public static void main(String[] args) { new Sub().show(); } } 继承情况的构造 首先🔺类初始化时,继承链上(包括当前类)的全部静态代码块最先执行一次。之后不再执行，除非程序又重启。(按链序和声明序且仅1次) 其次🔺创建子类实例时,会先进行父类的构造(要么显式进行，要么隐式用super()进行) 最后🔺类的构造顺序：构造代码块(按声明序) ➡ 构造方法 总体🔺父类静态块 ➡ 子类静态块 ➡ 父类构造块 ➡ 父类构造子 ➡ 子类构造块 ➡ 子类构造子（下划线”__”部分， 仅执行一次） 总结 1、为什么使用继承 从已有的类派生出新的类，称为继承。 在不同的类中也可能会有共同的特征和动作，可以把这些共同的特征和动作放在一个类中，让其它类共享。 因此可以定义一个通用类，然后将其扩展为其它多个特定类，这些特定类继承通用类中的特征和动作。 继承是 Java 中实现软件重用的重要手段，避免重复，易于维护，易于理解。 2、父类和子类 如果类 B 从类 A 派生，或者说类 B 扩展自类 A，或者说类 B 继承类 A， 则称类 A 为”父类”，也称为超类、基类； 称类 B 为”子类”，也称为次类、扩展类、派生类。 子类从它的父类中继承可访问的数据域和方法，也可以添加新的数据域和新的方法。 定义继承的语法： 修饰符 class 子类名 extends 父类名 例如：Shape 类是父类，其子类可以有 Circle 类、Rectangle 类、Triangle 类，等等。 继承的注意点： 子类不是父类的子集，子类一般比父类包含更多的数据域和方法。 父类中的 private 数据域在子类中是不可见的，因此在子类中不能直接使用它们。 继承是为”是一个”的关系建模的，父类和其子类间必须存在”是一个”的关系，否则不能用继承。 但也并不是所有”是一个”的关系都应该用继承。例如，正方形是一个矩形，但不能让 Square 类来继承 Rectangle 类，因为正方形不能从矩形扩展得到任何东西。正确的继承关系是 Square 类继承 Shape 类 Java 只允许单一继承（即一个子类只能有一个直接父类），C++ 可以多重继承（即一个子类有多个直接父类）。 3、super 关键字 super 表示使用它的类的父类。super 可用于： 调用父类的构造方法； 调用父类的方法（子类覆盖了父类的方法时）； 访问父类的数据域（可以这样用但没有必要这样用）。 调用父类的构造方法语法： super(); 或 super(参数列表); 注意：super 语句必须是子类构造方法的第一条语句。不能在子类中使用父类构造方法名来调用父类构造方法。 父类的构造方法不被子类继承。调用父类的构造方法的唯一途径是使用 super 关键字，如果子类中没显式调用，则编译器自动将 super(); 作为子类构造方法的第一条语句。这会形成一个构造方法链。 静态方法中不能使用 super 关键字。 调用父类的方法语法： super.方法名(参数列表); 如果是继承的方法，是没有必要使用 super 来调用，直接即可调用。但如果子类覆盖或重写了父类的方法，则只有使用 super 才能在子类中调用父类中的被重写的方法。 4、this 关键字 this 关键字表示当前对象。可用于： 调用当前类的构造方法，并且必须是方法的第一条语句。如：this(); 调用默认构造方法。this(参数); 调用带参构造方法。 限定当前对象的数据域变量。一般用于方法内的局部变量与对象的数据域变量同名的情况。如 this.num = num。this.num 表示当前对象的数据域变量 num，而 num 表示方法中的局部变量。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java笔记—数组","slug":"Java笔记—数组","date":"2019-11-20T04:54:46.000Z","updated":"2019-11-29T17:36:21.566Z","comments":true,"path":"2019/11/20/Java笔记—数组/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/20/Java%E7%AC%94%E8%AE%B0%E2%80%94%E6%95%B0%E7%BB%84/","excerpt":"Java笔记——数组创建时间：2019.11.20 说明：持续更新ing ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 数组 数组是一组相同类型的变量（元素）的集合。可以用来存放一组相同类型的数据。数组的学习涉及数组的定义、赋值和使用。再扩展一点就是二维数组的应用。数组既是一种重要的数据类型，也是一种重要的数据结构。 数组（array）————一组相同类型的变量(元素)集合 相同的任意类型 (包括基本类型、类类型等) 这组变量被连续地存放在Java堆区的内存空间 数组是一种引用类型，数组名是一个地址的别名 数组需要创建（new），否则不会被分配堆空间 数组名对应的地址单元中存放上述连续堆区空间的首地址 🔺 对程序员而言, 数组总体有三样东西：数组名+数组长度+数组元素","text":"Java笔记——数组创建时间：2019.11.20 说明：持续更新ing ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 数组 数组是一组相同类型的变量（元素）的集合。可以用来存放一组相同类型的数据。数组的学习涉及数组的定义、赋值和使用。再扩展一点就是二维数组的应用。数组既是一种重要的数据类型，也是一种重要的数据结构。 数组（array）————一组相同类型的变量(元素)集合 相同的任意类型 (包括基本类型、类类型等) 这组变量被连续地存放在Java堆区的内存空间 数组是一种引用类型，数组名是一个地址的别名 数组需要创建（new），否则不会被分配堆空间 数组名对应的地址单元中存放上述连续堆区空间的首地址 🔺 对程序员而言, 数组总体有三样东西：数组名+数组长度+数组元素 “声明、创建、初始化、访问”数组 声明数组： 🔺只给数组变量(由数组名描述)分配空间，而不会给数组按要存放的元素的多少来分配空间。 有两种形式——&gt;推荐第一种： 数据类型[] 数组名 //数据类型[] 数组名 int[] a; //数据类型 数组名[] int a[]; ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 创建数组：用new运算符，同对象的创建。 有两种形式——&gt; //先声明，后创建 int[] a; //声明存放int型数据的数组a a = new int[10]; //在Java堆区中创建10个int型元素空间(共40个字节) //声明和创建合一 int[] test = new int[12]; 注意： 🔺声明数组，仅仅创建数组变量🔺创建数组，才在堆区中分配空间 [ ]中必须是非负整数，否则执行时异常。可以是字面常量、也可以是变量，只要保证其值是非负整数。 创建数组之后，各元素的默认初始值是：数值型为0(0.0)；字符型’\\0’；引用类型null；布尔型false ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 初始化数组：在创建好的数组元素空间中存放初始值.否则按默认值初始化。 🔺数组创建时（即new时使用）初始化器语法：{元素值列表}。 //声明存放int型数据的数组aMonth并初始化 int[] aMonth = new int[]{1,2,3,4,5,6,7,8,9,10,11,12}; 注意： 使用了初始化器之后不能显式指定长度 即 new int[12]{…} ，不对 int[] a; //先声明数组a a = new int[2]{1,2}; // Error,不能显式指明长度[2] a = {1,2}; // Error a = new int[]{1,2}; // OK! int[] b = {1, 2}; // OK!此方式用得最多 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 访问数组： 🔺数组元素：数组中的每一个变量，也被称为下标变量，索引变量 🔺下标从0开始：用[ ]运算符访问元素，即 数组名 [ 数组下标 ] 🔺既然是变量，所以数组元素可以作为左值也可以作为右值，比如a[i]++、b[0]=5;、a=b[0]+2;等等。 数组长度属性 🔺数组唯一的一个 只读 属性：length 存有数组元素个数值。 🔺*数组名.length * 遍历数组 🔺增强版for语句：foreach语句（JDK5开始提供） 🔺适用于遍历数组、集合元素等形式 for(元素的数据类型 遍历变量x : 遍历对象obj){ //x是自定义遍历变量名 引用了x的Java语句; //循环体 } 注意： foreach语句是for的简化,任何foreach语句都可以改用for语句，反之不行。 foreach语句不关注下标。 用foreach的遍历变量不能修改元素值。 public class Demo { public static void main(String[] args) { int[] a = {1, 3, 4, 5, 6, 8, 10}; /* 循环输出a */ for(int n : a){ // 利用变量n遍历数组a System.out.printf(\"%4d \", n); // n表示数组a的每一个元素值 } } } 二维数组、多维数组 Arrays 类 主要功能： 🔺java.util.Arrays类： 数组操作实用类,它提供了一系列静态方法 equals()方法:比较两个数组长度是否相同和对应索引上的元素值是否相同. fill()方法:向数组中填充数据. copyOf()方法:复制一个数组的部分元素并生成一个新的数组返回 sort()方法:若是基本类型则把数组元素按自然顺序升序排列.若是引用类型,其该实现了Comparable接口才能调用sort方法,否则报异常. binarySearch()方法:对已排序数组使用二分查找算法查找指定元素. asList()方法:返回数组的List对象形式. toString()方法:返回包含所有元素信息的字符串 parallelSort()方法:开启多线程的排序. deepEquals()方法:深度比较两个数组是否相同.适于任何深度的多维(嵌套)数组. 问：数组可以作为方法的参数或返回值吗？ 当然是可以的 。答案来源 m博客 数组作为方法参数 🔺数组作为方法参数传递，传递的参数是数组内存的地址。 public static void main(String[] args) { int[] arr = {11, 22, 33, 44, 55}; System.out.println(\"1位置: \" + arr); printArray(arr); // 数组作为方法参数传递，传递的参数是数组内存的地址 } public static void printArray(int[] arr) { System.out.println(\"2位置: \" + arr); for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); } } 1234567891011 数组作为方法返回值 🔺数组作为方法的返回值，返回的是数组的内存地址。 public static void main(String[] args) { //调用方法，接收数组的返回值 //接收到的是数组的内存地址 int[] arr = getArray(); for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); } } /* 创建方法，返回值是数组类型 return返回数组的地址 */ public static int[] getArray() { int[] arr = { 1, 3, 5, 7, 9 }; //返回数组的地址，返回到调用者 return arr; } 1234567891011121314151617 该博主的延伸阅读： Java–数组的定义和访问、Java–数组原理内存图、Java–数组的常见操作 判断： Java中数组可以动态改变长度？ 错误。 Java中的数组的定义就是相同类型，固定长度的一组数据，一旦被初始化，长度不可更改。 10. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"教会你怎么安装和使用 Visio 哦 ~ ~","slug":"Visio教程","date":"2019-11-19T01:34:04.000Z","updated":"2019-11-29T17:38:35.080Z","comments":true,"path":"2019/11/19/Visio教程/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/19/Visio%E6%95%99%E7%A8%8B/","excerpt":"前言 很多学生会在编程、设计或其他时候可能使用到【制图工具】。最好用的莫不过【微软的Visio】了。但是很多学生不会使用Visio，甚至不会安装Visio。 &gt; Visio 这么好的工具，一定要会用。 今天，作者写一份教程，教会大家了解如何安装和使用 ==Visio==。 在正式教程之前，我们先介绍 Visio。 Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。 &gt; Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。","text":"前言 很多学生会在编程、设计或其他时候可能使用到【制图工具】。最好用的莫不过【微软的Visio】了。但是很多学生不会使用Visio，甚至不会安装Visio。 &gt; Visio 这么好的工具，一定要会用。 今天，作者写一份教程，教会大家了解如何安装和使用 ==Visio==。 在正式教程之前，我们先介绍 Visio。 Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。 &gt; Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。 //截断文章 安装1. 【下载资源】 网上也有很多资源，但是包是不完整的。版本也很多，要激活也不容易。 作者在这里已经打包好“Visio 2019”和“激活工具”了，点击这里(提取码: rwtr)开始下载。 由于现在的笔记本都是预装win10的，所以不用担心Visio 2019合不合适。毕竟Visio 2019在win7上是安装不了的。2. 【解压】 下载得到压缩包，解压，打开文件夹。 3. 【打开Setup】 打开“Visio 2019”，右键“Setup”选中“以管理员身份运行”。（似乎不用管理员也行？？？） 4. 【正在安装】 等待就好，很快的。 5. 【安装完成】 安装结束，点击“关闭”。 6. 【激活】 Visio 2019是==必须激活==才可以使用的。 否则，会一直弹窗提示激活的。 激活工具在另一个文件夹里。 补充一些关于KMS： KMS（全称:Key Management Service），这个是微软的一种新型产品激活机制，目的是为了Microsoft更好的遏制非法软件授权行为(盗版)。 当然作者不提倡破解、或盗版。 对于有能力的人，还是支持正版。但是学生嘛，能用就好了。 使用激活工具前，作者建议： ==最好关闭杀毒软件，如果有的话。== 作者没安装360那些，很流畅地激活成功。 ==激活工具无毒的。不关闭的话，可能被误报。== 1).【打开】 界面如下： 这个激活工具还可以xxxxxx。（你懂的） 我啥都没说哦hh 2).【激活】 简单一按，等待激活成功就好。 补充：可能有的电脑打开软件时会提示这个。解决很简单，安装框架就好。 （1）打开“控制面板”。（2）找到并点击“程序和功能”项，在打开的页面中，点击“启用或关闭Windows功能”。（3）在打开的“Windows功能”对话框中，找到并勾选“Microsoft.Net Framework”服务，单击“确定”即可。 使用激活后，就可以安安心心、大大方方地使用 Visio 了。o(￣▽￣)o 【打开】 【新建】新建页面，有一些初始模板可以使用。一般选择“基本框图”就好，然后“新建”。 【制图】 左侧可以选择很多官方自带的形状，当然还可以自己建立自己的模型。 右侧可以对图形自定义，包括颜色、线条、端点等等。 结尾使用 Visio 来制图真的很爽。但是，如果只是临时制图使用 Visio ，还得安装确实不太方便。因此 作者还收藏了几个线上制图的网站，在这提供给大家临时使用。 1. https://www.draw.io/ 2. https://zh.numberempire.com/graphingcalculator.php 3. https://www.processon.com 4. 当然用电脑自带的【画图】也是可以的，你看。 emmm只是好难看啊hhhh。 这就是结尾：如果教程上有什么不足的或者有问题的，可以私信我。谢谢你的阅读！ 本博客第一次发表于【简书】： https://www.jianshu.com/p/32648bcc6f1c 。现转载到作者的网站上。谢谢阅读！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"百合","slug":"百日","date":"2019-11-16T12:54:59.000Z","updated":"2019-11-25T12:23:15.221Z","comments":true,"path":"2019/11/16/百日/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/16/%E7%99%BE%E6%97%A5/","excerpt":"2019.11.16 星期六 晴天","text":"2019.11.16 星期六 晴天 💙汪曾祺老人的散文《活着多好呀》中“活着多好呀”为汪老一句名言。这位老人不管遇到什么环境，永远不消沉沮丧，守护心中的热情与生机，兴致盎然地生活。💛时光机，这个世界不存在的理想物品。可是我多希望有这东西，真是可惜无法回到两三年前，“时间就是让人猝不及防的东西”……💜有段时间，喜欢黑暗安静的环境。肚子一个人发呆，内室里一个窗户也不开，杜绝所有来往。但已经走出来那段抑郁期，今后不知道，但是现在我挺好的。恍惚发现，最好掩盖哭的方式，除了偷偷一个人，就是洗澡的时候。💚或记日记或写随笔或向月亮倾诉或对空气说说，~生活不易，但也没那么糟糕。柏拉图说：没有什么比健康更快乐的了，虽然在他们生病之前并不曾觉得那是最大的快乐。💗“谢谢你的不告而别”。下辈子，我们再会 ! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"解除课程中心看视频时的“ 窗口获取焦点事件 ”","slug":"解除课程中心看视频时的“ 窗口获取焦点事件 ”","date":"2019-11-16T09:54:59.000Z","updated":"2019-11-23T02:16:39.416Z","comments":true,"path":"2019/11/16/解除课程中心看视频时的“ 窗口获取焦点事件 ”/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/16/%E8%A7%A3%E9%99%A4%E8%AF%BE%E7%A8%8B%E4%B8%AD%E5%BF%83%E7%9C%8B%E8%A7%86%E9%A2%91%E6%97%B6%E7%9A%84%E2%80%9C%20%E7%AA%97%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6%20%E2%80%9D/","excerpt":"前言前段时间，在观看课程中心的马克思视频，因为要至少看到80%以上。 发现那我挂着刷不就得了？偏偏。。。。。 发现这个课程中心存在某个机制——一定要使视频一直处于“置顶”的状态，否者会自动暂停视频。","text":"前言前段时间，在观看课程中心的马克思视频，因为要至少看到80%以上。 发现那我挂着刷不就得了？偏偏。。。。。 发现这个课程中心存在某个机制——一定要使视频一直处于“置顶”的状态，否者会自动暂停视频。 //截断文章 就像下图这样： 操作鼠标前——&gt; 操作鼠标后——&gt; 你会注意到，视频的播放状态跟鼠标的行为有关，准确来说是==和鼠标点击的位置（焦点）有关==。 第一时间想到“这不就是windows的“窗口获取焦点”吗？ 补充先补充补充什么是窗口获取焦点？ 在你浏览其他窗口页面、或是浏览器最小化、又或是点击了程序窗口时，等等都算是浏览器窗口失去焦点，这时候 window.onblur 事件就会触发。 当然，当你的页面获得焦点的时候一样也会触发window.onfocus。 应该有人会注意到过，当你点击不同窗口时，窗口栏会有不同的颜色反馈，就比如win 10的资源管理器，前置窗口和后置窗口的窗口颜色是不是不一样？ 寻找直接按下F12，打开控制台，查看Elements…… emmmmmm结果，没找到对应的代码（或许我没仔细去挖hh） 再试那我直接Console。不就是当前窗口获取了焦点吗？？？？直接暴力敲下代码，并Enter，嘿嘿…… javascript:window.onblur=null;void 0 //有无`void 0`，都可以 当我Enter时，诶，成功了hhh效果就是这样。 后续测试了一段时间后，成功率基本达97%左右。后来就分享到班群，让更多人试试效果。两天刷完所有马克思的视频哈哈有木有？ 建议 一次最多同时两个视频在看，因为后台有个计时器再加上我不会写自动播放、自动静音的脚本hhhhh（有时间再去琢磨哈） 一旦刷新页面，就得重新Enter脚本 极小几率会失败，原因我也不清楚，失败重新Enter即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://melodyjerry.github.io/blog/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"Java笔记—对象、类","slug":"Java笔记—对象、类","date":"2019-11-15T04:54:59.000Z","updated":"2019-11-30T10:18:12.578Z","comments":true,"path":"2019/11/15/Java笔记—对象、类/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/15/Java%E7%AC%94%E8%AE%B0%E2%80%94%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB/","excerpt":"Java笔记——对象、类创建时间：2019.11.11 说明：持续更新ing 对象和类的概念。 对象：对象是类的一个实例（实实在在存在的个体），有属性（状态）和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 属性(property)： 静态特征行为(behavior)： 动态特征 类：类是对现实生活中事物的描述。类是一个模板，它描述一类对象的行为和状态。同种类型对象共性的抽象","text":"Java笔记——对象、类创建时间：2019.11.11 说明：持续更新ing 对象和类的概念。 对象：对象是类的一个实例（实实在在存在的个体），有属性（状态）和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 属性(property)： 静态特征行为(behavior)： 动态特征 类：类是对现实生活中事物的描述。类是一个模板，它描述一类对象的行为和状态。同种类型对象共性的抽象 用老师的话来说，就是下面这样——&gt; 下图中男孩（boy）、女孩（girl）为类（class），而具体的每个人为该类的对象（object）： 【定义类】 Java中的类 类可以看成是创建Java对象的模板。 通过下面一个简单的类来理解下Java中类的定义： public class Student { int id; String name; double score1, score2, score3; public Student(int id, String name) { this.id = id; this.name = name; } public double getAverageScore() { return (score1 ＋ score2 + score3) / 3; } } 一个类可以包含以下类型变量： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。一个类可以拥有多个方法。 Java中的对象现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。对比现实对象和软件对象，它们之间十分相似。 软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 创建对象——&gt; /*有两种基本形式*/ /*1.对象声明和创建*/ 类名 对象名 = new 类名(); Student xiaoming = new Student (); /*2.先声明,后创建*/ 类名 对象名; // 类(对象)变量 对象名 = new 类名(); //实例化 Student xiaobai ; xiaobai = new Student(); 类和对象的关系：类是具有相同==属性和方法==的集合，是对对象的抽象描述。 现实生活中的对象：张三、李四。 【想要描述】提取对象中的共性内容。对具体的抽象。 【描述时】这些对象的共性有：姓名、学号、年龄、性别、学习Java等等。（即定义类：描述事物的属性和行为，就是在定义属性和行为。属性和行为共同成为类中的成员（成员变量和成员方法）。） 映射到Java中，描述就是class定义的类，具体对象就是new建立的实体。 这些描述在Java当中是用类的形式来体现的。而对象是通过Java的new操作符所产生的一个实体，这个的实体存在于==堆内存==当中。 //定义类，就是描述事物，就是在定义属性和行为。属性和行为共同成为类中的成员（成员变量和成员方法）。 //需求：描述车汽车（颜色，轮胎数）。 class Car { //描述颜色 String color = \"red\"; //描述轮胎数 int num = 4; //运行行为。 void run() { System.out.println(color+\"..\"+num); } } class CarDemo { public static void main(String[] args){ //生产汽车：在Java中通过new操作符来完成。 //其实就是在堆内存中产生一个实体。 Car c = new Car(); //c就是一个【类类型】变量。记住：类类型变量只想对象。 //需求：将已有车的颜色的颜色改成蓝色。指定该对象做使用。 //在Java指挥方式是：【对象.对象成员】 c.color = \"blue\"; //需求：想要车运行起来。 c.run(); } } Car c = new Car();在内存中的示意图——&gt; c.run();——&gt;输出这个车的颜色“蓝色”和轮胎数“4”。 (1)倘若在c.run();后加入Car c1=new Car();c1.run();——&gt; (2)若main的代码块改为： class CarDemo { public static void main(String[] args){ Car c = new Car(); c.num = 5; Car c1 = c; c1.color = \"green\"; c.run(); } } 在内存中的示意图——&gt; 对对象调用的基本概念：用new建立对象，在堆内存中产生对象。那么对象的特点在于封装数据，数据包含属性和行为。想要操作对象中的内容就指挥对象做事，指挥哪个对象要明确，操作什么也要明确，用对象.xyz的形式就能完成。 【注意】：如下图， 以前定义在函数里面，现在定义在函数外面 【方法】 方法的定义： 方法是类或对象的行为特征的抽象。 Java中的方法不能独立存在，所有的方法必须定义在类中。 使用 “类名.方法” 或 “对象.方法” 的形式调用。 语法格式： 权限修饰符 返回值类型 方法名（参数类型 参数名1,参数类型 参数名2,...） { // 方法体 方法语句序列//当返回类型非void时,最后一条被执行语句必须是return语句,返回对应类型的值 } 访问权限/权限修饰符（4P权限）： 访问权限 类内 包层内 子类 包层外 public √ √ √ √ protected √ √ √ × package （缺省） √ √ × × private √ × × × return语句： 结束方法调用，并返回值。 return 表达式; return; 🔺方法被调用时,执行到方法内的return语句,则不论方法里是否还有语句未执行,立即结束方法的调用,并将return 后的表达式的值返回方法调用者🔺利用return 语句返回值，仅能返回一个值🔺return语句仅结束方法的执行 🔺void型方法 方法分类： 无参数无返回值 有参数无返回值 无参数有返回值 有参数有返回值 public class Method { public void aMethod() { System.out.println(\"无参数无返回值的方法\"); } public void bMethod(int b) { System.out.println(\"有参数无返回值的方法\"); } public int cMethod() { System.out.println(\"无参数有返回值的方法\"); return 10; } public int dMethod(int d) { System.out.println(\"有参数有返回值的方法\"); return d; } public static void main(String[] args) { int ret; // 创建Method类的对象 Method md = new Method(); // 通过对象.方法调用 md.aMethod(); md.bMethod(10); ret = md.cMethod(); ret = md.dMethod(10); System.out.println(ret); } } 方法的参数： 方法可以没有参数，或者有多个参数，参数类型可以是任意类型 方法参数也是局部变量 参数为引用数据类型4时： 当对象实例作为参数传递给方法时，传递的是对象的引用，为地址传递，接受参数的方法可以改变参数的值。 参数为简单数据类型时： 传递的是参数的副本，为值传递，接受参数的方法中不会改变参数的值。 public class MethodParam { /** * 方法的参数为基本数据类型时，传递的是值的副本（值拷贝） * 方法中不会改变元参数的值 */ public void swap(int a, int b) {//a, b为形参 int tmp; tmp = a; a = b; b = tmp; } int x = 100, y = 200; /** * 方法的参数为引用数据类型时，传递的对象的引用（传地址） * 方法中可以改变参数的值 */ public void swap2(MethodParam mp) { int tmp = mp.x; mp.x = mp.y; mp.y = tmp; } public static void main(String[] args) { MethodParam mp = new MethodParam(); int m = 10, n = 20; System.out.println(\"交换前：a = \"+m+\",b = \"+n); mp.swap(m, n);// m,n为实参 System.out.println(\"交换后：a = \"+m+\",b = \"+n); System.out.println(\"交换前：x = \"+mp.x+\",y = \"+mp.y); mp.swap2(mp); System.out.println(\"交换后：x = \"+mp.x+\",y = \"+mp.y); } } 普通方法调用——&gt; 成员方法和成员变量的关系——&gt; 【成员方法】和【构造方法】 【成员方法】 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【构造方法】 构造方法需满足以下三个条件 ： 1、方法名与类名同名 2、在方法中不能使用 return 语句，即无返回值 3、在方法名的前面*没有返回值的类型声明 * （有看到“ 构造方法无返回值也不可以加void，但其实返回的是首地址 ”这话还得去证实，先放在这里） ==老师推荐==：显式无参构造子,作为一种良好实践,定义了其他构造子，那就准备一个无参构造子 package me; public class Me { private String name; //成员变量 public Me(String name){ //构造方法 this.name = name; } public String getName() { //成员方法 return name; } public void setName(String name) {//成员方法 this.name = name; } } 我如果我在添加一age 如下 添加方法依然是成员方法 , package me; public class Me { private String name; //成员变量 private String age; //成员变量 public Me(String name){ //构造方法 this.name = name; } public String getName() { //成员方法 return name; } public void setName(String name) {//成员方法 this.name = name; } public String getAge() {//成员方法 return age; } public void setAge(String age) {//成员方法 this.age = age; } } 个人理解：无论多少方法，==除了构造方法外，其余都是成员方法==，当然这样理解可能有点偏见.. 它们的区别： 构造方法一般是给对象的数据进行初始化,没有返回值 成员方法一般实现对类中成员变量的操作，提供某些功能,有返回类型，可以为void类型 成员方法与构造方法调用的区别 package me; public class Book { public static void main(String[] args) { Me me = new Me(\"张三\");//构造方法调用 System.out.println(me); me.setName(\"李四\");//成员方法调用 System.out.println(me.getName()); } } 从上面的demo中可以看出，==构造方法通过new运算符调用==，==成员方法通过对象调用==。 注意：类中除了构造方法以外的方法都是成员方法。原因是在类中，除了变量外的基本都是成员方法。 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【this 关键字】 https://i.loli.net/2019/11/16/49d7AMODXhKbsuy.png ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【重载构造方法之间的调用】 【含对象成员的构造方法调用】 【无继承情况下的对象初始化顺序】 【创建对象】 对象是根据类创建的。在Java中，使用关键字new 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 下面是一个创建对象的例子： public class Puppy{ public Puppy(String name){ //这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public static void main(String[] args){ // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( \"tommy\" ); } } 编译并运行上面的程序，会打印出下面的结果： 小狗的名字是 : tommy ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【访问实例变量和方法】 通过已创建的对象来访问成员变量和成员方法，如下所示： /* 实例化对象 */ Object referenceVariable = new Constructor(); /* 访问类中的变量 */ referenceVariable.variableName; /* 访问类中的方法 */ referenceVariable.methodName(); ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【访问实例变量】和【调用成员方法】： public class Puppy{ int puppyAge; public Puppy(String name){ // 这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public void setAge( int age ){ puppyAge = age; } public int getAge( ){ System.out.println(\"小狗的年龄为 : \" + puppyAge ); return puppyAge; } public static void main(String[] args){ /* 创建对象 */ Puppy myPuppy = new Puppy( \"tommy\" ); /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println(\"变量值 : \" + myPuppy.puppyAge ); } } 编译并运行上面的程序，产生如下结果： 小狗的名字是 : tommy 小狗的年龄为 : 2 变量值 : 2 【方法重载，重构，覆盖，重写的区别】 方法重载还是比较好理解的，就是在类的内部，定义多个方法，这些方法的方法名字相同，参数类型、参数顺序、参数个数不同，注意，返回值类型并不能区分重载 。 public void show(int a,double b){ } public void show(double c){ } public int show(double d){ return 1; } //报错，方法已经定义了 方法重写（override)方法重写和方法覆盖都是一个道理，发生在子类继承父类或者实现接口的类，要求的是： 1.方法名字相同，2.参数个数不同，3.返回值类型不同 ， 代码： 方法重构 定义：在不改变外界外界访问的情况下对代码进行修改，但是不改变原方法的效果，提高其性能，使程序更加易读，可维护。重构是在不改变软件可观察行为的前提下改善其内部结构重构通常不是一次性的，它贯穿软件的整个生命周期，只要觉得不合理都是重构的时机。 题目：下面说法中，错误的有（ ） ​ A. Java面向对象语言容许单独的过程与函数存在； ​ B. Java面向对象语言容许单独的方法存在； ​ C. Java语言中的方法属于类中的成员（member）； ​ D. Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同。 答案：ABC 解释： 方法与函数：这两个概念不严格区分，就是一个东西，通过对象调用的，就是方法，直接调用，就是函数； 在java中，everything is object 所以，方法，函数，必须隶属于某一个类或对象， java中没有过程。（类中的代码块不知道算不算，就算代码块是过程，也是必须在类中才有的） 对于C选项，方法分为静态方法和非静态方法，静态方法属于类成员，非静态方法属于实例成员。 类其实一种类型，它封装了数据和操作。 对象是类的实例 一个对象比属于某个类 一个类可以声明多个对象 问：构造方法可以调用本类的其他方法吗？ 1,构造方法可以调用本类的其他方法。既然可以调用本类的属性,那么也就可以调用属于本类的其他方法。 2,需要注意的是,如果要在构造方法里调用一个非静态方法时,应该将该方法声明为private。因为如果这个类被其他类继承成为父类时,这个方法不是private的又被子类所重载，这样在实际创建子类的过程中递归调用到了父类的构造器时，父类构造器对这个方法的调用就会由于多态而实际上调用了子类的方法，当这个子类方法需要用到子类中实例变量1的时候，就会由于变量没有初始化而出现异常（子类中的实例变量没有初始化这种情况还是会遇见的），这是Java不想看到的情况。 一个类的构造方法有多个，在其他类中是否可以被调用？ 只要不是私有的构造函数，在其他类中就可以调用。 传对应的参数就行了 。 class` `A{ ``public` `A(String s){} ``public` `A(``int` `n){} ``public` `A(String s, ``int` `n){} } class` `B{ ``A a1 = ``new` `A(``\"abc\"``); ``A a2 = ``new` `A(``1``); ``A a3 = ``new` `A(``\"aaa\"``,``2``); } 类是一种引用类型。 Java的引用类型只有三种，分别是 类(class) 接口(interface) 数组 参考资料 问：方法一定是在类内部被定义的？ 所有方法必须写在类体里，也包括构造方法2的。 static方法同样属于类，叫类方法或静态方法，它与类一同被加载时，处于内存的公共代码区中，无需创建实例来调用，只需用类名引用即可。 static方法既可以通过类名来调用，也可以通过类的实例调用。 Java一切都是以类的形式存在，方法是类的一部分，需要通过类才能进行方法的调用。 从内存存储角度来说，java中找对应方法时，都是先找对应类实例，类实例是根据类来初始化内存的。如果方法在类外部，则无法找到该方法。 所以方法必须在类体里。 注意： 可以在其他类里使用这个类的方法（在不同的包下就要引ltem这个类），继承就是一个类从另一个类继承通过关键字extends 来实现 问：构造方法中可不可以有return语句呢? （这个解释有问题？）可以。而是我们写成这个样子就OK了：return; 其实，在任何的void类型的方法的最后你都可以写上：return; 问：非构造方法的一般成员方法必须有return语句？ 错。 （待补充……） 问：类中的数据成员可以按需选择任意类型，包括类本身？ 可以。可以参考下图，图源于陈三千的博客 问：Java中构造函数的权限可以是private吗？ 可以，这个类就不能再外部被new了，如果需要这个类的实例化对象，就只能在类内部提供静态方法生产这个类的对象了。 问：构造方法能不能被重载，构造方法能不能被重写？ 在回答这两个问题之前，首先先回顾：什么是构造方法？构造方法的特点是什么？ 概述：构造方法存在于类中，给对象数据（属性）初始化； 特点：方法名与类名一样；无返回值无void; 默认构造方法：我们不创建一个构造方法时，系统默认提供一个无参构造；当我们创建一个构造方法时，系统不再提供无参构造，所以在实际项目中，全部手动给出无参构造 其次\\什么是重载？什么是重写？** 重载：存在于在一个类中，方法名相同，方法参数的类型或个数不同 重写：存在于子父类中，方法名、方法参数、返回值全部相同 所以：构造方法可以重载，不能重写 在一个类中，可以有多个构造方法（方法参数不同） ，即重载，来实现对象属性不同的初始化； 但是子类中不能定义一个方法无void无返回值的方法，编译错误，即子类无法继承构造方法，但是子类的构造器中可以调用父类的构造方法（默认自动调用无参构造） 注意：回答来源于 CSDN博客 Java中可以定义一个空类（即没有数据成员和成员方法） 。 问： 下面这个类有几个构造方法？ class A{} 1个。（待补充……） 问：Java 类可以作为（ C ） A．类型定义机制 B．数据封装机制 C．类型定义机制和数据封装机制 D．上述都不对 用于定义类头的修饰符可以是public、abstract、final或者是默认(friendly) 题目：下列说法错误的有（ CD ） A． 在类方法中可用this来调用本类的类方法B． 在类方法中调用本类的类方法时可直接调用 C． 在类方法中只能调用本类中的类方法 D． 在类方法中绝对不能调用实例方法 C：类方法可以调用外部其他类的方法。D：只要实力化对象，也是可以调用实例方法的。 判断： 只有基本类型的参数传递使用值传递。 错误。 引用类型参数的传递，依然是值传递。但因为是地址值，所以会指向同一个对象实例。 Java中方法的参数传递是值传递（pass by value），并且为单向传递。 《Java 变量参数传入方法，修改后是否影响外面的值》。参考 博客 《某个变量当作函数的参数传递后，函数内部修改了。到底这个变量是否受影响》。参考 博客 问：类设计get方法和set方法的作用是什么？ 答1：一般类的成员变量被设置为private（私有的），这样设置安全性比较高，但是设置为私有的后其他的类和对象则无法调用该对象了，所以会有get和set方法，这两个方法一般设置为public，在其他的类中通过对象调用set或get方法即可操作私有的变量，增强程序的安全性，set为给对象赋值的方法，而get则是取得变量值的方法！ 答2：get set常用在自定义类，类创建了一个实例对象后，用set设置对象的某一个属性，get得到对象某一属性。如果不使用get set，你就得用点，点出来还得是个方法。其实就是给get set换个名而已。而且get set作为内部方法，可以访问私有数据 答3：别说的那么专业化了，理解都要半天。就这么理解吧，面向对象中，想对类的成员变量设置访问一些权限，于是，就将该字段设置为private的，这样别的类就不能访问了，然后在该内定义两个方法，一个专门用于获取，一个用于修改，这样，在你不想让别人乱动该字段的时候，就在该方法内写一些限制条件。而为了规范起见（团队开发需要嘛），就根据人家老外的习惯，将方法名设置为set+字段名，get+字段名（名字乱改没问题），既然规范了，那就是别人都叫这名了，于是，有些框架给对象赋值就有方法了，方法名称由get或set开始的又有private变量名的，就找出来调用。hibernate1框架就这样弄得，至于后面的版本是不是这样就不大清楚了。JavaBean就是一个JAVA类，既然是JAVA类就不需要什么组件了，这玩意直接深入到虚拟机了的 Java的包装类： 【包装类的概念】 【Integer类的用法】 【自动装箱机制和自动拆箱机制】 匿名对象： 使用方法： 当对对象的方法只调用一次，可以使用匿名对象来完成，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。 可以将匿名对象作为实际参数进行传递。 注脚：1.实例变量（全局变量）、成员变量、实例变量、属性 ↩2.java的构造方法、java的构造方法、Java入门：构造方法 ↩3.来创建一个新的对象。创建对象需要以下三步： ↩3.java之new的用处 ↩4.JAVA中基本数据类型和引用数据类型区别 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java笔记—面向对象","slug":"Java笔记—面向对象","date":"2019-11-13T04:54:46.000Z","updated":"2019-11-29T17:35:40.535Z","comments":true,"path":"2019/11/13/Java笔记—面向对象/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/13/Java%E7%AC%94%E8%AE%B0%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"Java笔记——面向对象创建时间：2019.11.11 说明：持续更新ing Java作为一种面向对象语言。支持以下基本概念： 多态 | 继承 | 封装 | 抽象 类 | 对象 | 实例 | 方法 | 重载 “面向对象”和“面向过程”的区别： 面向过程：如 C/C++ 例子：冰箱装大象。1、打开冰箱门；2、放进大象；3、关上冰箱门。强调过程，“打开”、“存储”、“关闭”三个动作。注重过程，注重的是过程涉及的行为（即功能）。 面向对象：如 Java 将功能封装进对象，强调具备了功能的对象。 面向对象是基于面向过程的。","text":"Java笔记——面向对象创建时间：2019.11.11 说明：持续更新ing Java作为一种面向对象语言。支持以下基本概念： 多态 | 继承 | 封装 | 抽象 类 | 对象 | 实例 | 方法 | 重载 “面向对象”和“面向过程”的区别： 面向过程：如 C/C++ 例子：冰箱装大象。1、打开冰箱门；2、放进大象；3、关上冰箱门。强调过程，“打开”、“存储”、“关闭”三个动作。注重过程，注重的是过程涉及的行为（即功能）。 面向对象：如 Java 将功能封装进对象，强调具备了功能的对象。 面向对象是基于面向过程的。 使用不同思想，对“冰箱装大象”的理解——&gt; 问：“人开冰箱”事件，其中人、冰箱都是实物（对象），开是动作。若使用面向对象思维，“开”的这个动作是属于“人”还是属于“冰箱”？ 答：属于“冰箱”，“人”只是调用了“冰箱”的“开”的方法（或功能），用力作用了门一下并将门打开了。 人开门：名词提炼法。 /* 人{ 开门（门）{ 门.开（）; } } 门{ 开（）{ 操作门轴; ……等等; } } */ 面向对象的三个特征：封装、继承、多态。 以后开发：其实就是找对象使用，没有对象就创建一个对象。 找对象，建立对象，使用对象，维护对象的关系。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java笔记—语法","slug":"Java笔记—语法","date":"2019-11-13T04:54:20.000Z","updated":"2019-11-29T17:36:18.031Z","comments":true,"path":"2019/11/13/Java笔记—语法/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/13/Java%E7%AC%94%E8%AE%B0%E2%80%94%E8%AF%AD%E6%B3%95/","excerpt":"Java笔记——语法创建时间：2019.11.11说明：持续更新ing 单引号’’中存放一个字符，不能存放字符串。双引号””中存放字符串。 Java是强类型语言。对于每一种数据都定义了明确的具体数据类型，在内存中总分配了不同的内存空间。 布尔型常量只有2个值：true、false 标识符由字母：26个，大小写；数字：0- 8；符号：$ _ 组成。 标识符不能数字开头、不能使用关键字 main不是关键字，但是是被JVM识别的名字，是程序的入口 Java中的名称规范： 包名：多单词组成，全为小写 xxxyyyy 类名接口： 多单词组成，所有单词的首字母大写 XxxYyyZzz 变量名和函数名：多单词组成时，第一个单词的首字母小写，其余首字母大写 xxxYyyZzz 常量名：所有字母都大写。每个单词用_隔开 XXX_YYY_ZZZ","text":"Java笔记——语法创建时间：2019.11.11说明：持续更新ing 单引号’’中存放一个字符，不能存放字符串。双引号””中存放字符串。 Java是强类型语言。对于每一种数据都定义了明确的具体数据类型，在内存中总分配了不同的内存空间。 布尔型常量只有2个值：true、false 标识符由字母：26个，大小写；数字：0- 8；符号：$ _ 组成。 标识符不能数字开头、不能使用关键字 main不是关键字，但是是被JVM识别的名字，是程序的入口 Java中的名称规范： 包名：多单词组成，全为小写 xxxyyyy 类名接口： 多单词组成，所有单词的首字母大写 XxxYyyZzz 变量名和函数名：多单词组成时，第一个单词的首字母小写，其余首字母大写 xxxYyyZzz 常量名：所有字母都大写。每个单词用_隔开 XXX_YYY_ZZZ //截断文章 注释，写在代码前面 对于整数：Java有三种表现形式。· 十进制：0-9，满10进1· 八进制：0-7，满8进1，用0开头表示· 十六进制：0-9，A-F或a-f（A\\a是10，B\\b是11…F\\f是15），满16进1，用0x开头表示 null常量：只有一个值null。在对象、引用数据类型时会用上。 二进制。一个字节8位0、1组合。 八进制：3位二进制位代表1位八进制位；十六进制：4位二进制位代表1位十六进制位。进制转换：进制越大，表示越短，更方便地表示数据。 二进制计算：5 + 4 = 9 负数地二进制表现形式：对应的整数二进制取反加1。负数的最高位都是1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"博客v1.4上线","slug":"博客v1.4","date":"2019-11-08T14:30:21.000Z","updated":"2019-11-29T17:39:13.419Z","comments":true,"path":"2019/11/08/博客v1.4/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/08/%E5%8D%9A%E5%AE%A2v1.4/","excerpt":"搞了半天时间，优化一些模板上的问题后，新博客1.4版本上线了","text":"搞了半天时间，优化一些模板上的问题后，新博客1.4版本上线了 //截断文章 新增 主页动画，点击体验效果（这里） 文字跳动（menu、head中的文字均可跳动）,比如顶部的“你用走，可是我用跑”…… 新增Valine评论（可以使用表情；发送前浏览）。想用别的，但是暂时先着Valine。可以试着来骚扰我（滑稽~~ 有评论，邮件提示(还未测试)。接入Leancloud（文档）。 底部开启鼠标滑动渲染 开启“一言”api。menu中作者名（Melody Jerry）下面随机显示一句话。同时，使用文字扭曲动画。 修复 1.重写三个按钮（menu、搜索、回到顶部）的代码，现在可以正常使用了。 更新menu的Github的url 修复移动端提示证书错误的问题（移动端重定向太多次了，难怪hhh） 主页和首页分仓（也不算是修复，不知道写哪而已） 已知问题（加粗的为重要问题） menu中的“分类”、“标签”、“关于”，仍然无法正常使用（原因未知） menu的Email仍旧无法mailto 文章增加标签或类名，无法被tags或categories绑定 浏览人数、浏览次数，无法使用（接口有问题？） 文字截断，异常。（原因位置） 等待发现 未来加入 音乐控件（自动？手动？浮窗？嵌入？音源线上还是本地？） 实时颜色 加载网页时、侧栏、搜索、进度条等动画 留言板？ 友情链接？快速导航？ 嵌入播放（这个很想要，链接一些学习视频） 天气控件 等待脑洞大开 最后从早上9点搞到下午4点，午饭还没吃hh，就一直坐在电脑前。找模板中的问题代码、修改代码，还是很麻烦的。最后分享一首今天网易日推的英文歌（版权原因，没法生成外联播放器）I’ll Be There-Jess Glynne对于我的博客有问题或建议，欢迎在评论或邮件中告诉我。谢谢每一位读者。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"多图片滚动测试","slug":"多图片滚动测试","date":"2019-11-07T23:10:13.000Z","updated":"2019-12-01T06:31:24.901Z","comments":true,"path":"2019/11/08/多图片滚动测试/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/08/%E5%A4%9A%E5%9B%BE%E7%89%87%E6%BB%9A%E5%8A%A8%E6%B5%8B%E8%AF%95/","excerpt":"","text":"无缝滚动 *{margin: 0;padding: 0;} #div1{position: relative;border:1px solid #0ff;width:800px; height: 180px;margin:50px auto 0;overflow: hidden;} /* 修改容器规模 */ #div1 ul{position: absolute;left: 0;} #div1 ul li{list-style: none;width:200px;float: left;padding: 10px;height: 160px;} #div1 ul li img{width:100%;} window.onload=function(){ var oDiv=document.getElementById('div1'); var oUl=oDiv.getElementsByTagName('ul')[0]; var aLi=oUl.getElementsByTagName('li'); var aA=document.getElementsByTagName('a');//获取向右向左的箭头 var timer=null; var iSpeed=10; oUl.innerHTML+=oUl.innerHTML;//定义图片可以循环播放 oUl.style.width=aLi.length*aLi[0].offsetWidth+'px';//定义外层ul的宽度，根据图片的个数和每个图片的宽度计算，保证总宽度是可调整的 function fnMove(){ if(oUl.offsetLeft0){ oUl.style.left=-oUl.offsetWidth/2+'px'; }//定义到边界的时候，实现无缝衔接 oUl.style.left=oUl.offsetLeft+iSpeed+'px'; //定义图片的右边距随着速度不断不断增加，或减小，实现运动的效果 } timer=setInterval(fnMove,30); aA[0].onclick=function(){ iSpeed=-10; //按下左箭头，定义向左运动 } aA[1].onclick=function(){ iSpeed=10; //按下右箭头，定义向右运动 } oDiv.onmouseover=function(){ clearInterval(timer); //鼠标移动到图片上，清除定时器，停止运动 } oDiv.onmouseout=function(){ timer=setInterval(fnMove,30); //鼠标移出，重新开启定时器，重新运动 } }; ←→！！！方向选择按钮异常！！！L2Dwidget.init({\"model\":{\"jsonPath\":\"/blog/live2dw/assets/assets/haruto.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"tagMode\":false,\"debug\":false,\"mobile\":{\"show\":true},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\"}); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"网页视频测试","slug":"网页视频测试","date":"2019-11-07T16:00:00.000Z","updated":"2020-02-20T09:46:04.960Z","comments":true,"path":"2019/11/08/网页视频测试/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/08/%E7%BD%91%E9%A1%B5%E8%A7%86%E9%A2%91%E6%B5%8B%E8%AF%95/","excerpt":"浏览测试效果👇","text":"浏览测试效果👇 video大窗口 video小窗口 embed窗口 iframe窗口 测试完毕 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"使用Hexo+GitHub建站","slug":"Hexo+GitHub","date":"2019-11-07T11:24:01.000Z","updated":"2019-12-06T15:32:21.356Z","comments":true,"path":"2019/11/07/Hexo+GitHub/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/07/Hexo+GitHub/","excerpt":"前言： 使用CSDN平台撰写博客似乎是一件美事，只不过个人觉得太过于依赖他人平台，不如就自己搭建一个属于自己的博客。","text":"前言： 使用CSDN平台撰写博客似乎是一件美事，只不过个人觉得太过于依赖他人平台，不如就自己搭建一个属于自己的博客。 安装篇 一、安装 【hexo】 前的准备安装hexo前的必要工作1).安装以下两个程序： 程序 下载地址 说明 Git Git - Downloads 网速的同学，可以自行百度移步到国内镜像 Node.js Node.js - Downloads 有LTS和Current两个版本，安装 LTS 版即可 注意：关于Git和Node.js的安装可能会有问题，尤其是Git的安装。这里贴上几张安装界面的截图（来源见水印，作者GroovRain）。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 2).配置（可以在未来部署，并非一定现在） 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 $ git config --global user.name \"your name\"` $ git config --global user.email \"your Email\"二、正式安装【hexo】 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。——官方 准备工作完成后，来安装hexo框架吧！ == 主要根据hexo官方的文档来安装hexo == ==使用 npm 安装 Hexo== $ npm install -g hexo-cli 这样,【hexo】就安装完成了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"}]},{"title":"博客文章太长？截断！","slug":"文章截断","date":"2019-11-06T08:49:56.000Z","updated":"2020-01-04T01:51:09.574Z","comments":true,"path":"2019/11/06/文章截断/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/06/%E6%96%87%E7%AB%A0%E6%88%AA%E6%96%AD/","excerpt":"写的md文章太长，担心放到首页上浏览效果不好，怎么办？ 那就直接截断文章。 截断按钮文字不是通过配置文件_config.yml实现的，而是在文章内容里实现。 只要在需要被截断的文章位置加上： &lt;!-- more --&gt; 就可以了！ 效果就像下面的这个按钮 可以点点看哦👇","text":"写的md文章太长，担心放到首页上浏览效果不好，怎么办？ 那就直接截断文章。 截断按钮文字不是通过配置文件_config.yml实现的，而是在文章内容里实现。 只要在需要被截断的文章位置加上： &lt;!-- more --&gt; 就可以了！ 效果就像下面的这个按钮 可以点点看哦👇 插入测试代码 （无任何作用、意义，仅提供该页面测试用） javascript:window.onblur=null;void 0; //all var open_all_chapter = document.getElementsByClassName(\"fold_chapter\"); for (var i = 1; i &lt; open_all_chapter.length; i++) { open_all_chapter[i].click() } //each var chapters = document.getElementsByClassName(\"rate_box\"); var count = 0; chapters[++count].click(); setInterval(() =&gt; { // var playButton = document.getElementById(\"div_play_wrapper\"); // if (playButton) { // playButton.click(); // } var TC = document.getElementsByClassName(\"layui-layer-close1\"); if (TC.length &gt; 0) { console.log(\"检测到弹窗\"); TC[0].click(); } console.log(\"正在\" + count + \"个\"); var isFinish = chapters[count].getElementsByClassName(\"round_complete\"); if (isFinish.length &gt; 0) { chapters[++count].click() console.log(\"进入下\"); if(chapters[count].className===\"rate_box\"){ chapters[++count].click() } } }, 5000); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]}],"categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"https://melodyjerry.github.io/blog/tags/Docker/"},{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"宝塔","slug":"宝塔","permalink":"https://melodyjerry.github.io/blog/tags/%E5%AE%9D%E5%A1%94/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Github","slug":"Github","permalink":"https://melodyjerry.github.io/blog/tags/Github/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://melodyjerry.github.io/blog/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"},{"name":"Web","slug":"Web","permalink":"https://melodyjerry.github.io/blog/tags/Web/"},{"name":"API","slug":"API","permalink":"https://melodyjerry.github.io/blog/tags/API/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MVC","slug":"MVC","permalink":"https://melodyjerry.github.io/blog/tags/MVC/"},{"name":"JAVA","slug":"JAVA","permalink":"https://melodyjerry.github.io/blog/tags/JAVA/"},{"name":"数据库","slug":"数据库","permalink":"https://melodyjerry.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"C/C++","slug":"C-C","permalink":"https://melodyjerry.github.io/blog/tags/C-C/"},{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"},{"name":"Druid","slug":"Druid","permalink":"https://melodyjerry.github.io/blog/tags/Druid/"},{"name":"云服务器","slug":"云服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Servlet","slug":"Servlet","permalink":"https://melodyjerry.github.io/blog/tags/Servlet/"},{"name":"Git","slug":"Git","permalink":"https://melodyjerry.github.io/blog/tags/Git/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"},{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"},{"name":"系统","slug":"系统","permalink":"https://melodyjerry.github.io/blog/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"halo","slug":"halo","permalink":"https://melodyjerry.github.io/blog/tags/halo/"},{"name":"文章","slug":"文章","permalink":"https://melodyjerry.github.io/blog/tags/%E6%96%87%E7%AB%A0/"},{"name":"镜像","slug":"镜像","permalink":"https://melodyjerry.github.io/blog/tags/%E9%95%9C%E5%83%8F/"},{"name":"jQuery","slug":"jQuery","permalink":"https://melodyjerry.github.io/blog/tags/jQuery/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://melodyjerry.github.io/blog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"素材","slug":"素材","permalink":"https://melodyjerry.github.io/blog/tags/%E7%B4%A0%E6%9D%90/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"https://melodyjerry.github.io/blog/tags/SQL-Server/"},{"name":"音乐","slug":"音乐","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9F%B3%E4%B9%90/"},{"name":"电影","slug":"电影","permalink":"https://melodyjerry.github.io/blog/tags/%E7%94%B5%E5%BD%B1/"},{"name":"脚本","slug":"脚本","permalink":"https://melodyjerry.github.io/blog/tags/%E8%84%9A%E6%9C%AC/"}]}