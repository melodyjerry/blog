{"meta":{"title":"MelodyHub","subtitle":"你用走 可是我用跑","description":"","author":"Melody Jerry","url":"http://yoursite.com","root":"/blog/"},"pages":[{"title":"categories","date":"2019-11-07T13:28:44.000Z","updated":"2019-11-07T13:30:41.085Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"layout: categoriescomments: false document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2019-11-07T13:28:19.000Z","updated":"2019-11-07T13:30:18.621Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"layout: tagscomments: false document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2019-11-07T13:28:58.000Z","updated":"2019-11-07T13:31:02.320Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"layout: aboutcomments: truereward: false document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"About me","date":"2019-11-09T08:49:56.000Z","updated":"2019-11-09T08:51:04.935Z","comments":true,"path":"about/me.html","permalink":"http://yoursite.com/about/me.html","excerpt":"","text":"我是谁？我在哪里？我在做什么？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Java笔记——包","slug":"Java笔记——包","date":"2019-11-23T05:54:59.000Z","updated":"2019-11-23T08:53:59.036Z","comments":true,"path":"2019/11/23/Java笔记——包/","link":"","permalink":"http://yoursite.com/2019/11/23/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%85/","excerpt":"Java笔记——包创建时间：2019.11.23 说明：持续更新ing 概念 包(package) 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 ✔ 用来组织和管理类、接口、枚举和注解✔ 有三方面作用：1)便于组织,比如按功能、按团队等；2)解决命名冲突；3)进行访问权限控制(同包可用，包外不可见等) 如同类似OS的文件夹(或目录或路径)一样，包也采用了树形目录的存储方式。","text":"Java笔记——包创建时间：2019.11.23 说明：持续更新ing 概念 包(package) 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 ✔ 用来组织和管理类、接口、枚举和注解✔ 有三方面作用：1)便于组织,比如按功能、按团队等；2)解决命名冲突；3)进行访问权限控制(同包可用，包外不可见等) 如同类似OS的文件夹(或目录或路径)一样，包也采用了树形目录的存储方式。 作用 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 🔺 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 同一个包中类名字是不同的，不同包中类的名字可以相同，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 语法格式 123package 包名或package 父包名[.子包名][.孙包名][.层次下去] 🔸包名符合标识符命名规范，一般由小写字母组成🔹必须出现在源文件的第一行(忽略注释语句)🔸每个源文件至多只能出现一个package语句🔹如果没有package语句，那就使用无名包(或称默认包:所在的当前目录)🔸包的背后对应着操作系统的路径名称 示例： 12345678910111213package ch08.web.sample; public class Person { String name; int age; //省略部分代码 } class Dog { String name; int age; //省略部分代码} 🔺package ch08.web.sample; 这个层级的文件夹必须先存在：即ch08/web/sample 包的使用 🔺import 关键字 为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。 为了使用另外一个包中的成员(主要是类)，可以明确import该成员。 避免重复使用完整路径的类名。 语法格式： 1import package1[.package2…].(classname|*); 注意： 必须紧跟在package语句之后(若有的话，若无package，则import出现在源文件头部)。 可以使用 * 来表示导入当前一层包中的所有类。但是* 不可以连续使用。 1import java.*.*; // Error! 不表示可以继续导入当前包的子包。如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。 类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。 Java常用包 🔵JavaAPI的类库也是按照包的方式组织的 包名 描述 备注 Java.lang Java语言进行程序设计的基础类(核心类库)，它是默认导入的包 Runnable接口和Object、Math、String、StringBuffer、System、Thread、Throwable类 Java.util 实用工具类包 定义系统特性、随机数、日期时间、日历、集合类等 Java.io IO类包 包含能提供多种输入输出的文件读写类 Java.net 网络编程API Java.sql 数据库操作包 Java.text 文本处理相关类 包含了一些用来处理文本、数字和消息的类和接口 Java.awt 提供创建界面和绘制图形图像的所有类 Javax.asing awt上封装的GUI包 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java笔记——继承","slug":"Java笔记——继承","date":"2019-11-21T09:54:59.000Z","updated":"2019-11-23T07:47:13.181Z","comments":true,"path":"2019/11/21/Java笔记——继承/","link":"","permalink":"http://yoursite.com/2019/11/21/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF/","excerpt":"Java笔记——继承 创建时间：2019.11.21 说明：持续更新ing 继承源于自然 就比如：兔子和羊属于食草动物类，狮子和豹属于食肉动物类。食草动物和食肉动物又是属于动物类。虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以 子类会具有父类的一般特性也会具有自身的特性。","text":"Java笔记——继承 创建时间：2019.11.21 说明：持续更新ing 继承源于自然 就比如：兔子和羊属于食草动物类，狮子和豹属于食肉动物类。食草动物和食肉动物又是属于动物类。虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以 子类会具有父类的一般特性也会具有自身的特性。 //截断文章 概念、目的、本质、特性 概念 它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 其主要作用在于，在已有基础上继续进行功能的扩充。（即，以存在的类为基础定义新的类，新类即拥有基类的数据成员和成员方法） 目的 继承的目的是代码重用 本质 描述了自然界中广泛存在的一种关系——类属关系（is-a），对应还有一种has-a关系即组合（聚合）关系。 特性 Java 继承的特性 子类拥有父类非private的属性，方法 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展 子类可以用自己的方式实现父类的方法 Java的继承是单继承，【但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性】 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系） 继承的关键字 继承可以使用 extends(单继承) 和 implements（变相的多继承）， 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 （1）extends关键字 Java只支持单继承，即：一个子类只能有一个父类.但可以有多个间接祖先类。 语法格式： 123456权限修饰符 class 父类名 { //父类体}权限修饰符 class 子类名 extends 父类名 { //子类体} 实例： 123456789101112public class Animal { private String name; private int id; public Animal(String myName, String myid) { //初始化属性值 } public void eat() { //吃东西方法的具体实现 } public void sleep() { //睡觉方法的具体实现 } } public class Penguin extends Animal{ } —————————————————————— 我 是 分 割 线 ——————————————————————— （2）implements关键字 变相地使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 public interface A { public void eat(); public void sleep(); } public interface B { public void show(); } public class C implements A,B { } &lt;!--￼2--&gt; 执行结果： &lt;!--￼3--&gt; —————————————————————— 我 是 分 割 线 ——————————————————————— （4）this关键字 指向”自己的引用“。 实例： 123456789101112131415161718192021222324class Animal { void eat() { System.out.println(\"animal : eat\"); }} class Dog extends Animal { void eat() { System.out.println(\"dog : eat\"); } void eatTest() { this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 }} public class Test { public static void main(String[] args) { Animal a = new Animal(); a.eat(); Dog d = new Dog(); d.eatTest(); }} 输出结果： 123animal : eatdog : eatanimal : eat ——————————————————————————— 我 是 分 割 线 ———————————————————————————— （5）final关键字 声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。 继承类型 Java 不支持多继承，但支持多重继承 （ 一般不会超过三层 ）。 继承类型 继承的限制 🔺 Java只允许单继承、不允许多继承（一个子类继承一个父类）。 🔺 子类对象在进行实例化前首先调用父类构造方法，再调用子类构造方法实例化子类对象。 🔺 在继承时，子类会继承父类的所有结构。 在进行继承的时候，子类会继承父类的所有结构（包括私有属性、构造方法、普通方法）显示继承：所有非私有操作属于显示继承（可以直接调用）。隐式继承：所有私有操作属于隐式继承（不可以直接调用，需要通过其它形式调用（get或者set））。 子类能够使用的是所有非private操作，而所有的private操作无法被直接使用，所以称为隐式继承。 继承中“域的隐藏” 在子类中重新定义( 同 名 )继承自父类的域. 🔺子类继承父类非私域。 🔺子类定义与从父类继承下来的同名域，在子类中用该名直接访问就只能访问到子类定义的域，即隐藏了同名的继承下来的父类域。 🔺如果要访问同名父类域：通过父类方法，或者使用“*super . *” 实例： 123456789101112131415161718192021222324import static java.lang.System.*;class Super{ private int v1 = 1; int v2 = 2; public int getV1() { return v1; }}class Sub extends Super{ int v1 = 11; int v2 = 22; public void show() { out.println(v1); //out.println(super.v1); out.println(getV1()); out.println(v2); out.println(super.v2); }}public class FHTest{ public static void main(String[] args) { new Sub().show(); }} 继承情况的构造 首先🔺类初始化时,继承链上(包括当前类)的全部静态代码块最先执行一次。之后不再执行，除非程序又重启。(按链序和声明序且仅1次) 其次🔺创建子类实例时,会先进行父类的构造(要么显式进行，要么隐式用super()进行) 最后🔺类的构造顺序：构造代码块(按声明序) ➡ 构造方法 总体🔺父类静态块 ➡ 子类静态块 ➡ 父类构造块 ➡ 父类构造子 ➡ 子类构造块 ➡ 子类构造子（下划线”__”部分， 仅执行一次） 总结 1、为什么使用继承 从已有的类派生出新的类，称为继承。 在不同的类中也可能会有共同的特征和动作，可以把这些共同的特征和动作放在一个类中，让其它类共享。 因此可以定义一个通用类，然后将其扩展为其它多个特定类，这些特定类继承通用类中的特征和动作。 继承是 Java 中实现软件重用的重要手段，避免重复，易于维护，易于理解。 2、父类和子类 如果类 B 从类 A 派生，或者说类 B 扩展自类 A，或者说类 B 继承类 A， 则称类 A 为”父类”，也称为超类、基类； 称类 B 为”子类”，也称为次类、扩展类、派生类。 子类从它的父类中继承可访问的数据域和方法，也可以添加新的数据域和新的方法。 定义继承的语法： 1修饰符 class 子类名 extends 父类名 例如：Shape 类是父类，其子类可以有 Circle 类、Rectangle 类、Triangle 类，等等。 继承的注意点： 子类不是父类的子集，子类一般比父类包含更多的数据域和方法。 父类中的 private 数据域在子类中是不可见的，因此在子类中不能直接使用它们。 继承是为”是一个”的关系建模的，父类和其子类间必须存在”是一个”的关系，否则不能用继承。 但也并不是所有”是一个”的关系都应该用继承。例如，正方形是一个矩形，但不能让 Square 类来继承 Rectangle 类，因为正方形不能从矩形扩展得到任何东西。正确的继承关系是 Square 类继承 Shape 类 Java 只允许单一继承（即一个子类只能有一个直接父类），C++ 可以多重继承（即一个子类有多个直接父类）。 3、super 关键字 super 表示使用它的类的父类。super 可用于： 调用父类的构造方法； 调用父类的方法（子类覆盖了父类的方法时）； 访问父类的数据域（可以这样用但没有必要这样用）。 调用父类的构造方法语法： 12345super(); 或 super(参数列表); 注意：super 语句必须是子类构造方法的第一条语句。不能在子类中使用父类构造方法名来调用父类构造方法。 父类的构造方法不被子类继承。调用父类的构造方法的唯一途径是使用 super 关键字，如果子类中没显式调用，则编译器自动将 super(); 作为子类构造方法的第一条语句。这会形成一个构造方法链。 静态方法中不能使用 super 关键字。 调用父类的方法语法： 1super.方法名(参数列表); 如果是继承的方法，是没有必要使用 super 来调用，直接即可调用。但如果子类覆盖或重写了父类的方法，则只有使用 super 才能在子类中调用父类中的被重写的方法。 4、this 关键字 this 关键字表示当前对象。可用于： 调用当前类的构造方法，并且必须是方法的第一条语句。如：this(); 调用默认构造方法。this(参数); 调用带参构造方法。 限定当前对象的数据域变量。一般用于方法内的局部变量与对象的数据域变量同名的情况。如 this.num = num。this.num 表示当前对象的数据域变量 num，而 num 表示方法中的局部变量。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"教会你怎么安装和使用 Visio 哦 ~ ~","slug":"Visio教程","date":"2019-11-19T01:34:04.000Z","updated":"2019-11-23T09:27:37.901Z","comments":true,"path":"2019/11/19/Visio教程/","link":"","permalink":"http://yoursite.com/2019/11/19/Visio%E6%95%99%E7%A8%8B/","excerpt":"前言 很多学生会在编程、设计或其他时候可能使用到【制图工具】。最好用的莫不过【微软的Visio】了。但是很多学生不会使用Visio，甚至不会安装Visio。 &gt; Visio 这么好的工具，一定要会用。 今天，作者写一份教程，教会大家了解如何安装和使用 ==Visio==。 在正式教程之前，我们先介绍 Visio。 Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。 &gt; Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。","text":"前言 很多学生会在编程、设计或其他时候可能使用到【制图工具】。最好用的莫不过【微软的Visio】了。但是很多学生不会使用Visio，甚至不会安装Visio。 &gt; Visio 这么好的工具，一定要会用。 今天，作者写一份教程，教会大家了解如何安装和使用 ==Visio==。 在正式教程之前，我们先介绍 Visio。 Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。 &gt; Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。 //截断文章 安装1. 【下载资源】 网上也有很多资源，但是包是不完整的。版本也很多，要激活也不容易。 作者在这里已经打包好“Visio 2019”和“激活工具”了，点击这里(提取码: rwtr)开始下载。 由于现在的笔记本都是预装win10的，所以不用担心Visio 2019合不合适。毕竟Visio 2019在win7上是安装不了的。2. 【解压】 下载得到压缩包，解压，打开文件夹。 image 3. 【打开Setup】 打开“Visio 2019”，右键“Setup”选中“以管理员身份运行”。（似乎不用管理员也行？？？） 4. 【正在安装】 等待就好，很快的。 image 5. 【安装完成】 安装结束，点击“关闭”。 6. 【激活】 Visio 2019是==必须激活==才可以使用的。 否则，会一直弹窗提示激活的。 激活工具在另一个文件夹里。 补充一些关于KMS： KMS（全称:Key Management Service），这个是微软的一种新型产品激活机制，目的是为了Microsoft更好的遏制非法软件授权行为(盗版)。 当然作者不提倡破解、或盗版。 对于有能力的人，还是支持正版。但是学生嘛，能用就好了。 使用激活工具前，作者建议： ==最好关闭杀毒软件，如果有的话。== 作者没安装360那些，很流畅地激活成功。 ==激活工具无毒的。不关闭的话，可能被误报。== 1).【打开】 界面如下： 这个激活工具还可以xxxxxx。（你懂的） 我啥都没说哦hh 2).【激活】 简单一按，等待激活成功就好。 补充：可能有的电脑打开软件时会提示这个。解决很简单，安装框架就好。 （1）打开“控制面板”。（2）找到并点击“程序和功能”项，在打开的页面中，点击“启用或关闭Windows功能”。（3）在打开的“Windows功能”对话框中，找到并勾选“Microsoft.Net Framework”服务，单击“确定”即可。 使用激活后，就可以安安心心、大大方方地使用 Visio 了。o(￣▽￣)o 【打开】 【新建】新建页面，有一些初始模板可以使用。一般选择“基本框图”就好，然后“新建”。 image 【制图】 左侧可以选择很多官方自带的形状，当然还可以自己建立自己的模型。 右侧可以对图形自定义，包括颜色、线条、端点等等。 结尾使用 Visio 来制图真的很爽。但是，如果只是临时制图使用 Visio ，还得安装确实不太方便。因此 作者还收藏了几个线上制图的网站，在这提供给大家临时使用。 1. https://www.draw.io/ image 2. https://zh.numberempire.com/graphingcalculator.php 3. https://www.processon.com 4. 当然用电脑自带的【画图】也是可以的，你看。 emmm只是好难看啊hhhh。 这就是结尾：如果教程上有什么不足的或者有问题的，可以私信我。谢谢你的阅读！ 本博客第一次发表于【简书】： https://www.jianshu.com/p/32648bcc6f1c 。现转载到作者的网站上。谢谢阅读！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"推荐文本编辑器：Notepad 3、Sublime和Atom","slug":"文本编辑器","date":"2019-11-18T02:34:04.000Z","updated":"2019-11-23T02:12:23.518Z","comments":true,"path":"2019/11/18/文本编辑器/","link":"","permalink":"http://yoursite.com/2019/11/18/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/","excerpt":"前言今天作者推荐两款文本编辑器。 我先后使用的Notepad 3、Sublime、Atom、VS Code、Vim。 这里作者就只推荐Notepad 3、Sublime和Atom。 关于VS Code和Vim，文末有两篇教程供大家入手。","text":"前言今天作者推荐两款文本编辑器。 我先后使用的Notepad 3、Sublime、Atom、VS Code、Vim。 这里作者就只推荐Notepad 3、Sublime和Atom。 关于VS Code和Vim，文末有两篇教程供大家入手。 //截断文章 Notepad 3 虽然 Windows 操作系统在过去几年中有了显著变化，但是，默认的 Windows 记事本却鲜有更新。如果您需要一个简单且适于编程的文本编辑器，Notepad3 将是一个不错的选择！ Notepad3是一款轻便快捷的基于 Scintilla 的文本编辑器，具有语法高亮、代码折叠、括号匹配、自动缩进、编码转换、换行格式转换、多次撤销或重做、书签、基于正则表达式的查找和替换等实用功能。它占用的内存很小，但功能强大，足以处理大多数编程工作。 Notepad 3 的界面 可能 是我见过所有主流文本编辑器里最最最简单清爽的吧？ 蓝奏云：下载链接（作者提供了已经汉化过的便携版本） （注意：Notepad 3和Notepad++没有关系 ） Sublime官方的介绍简单又粗暴 一款用于代码、标记和散文的精致文本编辑器 Sublime支持 Windows 、Mac 平台。插件是程序员的灵魂，Sublime不失这点。类似于 Eclipse，IDEA，它有着丰富的插件系统，完全可以满足各种开发编辑需求。 在这里插入图片描述 1）安装 官网关于Sublime的介绍语下就是win版的下载入口或者点击这里快速下载最新版==Sublime Text 3 (Build 3207)== 在这里插入图片描述 下载得到的是exe，双击开始安装。 在这里插入图片描述 安装导向界面，点击【Next】继续安装。 在这里插入图片描述 选择Sublime Text 3安装位置，您可以点击【Next】，软件会自动安装。或者您可以单击【Browse】，在弹出的安装位置窗口中，您可以自己选择Sublime Text安装位置，选择完成后点击【Next】。 在这里插入图片描述 这里可选择 添加到资源管理器上下文菜单 。 在这里插入图片描述 安装完后可以在桌面或者开始菜单中找到Sublime。 2）使用Sublime的界面特别简洁，让人看着很舒服。 在这里插入图片描述 这里，作者已经汉化过了。初始语言是English。 3）汉化 sublime 的插件的强大之处，sublime 通过 package control来统一管理安装的插件。现版本sublime 3自带package control功能。 将English变成Chinese，也可以通过Sublime的插件实现。 作者已经汉化过。为了教程，故在win7虚拟机上教大家如何实现汉化。 官网下载，并安装好, 刚安装好的是没有 Package Control 选项 在这里插入图片描述 找到 Tools-&gt;Install Package Control 选项，即可调出 Package Contro 不能直接找到 Install Package Control，去找“Tools-&gt;Command Palette…”选项 输入 ipc ,点击 Install Package Control，即可调出 Package Control 在这里插入图片描述 等待完成 在这里插入图片描述 找到 Preferences-&gt;Package Control 在这里插入图片描述 选项弹出命令行输入框，输入ip，点击“install Package 在这里插入图片描述 弹出命令行输入框，输入clz，点击“ChineseLocalizations” 在这里插入图片描述 搞定，设置成中文了 在这里插入图片描述 开开心心地食用汉化地Sublime吧 o(￣▽￣)o Atom Atom 是 Github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持CSS，HTML，JavaScript等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。 官网在这里👈 在这里插入图片描述 友情链接：w3school之Atom教程Atom 中文社区 1）安装 在这里插入图片描述 官网地Downloa或者点击这里快速下载最新版==Atom (1.41.0)== 在这里插入图片描述 下载得到exe，双击开始安装。安装过程很简单，直接省略。 2）使用Atom 的界面也比较简洁。Atom提供了侧栏、标签栏，可提高效率。Atom还能链接到GitHub，这真是GitHub用户的福利。(当然，Atom本来就是Github推出的hhhh) 在这里插入图片描述 3）汉化Atom的汉化有两种方法： 方法一 打开软件后，点击 File&gt; Settings&gt; install 在这里插入图片描述 搜索 chinese，安装两个插件 在这里插入图片描述 重启软件 在这里插入图片描述 因为插件托管在国外，可能因为网速原因，会非常慢，因此推荐下载中文插件包，请看方法二👇 方法二 打开https://atom.io/packages/去官网下载中文包，搜索【Chinese】，找到【atom-simplified-chinese-menu】点击进入主页（如上图），然后再点【Verions】，之后，找到最新版本，点【zip】包下载即可。。作者在这已经准备好中文包了，点击这里下载 在这里插入图片描述 将下载好了的压缩包解压到 C:/user/&lt;用户名&gt;/.atom/packages/目录下面 在这里插入图片描述 打开Atom，发现已经Chinese了。 在这里插入图片描述 综上主流的文本编辑器有很多。每个人的需求不一样，找到合适自己的才是好的。Notepad 3、Sublime、Atom、VS Code、Vim、Notepad++（前段时间闹事，作者不方便再提） VS Code：传送门 Vim：传送门 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"解除课程中心看视频时的“ 窗口获取焦点事件 ”","slug":"解除课程中心看视频时的“ 窗口获取焦点事件 ”","date":"2019-11-16T09:54:59.000Z","updated":"2019-11-23T02:16:39.416Z","comments":true,"path":"2019/11/16/解除课程中心看视频时的“ 窗口获取焦点事件 ”/","link":"","permalink":"http://yoursite.com/2019/11/16/%E8%A7%A3%E9%99%A4%E8%AF%BE%E7%A8%8B%E4%B8%AD%E5%BF%83%E7%9C%8B%E8%A7%86%E9%A2%91%E6%97%B6%E7%9A%84%E2%80%9C%20%E7%AA%97%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6%20%E2%80%9D/","excerpt":"前言前段时间，在观看课程中心的马克思视频，因为要至少看到80%以上。 发现那我挂着刷不就得了？偏偏。。。。。 发现这个课程中心存在某个机制——一定要使视频一直处于“置顶”的状态，否者会自动暂停视频。","text":"前言前段时间，在观看课程中心的马克思视频，因为要至少看到80%以上。 发现那我挂着刷不就得了？偏偏。。。。。 发现这个课程中心存在某个机制——一定要使视频一直处于“置顶”的状态，否者会自动暂停视频。 //截断文章 就像下图这样： 操作鼠标前——&gt; image.png 操作鼠标后——&gt; image.png 你会注意到，视频的播放状态跟鼠标的行为有关，准确来说是==和鼠标点击的位置（焦点）有关==。 第一时间想到“这不就是windows的“窗口获取焦点”吗？ 补充先补充补充什么是窗口获取焦点？ 在你浏览其他窗口页面、或是浏览器最小化、又或是点击了程序窗口时，等等都算是浏览器窗口失去焦点，这时候 window.onblur 事件就会触发。 当然，当你的页面获得焦点的时候一样也会触发window.onfocus。 应该有人会注意到过，当你点击不同窗口时，窗口栏会有不同的颜色反馈，就比如win 10的资源管理器，前置窗口和后置窗口的窗口颜色是不是不一样？ image.png 寻找直接按下F12，打开控制台，查看Elements…… emmmmmm结果，没找到对应的代码（或许我没仔细去挖hh） 再试那我直接Console。不就是当前窗口获取了焦点吗？？？？直接暴力敲下代码，并Enter，嘿嘿…… 1javascript:window.onblur=null;void 0 //有无`void 0`，都可以 当我Enter时，诶，成功了hhh效果就是这样。 image.png 后续测试了一段时间后，成功率基本达97%左右。后来就分享到班群，让更多人试试效果。两天刷完所有马克思的视频哈哈有木有？ 建议 一次最多同时两个视频在看，因为后台有个计时器再加上我不会写自动播放、自动静音的脚本hhhhh（有时间再去琢磨哈） 一旦刷新页面，就得重新Enter脚本 极小几率会失败，原因我也不清楚，失败重新Enter即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"脚本","slug":"脚本","permalink":"http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"Java笔记——对象、类","slug":"Java笔记——对象、类","date":"2019-11-15T09:54:59.000Z","updated":"2019-11-23T02:13:51.399Z","comments":true,"path":"2019/11/15/Java笔记——对象、类/","link":"","permalink":"http://yoursite.com/2019/11/15/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB/","excerpt":"Java笔记——对象、类创建时间：2019.11.11 说明：持续更新ing 对象和类的概念。 对象：对象是类的一个实例（实实在在存在的个体），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是对现实生活中事物的描述。类是一个模板，它描述一类对象的行为和状态。 下图中男孩（boy）、女孩（girl）为类（class），而具体的每个人为该类的对象（object）： 菜鸟教程.png","text":"Java笔记——对象、类创建时间：2019.11.11 说明：持续更新ing 对象和类的概念。 对象：对象是类的一个实例（实实在在存在的个体），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是对现实生活中事物的描述。类是一个模板，它描述一类对象的行为和状态。 下图中男孩（boy）、女孩（girl）为类（class），而具体的每个人为该类的对象（object）： 菜鸟教程.png //截断文章 问：类设计get方法和set方法的作用是什么？ 答1：一般类的成员变量被设置为private（私有的），这样设置安全性比较高，但是设置为私有的后其他的类和对象则无法调用该对象了，所以会有get和set方法，这两个方法一般设置为public，在其他的类中通过对象调用set或get方法即可操作私有的变量，增强程序的安全性，set为给对象赋值的方法，而get则是取得变量值的方法！ 答2：get set常用在自定义类，类创建了一个实例对象后，用set设置对象的某一个属性，get得到对象某一属性。如果不使用get set，你就得用点，点出来还得是个方法。其实就是给get set换个名而已。而且get set作为内部方法，可以访问私有数据 答3：别说的那么专业化了，理解都要半天。就这么理解吧，面向对象中，想对类的成员变量设置访问一些权限，于是，就将该字段设置为private的，这样别的类就不能访问了，然后在该内定义两个方法，一个专门用于获取，一个用于修改，这样，在你不想让别人乱动该字段的时候，就在该方法内写一些限制条件。而为了规范起见（团队开发需要嘛），就根据人家老外的习惯，将方法名设置为set+字段名，get+字段名（名字乱改没问题），既然规范了，那就是别人都叫这名了，于是，有些框架给对象赋值就有方法了，方法名称由get或set开始的又有private变量名的，就找出来调用。hibernate1框架就这样弄得，至于后面的版本是不是这样就不大清楚了。JavaBean就是一个JAVA类，既然是JAVA类就不需要什么组件了，这玩意直接深入到虚拟机了的 Java中的对象现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。对比现实对象和软件对象，它们之间十分相似。 软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 Java中的类类可以看成是创建Java对象的模板。通过下面一个简单的类来理解下Java中类的定义：12345678910111213public class Dog{ String breed; int age; String color; void barking(){ } void hungry(){ } void sleeping(){ }} 一个类可以包含以下类型变量：局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。一个类可以拥有多个方法，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法。 类和对象的关系： 现实生活中的对象：张三、李四。 【想要描述】提取对象中的共性内容。对具体的抽象。 【描述时】这些对象的共性有：姓名、学号、年龄、性别、学习Java等等。（即定义类：描述事物的属性和行为，就是在定义属性和行为。属性和行为共同成为类中的成员（成员变量和成员方法）。） 映射到Java中，描述就是class定义的类，具体对象就是new建立的实体。 这些描述在Java当中是用类的形式来体现的。而对象是通过Java的new操作符所产生的一个实体，这个的实体存在于==堆内存==当中。 12345678910111213141516171819202122232425//定义类，就是描述事物，就是在定义属性和行为。属性和行为共同成为类中的成员（成员变量和成员方法）。//需求：描述车汽车（颜色，轮胎数）。class Car { //描述颜色 String color = \"red\"; //描述轮胎数 int num = 4; //运行行为。 void run() { System.out.println(color+\"..\"+num); }}class CarDemo { public static void main(String[] args){ //生产汽车：在Java中通过new操作符来完成。 //其实就是在堆内存中产生一个实体。 Car c = new Car(); //c就是一个【类类型】变量。记住：类类型变量只想对象。 //需求：将已有车的颜色的颜色改成蓝色。指定该对象做使用。 //在Java指挥方式是：【对象.对象成员】 c.color = \"blue\"; //需求：想要车运行起来。 c.run(); }} Car c = new Car();在内存中的示意图——&gt; c.run();——&gt;输出这个车的颜色“蓝色”和轮胎数“4”。 (1)倘若在c.run();后加入Car c1=new Car();c1.run();——&gt; (2)若main的代码块改为： 123456789class CarDemo { public static void main(String[] args){ Car c = new Car(); c.num = 5; Car c1 = c; c1.color = \"green\"; c.run(); }} 在内存中的示意图——&gt; 对对象调用的基本概念：用new建立对象，在堆内存中产生对象。那么对象的特点在于封装数据，数据包含属性和行为。想要操作对象中的内容就指挥对象做事，指挥哪个对象要明确，操作什么也要明确，用对象.xyz的形式就能完成。 【注意】：如下图， 以前定义在函数里面，现在定义在函数外面 【方法】 方法的定义： 方法是类或对象的行为特征的抽象。 Java中的方法不能独立存在，所有的方法必须定义在类中。 使用 “类名.方法” 或 “对象.方法” 的形式调用。 语法格式： 1234权限修饰符 返回值类型 方法名（参数类型 参数名） { // 方法体 // 返回值} 方法分类： 无参数无返回值 有参数无返回值 无参数有返回值 有参数有返回值 123456789101112131415161718192021222324252627282930public class Method { public void aMethod() { System.out.println(\"无参数无返回值的方法\"); } public void bMethod(int b) { System.out.println(\"有参数无返回值的方法\"); } public int cMethod() { System.out.println(\"无参数有返回值的方法\"); return 10; } public int dMethod(int d) { System.out.println(\"有参数有返回值的方法\"); return d; } public static void main(String[] args) { int ret; // 创建Method类的对象 Method md = new Method(); // 通过对象.方法调用 md.aMethod(); md.bMethod(10); ret = md.cMethod(); ret = md.dMethod(10); System.out.println(ret); }} 方法的参数： 方法可以没有参数，或者有多个参数，参数类型可以是任意类型 方法参数也是局部变量 参数为引用数据类型时： 当对象实例作为参数传递给方法时，传递的是对象的引用，为地址传递，接受参数的方法可以改变参数的值。 参数为简单数据类型时： 传递的是参数的副本，为值传递，接受参数的方法中不会改变参数的值。 123456789101112131415161718192021222324252627282930313233343536373839public class MethodParam { /** * 方法的参数为基本数据类型时，传递的是值的副本（值拷贝） * 方法中不会改变元参数的值 */ public void swap(int a, int b) {//a, b为形参 int tmp; tmp = a; a = b; b = tmp; } int x = 100, y = 200; /** * 方法的参数为引用数据类型时，传递的对象的引用（传地址） * 方法中可以改变参数的值 */ public void swap2(MethodParam mp) { int tmp = mp.x; mp.x = mp.y; mp.y = tmp; } public static void main(String[] args) { MethodParam mp = new MethodParam(); int m = 10, n = 20; System.out.println(\"交换前：a = \"+m+\",b = \"+n); mp.swap(m, n);// m,n为实参 System.out.println(\"交换后：a = \"+m+\",b = \"+n); System.out.println(\"交换前：x = \"+mp.x+\",y = \"+mp.y); mp.swap2(mp); System.out.println(\"交换后：x = \"+mp.x+\",y = \"+mp.y); }} 【构造方法】 构造方法需满足以下三个条件 ： 1、方法名与类名同名 2、在方法中不能使用return 语句返回 3、在方法名的前面没有返回值的类型声明 12345678910111213package me;public class Me { private String name; //成员变量 public Me(String name){ //构造方法 this.name = name; } public String getName() { //成员方法 return name; } public void setName(String name) {//成员方法 this.name = name; }} 我如果我在添加一age 如下 添加方法依然是成员方法 , 1234567891011121314151617181920package me;public class Me { private String name; //成员变量 private String age; //成员变量 public Me(String name){ //构造方法 this.name = name; } public String getName() { //成员方法 return name; } public void setName(String name) {//成员方法 this.name = name; } public String getAge() {//成员方法 return age; } public void setAge(String age) {//成员方法 this.age = age; }} 个人理解：无论多少方法，==除了构造方法以为都是成员方法==，当然这样理解可能有点偏见.. 它们的区别： 构造方法一般是给对象的数据进行初始化,没有返回值 成员方法一般实现对类中成员变量的操作，提供某些功能,有返回类型，可以为void类型 成员方法与构造方法调用的区别 123456789package me;public class Book { public static void main(String[] args) { Me me = new Me(\"张三\");//构造方法调用 System.out.println(me); me.setName(\"李四\");//成员方法调用 System.out.println(me.getName()); }} 从上面的demo中可以看出，==构造方法通过new运算符调用==，==成员方法通过对象调用==。 注意： 类中除了构造方法以外的方法都是成员方法。 原因是在类中，除了变量外的基本都是成员方法。 【成员方法】 【方法重载，重构，覆盖，重写的区别】 方法重载还是比较好理解的，就是在类的内部，定义多个方法，这些方法的方法名字相同，参数类型和参数个数不同，注意，返回值类型并不能区分重载 。 1234567public void show(int a,double b){} public void show(double c){ } public int show(double d){return 1;} //报错，方法已经定义了 在看方法重写（override)方法重写和方法覆盖都是一个道理，发生在子类继承父类或者实现接口的类，要求的是： 1.方法名字相同，2.参数个数不同，3.返回值类型不同 ， 代码： 方法重构： 定义：在不改变外界外界访问的情况下对代码进行修改，但是不改变原方法的效果，提高其性能，使程序更加易读，可维护。重构是在不改变软件可观察行为的前提下改善其内部结构重构通常不是一次性的，它贯穿软件的整个生命周期，只要觉得不合理都是重构的时机。 题目：下面说法中，错误的有（ ） ​ A. Java面向对象语言容许单独的过程与函数存在； ​ B. Java面向对象语言容许单独的方法存在； ​ C. Java语言中的方法属于类中的成员（member）； ​ D. Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同。 答案：ABC 解释： 方法与函数：这两个概念不严格区分，就是一个东西，通过对象调用的，就是方法，直接调用，就是函数； 在java中，everything is object 所以，方法，函数，必须隶属于某一个类或对象， java中没有过程。（类中的代码块不知道算不算，就算代码块是过程，也是必须在类中才有的） 对于C选项，方法分为静态方法和非静态方法，静态方法属于类成员，非静态方法属于实例成员。 类其实一种类型，它封装了数据和操作。 对象是类的实例 一个对象比属于某个类 一个类可以声明多个对象 问：构造方法可以调用本类的其他方法吗？ 1,构造方法可以调用本类的其他方法。既然可以调用本类的属性,那么也就可以调用属于本类的其他方法。 2,需要注意的是,如果要在构造方法里调用一个非静态方法时,应该将该方法声明为private。因为如果这个类被其他类继承成为父类时,这个方法不是private的又被子类所重载，这样在实际创建子类的过程中递归调用到了父类的构造器时，父类构造器对这个方法的调用就会由于多态而实际上调用了子类的方法，当这个子类方法需要用到子类中实例变量1的时候，就会由于变量没有初始化而出现异常（子类中的实例变量没有初始化这种情况还是会遇见的），这是Java不想看到的情况。 一个类的构造方法有多个，在其他类中是否可以被调用？ 只要不是私有的构造函数，在其他类中就可以调用。 传对应的参数就行了 。 12345678910class` `A{ ``public` `A(String s){} ``public` `A(``int` `n){} ``public` `A(String s, ``int` `n){}}class` `B{ ``A a1 = ``new` `A(``\"abc\"``); ``A a2 = ``new` `A(``1``); ``A a3 = ``new` `A(``\"aaa\"``,``2``);} 类是一种引用类型。 Java的引用类型只有三种，分别是 类(class) 接口(interface) 数组 参考资料 问：方法一定是在类内部被定义的？ 所有方法必须写在类体里，也包括构造方法2的。 static方法同样属于类，叫类方法或静态方法，它与类一同被加载时，处于内存的公共代码区中，无需创建实例来调用，只需用类名引用即可。 static方法既可以通过类名来调用，也可以通过类的实例调用。 Java一切都是以类的形式存在，方法是类的一部分，需要通过类才能进行方法的调用。 从内存存储角度来说，java中找对应方法时，都是先找对应类实例，类实例是根据类来初始化内存的。如果方法在类外部，则无法找到该方法。 所以方法必须在类体里。 注意： 可以在其他类里使用这个类的方法（在不同的包下就要引ltem这个类），继承就是一个类从另一个类继承通过关键字extends 来实现 问：构造方法中可不可以有return语句呢? 可以。而是我们写成这个样子就OK了：return; 其实，在任何的void类型的方法的最后你都可以写上：return; 问：非构造方法的一般成员方法必须有return语句？ 问：类中的数据成员可以按需选择任意类型，包括类本身？ 可以。可以参考下图，图源于陈三千的博客 注脚：1.实例变量（全局变量）、成员变量、实例变量、属性 ↩2.java的构造方法、java的构造方法、Java入门：构造方法 ↩3.暂无 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java笔记——面向对象","slug":"Java笔记——面向对象","date":"2019-11-13T04:54:46.000Z","updated":"2019-11-23T02:15:00.151Z","comments":true,"path":"2019/11/13/Java笔记——面向对象/","link":"","permalink":"http://yoursite.com/2019/11/13/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"Java笔记——面向对象创建时间：2019.11.11 说明：持续更新ing Java作为一种面向对象语言。支持以下基本概念： 多态 | 继承 | 封装 | 抽象 类 | 对象 | 实例 | 方法 | 重载 “面向对象”和“面向过程”的区别： 面向过程：如 C/C++ 例子：冰箱装大象。1、打开冰箱门；2、放进大象；3、关上冰箱门。强调过程，“打开”、“存储”、“关闭”三个动作。注重过程，注重的是过程涉及的行为（即功能）。 面向对象：如 Java 将功能封装进对象，强调具备了功能的对象。 image.png 面向对象是基于面向过程的。 使用不同思想，对“冰箱装大象”的理解——&gt; 问：“人开冰箱”事件，其中人、冰箱都是实物（对象），开是动作。若使用面向对象思维，“开”的这个动作是属于“人”还是属于“冰箱”？ 答：属于“冰箱”，“人”只是调用了“冰箱”的“开”的方法（或功能），用力作用了门一下并将门打开了。 1234567891011121314人开门：名词提炼法。/*人{ 开门（门）{ 门.开（）; }}门{ 开（）{ 操作门轴; ……等等; }}*/","text":"Java笔记——面向对象创建时间：2019.11.11 说明：持续更新ing Java作为一种面向对象语言。支持以下基本概念： 多态 | 继承 | 封装 | 抽象 类 | 对象 | 实例 | 方法 | 重载 “面向对象”和“面向过程”的区别： 面向过程：如 C/C++ 例子：冰箱装大象。1、打开冰箱门；2、放进大象；3、关上冰箱门。强调过程，“打开”、“存储”、“关闭”三个动作。注重过程，注重的是过程涉及的行为（即功能）。 面向对象：如 Java 将功能封装进对象，强调具备了功能的对象。 image.png 面向对象是基于面向过程的。 使用不同思想，对“冰箱装大象”的理解——&gt; 问：“人开冰箱”事件，其中人、冰箱都是实物（对象），开是动作。若使用面向对象思维，“开”的这个动作是属于“人”还是属于“冰箱”？ 答：属于“冰箱”，“人”只是调用了“冰箱”的“开”的方法（或功能），用力作用了门一下并将门打开了。 1234567891011121314人开门：名词提炼法。/*人{ 开门（门）{ 门.开（）; }}门{ 开（）{ 操作门轴; ……等等; }}*/ //截断文章 面向对象的三个特征：封装、继承、多态。 以后开发：其实就是找对象使用，没有对象就创建一个对象。 找对象，建立对象，使用对象，维护对象的关系。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java笔记——语法","slug":"Java笔记——语法","date":"2019-11-13T04:54:20.000Z","updated":"2019-11-23T02:14:35.731Z","comments":true,"path":"2019/11/13/Java笔记——语法/","link":"","permalink":"http://yoursite.com/2019/11/13/Java%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95/","excerpt":"Java笔记——语法创建时间：2019.11.11说明：持续更新ing 单引号’’中存放一个字符，不能存放字符串。双引号””中存放字符串。 Java是强类型语言。对于每一种数据都定义了明确的具体数据类型，在内存中总分配了不同的内存空间。 布尔型常量只有2个值：true、false 标识符由字母：26个，大小写；数字：0- 8；符号：$ _ 组成。 标识符不能数字开头、不能使用关键字 main不是关键字，但是是被JVM识别的名字，是程序的入口 Java中的名称规范： 包名：多单词组成，全为小写 xxxyyyy 类名接口： 多单词组成，所有单词的首字母大写 XxxYyyZzz 变量名和函数名：多单词组成时，第一个单词的首字母小写，其余首字母大写 xxxYyyZzz 常量名：所有字母都大写。每个单词用_隔开 XXX_YYY_ZZZ","text":"Java笔记——语法创建时间：2019.11.11说明：持续更新ing 单引号’’中存放一个字符，不能存放字符串。双引号””中存放字符串。 Java是强类型语言。对于每一种数据都定义了明确的具体数据类型，在内存中总分配了不同的内存空间。 布尔型常量只有2个值：true、false 标识符由字母：26个，大小写；数字：0- 8；符号：$ _ 组成。 标识符不能数字开头、不能使用关键字 main不是关键字，但是是被JVM识别的名字，是程序的入口 Java中的名称规范： 包名：多单词组成，全为小写 xxxyyyy 类名接口： 多单词组成，所有单词的首字母大写 XxxYyyZzz 变量名和函数名：多单词组成时，第一个单词的首字母小写，其余首字母大写 xxxYyyZzz 常量名：所有字母都大写。每个单词用_隔开 XXX_YYY_ZZZ //截断文章 注释，写在代码前面 对于整数：Java有三种表现形式。· 十进制：0-9，满10进1· 八进制：0-7，满8进1，用0开头表示· 十六进制：0-9，A-F或a-f（A\\a是10，B\\b是11…F\\f是15），满16进1，用0x开头表示 null常量：只有一个值null。在对象、引用数据类型时会用上。 二进制。一个字节8位0、1组合。 八进制：3位二进制位代表1位八进制位；十六进制：4位二进制位代表1位十六进制位。进制转换：进制越大，表示越短，更方便地表示数据。 二进制计算：5 + 4 = 9 十进制转二进制.png 进制之间转换.png 负数地二进制表现形式：对应的整数二进制取反加1。负数的最高位都是1 负数的二进制.png document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"博客v1.4上线","slug":"v1.4","date":"2019-11-08T14:30:21.000Z","updated":"2019-11-23T02:18:33.831Z","comments":true,"path":"2019/11/08/v1.4/","link":"","permalink":"http://yoursite.com/2019/11/08/v1.4/","excerpt":"搞了半天时间，优化一些模板上的问题后，新博客1.4版本上线了","text":"搞了半天时间，优化一些模板上的问题后，新博客1.4版本上线了 //截断文章 新增 主页动画，点击体验效果（这里） 文字跳动（menu、head中的文字均可跳动）,比如顶部的“你用走，可是我用跑”…… 新增Valine评论（可以使用表情；发送前浏览）。想用别的，但是暂时先着Valine。可以试着来骚扰我（滑稽~~ 有评论，邮件提示(还未测试)。接入Leancloud（文档）。 底部开启鼠标滑动渲染 开启“一言”api。menu中作者名（Melody Jerry）下面随机显示一句话。同时，使用文字扭曲动画。 修复 1.重写三个按钮（menu、搜索、回到顶部）的代码，现在可以正常使用了。 更新menu的Github的url 修复移动端提示证书错误的问题（移动端重定向太多次了，难怪hhh） 主页和首页分仓（也不算是修复，不知道写哪而已） 已知问题（加粗的为重要问题） menu中的“分类”、“标签”、“关于”，仍然无法正常使用（原因未知） menu的Email仍旧无法mailto 文章增加标签或类名，无法被tags或categories绑定 浏览人数、浏览次数，无法使用（接口有问题？） 文字截断，异常。（原因位置） 等待发现 未来加入 音乐控件（自动？手动？浮窗？嵌入？音源线上还是本地？） 实时颜色 加载网页时、侧栏、搜索、进度条等动画 留言板？ 友情链接？快速导航？ 嵌入播放（这个很想要，链接一些学习视频） 天气控件 等待脑洞大开 最后从早上9点搞到下午4点，午饭还没吃hh，就一直坐在电脑前。找模板中的问题代码、修改代码，还是很麻烦的。最后分享一首今天网易日推的英文歌（版权原因，没法生成外联播放器）I’ll Be There-Jess Glynne对于我的博客有问题或建议，欢迎在评论或邮件中告诉我。谢谢每一位读者。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"发布","slug":"发布","permalink":"http://yoursite.com/tags/%E5%8F%91%E5%B8%83/"}]},{"title":"使用Hexo+GitHub建站","slug":"Hexo+GitHub","date":"2019-11-07T11:24:01.000Z","updated":"2019-11-23T02:14:47.177Z","comments":true,"path":"2019/11/07/Hexo+GitHub/","link":"","permalink":"http://yoursite.com/2019/11/07/Hexo+GitHub/","excerpt":"前言： 使用CSDN平台撰写博客似乎是一件美事，只不过个人觉得太过于依赖他人平台，不如就自己搭建一个属于自己的博客。","text":"前言： 使用CSDN平台撰写博客似乎是一件美事，只不过个人觉得太过于依赖他人平台，不如就自己搭建一个属于自己的博客。 //截断文章 安装篇 一、安装 【hexo】 前的准备安装hexo前的必要工作1).安装以下两个程序： 程序 下载地址 说明 Git Git - Downloads 网速的同学，可以自行百度移步到国内镜像 Node.js Node.js - Downloads 有LTS和Current两个版本，安装 LTS 版即可 注意：关于Git和Node.js的安装可能会有问题，尤其是Git的安装。这里贴上几张安装界面的截图（来源见水印，作者GroovRain）。 image.png f3e0287f.png 774cdfb9.png 2e023781.png 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ image.png 2).配置（可以在未来部署，并非一定现在） 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 $ git config --global user.name \"your name\"` $ git config --global user.email \"your Email\"二、正式安装【hexo】 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。——官方 准备工作完成后，来安装hexo框架吧！ == 主要根据hexo官方的文档来安装hexo == ==使用 npm 安装 Hexo== $ npm install -g hexo-cli image.png 这样,【hexo】就安装完成了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo+GitHub","slug":"Hexo-GitHub","permalink":"http://yoursite.com/tags/Hexo-GitHub/"}]},{"title":"文章太长？截断！","slug":"hello-world","date":"2019-11-06T08:49:56.000Z","updated":"2019-11-23T02:26:40.646Z","comments":true,"path":"2019/11/06/hello-world/","link":"","permalink":"http://yoursite.com/2019/11/06/hello-world/","excerpt":"","text":"写的md文章太长，担心放到首页上浏览效果不好，怎么办？ 那就直接截断文章。 截断按钮文字不是通过配置文件_config.yml实现的，而是在文章内容里实现。 只要在需要被截断的文章位置加上： 1&lt;!-- more --&gt; 就可以了！ 效果就像下面的这个按钮 可以点点看哦👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}]}