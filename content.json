{"meta":{"title":"MelodyHub","subtitle":"你用走 可是我用跑","description":"","author":"Melody Jerry","url":"https://melodyjerry.github.io/blog","root":"/blog/"},"pages":[{"title":"404 Not Found","date":"2020-02-13T05:06:58.070Z","updated":"2020-02-13T05:06:58.070Z","comments":true,"path":"404.html","permalink":"https://melodyjerry.github.io/blog/404.html","excerpt":"","text":"404 Not Found 您访问的页面，呃，鬼知道跑哪去了(´･ω･`) 可能是因为： 你的节操掉光啦~~~ 手残⑨级输错了地址~~~ 或该地址已被删除~~~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-02-09T06:07:15.686Z","updated":"2020-02-09T06:07:15.686Z","comments":true,"path":"mylist/index.html","permalink":"https://melodyjerry.github.io/blog/mylist/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"关于","date":"2020-02-21T17:01:19.276Z","updated":"2020-02-21T17:01:19.276Z","comments":true,"path":"about/index.html","permalink":"https://melodyjerry.github.io/blog/about/index.html","excerpt":"","text":"关……于……？ 关于啥呢？ 关于我这个小渣渣？ 目前，MelodyJerry还只是个学生，一个不起眼的学生。 然后，然后……没了，就这样。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"分类","date":"2020-02-01T09:53:46.111Z","updated":"2020-02-01T09:53:46.111Z","comments":true,"path":"categories/index.html","permalink":"https://melodyjerry.github.io/blog/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"成果展","date":"2020-02-09T06:42:13.805Z","updated":"2020-02-09T06:42:13.805Z","comments":true,"path":"projects/index.html","permalink":"https://melodyjerry.github.io/blog/projects/index.html","excerpt":"","text":"一枚 小渣渣 ，目前啥都没有~~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"友人帐","date":"2020-02-21T16:32:57.031Z","updated":"2020-02-21T16:32:57.031Z","comments":true,"path":"friends/index.html","permalink":"https://melodyjerry.github.io/blog/friends/index.html","excerpt":"","text":"欢迎小伙伴的到来。 如果有什么推荐/想法/问题，欢迎到底下留言。 给我留言，我们互相交换友链。 友链格式 名称：XXX 【博客名/昵称均可】头像链接：https://your/avatar/picture/ 【请使用https加密协议开头】博客地址：https://your/personal/blog/ 【请使用https加密协议开头】标签：#标签 #标签2 【这里可以写希望我贴上的标签喔~ 如：Web/Java/C++】 我的博客信息在这里喔~ 名称： MelodyHub头像链接： https://i.loli.net/2020/02/10/6yndjPI2rHL94vJ.png博客地址： https://melodyjerry.gitee.io/标签： # 后端 #音乐 最后，感谢小可爱们多多支持我喔٩(๑&gt;◡&lt;๑)۶有你们的鼓励，我会一定加油滴&gt;&lt;/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"标签","date":"2020-02-01T09:54:04.836Z","updated":"2020-02-01T09:54:04.836Z","comments":true,"path":"tags/index.html","permalink":"https://melodyjerry.github.io/blog/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"藏宝阁","date":"2020-02-14T10:26:07.922Z","updated":"2020-02-14T10:26:07.922Z","comments":true,"path":"treasures/index.html","permalink":"https://melodyjerry.github.io/blog/treasures/index.html","excerpt":"","text":"欢迎来到 MelodyJerry的藏宝阁 能找到藏宝阁的入口，说明你与我有缘 以下所有资源可供你学习使用 有补充，可以留言告诉我 我不定时更新此内容 工具集 MCTool.cn在线工具 http://tool.liumingye.cn/ 兔二工具 http://www.tool2.cn/ 精准云工具 https://jingzhunyun.com/ 脚本之家 http://tools.jb51.net/ patorjk.com的线上工具集 http://patorjk.com/blog/software/ 图床 SM.MS（知名且免费） https://sm.ms/ 路过图床（免费） https://imgchr.com/ img.vim-cn.com（免费且访问速度快。） https://img.vim-cn.com/ 图片压缩 压缩图 https://www.yasuotu.com/ 建站 站长素材 http://sc.chinaz.com/ 网页游戏 2048-Game（作者：Tomotoes） https://tomotoes.com/2048/ 小霸王游戏免费玩 https://www.yikm.net/ 简历 xaoxuu制作 … Simon Ma制作 Windows 10 镜像（ISO） 微软官方 https://www.microsoft.com/zh-cn/software-download/windows10 MSDN我告诉你 https://msdn.itellyou.cn/ 网络亦是美 http://www.yishimei.cn/ UUP专制ISO https://uup.rg-adguard.net/index.php 动漫（我基本不看动漫，帮老弟存的hh）AGE动漫：https://www.agefans.tv/ Zzz Fun：http://d.mqaq.fun/ 康点动漫：http://www.zzzfun.com/ 樱花动漫：https://www.6111.tv/ Anime1：https://anime1.me/ 度盘搜索引擎 大力盘搜索（无需登录，有下载弹窗），网址：https://www.dalipan.com/ 大圣盘（无需登录，无下载弹窗），网址：https://www.dashengpan.com/ 小白盘（无需登录，有下载弹窗），网址：https://www.xiaobaipan.com/ SooHub 搜哈普（无需登录，无下载弹窗），网址：https://www.soohub.com/ bdy搜（无需登录，有下载链接跳转页面），网址：http://www.bdyso.com/ 度盘搜（Pandownload 内置），官网：http://pandownload.com/ 电子书搜索 一站式电子书搜索工具 网站非常简洁，打开官网，直接列出了包含的 70+ 电子书搜索网站。 以及网站特点，如是否需要注册、是否免费等，一目了然。 官网：http://www.soshuvip.com/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Fiddler抓包工具","slug":"Fiddler抓包工具总结","date":"2020-03-02T12:35:18.468Z","updated":"2020-02-26T13:33:03.623Z","comments":true,"path":"2020/03/02/Fiddler抓包工具总结/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/02/Fiddler%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/","excerpt":"Fiddler抓包工具总结 https://www.cnblogs.com/yyhh/p/5140852.html","text":"Fiddler抓包工具总结 https://www.cnblogs.com/yyhh/p/5140852.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"},{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"MVC：开发模式","slug":"MVC：开发模式","date":"2020-03-02T12:35:18.456Z","updated":"2020-02-27T09:37:09.310Z","comments":true,"path":"2020/03/02/MVC：开发模式/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/02/MVC%EF%BC%9A%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/","excerpt":"MVC：开发模式一、jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 二、MVC M Model，模型。JavaBean 完成具体的业务操作，如：查询数据库，封装对象 V View，视图。JSP 展示数据 C Controller，控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 三、优缺点优点 耦合性低，方便维护，可以利于分工协作 重用性高 生命周期成本低 部署快 可维护性高 有软件工程化管理 缺点 使得项目架构变得复杂，对开发人员要求高 不适合小型，中等规模的应用程序 增加系统结构和实现的复杂性 视图与控制器间的过于紧密的连接 视图对模型数据的低效率访问 一般高级的界面工具或构造器不支持模式 扩展阅读 [CSDN] MVC模式简介 [菜鸟教程] MVC 模式 [百度百科] MVC框架","text":"MVC：开发模式一、jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 二、MVC M Model，模型。JavaBean 完成具体的业务操作，如：查询数据库，封装对象 V View，视图。JSP 展示数据 C Controller，控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 三、优缺点优点 耦合性低，方便维护，可以利于分工协作 重用性高 生命周期成本低 部署快 可维护性高 有软件工程化管理 缺点 使得项目架构变得复杂，对开发人员要求高 不适合小型，中等规模的应用程序 增加系统结构和实现的复杂性 视图与控制器间的过于紧密的连接 视图对模型数据的低效率访问 一般高级的界面工具或构造器不支持模式 扩展阅读 [CSDN] MVC模式简介 [菜鸟教程] MVC 模式 [百度百科] MVC框架 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MVC","slug":"MVC","permalink":"https://melodyjerry.github.io/blog/tags/MVC/"}]},{"title":"和一个人聊天很舒服是什么感觉？","slug":"和一个人聊天很舒服是什么感觉？","date":"2020-03-02T11:58:00.000Z","updated":"2020-03-02T12:28:34.469Z","comments":true,"path":"2020/03/02/和一个人聊天很舒服是什么感觉？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/02/%E5%92%8C%E4%B8%80%E4%B8%AA%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%BE%88%E8%88%92%E6%9C%8D%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%9F%E8%A7%89%EF%BC%9F/","excerpt":"说来这文案是有问题的。和一个人聊天很舒服是什么感觉？ 当然是很舒服啊。 我也是不知道当时为什么会这么写。 不过，确实很开心 ——2020.3.2","text":"说来这文案是有问题的。和一个人聊天很舒服是什么感觉？ 当然是很舒服啊。 我也是不知道当时为什么会这么写。 不过，确实很开心 ——2020.3.2 运气 彩 蛋 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"一熟悉的陌生人","slug":"一熟悉的陌生人","date":"2020-02-29T11:26:11.000Z","updated":"2020-03-02T12:24:51.823Z","comments":true,"path":"2020/02/29/一熟悉的陌生人/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/29/%E4%B8%80%E7%86%9F%E6%82%89%E7%9A%84%E9%99%8C%E7%94%9F%E4%BA%BA/","excerpt":"昨晚 和一个女孩在聊天，聊到了很多。聊着聊着，聊到了一些事情让我联想到一些经历。 后来，和她说了一些奇怪的话。想哭，早早结束了一日的聊天，自己静了静。 一觉醒来，却收到了她的另一大段话。看完的那刻，我觉得这是个好女孩。很可爱的女孩。 对她，我不知道如何去定位她。彼此都说了一些奇怪但又是奇妙的话。 硬要是用一个词来形容，我只能想到“熟悉的陌生人”。 陌生是此前从未有过任何交流，熟悉是原来都知道对方还有着很多相似的地方。 这么些天来，对她，心跳有过那么几次起伏跌落。 有那么几个时候觉得她是我想找的那个人，但可能是吧也可能不是…… 于我，生活和情感，是我目前觉得最难的两个了吧。——2020.2.29随笔 选自聊天记录的其中一张","text":"昨晚 和一个女孩在聊天，聊到了很多。聊着聊着，聊到了一些事情让我联想到一些经历。 后来，和她说了一些奇怪的话。想哭，早早结束了一日的聊天，自己静了静。 一觉醒来，却收到了她的另一大段话。看完的那刻，我觉得这是个好女孩。很可爱的女孩。 对她，我不知道如何去定位她。彼此都说了一些奇怪但又是奇妙的话。 硬要是用一个词来形容，我只能想到“熟悉的陌生人”。 陌生是此前从未有过任何交流，熟悉是原来都知道对方还有着很多相似的地方。 这么些天来，对她，心跳有过那么几次起伏跌落。 有那么几个时候觉得她是我想找的那个人，但可能是吧也可能不是…… 于我，生活和情感，是我目前觉得最难的两个了吧。——2020.2.29随笔 选自聊天记录的其中一张 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"HTTP案例：文件下载","slug":"HTTP案例：文件下载","date":"2020-02-24T14:10:12.000Z","updated":"2020-02-24T14:18:13.247Z","comments":true,"path":"2020/02/24/HTTP案例：文件下载/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/24/HTTP%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/","excerpt":"结束HTTP的学习后，记录一份案例学习的笔记。 需求 页面显示超链接 点击超链接后弹出下载提示框 完成图片文件下载","text":"结束HTTP的学习后，记录一份案例学习的笔记。 需求 页面显示超链接 点击超链接后弹出下载提示框 完成图片文件下载 分析 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示。如果不能解析，则弹出下载提示框。不不满足需求。 任何资源都必须弹出下载提示框。 使用响应头设置资源的打开方式： content-disposition:attachment;filename=xxx 步骤一、定义页面，编辑超链接href属性，并指向Servlet，传递资源名称filename 二、定义Servlet 获取文件名称 使用字节输入流加载文件进内存 指定response的响应头： content-disposition:attachment;filename=xxx 将数据写出到response输出流 代码 web下New一个download.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;文件下载&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"/day15/img/1.jpg\"&gt;图片1&lt;/a&gt; &lt;hr&gt; &lt;a href=\"/day15/downloadServlet?filename=1.jpg\"&gt;图片1&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 包cn.itcast.web.download下New一个DownloadServlet.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.itcast.web.download;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;/** * @Classname DownloadServlet * @Description 文件下载 * @Date 2020/2/24 下午 5:37 * @Created by jerry */@WebServlet(\"/downloadServlet\")public class DownloadServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求参数，即文件名称 String filename = request.getParameter(\"filename\"); //2.使用字节输入流加载进内存 //2-1.找到文件的服务器路径 ServletContext servletContext = this.getServletContext(); String realPath = servletContext.getRealPath(\"/img/\" + filename);//服务器路径 //2-2.用字节输入流关联 FileInputStream fileInputStream = new FileInputStream(realPath); //3.设置response的响应头 //3-1.设置响应头类型：content-type String minetype = servletContext.getMimeType(filename); response.setHeader(\"content-type\", minetype); //3-2.设置响应头打开方式：content-disposition response.setHeader(\"content-disposition\",\"attachment;filename=\"+filename); //4.将输入流写到输出流中 ServletOutputStream servletOutputStream = response.getOutputStream(); byte[] buff = new byte[1024 * 8]; //作为缓冲区 int lenght = 0; //读取 while ((lenght = fileInputStream.read(buff)) != -1){ //写入 servletOutputStream.write(buff, 0, lenght); } servletOutputStream.close(); //可以不关闭输出流 fileInputStream.close(); //建议关闭输出流，释放资源 } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 演示 思考/分析 中文文件问题 解决思路 获取客户端使用的浏览器版本信息 根据不同的版本信息，设置filename的编码方式不同 详细见 【视频】 ，里面有详解。 ****** 与本笔记相关的资源： 链接: https://pan.baidu.com/s/1q_B3k1LzQwxlslEOdpeDWQ 提取码: dx5u document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"HTTP中的ServletContext对象","slug":"HTTP中的ServletContext对象","date":"2020-02-24T09:08:11.000Z","updated":"2020-02-24T10:16:03.100Z","comments":true,"path":"2020/02/24/HTTP中的ServletContext对象/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/24/HTTP%E4%B8%AD%E7%9A%84ServletContext%E5%AF%B9%E8%B1%A1/","excerpt":"ServletContext对象 ServletContext对象范围：所有用户所有请求的数据 谨慎使用。所有用户可以操控它，不太安全；而且，它的生命周期长：服务器始到终，存储的数据多了，会造成内存的压力。 概念 代表整个web应用，可以和程序的容器（服务器）来通信（交互数据） 获取 通过request对象获取 调用request.getServletContext(); 通过HttpServlet获取 调用this.getServletContext(); 注意：2个调用方法获取到的ServletContext都是一样的。因此，更多的时候会使用this.getServletContext(); 功能 获取mine类型 域对象：共享数据 获取文件的真实路径(服务器路径)","text":"ServletContext对象 ServletContext对象范围：所有用户所有请求的数据 谨慎使用。所有用户可以操控它，不太安全；而且，它的生命周期长：服务器始到终，存储的数据多了，会造成内存的压力。 概念 代表整个web应用，可以和程序的容器（服务器）来通信（交互数据） 获取 通过request对象获取 调用request.getServletContext(); 通过HttpServlet获取 调用this.getServletContext(); 注意：2个调用方法获取到的ServletContext都是一样的。因此，更多的时候会使用this.getServletContext(); 功能 获取mine类型 域对象：共享数据 获取文件的真实路径(服务器路径) Demo12345678910111213141516171819202122232425262728293031323334353637package cn.itcast.web.servletcontext;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/servletContextDemo1\")public class ServletContextDemo1 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext对象获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext(); */ //1. 通过request对象获取 ServletContext context1 = request.getServletContext(); //2. 通过HttpServlet获取 ServletContext context2 = this.getServletContext(); System.out.println(context1); System.out.println(context2); System.out.println(context1 == context2);//true } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 控制台输出👇 1.获取mine类型 格式：大类型/小类型 比如，text/html 、 image/jpeg 等等 mine类型 在互联网通信过程中定义的一种文件数据类型 调用方法 String getMimeType(String file) Demo12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.itcast.web.servletcontext;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/servletContextDemo2\")public class ServletContextDemo2 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext功能： 1. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) 2. 域对象：共享数据 3. 获取文件的真实(服务器)路径 */ //2. 通过HttpServlet获取 ServletContext context = this.getServletContext(); //3. 定义文件名称 String filename = \"a.jpg\";//image/jpeg //4.获取MIME类型 String mimeType = context.getMimeType(filename); System.out.println(mimeType); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 2.域对象 共享数据 ServletContext对象范围：所有用户所有请求的数据 调用方法 设置数据 setAttribute(String name,Object value) 获取数据 getAttribute(String name) removeAttribute(String name) DemoServletContextDemo3.java 1234567891011121314151617181920212223242526272829303132333435package cn.itcast.web.servletcontext;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/servletContextDemo3\")public class ServletContextDemo3 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext功能： 1. 获取MIME类型： 2. 域对象：共享数据 3. 获取文件的真实(服务器)路径 */ //2. 通过HttpServlet获取 ServletContext context = this.getServletContext(); //设置数据 context.setAttribute(\"msg\",\"haha\"); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} ServletContextDemo4.java 1234567891011121314151617181920212223242526272829303132333435package cn.itcast.web.servletcontext;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/servletContextDemo4\")public class ServletContextDemo4 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext功能： 1. 获取MIME类型： 2. 域对象：共享数据 3. 获取文件的真实(服务器)路径 */ //2. 通过HttpServlet获取 ServletContext context = this.getServletContext(); //获取数据 Object msg = context.getAttribute(\"msg\"); System.out.println(msg); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 3.获取文件的真实路径(服务器路径) 调用方法 String getRealPath(String path) Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445package cn.itcast.web.servletcontext;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;@WebServlet(\"/servletContextDemo5\")public class ServletContextDemo5 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext功能： 1. 获取MIME类型： 2. 域对象：共享数据 3. 获取文件的真实(服务器)路径 */ // 通过HttpServlet获取 ServletContext context = this.getServletContext(); // 获取文件的服务器路径 String b = context.getRealPath(\"/b.txt\");//工作空间(IDEA)web目录下资源访问 System.out.println(b); // File file = new File(realPath); String c = context.getRealPath(\"/WEB-INF/c.txt\");//工作空间(IDEA)WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(\"/WEB-INF/classes/a.txt\");//工作空间(IDEA)src目录下的资源访问 System.out.println(a); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 项目空间、工作空间的区别：视频 进度条【04:52】 注意： 将来配置文件/资源文件的放置的路径不一样，要会写路径的字符串写法。 src目录的资源路径可以使用ClassLoader（类加载器，不能获取web目录的路径） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"热部署-IDEA实现不用重启Tomcat服务便可自动更新","slug":"热部署-IDEA实现不用重启Tomcat服务便可自动更新","date":"2020-02-24T06:36:53.000Z","updated":"2020-02-24T06:21:47.751Z","comments":true,"path":"2020/02/24/热部署-IDEA实现不用重启Tomcat服务便可自动更新/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/24/%E7%83%AD%E9%83%A8%E7%BD%B2-IDEA%E5%AE%9E%E7%8E%B0%E4%B8%8D%E7%94%A8%E9%87%8D%E5%90%AFTomcat%E6%9C%8D%E5%8A%A1%E4%BE%BF%E5%8F%AF%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/","excerpt":"Tomcat的热部署👇 一、配置Tomcat的Deployment处的“+”的Artifacts是war exploded形式： _:war exploded 作用：展开部署(相当于将资源文件进行展开后进行部署)_:war 作用：发布模式,这是先打成war包,再部署 二、修改Run/Debug Configurations On ‘Update’ Action：update class and resources On frame deactivation：update class and resources 三、浏览器F12，勾选上disable cache 四、以上都不行，那就到Plugins安装JRebel插件","text":"Tomcat的热部署👇 一、配置Tomcat的Deployment处的“+”的Artifacts是war exploded形式： _:war exploded 作用：展开部署(相当于将资源文件进行展开后进行部署)_:war 作用：发布模式,这是先打成war包,再部署 二、修改Run/Debug Configurations On ‘Update’ Action：update class and resources On frame deactivation：update class and resources 三、浏览器F12，勾选上disable cache 四、以上都不行，那就到Plugins安装JRebel插件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"IDEA设置方法参数列表类型自动提示","slug":"IDEA设置方法参数列表类型自动提示","date":"2020-02-23T14:36:53.000Z","updated":"2020-02-23T14:33:20.117Z","comments":true,"path":"2020/02/23/IDEA设置方法参数列表类型自动提示/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/23/IDEA%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA/","excerpt":"期望有这样的参数列表提示👇 File-Settings打开设置(或者ctrl +Alt+S)👇","text":"期望有这样的参数列表提示👇 File-Settings打开设置(或者ctrl +Alt+S)👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"BeanUtils的基本使用","slug":"BeanUtils的基本使用","date":"2020-02-23T08:36:53.000Z","updated":"2020-02-23T10:10:21.298Z","comments":true,"path":"2020/02/23/BeanUtils的基本使用/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/23/BeanUtils%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"在《HTTP案例学习：用户登录》的学习中，使用到BeanUtils。 案例中只涉及到封装username、password两个对象，但是实际上的用户登录界面，有十几个数据对象需要封装。 按原来的方式，是非常麻烦的。期望能够一次把所有参数获取到，并且通过一个方法，一次把所有数据封装成一个对象。 BeanUtils，一个工具类，简化数据封装 这里专门挑出来，做一份简单的笔记。 配合【教学视频】、【BeanUtils工具类常用方法】 食用更佳。","text":"在《HTTP案例学习：用户登录》的学习中，使用到BeanUtils。 案例中只涉及到封装username、password两个对象，但是实际上的用户登录界面，有十几个数据对象需要封装。 按原来的方式，是非常麻烦的。期望能够一次把所有参数获取到，并且通过一个方法，一次把所有数据封装成一个对象。 BeanUtils，一个工具类，简化数据封装 这里专门挑出来，做一份简单的笔记。 配合【教学视频】、【BeanUtils工具类常用方法】 食用更佳。 我们将原来写的代码， 1234567//2.获取请求参数String username = req.getParameter(\"username\");String password = req.getParameter(\"password\");//3.封装user对象User loginUser = new User();loginUser.setUsername(username);loginUser.setPassword(password); 使用BeanUtils工具类进行封装， 123456789101112//2.获取所有请求参数Map&lt;String, String[]&gt; map = req.getParameterMap();//3.创建User对象User loginUser = new User();//3-2.使用BeanUtils封装try { BeanUtils.populate(loginUser,map);} catch (IllegalAccessException e) { e.printStackTrace();} catch (InvocationTargetException e) { e.printStackTrace();} 会发现只用简单几行代码就完成了封装，而不用和之前一样分别对每个数据进行封装。 BeanUtils 工具类，简化数据封装 用于封装JavaBean的 JavaBean：标准(简单)的Java类 概念 JavaBean 成员变量 属性：setter和getter方法截取后的产物 例如：getUsername() –&gt; Username–&gt; username（大多数下，名字一样） JavaBean 标准的Java类 一般放在domain等package下 功能 封装数据 要求 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共setter和getter方法 属性 setter和getter方法截取后的产物 例如：getUsername() –&gt; Username–&gt; username（大多数下，名字一样） 调用方法 setProperty() 设置属性值 getProperty() 获取属性值 populate(Object obj, Map map) 将map集合的键值对信息，封装到对应的JavaBean对象中 Demo配合 《HTTP案例学习：用户登录》 ，现在New一个BeanUtils.java 123456789101112131415161718192021222324package cn.itcast.test;import cn.itcast.domain.User;import org.apache.commons.beanutils.BeanUtils;import org.junit.Test;import java.lang.reflect.InvocationTargetException;public class BeanUtilsTest { @Test public void test(){ User user = new User(); try { BeanUtils.setProperty(user,\"username\",\"zhangsan\"); System.out.println(user); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } }} 控制台输出： 扩展后来看的一篇博客 【BeanUtils工具类常用方法】，觉得写的很不错，一起记录在这里。 相关资料【教学视频】：https://www.bilibili.com/video/av70420291?p=143 【BeanUtils工具类常用方法】：https://blog.csdn.net/wzc1991520/article/details/80176679 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"html中form表单的action路径的写法","slug":"html中form表单的action路径的写法","date":"2020-02-23T07:36:53.000Z","updated":"2020-02-23T07:57:34.993Z","comments":true,"path":"2020/02/23/html中form表单的action路径的写法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/23/html%E4%B8%ADform%E8%A1%A8%E5%8D%95%E7%9A%84action%E8%B7%AF%E5%BE%84%E7%9A%84%E5%86%99%E6%B3%95/","excerpt":"在 《HTTP案例学习：用户登录》 中提及到html中form表单的action路径的写法 是 虚拟目录+Servlet的资源路径 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/day14_test/loginServlet\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码:&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 先记住，日后还会涉及到的。","text":"在 《HTTP案例学习：用户登录》 中提及到html中form表单的action路径的写法 是 虚拟目录+Servlet的资源路径 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/day14_test/loginServlet\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码:&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 先记住，日后还会涉及到的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"IDEA添加jar包的三种方式(小结)","slug":"IDEA中单元测试@Test使用","date":"2020-02-23T04:36:53.000Z","updated":"2020-02-23T05:12:20.399Z","comments":true,"path":"2020/02/23/IDEA中单元测试@Test使用/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/23/IDEA%E4%B8%AD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95@Test%E4%BD%BF%E7%94%A8/","excerpt":"相关文章： https://blog.csdn.net/QQljh123456/article/details/81583786","text":"相关文章： https://blog.csdn.net/QQljh123456/article/details/81583786 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"HTTP响应信息数据-Response","slug":"HTTP响应信息数据-Response","date":"2020-02-22T13:15:01.000Z","updated":"2020-02-24T06:39:57.048Z","comments":true,"path":"2020/02/22/HTTP响应信息数据-Response/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/22/HTTP%E5%93%8D%E5%BA%94%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE-Response/","excerpt":"接着前面两篇博文 《HTTP：超文本传输协议》 、 《HTTP请求信息数据 - Request》 的学习。 现在记录关于 HTTP响应信息数据-Response 的笔记。 响应信息数据 格式 Servlet类中service()方法的参数ServletResponse Response在一次响应结束后，自动被销毁，其输出流也会自动被关闭。 字符串数据，比如： 12345678910111213HTTP/1.1 200 OKContent-Type: text/html;charset=UTF-8Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt;&lt;/html&gt;","text":"接着前面两篇博文 《HTTP：超文本传输协议》 、 《HTTP请求信息数据 - Request》 的学习。 现在记录关于 HTTP响应信息数据-Response 的笔记。 响应信息数据 格式 Servlet类中service()方法的参数ServletResponse Response在一次响应结束后，自动被销毁，其输出流也会自动被关闭。 字符串数据，比如： 12345678910111213HTTP/1.1 200 OKContent-Type: text/html;charset=UTF-8Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt;&lt;/html&gt; 响应行 格式：协议/版本 响应状态码 状态码描述 响应状态码 服务器告诉客户端浏览器本次请求和响应的一个状态。 特点 状态码都是3位数字 分类 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx状态码 2xx：成功。代表： 200 3xx：重定向。代表： 302：重定向 304：访问缓存 4xx：客户端错误。代表： 403：错误是一种在网站访问过程中，常见的错误提示，表示资源不可用。服务器理解客户的请求，但拒绝处理它，通常由于服务器上文件或目录的权限设置导致的WEB访问错误。 404：请求路径没有对应的资源 405：请求方式没有对应的doXxx方法 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头 格式：响应头名称 ：值 常见的响应头 Content-Type Content-disposition Content-Type 服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition 服务器告诉客户端以什么格式打开响应体数据 其值： in-line：默认值，在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体。涉及文件下载等功能。 响应空行 就是一个空行（空白行） 作用：分割响应头和响应体 响应体 传输的数据 文件、HTML网页源码等等。比如， 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt;&lt;/html&gt; 案例1：重定向 重定向：资源跳转的方式 步骤 ResponseDemo1.java 12345678910111213141516171819202122232425262728293031323334353637383940package cn.itcast.web.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 重定向 */@WebServlet(\"/responseDemo1\")public class ResponseDemo1 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo1........\"); //访问/responseDemo1，会自动跳转到/responseDemo2资源 /* //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(\"location\",\"/day15/responseDemo2\");*/ //演示，不能使用request对象来共享数据 request.setAttribute(\"msg\",\"response\"); //动态获取虚拟目录 String contextPath = request.getContextPath(); //简单的重定向方法 response.sendRedirect(contextPath+\"/responseDemo2\"); //response.sendRedirect(\"http://www.itcast.cn\"); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} ResponseDemo2.java 12345678910111213141516171819202122232425package cn.itcast.web.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/responseDemo2\")public class ResponseDemo2 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo2222222........\"); //演示，不能使用request对象来共享数据 Object msg = request.getAttribute(\"msg\"); System.out.println(msg); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 演示： 特点 重定向的特点：redirect 地址栏发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。不能使用request对象来共享数据 转发的特点：forward 转发地址栏路径不变 转发只能访问当前服务器下的资源 转发是一次请求，可以使用request对象来共享数据 forward 和 redirect 区别 路径写法分类 相对路径 绝对路径 相对路径 通过相对路径不可以确定唯一资源 如：./index.html 不以/开头，以.开头路径 规则 找到当前资源和目标资源之间的相对位置关系 ./：当前目录 ../：后退一级目录 绝对路径(JSP时推荐使用) 通过绝对路径可以确定唯一资源 如：http://localhost/day15/responseDemo2 中 /day15/responseDemo2 以/开头的路径 JSP时推荐使用 规则 判断定义的路径是给谁用的？判断请求将来从哪儿发出 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) 建议动态获取虚拟目录：request.getContextPath() 重定向是客户端浏览器进行的 &lt;a&gt;、 &lt;form&gt;等要重定向… 给服务器使用：不需要加虚拟目录 比如：转发时的路径request.getRequestDispatcher(\"/responseDemo2\").forward(request,response); 案例2：服务器输出字符数据到浏览器步骤 获取字符输出流 输出数据 演示 ResponseDemo4.java 12345678910111213141516171819202122232425262728293031323334package cn.itcast.web.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(\"/responseDemo4\")public class ResponseDemo4 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取流对象之前，设置流的默认编码：ISO-8859-1 设置为：GBK // response.setCharacterEncoding(\"utf-8\"); //告诉浏览器，服务器发送的消息体数据的编码。建议浏览器使用该编码解码 //response.setHeader(\"content-type\",\"text/html;charset=utf-8\"); //简单的形式，设置编码 response.setContentType(\"text/html;charset=utf-8\"); //1.获取字符输出流 PrintWriter pw = response.getWriter(); //2.输出数据 pw.write(\"&lt;h1&gt;hello response&lt;/h1&gt;\"); pw.write(\"&lt;br&gt;你好啊啊啊 response\"); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 演示 注意乱码问题(编解码问题) PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 设置该流的默认编码 告诉浏览器响应体使用的编码 简单的形式，设置编码，是在获取流之前设置 response.setContentType(\"text/html;charset=utf-8\"); Demo上面ResponseDemo4.java文件中 12345678//获取流对象之前，设置流的默认编码：ISO-8859-1 设置为：GBK// response.setCharacterEncoding(\"utf-8\");//告诉浏览器，服务器发送的消息体数据的编码。建议浏览器使用该编码解码//response.setHeader(\"content-type\",\"text/html;charset=utf-8\");//简单的形式，设置编码response.setContentType(\"text/html;charset=utf-8\"); 案例3：服务器输出字节数据到浏览器步骤 获取字符输出流 输出数据 演示 ResponseDemo5.java 12345678910111213141516171819202122232425package cn.itcast.web.servlet;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/responseDemo5\")public class ResponseDemo5 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\"text/html;charset=utf-8\"); //1.获取字节输出流 ServletOutputStream sos = response.getOutputStream(); //2.输出数据 sos.write(\"你好\".getBytes(\"utf-8\")); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 演示 案例4：验证码 本质：图片 目的：防止恶意表单注册 步骤 创建一对象，在内存中代表一个图片（验证码图片对象） 美化图片 将图片输出到页面展示 演示 New一个CheckCode.java 12345678910111213141516171819202122232425262728293031323334353637383940package cn.itcast.web.servlet;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.image.BufferedImage;import java.io.IOException;/** * @Classname CheckCode * @Description TODO * @Date 2020/2/23 下午 10:20 * @Created by jerry */@WebServlet(\"/checkCodeServlet\")public class CheckCode extends HttpServlet { @Override protected void doPost(HttpServletRequest requeste, HttpServletResponse response) throws ServletException, IOException { int width = 100; int height = 50; //1.创建一对象，在内存中代表一个图片（验证码图片对象） BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2. 美化图片 //3.将图片输出到页面展示 ImageIO.write(image, \"jpg\", response.getOutputStream()); } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 没有美化前 美化图片 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package cn.itcast.web.servlet;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;/** * 验证码 */@WebServlet(\"/checkCodeServlet\")public class CheckCode extends HttpServlet { @Override protected void doPost(HttpServletRequest requeste, HttpServletResponse response) throws ServletException, IOException { int width = 100; int height = 50; //1.创建一对象，在内存中代表一个图片（验证码图片对象） BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2. 美化图片 //2-1.填充背景色 Graphics g = image.getGraphics(); //画笔对象，可画/填充 g.setColor(Color.pink); //设置画笔颜色 g.fillRect(0,0,width,height); //g.fill3DRect(0, 0, width, height, true); //2-2.画边框 g.setColor(Color.BLUE); g.drawRect(0, 0, width-1, height-1); //2-3.随机字符（全部） String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789\"; //生产随机角标 Random ran = new Random(); //2-3.写验证码 for (int i = 1; i &lt;= 4; i++) { int index = ran.nextInt(str.length()); //获取字符 char ch = str.charAt(index); //随机字符 //写入字符 g.drawString(ch+\"\", width/5*i , height/2); } /*g.drawString(\"a\", 20, 25); g.drawString(\"2\", 33, 15); g.drawString(\"4\", 72, 35); g.drawString(\"g\", 80, 20);*/ //2-4.画出干扰线 g.setColor(Color.green); //随机生成坐标点 for (int i = 0; i &lt; 10; i++) { int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1, y1, x2, y2); } //3.将图片输出到页面展示 ImageIO.write(image, \"jpg\", response.getOutputStream()); } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 美化后 在页面中配合注册表单等使用验证码 点击超链接或图片后，直接加载随机验证码 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;验证码&lt;/title&gt; &lt;script&gt; /**分析： * 点击超链接/图片，需要换一张 * 1.给超链接/图片绑定单击事件 * 2.重新设置图片的src属性值 */ window.onload = function () { //1.获取图片对象 var img = document.getElementById(\"checkCode\"); var a = document.getElementById(\"change\"); //2.绑定单击事件 img.onclick = function () { //获取时间戳 var date = new Date().getTime(); //毫秒值 //利用时间戳，浏览器访问就一定不会去访问缓存了。每一时刻的链接都是不一样的。 img.src = \"/day15/checkCodeServlet?\" + date; } a.onlick = function () { var date = new Date().getTime(); a.href = \"/day15/checkCodeServlet?\" + date; } } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=\"checkCode\" src=\"/day15/checkCodeServlet\" /&gt;&lt;br&gt; &lt;a id=\"change\" href=\"\"&gt;看不清，换一张？&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 演示 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"创建@Test测试Druid连接池时的问题","slug":"创建@Test测试Druid连接池时的问题","date":"2020-02-22T12:55:12.000Z","updated":"2020-02-23T07:28:32.757Z","comments":true,"path":"2020/02/22/创建@Test测试Druid连接池时的问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/22/%E5%88%9B%E5%BB%BA@Test%E6%B5%8B%E8%AF%95Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"记录学习 《HTTP案例学习：用户登录》 时候遇到的一些问题","text":"记录学习 《HTTP案例学习：用户登录》 时候遇到的一些问题 IDEA run之后，控制台输出一堆问题： 123456789二月 23, 2020 1:30:34 下午 com.alibaba.druid.pool.DruidDataSource error严重: init datasource errorcom.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server.二月 23, 2020 1:30:34 下午 com.alibaba.druid.pool.DruidDataSource error严重: dataSource init error二月 23, 2020 1:30:34 下午 com.alibaba.druid.pool.DruidDataSource info信息: {dataSource-1} inited 我估计是MySQL版本的问题，因为从我开始学习MySQL来安装的是8.0，学习期间就遇到很多问题，不过都能逐一解决。 但是这次我果断直接降级到5.7。 不过，降级后还是被提示错误 12345678910111213141516171819202122232425262728293031323334353637383940二月 23, 2020 2:41:58 下午 com.alibaba.druid.pool.DruidDataSource info信息: {dataSource-1} inited二月 23, 2020 2:41:58 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions信息: Loading XML bean definitions from class path resource [org/springframework/jdbc/support/sql-error-codes.xml]二月 23, 2020 2:41:58 下午 org.springframework.jdbc.support.SQLErrorCodesFactory &lt;init&gt;信息: SQLErrorCodes loaded: [DB2, Derby, H2, HSQL, Informix, MS-SQL, MySQL, Oracle, PostgreSQL, Sybase, Hana]......................................org.springframework.dao.EmptyResultDataAccessException: Incorrect result size: expected 1, actual 0 at org.springframework.dao.support.DataAccessUtils.requiredSingleResult(DataAccessUtils.java:74) at org.springframework.jdbc.core.JdbcTemplate.queryForObject(JdbcTemplate.java:777) at cn.itcast.Dao.UserDao.login(UserDao.java:25) at cn.itcast.test.UserDaoTest.testLogin(UserDaoTest.java:23) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)Process finished with exit code -1 分析了信息: SQLErrorCodes loaded: [DB2, Derby, H2, HSQL, Informix, MS-SQL, MySQL, Oracle, PostgreSQL, Sybase, Hana]， 信息是提示sql语句错了。 仔细检查一下sql语句，单纯的去 cmd 中用自己的sql语句执行一下检查问题。 果然是sql语句的问题。 剩下的错误提示，是数据库的字段的问题。 1234//正确loginuser.setUsername(\"superbaby\");//错误，字段少了个yloginuser.setUsername(\"superbab\"); 再次run，这次得到如期的结果。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Druid","slug":"Druid","permalink":"https://melodyjerry.github.io/blog/tags/Druid/"}]},{"title":"HTTP案例学习：用户登录&验证码","slug":"HTTP案例学习：用户登录&验证码","date":"2020-02-22T12:44:12.000Z","updated":"2020-02-27T14:37:56.760Z","comments":true,"path":"2020/02/22/HTTP案例学习：用户登录&验证码/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/22/HTTP%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95&%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"本笔记包括两个案例，分别是用户登录、验证码。","text":"本笔记包括两个案例，分别是用户登录、验证码。 案例：用户登录接着 《HTTP：超文本传输协议》 、 《HTTP请求信息数据 - Request》 的学习，现在记录一份案例学习。 用户需求 编写 login.html 登录页面，并且有 username &amp; password 两个输入框 使用 Druid 数据库连接池技术，操作 MySQL，day14数据库中user表 使用 JdbcTemplate 技术封装 JDBC 登录成功跳转到 SuccessServlet 展示：登录成功！用户名,欢迎您 登录失败跳转到 FailServlet 展示：登录失败，用户名或密码错误 分析 步骤 创建项目，导入html页面，配置文件，jar包 创建数据库环境 创建包cn.itcast.domain,创建类User 创建包cn.itcast.util,编写工具类JDBCUtils 创建包cn.itcast.dao,创建类UserDao,提供login方法 编写cn.itcast.web.servlet.LoginServlet类 编写FailServlet和SuccessServlet类 BeanUtils工具类，简化数据封装 一、创建项目，导入html页面，配置文件，jar包 新建Module web文件夹下创建login.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/day14_test/loginServlet\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码:&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 这里的login.html中form表单的action路径的写法：虚拟目录+Servlet的资源路径是虚拟目录+Servlet的资源路径 关于 《html中form表单的action路径的写法》 将Druid配置文件druid.properties导入到src文件下 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql:///day14username=rootpassword=rootinitialSize=5maxActive=10maxWait=3000 导入jar包到Web的WEB-INF文件中 在项目的web文件夹下创建文件夹WEB-INF，将lib文件夹粘贴进去 并把jar包加入到工作空间里 二、创建数据库环境 打开Navicat，创建数据库和数据表 12345678CREATE DATABASE day14;USE day14;CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL); 插入一条记录 三、创建包cn.itcast.domain,创建类User 右键项目的src文件，New一个包cn.itcast.domain 在包下，New一个User.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.itcast.domain;/** * 用户的实体类 */public class User { private int id; private String username; private String password; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; }} 四、创建包cn.itcast.util,编写工具类JDBCUtils New一个包cn.itcast.util New一个JDBCUtils.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.itcast.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.ConnectionEvent;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * JDBC的工具类 使用Durid连接池 */public class JDBCUtils { private static DataSource ds; static { try { //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\"); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static DataSource getDataSource(){ return ds; } /** * 获取连接池Connection对象 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); }} 五、创建包cn.itcast.dao,创建类UserDao,提供login方法 New一个包cn.itcast.dao New一个UserDao.java 123456789101112131415161718192021222324252627282930313233343536package cn.itcast.Dao;import cn.itcast.domain.User;import cn.itcast.util.JDBCUtils;import com.alibaba.druid.util.JdbcUtils;import org.springframework.dao.DataAccessException;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;/** * 操作数据库中User表的类 */public class UserDao { // 声明JDBCTemplate对象公用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return User包含用户全部数据；没有查询到，返回null */ public User login(User loginUser) { try { //1.编写SQL String sql = \"select * from user where username = ? and password = ?\"; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; } catch (DataAccessException e) { e.printStackTrace(); // 记录日志，后期写入文件里，不会总在控制台打印 return null; } }} 测试一下UserDao New一个包cn.itcast.test，New一个UserDaoTest.java 123456789101112131415161718192021222324252627package cn.itcast.test;import cn.itcast.Dao.UserDao;import cn.itcast.domain.User;import org.junit.Test;/** * @Classname UserDaoTest * @Description TODO * @Date 2020/2/23 下午 1:00 * @Created by jerry */public class UserDaoTest { @Test public void testLogin(){ User loginuser = new User(); loginuser.setUsername(\"superbaby\"); loginuser.setPassword(\"123\"); UserDao dao = new UserDao(); User user = dao.login(loginuser); System.out.println(user); }} run后，控制台输出 这个@Test部分，遇到了一些问题，就顺便记录在《创建@Test测试Druid连接池时的问题》 里面。 六、编写cn.itcast.web.servlet.LoginServlet类 New一个包cn.itcast.web.servlet New一个LoginServlet.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.itcast.web.servlet;import cn.itcast.Dao.UserDao;import cn.itcast.domain.User;import cn.itcast.test.UserDaoTest;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/loginServlet\")public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.设置编码 req.setCharacterEncoding(\"utf-8\"); //2.获取请求参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(\"username\"); loginUser.setPassword(\"password\"); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //真正获取到的user //5.判断user if(user == null){ //登录失败 req.getRequestDispatcher(\"/failServlet\").forward(req,resp); //转发 }else{ //登录成功 //存储数据 req.setAttribute(\"user\",user); //转发 req.getRequestDispatcher(\"/successServlet\").forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); }} 七、编写FailServlet和SuccessServlet类 New一个FailServlet.java 12345678910111213141516171819202122232425262728293031323334package cn.itcast.web.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Classname failServlet * @Description TODO * @Date 2020/2/23 下午 3:38 * @Created by jerry */@WebServlet(\"/failServlet\")public class FailServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //给页面写一句话 //设置页面编码 response.setContentType(\"text/html;charset=utf-8\"); //输出 response.getWriter().write(\"登录失败，用户名或密码错误\"); }} New一个SuccessServlet.java 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast.web.servlet;import cn.itcast.domain.User;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Classname successServlet * @Description TODO * @Date 2020/2/23 下午 3:38 * @Created by jerry */@WebServlet(\"/successServlet\")public class SuccessServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取request域中共享的user对象 User user = (User) request.getAttribute(\"user\"); if(user != null){ //给页面写一句话 //设置页面编码 response.setContentType(\"text/html;charset=utf-8\"); //输出 response.getWriter().write(\"登录失败，用户名或密码错误\"); } }} 八、测试浏览器访问：http://localhost/day14_test/login.html 九、BeanUtils工具类，简化数据封装 在LoginServlet.java中使用BeanUtils工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package cn.itcast.web.servlet;import cn.itcast.Dao.UserDao;import cn.itcast.domain.User;import cn.itcast.test.UserDaoTest;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(\"/loginServlet\")public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.设置编码 req.setCharacterEncoding(\"utf-8\"); /*//2.获取请求参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password);*/ //2.获取所有请求参数 Map&lt;String, String[]&gt; map = req.getParameterMap(); //3.创建User对象 User loginUser = new User(); //3-2.使用BeanUtils封装 try { BeanUtils.populate(loginUser,map); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //真正获取到的user //5.判断user if(user == null){ //登录失败 req.getRequestDispatcher(\"/failServlet\").forward(req,resp); //转发 }else{ //登录成功 //存储数据 req.setAttribute(\"user\",user); //转发 req.getRequestDispatcher(\"/successServlet\").forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); }} 关于BeanUtils的更多使用，看下一篇笔记《BeanUtils的基本使用》 。 与本笔记相关的资源： 链接: https://pan.baidu.com/s/1pV1ArOotLcoH9mKYABEm5g 提取码: w9h8 案例：验证码接着 《JSP&amp;Cookie&amp;Session技术》 的学习， 现在记录一份案例的学习。 用户需求 访问带有验证码的登录页面login.jsp 用户输入用户名，密码以及验证码， 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 如果验证码输入有误，跳转登录页面，提示：验证码错误 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 分析 设置request编码 获取参数 获取生成的验证码 将用户信息封装到User对象 判断程序生成的验证码和用户输入的验证码是否一致。从session中获取程序生成的验证码 一致：再判断用户名和密码是否正确 正确： 1.登陆成功 2.存储数据到session中 3.跳转（重定向）到success.jsp 不正确： 1.给提示信息：用户名或密码错误 2.跳转（转发）到登录页面 不一致： 1.给用户提示信息：验证码错误 2.存储提示信息到request 3.跳转（转发）到登录页面 login.jsp显示错误信息，从request域中获取 CodeCheckCodeServlet.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package cn.itcast.servlet;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;@WebServlet(\"/checkCodeServlet\")public class CheckCodeServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { int width = 100; int height = 50; //1.创建一对象，在内存中图片(验证码图片对象) BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2.美化图片 //2.1 填充背景色 Graphics g = image.getGraphics();//画笔对象 g.setColor(Color.PINK);//设置画笔颜色 g.fillRect(0,0,width,height); //2.2画边框 g.setColor(Color.BLUE); g.drawRect(0,0,width - 1,height - 1); String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789\"; //生成随机角标 Random ran = new Random(); StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt;= 4; i++) { int index = ran.nextInt(str.length()); //获取字符 char ch = str.charAt(index);//随机字符 sb.append(ch); //2.3写验证码 g.drawString(ch+\"\",width/5*i,height/2); } String checkCode_session = sb.toString(); //将验证码存入session request.getSession().setAttribute(\"checkCode_session\",checkCode_session); //2.4画干扰线 g.setColor(Color.GREEN); //随机生成坐标点 for (int i = 0; i &lt; 10; i++) { int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1,y1,x2,y2); } //3.将图片输出到页面展示 ImageIO.write(image,\"jpg\",response.getOutputStream()); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} login.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;!--点击刷新验证码--&gt; &lt;script&gt; window.onload = function(){ document.getElementById(\"img\").onclick = function(){ this.src=\"/day16/checkCodeServlet?time=\"+new Date().getTime(); } } &lt;/script&gt; &lt;style&gt; div{ color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/day16/loginServlet\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"checkCode\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;img id=\"img\" src=\"/day16/checkCodeServlet\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;input type=\"submit\" value=\"登录\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;div&gt;&lt;%=request.getAttribute(\"cc_error\") == null ? \"\" : request.getAttribute(\"cc_error\")%&gt;&lt;/div&gt; &lt;div&gt;&lt;%=request.getAttribute(\"login_error\") == null ? \"\" : request.getAttribute(\"login_error\") %&gt;&lt;/div&gt; &lt;!-- 等同于 EL表达式。有信息就打印输出，没有就显示空字符串。 ${requestScope.cc_error} ${requestScope.login.error} --&gt;&lt;/body&gt;&lt;/html&gt; LoginServlet.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.itcast.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;@WebServlet(\"/loginServlet\")public class LoginServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.设置request编码 request.setCharacterEncoding(\"utf-8\"); //2.获取参数 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); String checkCode = request.getParameter(\"checkCode\"); //3.先获取生成的验证码 HttpSession session = request.getSession(); String checkCode_session = (String) session.getAttribute(\"checkCode_session\"); //删除session中存储的验证码 session.removeAttribute(\"checkCode_session\"); //3.先判断验证码是否正确 if(checkCode_session!= null &amp;&amp; checkCode_session.equalsIgnoreCase(checkCode)){ //忽略大小写比较 //验证码正确 //判断用户名和密码是否一致 if(\"zhangsan\".equals(username) &amp;&amp; \"123\".equals(password)){//需要调用UserDao查询数据库 //登录成功 //存储信息，用户信息 session.setAttribute(\"user\",username); //重定向到success.jsp response.sendRedirect(request.getContextPath()+\"/success.jsp\"); }else{ //登录失败 //存储提示信息到request request.setAttribute(\"login_error\",\"用户名或密码错误\"); //转发到登录页面 request.getRequestDispatcher(\"/login.jsp\").forward(request,response); } }else{ //验证码不一致 //存储提示信息到request request.setAttribute(\"cc_error\",\"验证码错误\"); //转发到登录页面 request.getRequestDispatcher(\"/login.jsp\").forward(request,response); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); }} success.jsp1234567891011&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;成功登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;%=request.getSession().getAttribute(\"user\")%&gt;,欢迎您&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; Demo 视频详解 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"2020.2.22随笔","slug":"2020.2.22随笔","date":"2020-02-22T09:36:53.000Z","updated":"2020-02-29T12:24:24.909Z","comments":true,"path":"2020/02/22/2020.2.22随笔/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/22/2020.2.22%E9%9A%8F%E7%AC%94/","excerpt":"好久好久，没能有人和我聊着久，聊的这么嗨了。就当做这两天的随笔吧。晚安🌙 ——2020.2.22","text":"好久好久，没能有人和我聊着久，聊的这么嗨了。就当做这两天的随笔吧。晚安🌙 ——2020.2.22 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"HTTP请求信息数据-Request","slug":"HTTP请求信息数据-Request","date":"2020-02-21T12:25:00.000Z","updated":"2020-02-22T12:22:45.504Z","comments":true,"path":"2020/02/21/HTTP请求信息数据-Request/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/21/HTTP%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE-Request/","excerpt":"接着上篇博文 《HTTP：超文本传输协议》 的学习。 现在，来学习两个对象：Request &amp; Response。 request对象和response对象的原理 request和response对象是由服务器创建的。接着我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 其基本原理，如下图👇 request对象继承体系结构ServletRequest – interface，接口 ↓|继承 HttpServletRequest – interface，接口 ↓|实现 org.apache.catalina.connector.RequestFacade – 类，Tomcat编写的 Tomcat 是用纯Java语言编写的 request功能 基础功能 获取请求消息数据 其他功能： 1.获取请求参数通用方式 2.请求转发 3.共享数据 4.获取ServletContext 获取请求消息数据 获取请求行数据 获取请求头数据 获取请求体数据","text":"接着上篇博文 《HTTP：超文本传输协议》 的学习。 现在，来学习两个对象：Request &amp; Response。 request对象和response对象的原理 request和response对象是由服务器创建的。接着我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 其基本原理，如下图👇 request对象继承体系结构ServletRequest – interface，接口 ↓|继承 HttpServletRequest – interface，接口 ↓|实现 org.apache.catalina.connector.RequestFacade – 类，Tomcat编写的 Tomcat 是用纯Java语言编写的 request功能 基础功能 获取请求消息数据 其他功能： 1.获取请求参数通用方式 2.请求转发 3.共享数据 4.获取ServletContext 获取请求消息数据 获取请求行数据 获取请求头数据 获取请求体数据 获取请求消息数据的字符串格式 👇 1234567891011POST /login.html HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://localhost/login.htmlConnection: keep-aliveUpgrade-Insecure-Requests: 1username=zhangsan 一.获取请求行数据1GET /day14/demo1?name=zhangsan HTTP/1.1 调用方法（★★重点掌握）： 获取请求方式：GET String getMethod() ★★获取虚拟目录：/day14 String getContextPath() 获取Servlet路径：/demo1 String getServletPath() 获取get方式请求参数：name=zhangsan String getQueryString() 不用这个，以后会用更高级的方式 多个参数之间用&amp;连接 ★★获取请求URI：/day14/demo1 String getRequestURI()：/day14/demo1 StringBuffer getRequestURL()：http://localhost/day14/demo1 URL：统一资源定位符 ： http://localhost/day14/demo1 其地位相当于”中华人民共和国” URI：统一资源标识符，其表示范围更大 ：/day14/demo1 其地位相当于”共和国” 获取协议及版本：HTTP/1.1 String getProtocol() 该方法在Interface ServletRequest中 获取客户机的IP地址： String getRemoteAddr() 该方法在Interface ServletRequest中 示例新建RequestDemo1.java，输入代码👇 可以在新建时候选择创建Servlet，IDEA自动生成相应模板。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 演示Request对象获取请求行数据 */@WebServlet(\"/RequestDemo1\")public class RequestDemo1 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：/Servlet * String getContextPath() 3. 获取Servlet路径: /requestDemo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (*)获取请求URI：/Servlet/requestDemo1 * String getRequestURI(): /day14/requestDemo1 * StringBuffer getRequestURL() :http://localhost/Servlet/requestDemo1 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() */ //1. 获取请求方式 ：GET String method = request.getMethod(); System.out.println(method); //2.(*)获取虚拟目录：/day14 String contextPath = request.getContextPath(); System.out.println(contextPath); //3. 获取Servlet路径: /demo1 String servletPath = request.getServletPath(); System.out.println(servletPath); //4. 获取get方式请求参数：name=zhangsan String queryString = request.getQueryString(); System.out.println(queryString); //5.(*)获取请求URI：/day14/demo1 String requestURI = request.getRequestURI(); StringBuffer requestURL = request.getRequestURL(); System.out.println(requestURI); System.out.println(requestURL); //6. 获取协议及版本：HTTP/1.1 String protocol = request.getProtocol(); System.out.println(protocol); //7. 获取客户机的IP地址： String remoteAddr = request.getRemoteAddr(); System.out.println(remoteAddr); }} 演示👇 浏览器访问：http://localhost/Servlet/RequestDemo1?name=zhangsan IDEA控制台输出： 二.获取请求头数据12345678Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://localhost/login.htmlConnection: keep-aliveUpgrade-Insecure-Requests: 1 调用方法（★★重点掌握）： ★★String getHeader(String name) 通过请求头的名称获取请求头的值 参数不分大小写，只要单词拼写的对即可 Enumeration&lt;String&gt; getHeaderNames() 获取所有的请求头名称 封装成 Enumeration&lt;String&gt; 注意：从JDK1.0开始，该接口的功能由Iterator（迭代器）接口 复制。此外，Iterator还添加了一个可选的删除操作，并且有较短的方法名称。新的实现应该考虑使用迭代器优选于枚举。——JDK 8 文档 示例一、调用Enumeration&lt;String&gt; getHeaderNames()，演示获取所有请求头数据 新建一个Servlet，名为RequestDemo2.java 1234567891011121314151617181920212223242526272829import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Enumeration;@WebServlet(\"/RequestDemo2\")public class RequestDemo2 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 演示获取请求头数据 // 1.获取所有请求头数据 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); // 2.遍历 while(headerNames.hasMoreElements()){ String name = headerNames.nextElement(); // 根据名称获取请求头的值 String value = request.getHeader(name); System.out.println(name + \"--\" + value); } }} 浏览器访问：http://localhost/Servlet/RequestDemo2 IDEA控制台输出： 二、调用String getHeader(String name)，user-agent、referer 新建一个Servlet，名为RequestDemo3.java 1234567891011121314151617181920212223242526272829import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/RequestDemo3\")public class RequestDemo3 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 演示获取请求头数据：user-agent(客户端版本) // 获取请求头数据：user-agent String agent = request.getHeader(\"user-agent\"); // 判断agent的浏览器版本，可以解决浏览器兼容问题 if(agent.contains(\"Chrome\")) { // 谷歌浏览器 System.out.println(\"谷歌来了。。。\"); } else if (agent.contains(\"Firefox\")) { // 火狐浏览器 System.out.println(\"火狐来了。。。\"); } }} 浏览器访问：http://localhost/Servlet/RequestDemo3 IDEA控制台输出： 注意： 获取请求头数据：user-agent(客户端版本) 判断agent的浏览器版本，可以解决浏览器兼容问题 新建一个Servlet，名为RequestDemo4.java 123456789101112131415161718192021222324252627282930313233343536373839import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/RequestDemo4\")public class RequestDemo4 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 演示请求头数据：referer String referer = request.getHeader(\"referer\"); System.out.println(referer); // http://localhost/Servlet/login.html //防盗链 if(referer != null) { if(referer.contains(\"/Servlet\")) { // 正常访问 System.out.println(\"播放电影。。。\"); /* 等同于，只不过不再是输出到控制台，而是直接打印在页面上 response.setContentType(\"text/html;charset=utf-8\"); response.getWriter.writer(\"播放电影。。。\") */ } else { // 盗链 System.out.println(\"想看电影吗？来优酷吧。。。\"); /* 等同于，只不过不再是输出到控制台，而是直接打印在页面上 response.setContentType(\"text/html;charset=utf-8\"); response.getWriter.writer(\"想看电影吗？来优酷吧。。。\") */ } } }} 新建一个html文件，名为login.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/Servlet/Demo3\" method=\"get\"&gt; &lt;input name=\"username\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;!--加入超链接--&gt; &lt;a href=\"http://localhost/Servlet/RequestDemo4\"&gt;RequestDemo3&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 演示👉获取请求头数据：referer 关于获取referer来防盗链，观看 视频（进度条【10:56】） 三.获取请求体数据1username=zhangsan 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 步骤： 获取流对象 获取字符输入流：文字等字符数据 获取字节输入流：上传图片、文件等字节数据 再从流对象中获取数据 调用方法： BufferedReader getReader() 获取字符输入流，只能操作字符数据 返回值是BufferedReader，高效的、带有缓冲区的 该方法在Interface ServletRequest中 ServletInputStream getInputStream() 获取字节输入流，可以操作所有类型数据 但是获取字符时不方便，更推荐用第一个调用方法 返回值是ServletInputStream，继承了InputStream。 涉及到文件上传等知识 该方法在Interface ServletRequest中 示例 新建html文件，名为regist.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;注册页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/Servlet/RequestDemo5\" method=\"post\"&gt; &lt;input type=\"text\" placeholder=\"请输入用户名\" name=\"username\"&gt;&lt;br&gt; &lt;input type=\"text\" placeholder=\"请输入密码\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 新建一个Servlet，名为RequestDemo5.java 1234567891011121314151617181920212223242526import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;@WebServlet(\"/RequestDemo5\")public class RequestDemo5 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取请求消息体--请求参数 //1.获取字符流 BufferedReader br = request.getReader(); //2.读取数据 String line = null; while((line = br.readLine()) != null){ System.out.println(line); } br.close(); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { }} 浏览器访问：http://localhost/Servlet/regist.html 控制台输出： 注意：多个参数之间用&amp;连接。 其他功能 获取请求参数通用方式 请求转发 共享数据 一、获取请求参数通用方式 不论GET还是POST请求方式都可以使用下列方法来获取请求参数 上述即，doGet() 和 doPost() 的方法体代码完全一样 因此，为了简化，只需要选择在doPost() 的方法体中写代码，之后在doGet() 中调用 this.doPost(request,response); 调用方法： String getParameter(String name) 根据参数名称获取参数值： username=zs&amp;password=123 String[] getParameterValues(String name) 根据参数名称获取参数值的数组：hobby=xuexi&amp;hobby=game 将键值对，按一个键来封装不同的值并封装成一个数组 多用于复选框 Enumeration&lt;String&gt; getParameterNames() 获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap() 获取所有参数的Map集合 示例 新建regist2.html 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;注册页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/Servlet/RequestDemo6\" method=\"post\"&gt; &lt;input type=\"text\" placeholder=\"请输入用户名\" name=\"username\"&gt;&lt;br&gt; &lt;input type=\"text\" placeholder=\"请输入密码\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"checkbox\" name=\"hobby\" value=\"game\"&gt;游戏 &lt;input type=\"checkbox\" name=\"hobby\" value=\"study\"&gt;学习 &lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 新建RequestDemo6.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;import java.util.Enumeration;import java.util.Map;import java.util.Set;@WebServlet(\"/RequestDemo6\")public class RequestDemo6 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //post 获取请求参数 //根据参数名称获取参数值 String username = request.getParameter(\"username\"); /* System.out.println(\"post\"); System.out.println(username);*/ //根据参数名称获取参数值的数组 String[] hobbies = request.getParameterValues(\"hobby\"); /*for (String hobby : hobbies) { System.out.println(hobby); }*/ //获取所有请求的参数名称 Enumeration&lt;String&gt; parameterNames = request.getParameterNames(); /*while(parameterNames.hasMoreElements()){ String name = parameterNames.nextElement(); System.out.println(name); String value = request.getParameter(name); System.out.println(value); System.out.println(\"----------------\"); }*/ // 获取所有参数的map集合 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); //遍历 Set&lt;String&gt; keyset = parameterMap.keySet(); for (String name : keyset) { //获取键获取值 String[] values = parameterMap.get(name); System.out.println(name); for (String value : values) { System.out.println(value); } System.out.println(\"-----------------\"); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //get 获取请求参数/* //根据参数名称获取参数值 String username = request.getParameter(\"username\"); System.out.println(\"get\"); System.out.println(username);*/ this.doPost(request,response); }} 浏览器访问：http://localhost/Servlet/regist2.html 控制台输出： 中文乱码问题 GET方式：tomcat 8 已经将 GET方式乱码问题解决了 POST方式：会乱码 解决：在获取参数前，设置request的编码request.setCharacterEncoding(\"utf-8\"); 。对应着html页面的编码。 二、请求转发 一种在服务器内部的资源跳转方式 特点 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中 转发就是一次请求。像上图的AServlet和BServlet两种资源使用的是同一次请求。 步骤 通过request对象获取请求转发器对象 RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发 forward(ServletRequest request, ServletResponse response) 示例 新建RequestDemo8.java 12345678910111213141516171819202122232425262728293031323334import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/RequestDemo8\")public class RequestDemo8 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"Demo8888被访问了。。。\"); //转发到Demo9资源 /* RequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/RequestDemo9\"); requestDispatcher.forward(request,response); // 一般不这么写，直接写成： request.getRequestDispatcher(\"/RequestDemo9\").forward(request,response); */ //存储数据到request域中 request.setAttribute(\"msg\",\"hello\"); request.getRequestDispatcher(\"/RequestDemo9\").forward(request,response); //没法跳转到外部资源，比如下面这个是不行的//request.getRequestDispatcher(\"http://www.itcast.cn\").forward(request,response); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 新建RequestDemo9.java 123456789101112131415161718192021222324import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/RequestDemo9\")public class RequestDemo9 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取数据 Object msg = request.getAttribute(\"msg\"); System.out.println(msg); System.out.println(\"Demo9999也被访问了。。。\"); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 浏览器访问：http://localhost/Servlet/RequestDemo8 控制台输出： 三、共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 调用方法： void setAttribute(String name,Object obj) 存储数据 Object getAttitude(String n ame) 通过键获取值 void removeAttribute(String name) 通过键移除键值对 👉视频 的【03:15】，详细说到 如何共享数据。 示例示例放在 __ 请求转发 的示例 __ 中。 详细见代码文件中的两个注释： RequestDemo8的【// 存储数据到request域中】 RequestDemo9的【// 获取数据】 四、获取ServletContext调用方法： ServletContext getServletContext() 示例 新建RequestDemo10.java 123456789101112131415161718192021222324import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/RequestDemo10\")public class RequestDemo10 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ServletContext servletContext = request.getServletContext(); System.out.println(servletContext); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); }} 浏览器访问：http://localhost/Servlet/RequestDemo10 控制台输出： 下篇博客 《HTTP响应信息数据 - Response》 中，详细学习响应信息数据 - Response。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"HTTP：超文本传输协议","slug":"HTTP：超文本传输协议","date":"2020-02-21T10:25:00.000Z","updated":"2020-02-23T12:51:40.306Z","comments":true,"path":"2020/02/21/HTTP：超文本传输协议/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/21/HTTP%EF%BC%9A%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/","excerpt":"概念 HTTP == Hyper Text Transfer Protocol 超文本传输协议 传输协议：定义了客户端和服务器端通信时，发送数据的格式。 特点 基于TCP/IP的高级协议 默认端口号:80 基于请求/响应模型的：一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 网页中每一个文件都是一次单独的请求，几张图片，就是几次请求。如下图所示。","text":"概念 HTTP == Hyper Text Transfer Protocol 超文本传输协议 传输协议：定义了客户端和服务器端通信时，发送数据的格式。 特点 基于TCP/IP的高级协议 默认端口号:80 基于请求/响应模型的：一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 网页中每一个文件都是一次单独的请求，几张图片，就是几次请求。如下图所示。 历史版本http 0.9 只有一个命令GET 没有HEADER等描述数据的信息 服务器发送完毕，就关闭TCP连接 每一次请求响应都会建立新的连接 http 1.0 增加了很多命令，如status code和header 多字符集支持、多部分发送、权限、缓存等 http 1.1 持久连接：keep-alive 复用连接（较http1.0的每一次请求响应都会建立新的连接。好处：节约了连接的资源，提升了传输的速度。） 提高性能的关键是低延迟而不是高带宽。 较http1.0，对缓存的支持更好 推送：主动发送js、css推送到浏览器。 二进制流：可以并行发送数据。 http 2.0 所有数据以二进制传输 同一个连接里面发送多个请求不再需要按顺序来 头消息压缩以及推送等提高效率的功能 所有的请求共用一个连接，可以更有效的使用tcp连接，通过带宽来提升http性能 可以减少服务链接的压力，内存减少了，链接吞吐量大了 解决浏览器连接数有限的问题 资源合并减少请求的优化手段在http2.0来说是没有效果的 请求信息数据 格式 Servlet类中service()方法的参数ServletRequest 字符串格式，比如： 1234567891011POST /login.html HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://localhost/login.htmlConnection: keep-aliveUpgrade-Insecure-Requests: 1 username=zhangsan 以下关于 请求信息数据格式 的内容有缺省，详细见下一篇博客 《HTTP请求信息数据 - Request》 中。 请求行 格式：请求方式 请求url 请求协议/版本 请求方式 HTTP协议有7种请求协议，常用的有GET、POST两种 GET 请求参数在请求行中，在url后 请求的url长度有限制的 不太安全（参数跟在url之后） 浏览器控制台显示👇 POST 请求参数在请求体中 请求的url长度没有限制的 相对安全（参数在请求体中） 浏览器控制台显示👇 请求url 假设为 /login.html 请求协议/版本 HTTP/1.1 请求头 客户端浏览器告诉服务器一些信息 格式：请求头名称 : 请求头值 若有多个，则一行一个。 常见的请求头 Host User-Agent Referer Host 请求的主机地址 User-Agent 浏览器告诉服务器，我访问你时候使用的浏览器版本信息 作用：可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer 比如上面几张图片的Referer是 http://localhost/login.html 告诉服务器，我（当前请求）从哪里来？ 作用：防盗链、统计工作 举个例子：我的网站想播放《战狼2》电影👇 Connection keep-alive http1.1，表示该链接可以被复用 请求空行 就是一个空行（空白行） 作用：分割POST请求的请求头和请求体 请求体/请求正文 封装POST请求信息的请求参数 下一篇博客 《HTTP请求信息数据 - Request》 中，详细学习了 请求信息数据 - Request。 响应信息数据 格式 Servlet类中service()方法的参数ServletResponse 字符串数据，比如： 12345678910111213HTTP/1.1 200 OKContent-Type: text/html;charset=UTF-8Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt;&lt;/html&gt; 响应行 格式：协议/版本 响应状态码 状态码描述 响应状态码 服务器告诉客户端浏览器本次请求和响应的一个状态。 特点 状态码都是3位数字 分类 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx状态码 2xx：成功。代表： 200 3xx：重定向。代表： 302：重定向 304：访问缓存 4xx：客户端错误。代表： 403：错误是一种在网站访问过程中，常见的错误提示，表示资源不可用。服务器理解客户的请求，但拒绝处理它，通常由于服务器上文件或目录的权限设置导致的WEB访问错误。 404：请求路径没有对应的资源 405：请求方式没有对应的doXxx方法 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头 格式：响应头名称 ：值 常见的响应头 Content-Type Content-disposition Content-Type 服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition 服务器告诉客户端以什么格式打开响应体数据 其值： in-line：默认值，在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体。涉及文件下载等功能。 响应空行 就是一个空行（空白行） 作用：分割响应头和响应体 响应体 传输的数据 文件、HTML网页源码等等。比如， 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt;&lt;/html&gt; 下下篇博客 《HTTP响应信息数据 - Response》 中，详细学习响应信息数据 - Response。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"hexo s浏览博客时，提示4000端口问题","slug":"hexo s浏览博客时，提示4000端口问题","date":"2020-02-21T10:17:00.000Z","updated":"2020-02-21T10:19:19.210Z","comments":true,"path":"2020/02/21/hexo s浏览博客时，提示4000端口问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/21/hexo%20s%E6%B5%8F%E8%A7%88%E5%8D%9A%E5%AE%A2%E6%97%B6%EF%BC%8C%E6%8F%90%E7%A4%BA4000%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98/","excerpt":"记录一次使用Hexo来，第一次遇到的问题。 讲真我也不知道为什么我的4000端口会被占用，我只是如常一样地使用Hexo而已。 问题hexo s浏览博客时，提示4000端口问题。代码提示如下： 1234567891011121314151617181920$ hexo serverFATAL Port 4000 has been used. Try other port instead.FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/doError: listen EADDRINUSE 0.0.0.0:4000 at Object.exports._errnoException (util.js:1026:11) at exports._exceptionWithHostPort (util.js:1049:20) at Server._listen2 (net.js:1257:14) at listen (net.js:1293:10) at net.js:1403:9 at _combinedTickCallback (internal/process/next_tick.js:77:11) at process._tickCallback (internal/process/next_tick.js:98:9)FATAL listen EADDRINUSE 0.0.0.0:4000Error: listen EADDRINUSE 0.0.0.0:4000 at Object.exports._errnoException (util.js:1026:11) at exports._exceptionWithHostPort (util.js:1049:20) at Server._listen2 (net.js:1257:14) at listen (net.js:1293:10) at net.js:1403:9 at _combinedTickCallback (internal/process/next_tick.js:77:11) at process._tickCallback (internal/process/next_tick.js:98:9) 解决可以在站点下的文件_config.yml内加上如下代码更改hexo-server运行时的端口号： 1234server: port: 40401 compress: true header: true 其中40401可以换成想要运行的端口号。","text":"记录一次使用Hexo来，第一次遇到的问题。 讲真我也不知道为什么我的4000端口会被占用，我只是如常一样地使用Hexo而已。 问题hexo s浏览博客时，提示4000端口问题。代码提示如下： 1234567891011121314151617181920$ hexo serverFATAL Port 4000 has been used. Try other port instead.FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/doError: listen EADDRINUSE 0.0.0.0:4000 at Object.exports._errnoException (util.js:1026:11) at exports._exceptionWithHostPort (util.js:1049:20) at Server._listen2 (net.js:1257:14) at listen (net.js:1293:10) at net.js:1403:9 at _combinedTickCallback (internal/process/next_tick.js:77:11) at process._tickCallback (internal/process/next_tick.js:98:9)FATAL listen EADDRINUSE 0.0.0.0:4000Error: listen EADDRINUSE 0.0.0.0:4000 at Object.exports._errnoException (util.js:1026:11) at exports._exceptionWithHostPort (util.js:1049:20) at Server._listen2 (net.js:1257:14) at listen (net.js:1293:10) at net.js:1403:9 at _combinedTickCallback (internal/process/next_tick.js:77:11) at process._tickCallback (internal/process/next_tick.js:98:9) 解决可以在站点下的文件_config.yml内加上如下代码更改hexo-server运行时的端口号： 1234server: port: 40401 compress: true header: true 其中40401可以换成想要运行的端口号。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"将本地文件传到阿里云服务器","slug":"将本地文件传到阿里云服务器","date":"2020-02-21T05:47:34.000Z","updated":"2020-02-21T05:00:50.819Z","comments":true,"path":"2020/02/21/将本地文件传到阿里云服务器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/21/%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%BC%A0%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"问题怎么将本地文件传到阿里云服务器里面？ 解决 第一种：在阿里云服务器里建一个FTP服务商，在本地用FTP客户端上传文件 第二种：进阿里云服务器远程界面的时候，把本地磁盘带进去，然后进服务器里直接从本地磁盘里把文件复制到服务器里 第三种：QQ安装到阿里云服务器里，用QQ对传 第四种：把本地文件上传到邮箱里 ，然后进阿里云服务器里打开您的邮箱，进去下载文件即可 链接：https://www.w3cschool.cn/intellij_idea_doc/","text":"问题怎么将本地文件传到阿里云服务器里面？ 解决 第一种：在阿里云服务器里建一个FTP服务商，在本地用FTP客户端上传文件 第二种：进阿里云服务器远程界面的时候，把本地磁盘带进去，然后进服务器里直接从本地磁盘里把文件复制到服务器里 第三种：QQ安装到阿里云服务器里，用QQ对传 第四种：把本地文件上传到邮箱里 ，然后进阿里云服务器里打开您的邮箱，进去下载文件即可 链接：https://www.w3cschool.cn/intellij_idea_doc/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"云服务器","slug":"云服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"Servlet 体系结构","slug":"Servlet 体系结构","date":"2020-02-20T12:23:11.000Z","updated":"2020-02-21T13:58:43.395Z","comments":true,"path":"2020/02/20/Servlet 体系结构/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/Servlet%20%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"我们在写一个class 并 implement Servlet时，需要重写Servlet中的5个方法，但是大多时候都只用到 service 方法。 虽然中用到service方法，但其余的4个方法还得重写。 那我们能不能编写一个class，去继承或实现 Servlet 后，只用定义一个 service 方法就可以了。其他方法想有就有，不想有就没有？ 这时候我们就要聊聊 Servlet 体系结构了。 Servlet 体系结构Servlet – interface，接口 ↓|实现 GenericServlet – 实现类，抽象类 ↓|继承 HttpServlet – 实现类，抽象类 做项目时，创建Servlet时候，推荐使用第三种方式：👉继承HttpServlet👉定义类继承HttpServlet👉 复写doGet/doPost方法","text":"我们在写一个class 并 implement Servlet时，需要重写Servlet中的5个方法，但是大多时候都只用到 service 方法。 虽然中用到service方法，但其余的4个方法还得重写。 那我们能不能编写一个class，去继承或实现 Servlet 后，只用定义一个 service 方法就可以了。其他方法想有就有，不想有就没有？ 这时候我们就要聊聊 Servlet 体系结构了。 Servlet 体系结构Servlet – interface，接口 ↓|实现 GenericServlet – 实现类，抽象类 ↓|继承 HttpServlet – 实现类，抽象类 做项目时，创建Servlet时候，推荐使用第三种方式：👉继承HttpServlet👉定义类继承HttpServlet👉 复写doGet/doPost方法 GenericServlet 将 Servlet 接口中的其他方法做了默认空实现，只将 service() 方法作为抽象 将来定义 Servlet 类时候，可以继承 GenericServlet，实现 service() 方法即可 其余四种方法， 若有需要，手动重写即可。 123456789@WebServlet(\"/demo2\")public class ServletDemo2 extends GenericServlet { @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"demo2....\"); } } HttpServlet 该抽象类是对 HTTP协议 的封装和描述，可以简化某些操作 HTTP协议 有 7种 请求方式。现在，我们假设只是用最常用的两种请求方式GET和POST这两种请求方式。 service()方法中 最先要干 的其中2件事👇 将来不管怎么样，都得做这么一件事：“先判断请求方式👉判断完后，要通过不同的请求方式，做出不同的代码逻辑“。 那么，这个过程是非常麻烦的。 同时，这个过程也是所有 service() 都该做的一个过程。 所以这个时候，官方针对这个过程，专门提供了一个class HttpServlet。 HttpServlet 已经帮程序员做好了这个过程，写好了相应的代码，就如上图的红色字体部分。集程序员不再需要去判断请求方式了。 HttpServlet 内部定义了 doGet(){} 和 doPost(){} 这两个方法。并且在判断请求方式的 if 中调用了这两个方法。 这就是其基本的定义原理。就如下图👇 若将来想要屏蔽这种GET或POST请求方式的处理逻辑：我们可以继承 HttpServlet，并且去重写 doGet(){} 和 doPost(){}这两个方法。 因为将来都是调用 service()方法 ，并且 service()会做一个方法分发：你是get就调用 doGet() ，你是post就调用 doPost() 。 做项目时，创建Servlet时候，推荐使用第三种方式：👉继承HttpServlet👉定义类继承HttpServlet👉 复写doGet/doPost方法 步骤 定义 class 继承 HttpServlet 重写doGet() 和 doPost() 两个方法 123456789101112131415161718192021222324252627/* ServletDemo3.java */import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Classname ServletDemo3 * @Description TODO * @Date 2020/2/20 下午 10:54 * @Created by jerry */@WebServlet(\"demo3\")public class ServletDemo3 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doGet......\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doPost......\"); }} 注意 通过浏览器直接请求，是GET方式 现在掌握的知识，只能通过表单，完成POST方式 简单案例 新建login.html文件 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/demo3\" method=\"post\"&gt; &lt;input name=\"username\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 重启服务，访问页面 将 method=\"post\" 改为 method=\"get\" 再访问页面 注意： 使用get方式后，请求的参数会跟在url后。 后续阅读相关文章1、GenericServlet和HttpServlet 2、GenericServlet 、Servlet和httpServler他们之间的关系 3、GenericServlet和HttpServlet有什么区别？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Servlet","slug":"Servlet","permalink":"https://melodyjerry.github.io/blog/tags/Servlet/"}]},{"title":"IDEA官方文档","slug":"IntelliJ IDEA官方文档","date":"2020-02-20T11:47:34.000Z","updated":"2020-02-20T12:47:12.981Z","comments":true,"path":"2020/02/20/IntelliJ IDEA官方文档/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/IntelliJ%20IDEA%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/","excerpt":"一份 W3C school 提供的 《IntelliJ IDEA官方文档》 链接：https://www.w3cschool.cn/intellij_idea_doc/","text":"一份 W3C school 提供的 《IntelliJ IDEA官方文档》 链接：https://www.w3cschool.cn/intellij_idea_doc/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"愿有情人终成眷属，执手前走共度一生","slug":"愿有情人终成眷属，执手前走共度一生","date":"2020-02-20T10:47:34.000Z","updated":"2020-03-02T12:25:21.915Z","comments":true,"path":"2020/02/20/愿有情人终成眷属，执手前走共度一生/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/%E6%84%BF%E6%9C%89%E6%83%85%E4%BA%BA%E7%BB%88%E6%88%90%E7%9C%B7%E5%B1%9E%EF%BC%8C%E6%89%A7%E6%89%8B%E5%89%8D%E8%B5%B0%E5%85%B1%E5%BA%A6%E4%B8%80%E7%94%9F/","excerpt":"浏览博客 网易云热评墙 时，看见两段很感触的网易云音乐热评。截了两张图，就当做今天的随笔。 “愿有情人终成眷属”，这话我想在后边加上一句，“执手前走共度一生”。——2020.02.20随笔","text":"浏览博客 网易云热评墙 时，看见两段很感触的网易云音乐热评。截了两张图，就当做今天的随笔。 “愿有情人终成眷属”，这话我想在后边加上一句，“执手前走共度一生”。——2020.02.20随笔 图片[1]链接：https://www.7ooooo.cn/490/.html 图片[2]链接：https://www.7ooooo.cn/523/.html 关注我们：请关注一下我们的微信公众号（xielihaia）版权声明：版权归 网易云热评墙 所有！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"IDEA与Tomcat的其他相关配置","slug":"IDEA与Tomcat的其他相关配置","date":"2020-02-20T09:42:00.000Z","updated":"2020-02-20T11:41:38.008Z","comments":true,"path":"2020/02/20/IDEA与Tomcat的其他相关配置/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/IDEA%E4%B8%8ETomcat%E7%9A%84%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","excerpt":"IDEA会为每一个Tomcat部署的项目单独建立一份配置文件 查看控制台的log 1Using CATALINA_BASE: \"C:\\Users\\丶Melody\\.IntelliJIdea2019.1\\system\\tomcat\\_test\" 工作空间项目 和 Tomcat部署的Web项目 Tomcat真正访问的是“Tomcat部署的Web项目” “Tomcat部署的Teb项目”对应着“工作空间项目” 的Web目录下的所有资源 IDEA工作台中，项目的src对应着WEB-INF目录 WEB-INF目录下的资源不能被浏览器直接访问。日后可以利用其他技术访问到。 断点调试：使用”小虫子”启动 dubug 启动 视频讲解【00:28】1.IDEA会为每一个Tomcat部署的项目单独建立一份配置文件 【03:15】2.工作空间项目 和 Tomcat部署的Web项目 【09:04】3.断点调试：使用”小虫子”启动 dubug 启动","text":"IDEA会为每一个Tomcat部署的项目单独建立一份配置文件 查看控制台的log 1Using CATALINA_BASE: \"C:\\Users\\丶Melody\\.IntelliJIdea2019.1\\system\\tomcat\\_test\" 工作空间项目 和 Tomcat部署的Web项目 Tomcat真正访问的是“Tomcat部署的Web项目” “Tomcat部署的Teb项目”对应着“工作空间项目” 的Web目录下的所有资源 IDEA工作台中，项目的src对应着WEB-INF目录 WEB-INF目录下的资源不能被浏览器直接访问。日后可以利用其他技术访问到。 断点调试：使用”小虫子”启动 dubug 启动 视频讲解【00:28】1.IDEA会为每一个Tomcat部署的项目单独建立一份配置文件 【03:15】2.工作空间项目 和 Tomcat部署的Web项目 【09:04】3.断点调试：使用”小虫子”启动 dubug 启动 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"Servlet：运行在服务器端的小程序","slug":"Servlet：运行在服务器端的小程序","date":"2020-02-20T07:19:00.000Z","updated":"2020-02-21T09:54:31.828Z","comments":true,"path":"2020/02/20/Servlet：运行在服务器端的小程序/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/Servlet%EF%BC%9A%E8%BF%90%E8%A1%8C%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/","excerpt":"Servlet： server applet 概念：运行在服务器端的小程序 Servlet就是一个接口，定义了Java类被浏览器访问到（Tomcat识别）的规则（我是跳转内容）↩。 将来我们自定义一个类，实现Servlet接口，复写（重写Override）方法。 快速理解","text":"Servlet： server applet 概念：运行在服务器端的小程序 Servlet就是一个接口，定义了Java类被浏览器访问到（Tomcat识别）的规则（我是跳转内容）↩。 将来我们自定义一个类，实现Servlet接口，复写（重写Override）方法。 快速理解 快速入门 创建JavaEE项目 定义一个类，实现Servlet接口 123456789/* ServletDemo1.java */package cn.itcast.web.servlet;import javax.servlet.*;import java.io.IOException;public class ServletDemo1 implements Servlet { //TODO} ​ 实现接口中的抽象方法 1234567891011121314151617181920212223242526272829303132333435/* ServletDemo1.java */package cn.itcast.web.servlet;import javax.servlet.*;import java.io.IOException;public class ServletDemo1 implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } // 提供服务的方法 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"Hello Servlet\"); } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } 配置Servlet，在web.xml的&lt;web-app&gt;&lt;/web-app&gt;中添加： 12345678910&lt;!--配置Servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; servlet-mapping是做一个映射，servlet-name对应servlet-class，url-pattern是资源路径（/开头） &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;，中的cn.itcast.web.servlet.ServletDemo1是全类名，这里涉及到反射。日后补充。 启动服务，看看结果 浏览器中是空白的， 但是IDEA控制台中显示“Hello Servlet” 每刷新一次页面，控制台就多一句“Hello Servlet”。 执行原理 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。 如果有，则在找到对应的&lt;servlet-class&gt;全类名（涉及到反射） tomcat会将字节码文件加载进内存，并且创建其对象 调用其方法 为什么能调用方法？ 因为实现了【规则】（点击我跳转）。实现规则，实现Servlet接口，实现了接口中的方法。 ServletDemo可以调试、运行，看看每个方法的执行次数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import javax.servlet.*;import java.io.IOException;/** * Servlet的方法 */public class ServletDemo1 implements Servlet { /** * 初始化的方法 * 在Servlet被创建时，执行，且只执行一次。 * @param servletConfig * @throws ServletException */ @Override public void init(ServletConfig servletConfig) throws ServletException { System.out.println(\"init...\"); } /** * 获取ServletConfig对象 * ServletConfig：Servlet的配置对象 * @return */ @Override public ServletConfig getServletConfig() { return null; } /** * 提供服务的方法 * 每一次Servlet被访问时，执行。可执行多次。 * @param servletRequest * @param servletResponse * @throws ServletException * @throws IOException */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"service...\"); } /** * 获取Servlet的一些信息（版本、作者……） * @return */ @Override public String getServletInfo() { return null; } /** * 销毁的方法 * 在服务器正常关闭时，执行。只执行一次。 * 非正关闭时，destroy方法不会执行。 */ @Override public void destroy() { System.out.println(\"destroy...\"); }} Servlet中的生命周期方法1.被创建：执行init方法，只执行一次 Servlet什么时候被创建？ 默认情况下，第一次被访问时，被创建。 在服务器启动时，被创建。 可以配置执行Servlet的创建时机，在&lt;servlet&gt;&lt;/servlet&gt;标签中配置&lt;load-on-startup&gt;整数值&lt;/load-on-startup&gt; 1.第一次被访问时，创建 负整数 2.在服务器启动时，创建 0或正整数(一般0~10) 12345678910111213/** * 初始化的方法 * 在Servlet被创建时，执行，且只执行一次。 * @param servletConfig * @throws ServletException */@Overridepublic void init(ServletConfig servletConfig) throws ServletException { System.out.println(\"init...\"); // 定义局部变量，这样不存在多线程的安全问题 int number = 3;} Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的。 多个用户同时访问时，可能存在线程安全问题。 解决：尽量不要在Servlet中定义成员变量（定义局部变量就不存在安全问题了）。即使定义了成员变量，也不要对修改值。 2.提供服务：执行service方法，可执行多次 每次访问Servlet时，Service方法都会被调用一次。 123456789101112/** * 提供服务的方法 * 每一次Servlet被访问时，执行。可执行多次。 * @param servletRequest * @param servletResponse * @throws ServletException * @throws IOException */@Overridepublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"service...\");} 3.被销毁：执行destroy方法，只执行一次 Servlet被销毁时执行。服务器关闭时，Servlet被销毁 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源 123456789/** * 销毁的方法 * 在服务器正常关闭时，执行。只执行一次。 * 非正关闭时，destroy方法不会执行。 */@Overridepublic void destroy() { System.out.println(\"destroy...\");} Servlet 3.0 官方提供新的标准 Servlet 3.0 从 Java EE 6 开始支持 Servlet 3.0 好处 支持注解配置。可以不需要web.xml了 步骤 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 定义一个类，实现Servlet接口 复写方法 在类上使用@WebServlet注解，进行配置 @WebServlet(\"资源路径\") 比如：12345@WebServlet(urlPatterns = \"/demo2\")或@WebServlet(value = \"/demo2\")或@WebServlet(\"/demo2\") 访问：http://localhost:8080/Servlet3/demo2 @WebServlet注解 @WebServlet中有个很特殊的属性value 一般表示最重要的属性，就用value表示。 特性：如果只有一个属性，value可以省略不写。 除去value，最重要的属性是urlPatterns 1234567891011121314151617@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface WebServlet { String name() default \"\"; //相当于&lt;Servlet-name&gt; String[] value() default {}; //代表urlPatterns()属性配置 String[] urlPatterns() default {}; //相当于&lt;url-pattern&gt; int loadOnStartup() default -1; //相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default {}; boolean asyncSupported() default false; String smallIcon() default \"\"; String largeIcon() default \"\"; String description() default \"\"; String displayName() default \"\"; } Servlet 体系结构跳转到我得下一篇博文👉 [Servlet 体系结构](https://melodyjerry.gitee.io/blog/2020/02/20/Servlet 体系结构/) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"},{"name":"Servlet","slug":"Servlet","permalink":"https://melodyjerry.github.io/blog/tags/Servlet/"}]},{"title":"Tomcat简单修改虚拟目录实现访问多个项目","slug":"Tomcat简单修改虚拟目录实现访问多个项目","date":"2020-02-20T06:55:00.000Z","updated":"2020-02-20T09:38:11.642Z","comments":true,"path":"2020/02/20/Tomcat简单修改虚拟目录实现访问多个项目/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/Tomcat%E7%AE%80%E5%8D%95%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%8E%B0%E8%AE%BF%E9%97%AE%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/","excerpt":"可以通过 修改Application Contest（虚拟目录） 实现访问多个项目 修改项目名称作为对应的虚拟目录， 重启服务后，浏览器访问时， 12http://localhost:8080/项目a/资源5例如：http://localhost:55555/ServletDemo/demo1.html","text":"可以通过 修改Application Contest（虚拟目录） 实现访问多个项目 修改项目名称作为对应的虚拟目录， 重启服务后，浏览器访问时， 12http://localhost:8080/项目a/资源5例如：http://localhost:55555/ServletDemo/demo1.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"IDEA启动Tomcat报错","slug":"IDEA启动Tomcat报错","date":"2020-02-19T12:02:09.000Z","updated":"2020-02-20T09:37:58.897Z","comments":true,"path":"2020/02/19/IDEA启动Tomcat报错/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/IDEA%E5%90%AF%E5%8A%A8Tomcat%E6%8A%A5%E9%94%99/","excerpt":"问题 IDEA run的时候报错： 12Error running 'Tomcat 8.5.51':Address loaclhost:1099 is already in use","text":"问题 IDEA run的时候报错： 12Error running 'Tomcat 8.5.51':Address loaclhost:1099 is already in use 分析控制台提示1099端口已经被占用。 解决解决方法要么是杀死端口号1099对应的进程，要么就是修改IDEA中Tomcat的端口号。 建议优先选择杀死对应进程。 方法一 根据端口号查找对应的PID，可以通过在cmd中输入命令， 1netstat -ano | findstr 1099 找到该进程的进程号为7256 输入命令，杀死进程 123tskill 7256或taskkill -f -pid 7256 方法二同方法一，知道进程的PID后，直接去进程管理器，直接右键结束进程。 方法三针对方法一、二均无效时，只能在IDEA中修改端口： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"IDEA 常用快捷键列表","slug":"IDEA输出打印System.out.println()的快捷键","date":"2020-02-19T09:02:00.000Z","updated":"2020-02-20T06:19:40.357Z","comments":true,"path":"2020/02/19/IDEA输出打印System.out.println()的快捷键/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/IDEA%E8%BE%93%E5%87%BA%E6%89%93%E5%8D%B0System.out.println()%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"IDEA输出打印System.out.println()的快捷键在eclipse中习惯了使用syso，开始用idea很不习惯。 在idea中直接输入sout，自动出现提示，不像eclipse中那样还要alt+/，这算是idea的一个优点了。 sout 看图： 按Tab或Enter都可以出现","text":"IDEA输出打印System.out.println()的快捷键在eclipse中习惯了使用syso，开始用idea很不习惯。 在idea中直接输入sout，自动出现提示，不像eclipse中那样还要alt+/，这算是idea的一个优点了。 sout 看图： 按Tab或Enter都可以出现 十大Intellij IDEA快捷键 for System.out、main快捷键 1 智能提示 Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。 最后要说一点，Intellij能够智能感知spring、hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。 2 重构 Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。 切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。 3 代码生成这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。 另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。 4 编辑编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+&lt;/&gt;折叠代码就不多说了。 关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。 5 查找打开类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。 类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。 要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。 Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。 6 其他辅助以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有： Ø 命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 Ø 新建：Alt+Insert可以新建类、方法等任何东西。 Ø 格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 Ø 切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 Ø 单元测试：Ctrl+Alt+T创建单元测试用例。 Ø 运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 Ø 调试：F7/F8/F9分别对应Step into，Step over，Continue。 此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。 7 最终榜单这榜单阵容太豪华了，后几名都是如此有用，毫不示弱。 Ø Top #10切来切去：Ctrl+Tab Ø Top #9选你所想：Ctrl+W Ø Top #8代码生成：Template/Postfix +Tab Ø Top #7发号施令：Ctrl+Shift+A Ø Top #6无处藏身：Shift+Shift Ø Top #5自动完成：Ctrl+Shift+Enter Ø Top #4创造万物：Alt+Insert 太难割舍，前三名并列吧！ Ø Top #1智能补全：Ctrl+Shift+Space Ø Top #1自我修复：Alt+Enter Ø Top #1重构一切：Ctrl+Shift+Alt+T ————————版权声明：本文为CSDN博主「Jenrey」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/jenrey/article/details/79961825 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"IDEA 常用快捷键列表","slug":"IDEA常用快捷键列表","date":"2020-02-19T09:00:00.000Z","updated":"2020-02-19T09:27:20.306Z","comments":true,"path":"2020/02/19/IDEA常用快捷键列表/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%88%97%E8%A1%A8/","excerpt":"IDEA 常用快捷键列表","text":"IDEA 常用快捷键列表 ——- IDEA中窗口最大化—-&gt;Windows 上： Ctrl+Shift+F12 ——– ctrl+z撤回代码 ——- ctrl+shift+z恢复撤回代码 ——- ctrl + Alt + V (返回属性变量) ——- shift+ctrl+u (大小写的切换) ——- Ctrl+Alt+L，格式化代码 ——- Ctrl+D 将当前行复制到下一行 ——- Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch 也可抛错误 ——- 快捷方式一（光标移到该代码行，Alt+Enter），可以异常外抛出，也可以try-catch： ——- Ctrl+Shift+Space，自动补全代码（提示） ——- Ctrl+O，重写方法 ——- Ctrl+I，实现方法 ——- ctrl + shift + enter 句末加； ——- 连安两下 shift 查找文件 ——- CtrL +shift +r 全局搜索： ——- ctrl +r 替换当前页的单词 ——- 代码格式化： shfit + G (自定义) //ctrl +alt +L —— 直接查看和进入接口实现类的快捷键 ： Ctrl+Alt+鼠标左键 —– 单机两下放大窗户： —– alt+capslk(大小写切换)+鼠标左键 或者：ALT + 鼠标左键 列编辑模式 ————- ctrl+shift+enter不只是用来行尾加分号的； idea进阶快捷键： 1 查看接口的实现类：Ctrl+Alt+B： 2：查看一个类中有什么方法：Alt+7 或 点左侧边栏Structure 2 返回上/下个光标地方:Alt+Ctrl+箭头(向左) 和 Alt+ Ctrl+箭头(向右)—（全键盘） 3： 查看Java方法调用树(被调/主调)：Ctrl+Alt+H 4 :查看类继承关系图：Ctrl+Alt+U 5:查看当前类的继承树：Ctrl+H 6: 查看定义的变量在哪里被调用：Ctrl+Alt+F7 7:查看一个类中有什么方法：Alt+7 或 点左侧边栏Structure 8:列编辑：alt +左键 9:自动生成not null判断语句 自动生成not null这种if判断，在IDEA里有很多种办法，其中一种办法你可能没想到。 upload successful 当我们使用rabbitTemplate. 后，直接输入notnull并回车，IDEA就好自动生成if判断了。 upload successful 编辑Ctrl+Shift + Enter，语句完成\" ！\"，否定完成，输入表达式时按 “！”键Ctrl+E，最近的文件Ctrl+Shift+E，最近更改的文件Shift+Click，可以关闭文件Ctrl+[ OR ]，可以跑到大括号的开头与结尾Ctrl+F12，可以显示当前文件的结构Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择Ctrl+N，可以快速打开类Ctrl+Shift+N，可以快速打开文件Alt+Q，可以看到当前方法的声明Ctrl+P，可以显示参数信息Ctrl+Shift+Insert，可以选择剪贴板内容并插入Alt+Insert，可以生成构造器/Getter/Setter等Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catchCtrl+Enter，导入包，自动修正Ctrl+Alt+L，格式化代码Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作Ctrl+Alt+O，优化导入的类和包Ctrl+R，替换文本Ctrl+F，查找文本Ctrl+Shift+Space，自动补全代码Ctrl+空格，代码提示（与系统输入法快捷键冲突）Ctrl+Shift+Alt+N，查找类中的方法或变量★Alt+Enter，快速修复错误提示、导入包、自动修正代码、解决出现的问题、生成返回值…… 详细见 最特殊的快捷键 Alt + Enter 介绍 Alt+Shift+C，最近的更改Alt+Shift+Up/Down，上/下移一行Shift+F6，重构 – 重命名Ctrl+X，删除行Ctrl+D，复制行Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）Ctrl+J，自动代码（例如：serr）Ctrl+Alt+J，用动态模板环绕Ctrl+H，显示类结构图（类的继承层次）Ctrl+Q，显示注释文档Alt+F1，查找代码所在位置Alt+1，快速打开或隐藏工程面板Ctrl+Alt+left/right，返回至上次浏览的位置Alt+left/right，切换代码视图Alt+Up/Down，在方法间快速移动定位Ctrl+Shift+Up/Down，向上/下移动语句F2 或 Shift+F2，高亮错误或警告快速定位Tab，代码标签输入完成后，按 Tab，生成代码Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失Alt+F3，逐个往下查找相同文本，并高亮显示Ctrl+Up/Down，光标中转到第一行或最后一行下Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）Ctrl+Alt+B，跳转到方法实现处Ctrl+Shift+Backspace，跳转到上次编辑的地方Ctrl+O，重写方法Ctrl+Alt+Space，类名自动完成Ctrl+Alt+Up/Down，快速跳转搜索结果Ctrl+Shift+J，整合两行Alt+F8，计算变量值Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本Ctrl+Alt+Shift+V，简单粘贴Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口F12，把焦点从编辑器移到最近使用的工具窗口Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器Ctrl+W，可以选择单词继而语句继而行继而函数Ctrl+Shift+W，取消选择光标所在词Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置Ctrl+I，实现方法Ctrl+Shift+U，大小写转化Ctrl+Y，删除当前行 Shift+Enter，向下插入新行psvm/sout，main/System.out.println();Ctrl+J，查看更多Ctrl+Shift+F，全局查找Ctrl+F，查找Shift+F3，向上查找F3，向下查找Ctrl+Shift+S，高级搜索Ctrl+U，转到父类Ctrl+Alt+S，打开设置对话框Alt+Shift+Inert，开启/关闭列选择模式Ctrl+Alt+Shift+S，打开当前项目/模块属性Ctrl+G，定位行Alt+Home，跳转到导航栏Ctrl+Enter，上插一行Ctrl+Backspace，按单词删除Ctrl+\"+/-\"，当前方法展开、折叠Ctrl+Shift+\"+/-\"，全部展开、折叠 调试、编译Ctrl+F2，停止Alt+Shift+F9，选择 DebugAlt+Shift+F10，选择 RunCtrl+Shift+F9，编译Ctrl+Shift+F10，运行Ctrl+Shift+F8，查看断点F8，步过F7，步入Shift+F7，智能步入Shift+F8，步出Alt+Shift+F8，强制步过Alt+Shift+F7，强制步入Alt+F9，运行至光标处Ctrl+Alt+F9，强制运行至光标处F9，恢复程序Alt+F10，定位到断点Ctrl+F8，切换行断点Ctrl+F9，生成项目Alt+1，项目Alt+2，收藏Alt+6，TODOAlt+7，结构Ctrl+Shift+C，复制路径Ctrl+Alt+Shift+C，复制引用，必须选择类名Ctrl+Alt+Y，同步Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）Shift+F12，还原默认布局Ctrl+Shift+F12，隐藏/恢复所有窗口Ctrl+F4，关闭Ctrl+Shift+F4，关闭活动选项卡Ctrl+Tab，转到下一个拆分器Ctrl+Shift+Tab，转到上一个拆分器 重构Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除Ctrl+Alt+N，内联 查找Ctrl+F，查找Ctrl+R，替换F3，查找下一个Shift+F3，查找上一个Ctrl+Shift+F，在路径中查找Ctrl+Shift+R，在路径中替换Ctrl+Shift+S，搜索结构Ctrl+Shift+M，替换结构Alt+F7，查找用法Ctrl+Alt+F7，显示用法Ctrl+F7，在文件中查找用法Ctrl+Shift+F7，在文件中高亮显示用法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"Tomcat启动时中文乱码的问题","slug":"Tomcat启动时中文乱码的问题","date":"2020-02-19T08:01:00.000Z","updated":"2020-02-20T09:39:51.634Z","comments":true,"path":"2020/02/19/Tomcat启动时中文乱码的问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/Tomcat%E5%90%AF%E5%8A%A8%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"问题Tomcat启动时中文乱码的问题 解决方法修改conf文件夹下的logging.properties文件 第47行代码： 1java.util.logging.ConsoleHandler.encoding = UTF-8 改为 1java.util.logging.ConsoleHandler.encoding = GBK","text":"问题Tomcat启动时中文乱码的问题 解决方法修改conf文件夹下的logging.properties文件 第47行代码： 1java.util.logging.ConsoleHandler.encoding = UTF-8 改为 1java.util.logging.ConsoleHandler.encoding = GBK 扩展如果IDEA中使用Tomcat也乱码，可以额为参考此方法。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"Tomcat：Web服务器软件","slug":"Tomcat：服务器软件","date":"2020-02-19T07:25:00.000Z","updated":"2020-02-21T14:06:15.058Z","comments":true,"path":"2020/02/19/Tomcat：服务器软件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/Tomcat%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AF%E4%BB%B6/","excerpt":"Tomcat：web服务器软件 Tomcat 是用纯Java语言编写的 安装下载 https://tomcat.apache.org/download-80.cgi 免安装，解压压缩包即可。 注意：安装目录建议不要有中文和空格 目录结构 启动 Windows：运行./bin/startup.bat Linux：运行./bin/startup.sh","text":"Tomcat：web服务器软件 Tomcat 是用纯Java语言编写的 安装下载 https://tomcat.apache.org/download-80.cgi 免安装，解压压缩包即可。 注意：安装目录建议不要有中文和空格 目录结构 启动 Windows：运行./bin/startup.bat Linux：运行./bin/startup.sh 可能遇到的问题中文乱码详细见博文 【Tomcat启动时中文乱码的问题】 黑窗口一闪而过 原因： 没有正确配置JAVA_HOME环境变量 解决方案：正确配置JAVA_HOME环境变量 启动报错暴力 找到占用的端口号，并且找到对应的进程，杀死该进程 cmd&gt;netstat -ano &gt; 查看进程id（PID）&gt;任务管理器（查看-选择列-PID）&gt;结束进程（对应PID） 温柔 修改自身的端口号 ./conf/server.xml `&lt;Connector port=”8888” protocol=”HTTP/1.1” connectionTimeout=\"20000\" redirectPort=\"8445\" /&gt;` 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 好处：在访问时，就不用输入端口号 该方式可实现单机多Tomcat并存 访问浏览器输入： 访问自己：http://localhost:8080 访问别人：http://别人的ip:8080 查看IP地址 cmd&gt;$ ipconfig &gt;IPv4地址 关闭 针对服务器本身，推荐使用“正常关闭” 但是后期是配合IDEA使用Tomcat 正常关闭 有两种方式： 手动运行./bin/shutdown.bat 在Tomcat窗口，按Ctrl+C 强制关闭 点击Tomcat窗口右上角的X 部署/配置项目的方式 有三种方式： 直接将项目放到webapps目录下即可 配置conf/server.xml文件 在conf\\Catalina\\localhost创建任意名称的xml文件 虚拟目录浏览器通过http://localhost:8080访问，需要访问到某一个项目时，需要在其随后加上/目录或路径（称作虚拟目录） 直接将项目放到webapps目录下即可 /项目(文件夹)名”：项目的访问路径，也称虚拟目录 简化部署 第一种方式还有一种简化部署的形式 将项目打成一个war包，再将war包放置到webapps目录下 war 包会自动解压缩 若删除项目，删除对应war包即可。自动会删除对应生产的项目文件夹。 配置conf/server.xml文件 在&lt;Host&gt;标签体中配置 &lt;Context docBase=\"D:\\hello\" path=\"/hehe\" /&gt; docBase：项目存放的路径 path：虚拟目录 缺点：需要修改配置文件，不太安全 在conf\\Catalina\\localhost创建任意名称的xml文件 在文件中编写 &lt;Context docBase=\"D:\\hello\" /&gt; 虚拟目录：xml文件的名称。比如localhost:8080/xml文件/index.html 热部署方式：删除或修改文件名后，不需要重启服务。 部署项目的类型 静态项目 动态项目 静态项目 只能存放静态资源 HTML、CSS、JavaScript、图片、音频、视频、文本等等 动态项目 不仅可存放静态资源，还有动态资源 目录结构(Java动态项目)12345项目根目录 ﹂-WEB-INF目录 ﹂web.xml：web项目的核心配置文件 ﹂classes目录：放置字节码文件的目录 ﹂lib目录：放置依赖的jar包 比如： IDEA中配合使用Tomcat集成到IDEA中 新建Web项目 运行项目 注意： 默认war打包部署 / ：默认虚拟目录设置当前项目为根目录 其他配置 重新部署项目时，不再重启Tomcat服务器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"Github提速","slug":"Github提速","date":"2020-02-18T09:00:00.000Z","updated":"2020-02-19T10:46:27.721Z","comments":true,"path":"2020/02/18/Github提速/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/18/Github%E6%8F%90%E9%80%9F/","excerpt":"经常要clone github中的一些项目，无奈如果不爬梯子的话速度实在是龟速，经常1k/s，于是献上改Hosts大法。 第一步：打开http://codeload.github.com.ipaddress.com/#ipinfo 找到你浏览器上实际显示的IP地址， 例图 ： 第二步：按win+r唤起运行框，输入cmd，然后再依次ping一下上面的地址 第三步：打开你C:\\Windows\\System32\\drivers\\etc\\hosts文件，在文件末尾追加如下一行即可 1140.82.113.9 http://codeload.github.com","text":"经常要clone github中的一些项目，无奈如果不爬梯子的话速度实在是龟速，经常1k/s，于是献上改Hosts大法。 第一步：打开http://codeload.github.com.ipaddress.com/#ipinfo 找到你浏览器上实际显示的IP地址， 例图 ： 第二步：按win+r唤起运行框，输入cmd，然后再依次ping一下上面的地址 第三步：打开你C:\\Windows\\System32\\drivers\\etc\\hosts文件，在文件末尾追加如下一行即可 1140.82.113.9 http://codeload.github.com 另外以下这些github hosts，可能对你所在地区来说不是最优版本，最优hosts的选择可以参考上面三个步骤 123456789101112131415161718# GitHub Start192.30.253.112 github.com192.30.253.119 gist.github.com151.101.100.133 assets-cdn.github.com151.101.100.133 raw.githubusercontent.com151.101.100.133 gist.githubusercontent.com151.101.100.133 cloud.githubusercontent.com151.101.100.133 camo.githubusercontent.com151.101.100.133 avatars0.githubusercontent.com151.101.100.133 avatars1.githubusercontent.com151.101.100.133 avatars2.githubusercontent.com151.101.100.133 avatars3.githubusercontent.com151.101.100.133 avatars4.githubusercontent.com151.101.100.133 avatars5.githubusercontent.com151.101.100.133 avatars6.githubusercontent.com151.101.100.133 avatars7.githubusercontent.com151.101.100.133 avatars8.githubusercontent.com# GitHub End document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Github","slug":"Github","permalink":"https://melodyjerry.github.io/blog/tags/Github/"}]},{"title":"JavaScript：让页面元素动起来","slug":"JavaScript：让页面元素动起来","date":"2020-02-18T01:01:00.000Z","updated":"2020-02-18T14:50:39.641Z","comments":true,"path":"2020/02/18/JavaScript：让页面元素动起来/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/18/JavaScript%EF%BC%9A%E8%AE%A9%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%8A%A8%E8%B5%B7%E6%9D%A5/","excerpt":"概念一门客户端脚本语言 特点 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎 脚本语言：不需要编译，直接就可以被浏览器解析执行了 功能 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。","text":"概念一门客户端脚本语言 特点 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎 脚本语言：不需要编译，直接就可以被浏览器解析执行了 功能 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。 发展史 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C– ，后来更名为：ScriptEase 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript 1996年，微软抄袭JavaScript开发出JScript语言 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。 JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)ECMAScript：客户端脚本语言的标准基本语法与html结合方式内部JS 定义&lt;script&gt;，标签体内容就是js代码 外部JS 定义&lt;script&gt;，通过src属性引入外部的js文件 注意 &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。 &lt;script&gt;可以定义多个。 注释 单行注释：// 注释内容 多行注释：/* 注释内容 */ 数据类型详细见 JavaScript 数据类型 原始数据类型(基本数据类型) number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型) string：字符串。 字符串 “abc” “a” ‘abc’ boolean：布尔。 true和false null：一个对象为空的占位符 undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined Undefined 与 Null 的区别 Undefined 与 Null 的值相等，但类型不相等： 1234typeof undefined // undefined typeof null // objectnull === undefined // falsenull == undefined // true 引用数据类型 对象（object） 数组（array） 变量 变量：一小块存储数据的内存空间 Java语言是强类型语言，而JavaScript是弱类型语言。 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。 语法1var 变量名 = 初始化值; typeof运算符 获取变量的类型 注：null运算后得到的是object 更多见 《JavaScript中typeof知多少？》 运算符 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换。 其他类型转number： string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字） boolean转number：true转为1，false转为0 算数运算符算术运算符对数值（文字或变量）执行算术运算。 运算符 描述 + 加法 - 减法 * 乘法 ** 幂（将第一个操作数提升到第二个操作数的幂。ES2016） / 除法 % 系数（返回除法的余数） ++ 递增 – 递减 赋值运算符赋值运算符向 JavaScript 变量赋值。 运算符 特殊说明 例子 等同于 = x = y x = y += x += y x = x + y -= x -= y x = x - y *= x *= y x = x * y /= x /= y x = x / y %= 把余数赋值给变量 x %= y x = x % y &lt;&lt;= x &lt;&lt;= y x = x &lt;&lt; y &gt;&gt;= x &gt;&gt;= y x = x &gt;&gt; y &gt;&gt;&gt;= x &gt;&gt;&gt;= y x = x &gt;&gt;&gt; y &amp;= x &amp;= y x = x &amp; y ^= x ^= y x = x ^ y |= x |= y x = x | y **= x **= y x = x ** y 提示：****=** 运算符属于 ECMAScript 2016 proposal (ES7) 的实验部分。它的跨浏览器表现并不稳定。请勿使用。 比较运算符比较运算符在逻辑语句中使用，以判定变量或值是否相等。 我们给定 x = 5，下表中解释了比较运算符： 运算符 描述 比较 返回 == 等于 x == 8 false x == 5 true x == “5” true === 值相等并且类型相等 x === 5 true x === “5” false != 不相等 x != 8 true !== 值不相等或类型不相等 x !== 5 false x !== “5” true x !== 8 true &gt; 大于 x &gt; 8 false &lt; 小于 x &lt; 8 true &gt;= 大于或等于 x &gt;= 8 false &lt;= 小于或等于 x &lt;= 8 true 比较方式 类型相同：直接比较 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。 类型不同：先进行类型转换，再比较 ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false 逻辑运算符逻辑运算符用于判定变量或值之间的逻辑。 我们给定 x = 6 且 y = 3，下表解释了逻辑运算符： 运算符 描述 例子 &amp;&amp; 与 (x &lt; 10 &amp;&amp; y &gt; 1) 为 true || 或 (x == 5 || y == 5) 为 false ! 非 !(x == y) 为 true 其他类型转boolean： number：0或NaN为假，其他为真 string：除了空字符串(“”)，其他都是true null&amp;undefined：都是false 对象：所有对象都为true 条件（三元）运算符语法： 1变量名=(表达式)? 值1:值2; 判断表达式的值，如果是true则取值1，如果是false则取值2； 示例： 1var voteable = (age &lt; 18) ? \"太年轻\":\"足够成熟\"; 字符串运算符+ 运算符也可用于对字符串进行相加（concatenate，级联）。+= 赋值运算符也可用于相加（级联）字符串： 实例：给定 text1 = “Good “, text2 = “Morning”, 及 text3 = “”, 下面的表格解释了字符串运算符的使用： 运算符 例子 text1 text2 text3或text1 + text3 = text1 + text2 “Good “ “Morning” “Good Morning” += text1 += text2 “Hello” “Kitty！” “Hello Kitty!” 字符串+数字=字符串 相加两个数字，将返回和。但对一个数字和一个字符串相加将返回一个字符串。 类型运算符 运算符 描述 typeof 返回变量的类型。 instanceof 返回 true，如果对象是对象类型的实例。 typeof 运算符您可以使用 typeof 运算符来确定 JavaScript 变量的数据类型。 12345678910typeof \"Bill\" // 返回 \"string\"typeof 3.14 // 返回 \"number\"typeof NaN // 返回 \"number\"typeof false // 返回 \"boolean\"typeof [1,2,3,4] // 返回 \"object\"typeof {name:'Bill', age:62} // 返回 \"object\"typeof new Date() // 返回 \"object\"typeof function () {} // 返回 \"function\"typeof myCar // 返回 \"undefined\" *typeof null // 返回 \"object\" 请注意： NaN 的数据类型是数值 数组的数据类型是对象 日期的数据类型是对象 null 的数据类型是对象 未定义变量的数据类型是 undefined 尚未赋值的变量的数据类型也是 undefined 无法使用 typeof 去判断 JavaScript 对象是否是数组（或日期）。 typeof 的数据类型： typeof 运算符不是变量。它属于运算符。运算符（比如 + - * /）没有数据类型。 但是，typeof 始终会返回字符串（包含运算数的类型）。 另外涉及到Number() 转换数值，String() 转换字符串，Boolean() 转换布尔值。 位运算符位运算符处理 32 位数。 该运算中的任何数值运算数都会被转换为 32 位的数。结果会被转换回 JavaScript 数。 运算符 描述 例子 等同于 结果 十进制 &amp; 与 (and) 5 &amp; 1 0101 &amp; 0001 0001 1 | 或 (or) 5 | 1 0101 | 0001 0101 5 ~ 非 (not) ~ 5 ~0101 1010 10 ^ 异或 (xor) 5 ^ 1 0101 ^ 0001 0100 4 &lt;&lt; 零填充左位移 5 &lt;&lt; 1 0101 &lt;&lt; 1 1010 10 &gt;&gt; 有符号右位移 5 &gt;&gt; 1 0101 &gt;&gt; 1 0010 2 &gt;&gt;&gt; 零填充右位移 5 &gt;&gt;&gt; 1 0101 &gt;&gt;&gt; 1 0010 2 上例使用 4 位无符号的例子。但是 JavaScript 使用 32 位有符号数。因此，在 JavaScript 中，~ 5 不会返回 10，而是返回 -6。~00000000000000000000000000000101 将返回 11111111111111111111111111111010。 JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数。执行按位操作后，结果将转换回 64 位 JavaScript 数。 运算符优先级值 值 运算符 描述 实例 20 ( ) 表达式分组 (3 + 4) 19 . 成员 person.name 19 [] 成员 person[“name”] 19 () 函数调用 myFunction() 19 new 创建 new Date() 17 ++ 后缀递增 i++ 17 – 后缀递减 i– 16 ++ 前缀递增 ++i 16 – 前缀递减 –i 16 ! 逻辑否 !(x==y) 16 typeof 类型 typeof x 15 ** 求幂 (ES7) 10 ** 2 14 * 乘 10 * 5 14 / 除 10 / 5 14 % 模数除法 10 % 5 13 + 加 10 + 5 13 - 减 10 - 5 12 &lt;&lt; 左位移 x &lt;&lt; 2 12 &gt;&gt; 右位移 x &gt;&gt; 2 12 &gt;&gt;&gt; 右位移（无符号） x &gt;&gt;&gt; 2 11 &lt; 小于 x &lt; y 11 &lt;= 小于或等于 x &lt;= y 11 &gt; 大于 x &gt; y 11 &gt;= 大于或等于 x &gt;= y 11 in 对象中的属性 “PI” in Math 11 instanceof 对象的实例 instanceof Array 10 == 相等 x == y 10 === 严格相等 x === y 10 != 不相等 x != y 10 !== 严格不相等 x !== y 9 &amp; 按位与 x &amp; y 8 ^ 按位 XOR x ^ y 7 | 按位或 x | y 6 &amp;&amp; 逻辑与 x &amp;&amp; y 5 || 逻辑否 x || y 4 ? : 条件 ? “Yes” : “No” 3 = 赋值 x = y 3 += 赋值 x += y 3 -= 赋值 x -= y 3 *= 赋值 x *= y 3 %= 赋值 x %= y 3 &lt;&lt;= 赋值 x &lt;&lt;= y 3 &gt;&gt;= 赋值 x &gt;&gt;= y 3 &gt;&gt;&gt;= 赋值 x &gt;&gt;&gt;= y 3 &amp;= 赋值 x &amp;= y 3 ^= 赋值 x ^= y 3 |= 赋值 x |= y 2 yield 暂停函数 yield x 1 , 逗号 7 , 8 注意：淡红色指示实验性或建议性的技术（ECMASScript 2016 或 ES7） 提示：括号中的表达式会在值在表达式的其余部分中被使用之前进行完全计算。 流程控制语句 if...else... switch: 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7) switch(变量): case 值: 在JS中,switch语句可以接受任意的原始数据类型 while for JS特殊语法 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议) 变量的定义使用var关键字，也可以不使用 用： 定义的变量是局部变量 不用：定义的变量是全局变量(不建议) 练习：99乘法表12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;99乘法表&lt;/title&gt; &lt;style&gt; td{ border: 1px solid; } &lt;/style&gt; &lt;script&gt; document.write(\"&lt;table align='center'&gt;\"); //1.完成基本的for循环嵌套，展示乘法表 for (var i = 1; i &lt;= 9 ; i++) { document.write(\"&lt;tr&gt;\"); for (var j = 1; j &lt;=i ; j++) { document.write(\"&lt;td&gt;\"); //输出 1 * 1 = 1 document.write(i + \" * \" + j + \" = \" + ( i*j) +\"&amp;nbsp;&amp;nbsp;&amp;nbsp;\"); document.write(\"&lt;/td&gt;\"); } /*//输出换行 document.write(\"&lt;br&gt;\");*/ document.write(\"&lt;/tr&gt;\"); } //2.完成表格嵌套 document.write(\"&lt;/table&gt;\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 基本对象Function：函数(方法)对象创建格式 123function 方法名称(形式参数列表){ 方法体} 123var 方法名 = function(形式参数列表){ 方法体} 建议不用 1var fun = new Function(形式参数列表,方法体); //忘掉吧 方法属性 length：代表形参的个数 特点 方法定义是，形参的类型不用写,返回值类型也不写。 方法是一个对象，如果定义名称相同的方法，会覆盖 在JS中，方法的调用只与方法的名称有关，和参数列表无关 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数 调用12345方法名称(实际参数列表);&lt;!--比如：var x = myFunction(4, 3); // 调用函数，返回值被赋值给 x--&gt; 函数中的代码将在其他代码调用该函数时执行： 当事件发生时（当用户点击按钮时） 当 JavaScript 代码调用时 自动的（自调用） 返回当 JavaScript 到达 return 语句，函数将停止执行。如果函数被某条语句调用，JavaScript 将在调用语句之后“返回”执行代码。函数通常会计算出返回值。这个返回值会返回给调用者： 123function myFunction(a, b) { return a * b; // 函数返回 a 和 b 的乘积} Array：数组对象创建格式 var arr = new Array(元素列表); var arr = new Array(默认长度); var arr = [元素列表]; 方法 join(参数)：将数组中的元素按照指定的分隔符拼接为字符串 push()：向数组的末尾添加一个或更多元素，并返回新的长度 属性 lengh:数组的长度 特点1. JS中，数组元素的类型可变的。 2. JS中，数组长度可变的。Boolean：布尔布尔值只有两个值：true 或 false。 实例 12var x = true;var y = false; 布尔值经常用在条件测试中。 Date：日期对象创建格式1var date = new Date(); 方法 toLocaleString()：返回当前date对象对应的时间本地字符串格式 getTime()：获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差 Math：数学对象创建特点 Math对象不用创建，直接使用。 格式：Math.方法名(); 方法 random():返回 0 ~ 1 之间的随机数。 含0不含1 ceil(x)：对数进行上舍入 floor(x)：对数进行下舍入 round(x)：把数四舍五入为最接近的整数 属性 PI Number：数值JavaScript 只有一种数值类型。 写数值时用不用小数点均可： 实例 12var x1 = 34.00; // 带小数点var x2 = 34; // 不带小数点 超大或超小的数值可以用科学计数法来写： 实例 12var y = 123e5; // 12300000var z = 123e-5; // 0.00123 String：字符串字符串（或文本字符串）是一串字符（比如 “Bill Gates”）。 字符串被引号包围。您可使用单引号或双引号： 实例 12var carName = \"Porsche 911\"; // 使用双引号var carName = 'Porsche 911'; // 使用单引号 您可以在字符串内使用引号，只要这些引号与包围字符串的引号不匹配： 实例 123var answer = \"It's alright\"; // 双引号内的单引号var answer = \"He is called 'Bill'\"; // 双引号内的单引号var answer = 'He is called \"Bill\"'; // 单引号内的双引号 RegExp：正则表达式对象正则表达式：定义字符串的组成规则。 单个字符:[]如： [a] [ab] [a-zA-Z0-9_] 特殊符号代表特殊含义的单个字符： \\d:单个数字字符 [0-9] \\w:单个单词字符 [a-zA-Z0-9_] 量词符号： ?：表示出现0次或1次 *：表示出现0次或多次 +：表示出现1次或多次 {m,n}:表示 m&lt;= 数量 &lt;= n m如果缺省：{,n}：最多n次n 如果缺省：{m,}：最少m次 开始结束符号 ^:开始 $:结束 正则对象创建有两种创建形式： var reg = new RegExp(\"正则表达式\"); var reg = /正则表达式/; 方法 test(参数):验证指定的字符串是否符合正则定义的规范 Global：全局对象特点 全局对象 这个Global中封装的方法不需要对象就可以直接调用：方法名(); 方法 encodeURI()：url编码 decodeURI()：url解码 encodeURIComponent()：url编码,编码的字符更多 decodeURIComponent()：url解码 parseInt()：将字符串转为数字 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number isNaN()：判断一个值是否是NaN NaN六亲不认，连自己都不认。NaN参与的==比较，全部都是false eval()：讲 JavaScript 字符串，并把它作为脚本代码来执行。 URL编码 传智播客 = %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2 BOM概念 Browser Object Model 浏览器对象模型 将浏览器的各个组成部分封装成对象。 浏览器对象模型（Browser Object Model (BOM)）不存在浏览器对象模型（BOM）的官方标准。 现代的浏览器已经（几乎）实现了 JavaScript 交互相同的方法和属性，因此它经常作为 BOM 的方法和属性被提到。 该部分笔记不全，详细见 JavaScript Window - 浏览器对象模型 组成 Window：窗口对象 Navigator：浏览器对象 Screen：显示器屏幕对象 History：历史记录对象 Location：地址栏对象 Navigator 浏览器对象 Navigator 对象获取一些浏览器的信息. 属性 appName 返回浏览器的名称。 相关文档 https://www.w3school.com.cn/jsref/dom_obj_navigator.asp Screen 屏幕对象 Screen 对象包含有关客户端显示屏幕的信息。 属性 width: 返回屏幕的宽度 height: 返回屏幕的高度 相关文档 https://www.w3school.com.cn/jsref/dom_obj_screen.asp Location 地址栏对象 Location 对象包含有关当前 URL 的信息。 创建(获取) window.location location 方法 reload(): 重新加载当前文档,刷新操作. 属性 href: 设置或返回完整的url. Demo123456789101112131415&lt;body&gt;&lt;input id=\"btn\" type=\"button\" value=\"跳转\"&gt;&lt;script type=\"text/javascript\"&gt; // 获取input标签 var btn = document.getElementById(\"btn\"); // 设置事件 btn.onclick = function (){ location.href = \"https://www.baidu.com\"; }&lt;/script&gt;&lt;/body&gt; 相关文档 https://www.w3school.com.cn/jsref/dom_obj_location.asp History 对象 History 对象包含用户（在浏览器窗口中）访问过的 URL。 创建(获取) window.history history 方法 back() 加载 history 列表中的前一个 URL。 forward() 加载 history 列表中的下一个 URL。 go(参数)加载 history 列表中的某个具体页面。 参数：正数：前进几个历史记录负数：后退几个历史记录 属性 length: 返回当前窗口历史列表中的url数量. Window 窗口对象 Window 对象表示浏览器中打开的窗口。 方法 与弹出框有关的方法 alert(): 显示带有一段消息和一个确认按钮的警告框. confirm(): 显示带有一段消息,以及确认和取消两个按钮的对话框. 若点击确定,该方法返回true, 点击取消,返回false. 如果用户点击确定按钮，则方法返回true 如果用户点击取消按钮，则方法返回false prompt(): 显示可提示用户输入的对话框. 返回值为用户输入的内容. 与打开关闭有关的方法 close():关闭浏览器窗口。谁调用我 ，我关谁 open(arg1, arg2, arg3, arg4): 打开一个新的浏览器窗口，返回新的Window对象 注意: 这4个参数都是可选的, arg1 传入url, arg3传入窗口的特征(设置宽高等) 1window.open(\"https://www.baidu.com\",\"\",\"width=100,height=100\"); 与定时器有关的方法 setTimeout(code,millisec): 在指定的毫秒数后调用函数或计算表达式。 参数： js代码或者方法对象 毫秒值 返回值：唯一标识，用于取消定时器 clearTimeout(id_of_settimeout): 取消由 setTimeout() 方法设置的 timeout。传入某个定时器的id用来取消指定的定时器. setInterval(code,millisec): 按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval(id_of_settimeout): 取消由 setInterval() 设置的 timeout。 属性 获取其他BOM对象 History location Navigator Screen 获取DOM对象 document 特点 Window对象不需要创建可以直接使用： window.方法名() window引用可以省略：方法名(); DOM简单学习：为了满足案例要求 功能：控制html文档的内容 获取页面标签(元素)对象：Element* `document.getElementById(\"id值\")`:通过元素的id获取元素对象 操作Element对象： 修改属性值： 明确获取的对象是哪一个？ 查看API文档，找其中有哪些属性可以设置 修改标签体内容： 属性：``innerHTML` 获取元素对象 使用innerHTML属性修改标签体内容 概念 Document Object Model 文档对象模型 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作 功能 控制html文档的内容 W3C DOM 标准被分为 3 个不同的部分 核心 DOM — 针对任何结构化文档的标准模型 Document：文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 Node：节点对象，其他5个(D、E、A、T、C)的父对象 XML DOM — 针对 XML 文档的标准模型 HTML DOM — 针对 HTML 文档的标准模型 对象树当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM 模型被结构化为对象树： DOM: Document Object Model 文档对象模型 文档: 超文本文档(超文本标记文档) html, xml 对象: 提供了属性和方法. 模型: 使用属性和方法操作超文本标记文档 可以使用js里面的dom里面提供的对象,使用这些对象的属性和方法,对标记型文档进行操作. dom里面已经将html里面的标签,属性,文本内容都封装成了对象. 该部分笔记不全，详细见 JavaScript HTML DOM DOM解析html文档的过程 根据html的层级结构,在内存中分配一个树形结构, 需要把html中的每部分封装为对象. Document对象: 整个文档 Element对象: 标签对象 Attribute对象: 首先要获取标签对象 Text对象: 首先要获取标签对象 Comment对象: 注释对象 Node节点对象: 这个对象是上面这些对象的父对象, 如果在对象内找不到想要的方法, 此时可以在Node节点对象中去查找想要的方法. 核心DOM模型Document 文档对象创建(获取) 在html dom模型中可以使用window对象来获取 window.document document 方法write() 向页面输出变量/html代码 12document.write(\"abc\");document.write(\"&lt;hr&gt;\"); 获取Element对象getElementById() ： 根据id属性值获取元素对象,id属性值一般唯一getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组 创建其他的DOM对象 createAttribute(name) createComment() createElement() createTextNode() Element 元素对象(标签对象)创建(获取) 通过document来获取和创建 方法 首先通过document来获取元素,然后通过元素进行操作 getAttribute(attributename): 获取指定的属性 setAttribute(attributename,attributevalue): 给元素添加属性 removeAttribute(attributename): 移除指定名称的属性 注意: 不能删除 value 获取标签下面的子标签 childNodes: 这个属性兼容性很差 getElementsByTagName(标签名): 兼容性好,获取标签下面子标签的唯一有效方法. Node 节点对象特点 所有dom对象都可以被认为是一个节点. 属性 parentNode 返回节点的父节点 方法nodeName:获取节点的名称nodeType: 获取节点的类型nodeValue: 获取节点的value值因为dom在解析html的时候, html里面的标签,属性,文本都是一个节点,所以上面的三个属性对其都是不同的值. 标签节点对应的nodeType为1 属性节点对应的nodeType为2 文本节点对应的nodeType为3 parentNode: 获取父节点的属性childNodes: 得到所有子节点,兼容性差firstChild: 获取第一个子节点lastChild: 获取最后一个子节点nextSibling: 返回一个给定节点的下一个兄弟节点previousSibling: 返回一个给定节点的上一个兄弟节点 CRUD_DOM树查找节点 getElementById():通过节点的id属性,查找指定节点 添加节点 appendChild()：向节点的子节点列表的结尾添加新的子节点 插入节点 insertBefore(newNode, oldNode): 向oldNode节点前插入一个新节点.通过父节点添加 删除节点 removeChild()：删除（并返回）当前节点的指定子节点。 替换节点 replaceChild()：用新节点替换一个子节点。通过父节点替换 复制节点 cloneNode(true): 复制节点 innerHTML属性 innerHTML作用: 获取文本内容 向标签里面设置内容(可以是html代码) Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div#div1 { width: 360px; height: 150px; border: 2px solid red; } div#div2 { width: 360px; height: 150px; border: 2px solid black; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"div1\"&gt; &lt;ul id=\"ul1\"&gt; &lt;li id=\"li1\"&gt;one&lt;/li&gt; &lt;li id=\"li2\"&gt;two&lt;/li&gt; &lt;li id=\"li3\"&gt;three&lt;/li&gt; &lt;li id=\"li4\"&gt;four&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div id=\"div2\"&gt;&lt;/div&gt;&lt;input id=\"input1\" type=\"button\" value=\"添加节点\"&gt;&lt;input id=\"input2\" type=\"button\" value=\"插入节点\"&gt;&lt;input id=\"input3\" type=\"button\" value=\"删除节点\"&gt;&lt;input id=\"input4\" type=\"button\" value=\"替换节点\"&gt;&lt;input id=\"input5\" type=\"button\" value=\"复制节点\"&gt;&lt;script type=\"text/javascript\"&gt; // 添加节点 /* 1.获取到ul 2.获取到div2 3.把ul添加到div2 */ var input1 = document.getElementById(\"input1\"); input1.onclick = function () { var ul = document.getElementById(\"ul1\"); var div = document.getElementById(\"div2\"); div.appendChild(ul); } // 插入节点 /* 1.获取到li3标签 2.创建li 3.创建文本 4.把文本添加到li下面 5.获取到ul 6.把li添加到ul下面 */ var input2 = document.getElementById(\"input2\"); input2.onclick = function () { var li3 = document.getElementById(\"li3\"); var li = document.createElement(\"li\"); var text = document.createTextNode(\"朝阳红\"); li.appendChild(text); var ul = document.getElementById(\"ul1\"); ul.insertBefore(li, li3); } // 删除节点 /* 1.获取到li标签 2.执行父节点ul标签 3.执行删除 */ var input3 = document.getElementById(\"input3\"); input3.onclick = function () { var li3 = document.getElementById(\"li3\"); var ul = document.getElementById(\"ul1\"); ul.removeChild(li3); } // 替换节点 /* 1.获取到li标签 2.创建标签li 3.创建文本 4.把文本添加到li下面 5.获取父节点Ul标签 6.执行替换 */ var input4 = document.getElementById(\"input4\"); input4.onclick = function () { var li3 = document.getElementById(\"li3\"); var li = document.createElement(\"li\"); var text = document.createTextNode(\"HelloWorld\"); li.appendChild(text); var ul = document.getElementById(\"ul1\"); ul.replaceChild(li, li3); } // 复制节点(把ul列表复制到另一个div中) /* 1.获取到ul 2.执行复制方法：cloneNode(true) 3.把复制后的内容放到div2中 获取div2 appendChild方法 */ var input5 = document.getElementById(\"input5\"); input5.onclick = function () { var ul = document.getElementById(\"ul1\"); var ulClone = ul.cloneNode(true); var div = document.getElementById(\"div2\"); div.appendChild(ulClone); }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML DOM 标签体的设置和获取：innerHTML 使用html元素对象的属性 控制元素样式 使用元素的style属性来设置 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。如：12345//修改样式方式1div1.style.border = \"1px solid red\";div1.style.width = \"200px\";//font-size--&gt; fontSizediv1.style.fontSize = \"20px\"; 控制样式 通过DOM来控制标签的样式 使用 style 属性来设置 提前定义好类选择器的样式，通过元素的 className 属性来设置其class属性值。 Demo123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .sun { font-weight: bold; font-size: 30px; color: skyblue; border: 2px dashed #000; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"zy\"&gt;桂朝阳&lt;/div&gt;&lt;div class=\"sun\"&gt;大太阳&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; // 获取类名为zy的标签 var zy = window.document.getElementsByClassName(\"zy\")[0]; // alert(zy.className); // 方式一(自己添加)给类名为zy的div添加样式 // zy.style.border = \"1px solid #ccc\"; // zy.style.fontSize = \"20px\"; // 方式二(调用已经写好的) zy.className = \"sun\"; &lt;/script&gt;&lt;/body&gt; 事件简单学习 功能： 某些组件被执行了某些操作后，触发某些代码的执行。 比如，造句： xxx被xxx,我就xxx。 我方水晶被摧毁后，我就责备对友。 敌方水晶被摧毁后，我就夸奖自己。 如何绑定事件 直接在html标签上，指定事件的属性(操作)，属性值就是 js 代码 事件：onclick — 单击事件 通过 js 获取元素对象，指定事件属性，设置一个函数 小案例： 123456789101112131415161718192021&lt;body&gt; &lt;img id=\"light\" src=\"img/off.gif\" onclick=\"fun();\"&gt; &lt;img id=\"light2\" src=\"img/off.gif\"&gt; &lt;script&gt; function fun(){ alert('我被点了'); alert('我又被点了'); } function fun2(){ alert('咋老点我？'); } //1.获取light2对象 var light2 = document.getElementById(\"light2\"); //2.绑定事件 light2.onclick = fun2; &lt;/script&gt;&lt;/body&gt; 功能些组件被执行了某些操作后，触发某些代码的执行 事件监听机制 概念: 某些组件被执行了某些操作后，触发某些代码的执行。 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了 事件源：组件。如： 按钮 文本输入框… 监听器：代码。 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。 常见的事件 点击事件： onclick：单击事件 ondblclick：双击事件 焦点事件 onfocus:元素获得焦点 onblur：失去焦点 一般用于表单验证 加载事件： onload：一张页面或一幅图像完成加载。 鼠标事件： onmousedown： 鼠标按钮被按下。 定义方法时，定义一个形参，接受event对象。 event对象的button属性可以获取鼠标按钮键被点击了。 onmouseup ：鼠标按键被松开。onmousemove ：鼠标被移动。onmouseover ：鼠标移到某元素之上。onmouseout ：鼠标从某元素移开。 键盘事件： onkeydown ：某个键盘按键被按下。 onkeyup ：某个键盘按键被松开。 onmouseout：某个键盘按键被按下并松开。 选择和改变 onchange ：域的内容被改变。 onselect ：文本被选中。 表单事件： onsubmit ：确认按钮被点击。 可以阻止表单的提交 方法返回false则表单被阻止提交。 onreset ：重置按钮被点击。 Demo:电灯开关12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;电灯开关&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img id=\"light\" src=\"img/off.gif\"&gt;&lt;script&gt; /* 分析： 1.获取图片对象 2.绑定单击事件 3.每次点击切换图片 * 规则： * 如果灯是开的 on,切换图片为 off * 如果灯是关的 off,切换图片为 on * 使用标记flag来完成 */ //1.获取图片对象 var light = document.getElementById(\"light\"); var flag = false;//代表灯是灭的。 off图片 //2.绑定单击事件 light.onclick = function(){ if(flag){//判断如果灯是开的，则灭掉 light.src = \"img/off.gif\"; flag = false; }else{ //如果灯是灭的，则打开 light.src = \"img/on.gif\"; flag = true; } }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 标记&gt;&gt;&gt;学习BOM和DOM时用的是CSDN博主「White Camel」的笔记，原文链接：https://blog.csdn.net/m0_37989980/article/details/103669620 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"}]},{"title":"歌《人命之河》","slug":"歌《人命之河》","date":"2020-02-17T14:49:52.000Z","updated":"2020-02-17T15:05:26.730Z","comments":true,"path":"2020/02/17/歌《人命之河》/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/17/%E6%AD%8C%E3%80%8A%E4%BA%BA%E5%91%BD%E4%B9%8B%E6%B2%B3%E3%80%8B/","excerpt":"","text":"记录昨天，2020-2-17，周日。 中午，老爸做了新菜，名叫“凉拌猪肉”（老爸自己起的名字），味道还不错 老弟“放假”（在家网上教学六天，周日放假hhh），下午我们去到外公外婆那。 外公外婆2人+二姨一家4人+我们一家3人=9人。 老爸又露了一手，一桌的饭菜，。结果留给我收尾，我也吃不完，实则太多了，嗝~~（太撑了hh） 看见外公的身体比之前还虚弱，很累的样子。保佑阿公身体健康🙆 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"[转]Git很慢怎么办","slug":"转-Git-很慢怎么办","date":"2020-02-17T11:35:47.000Z","updated":"2020-02-17T11:37:30.465Z","comments":true,"path":"2020/02/17/转-Git-很慢怎么办/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/17/%E8%BD%AC-Git-%E5%BE%88%E6%85%A2%E6%80%8E%E4%B9%88%E5%8A%9E/","excerpt":"","text":"it’s fucking slow, guess why当你想要解决一个问题的时候，最好先学会尽可能准确地描述你的问题，像「Git 很慢怎么办」之类的问题就是反面教材，这就像说「我的国家不行了」一样，这种模棱两可、似是而非的问题对出题人和答题人都是一种困扰，出题人把握不了自己的问题，便始终不会自查，答题人无法知晓出题人真正的问题，也只能一顿瞎猜。 如果你假以思考，结合实际情况，比如你操作的命令，是 git clone 还是 git checkout? 这样就能很快推断出真正的问题，即「Git clone 很慢怎么办」，如果更进一步，你想到你正在 clone 的是一个国外的地址，比如 github.com，你会想到这也许是网络问题。 当你做出更多的判断而不是用一个模糊的问题来让别人替你判断的时候，你的问题也就迎刃而解了。 现在这个模糊的问题变成了解决 Git 同步国外项目的网络问题了，这种情况你应该很熟悉，可以使用「代理」来解决。而 Git 支持两种网络传输协议，即 HTTP 和 SSH 协议，于是你只需要在 Google 搜索 Git 如何配置 HTTP 代理和 SSH 代理 就行了，当然也可以继续阅读，参考我用的配置。 配置 HTTP 代理如果你 git clone 时用的是 http 开头的地址，那就得配置 http 代理: 123git config --global http.proxy http://127.0.0.1:1087# 或者 Socks5 代理git config --global http.proxy socks5://127.0.0.1:1086 配置 SSH 代理如果你 git clone 时用的是 ssh 开头的地址，那就得配置 SSH 代理。 对 macOS 用户，你可以使用 connect，这是一个让 SSH 支持 SOCKS/HTTPS 代理的工具，这里我们用 homebrew 来安装: 1brew install connect 然后编辑你的 ~/.ssh/config 文件，加入以下代码: 123Host * User git ProxyCommand connect -S 127.0.0.1:1086 %h %p 这样 SSH 连接时就会使用位于 127.0.0.1:1086 的代理。 原文链接：https://egoist.moe/2019/08/15/git-is-slow/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://melodyjerry.github.io/blog/tags/Git/"}]},{"title":"制作一个简单的HTML登录页面","slug":"制作一个简单的HTML登录页面","date":"2020-02-17T10:20:00.000Z","updated":"2020-02-22T12:58:37.188Z","comments":true,"path":"2020/02/17/制作一个简单的HTML登录页面/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/17/%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84HTML%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/","excerpt":"需求制作一个HTML登录页面，包含邮箱，登录密码，立即注册，忘记密码等","text":"需求制作一个HTML登录页面，包含邮箱，登录密码，立即注册，忘记密码等 HTML部分1234567891011121314151617181920&lt;div class=\"dowebok\"&gt; &lt;div class=\"dowebok\"&gt; &lt;div class=\"logo\"&gt;&lt;/div&gt; &lt;div class=\"form-item\"&gt; &lt;input id=\"username\" type=\"text\" autocomplete=\"off\" placeholder=\"邮箱\"&gt; &lt;/div&gt; &lt;div class=\"form-item\"&gt; &lt;input id=\"password\" type=\"password\" autocomplete=\"off\" placeholder=\"登录密码\"&gt; &lt;/div&gt; &lt;div class=\"form-item\"&gt;&lt;button id=\"submit\"&gt;登 录&lt;/button&gt;&lt;/div&gt; &lt;div class=\"reg-bar\"&gt; &lt;a class=\"reg\" href=\"javascript:\"&gt;立即注册&lt;/a&gt; &lt;a class=\"forget\" href=\"javascript:\"&gt;忘记密码&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; CSS部分12345678910111213141516171819202122232425262728* { margin: 0; padding: 0; } html { height: 100%; } body { height: 100%; background: #fff url(img/backgroud.png) 50% 50% no-repeat; background-size: cover;} .dowebok { position: absolute; left: 50%; top: 50%; width: 430px; height: 550px; margin: -300px 0 0 -215px; border: 1px solid #fff; border-radius: 20px; overflow: hidden;} .logo { width: 104px; height: 104px; margin: 50px auto 80px; background: url(img/login.png) 0 0 no-repeat; } .form-item { position: relative; width: 360px; margin: 0 auto; padding-bottom: 30px;} .form-item input { width: 288px; height: 48px; padding-left: 70px; border: 1px solid #fff; border-radius: 25px; font-size: 18px; color: #fff; background-color: transparent; outline: none;} .form-item button { width: 360px; height: 50px; border: 0; border-radius: 25px; font-size: 18px; color: #1f6f4a; outline: none; cursor: pointer; background-color: #fff; } #username { background: url(img/emil.png) 20px 14px no-repeat; } #password { background: url(img/password.png) 23px 11px no-repeat; } .tip { display: none; position: absolute; left: 20px; top: 52px; font-size: 14px; color: #f50; } .reg-bar { width: 360px; margin: 20px auto 0; font-size: 14px; overflow: hidden;} .reg-bar a { color: #fff; text-decoration: none; } .reg-bar a:hover { text-decoration: underline; } .reg-bar .reg { float: left; } .reg-bar .forget { float: right; } .dowebok ::-webkit-input-placeholder { font-size: 18px; line-height: 1.4; color: #fff;} .dowebok :-moz-placeholder { font-size: 18px; line-height: 1.4; color: #fff;} .dowebok ::-moz-placeholder { font-size: 18px; line-height: 1.4; color: #fff;} .dowebok :-ms-input-placeholder { font-size: 18px; line-height: 1.4; color: #fff;} @media screen and (max-width: 500px) { * { box-sizing: border-box; } .dowebok { position: static; width: auto; height: auto; margin: 0 30px; border: 0; border-radius: 0; } .logo { margin: 50px auto; } .form-item { width: auto; } .form-item input, .form-item button, .reg-bar { width: 100%; } } 效果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"CSS","slug":"CSS","permalink":"https://melodyjerry.github.io/blog/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"}]},{"title":"CSS：页面美化和布局控制","slug":"CSS页面美化和布局控制","date":"2020-02-17T08:20:00.000Z","updated":"2020-02-22T12:52:29.526Z","comments":true,"path":"2020/02/17/CSS页面美化和布局控制/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/17/CSS%E9%A1%B5%E9%9D%A2%E7%BE%8E%E5%8C%96%E5%92%8C%E5%B8%83%E5%B1%80%E6%8E%A7%E5%88%B6/","excerpt":"概念Cascading Style Sheets :层叠样式表 层叠：多个样式可以作用在同一个html的元素上，同时生效 好处 功能强大 将内容展示和样式控制分离 降低耦合度。解耦 让分工协作更容易 提高开发效率","text":"概念Cascading Style Sheets :层叠样式表 层叠：多个样式可以作用在同一个html的元素上，同时生效 好处 功能强大 将内容展示和样式控制分离 降低耦合度。解耦 让分工协作更容易 提高开发效率 使用方式CSS与html结合方式 1.内联样式（作用域最小） 在标签内使用style属性指定css代码 如：1&lt;div style=\"color:red;\"&gt;hello css&lt;/div&gt; 2.内部样式 在head标签内，定义style标签，style标签的标签体内容就是css代码 如：123456&lt;style&gt; div{ color:blue; }&lt;/style&gt;&lt;div&gt;hello css&lt;/div&gt; 3.外部样式（作用域最大） 定义css资源文件。 在head标签内，定义link标签，引入外部的资源文件 如：123456789 &lt;!--a.css文件--&gt;div{ color:green;}&lt;!--html文件--&gt;&lt;link rel=\"stylesheet\" href=\"css/a.css\"&gt;&lt;div&gt;hello css&lt;/div&gt;&lt;div&gt;hello css&lt;/div&gt; 特别注意 1,2,3种方式 css作用范围越来越大 第1方式不常用，后期常用第2,3种 第3种格式可以写为：123&lt;style&gt; @import \"css/a.css\"; &lt;/style&gt; 语法格式 格式：12345选择器 { 属性名1:属性值1; 属性名2:属性值2; ...} 选择器:筛选具有相似特征的元素 注意：每一对属性需要使用；隔开，最后一对属性可以不加； 选择器筛选具有相似特征的元素 分类选择器分两种： 基础选择器 扩展选择器 基础选择器id选择器选择具体的id属性值的元素.建议在一个html页面中id值唯一 语法：12345#id属性值{ 属性名1:属性值1; 属性名2:属性值2; ...} 元素选择器选择具有相同标签名称的元素 语法：12345标签名称{ 属性名1:属性值1; 属性名2:属性值2; ...} 注意：id选择器优先级高于元素选择器 类选择器选择具有相同的class属性值的元素。 语法：12345.class属性值{ 属性名1:属性值1; 属性名2:属性值2; ...} 注意：类选择器选择器优先级高于元素选择器 扩展选择器选择所有元素 语法： 12345* { 属性名1:属性值1; 属性名2:属性值2; ...} 并集选择器选择多个元素 语法：12345选择器1, 选择器2 { 属性名1:属性值1; 属性名2:属性值2; ...} 子选择器筛选 选择器1下 的 选择器2 元素 语法： 12345选择器1 选择器2{ 属性名1:属性值1; 属性名2:属性值2; ...} 区别于 子选择器： 多个选择器之间的分隔符，一个是逗号，一个是空格。 父选择器筛选 选择器2 的 父元素选择器1 语法： 12345选择器1 &gt; 选择器2{ 属性名1:属性值1; 属性名2:属性值2; ...} 属性选择器选择元素名称，属性名=属性值的元素 语法： 12345元素名称 [属性名 = \"属性值\"] { 属性名1:属性值1; 属性名2:属性值2; ...} 伪类选择器选择一些元素具有的状态 语法： 12345元素: 状态{ 属性名1:属性值1; 属性名2:属性值2; ...} 比如： 123456789101112a:link{ color:red; } a:hover{ color: yellow; } a:visited{ color: blue; } a:active{ color: brown; } &lt;a&gt;的状态：link：初始化的状态visited：被访问过的状态active：正在访问状态hover：鼠标悬浮状态 属性属性有字体、文本、背景、边框、尺寸…… 字体、文本 font-size：字体大小 color：文本颜色 text-align：对其方式 line-height：行高 背景 background：设置背景 边框 border：设置边框，符合属性 尺寸 width：宽度 height：高度 盒子模型：控制布局 margin：外边距 padding：内边距 默认情况下内边距会影响整个盒子的大小 box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 float：浮动 left right 实践案例这里有 70个CSS实例 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"CSS","slug":"CSS","permalink":"https://melodyjerry.github.io/blog/tags/CSS/"}]},{"title":"MySQL中的约束","slug":"MySQL中的约束","date":"2020-02-16T09:24:41.000Z","updated":"2020-02-16T07:52:33.753Z","comments":true,"path":"2020/02/16/MySQL中的约束/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/16/MySQL%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F/","excerpt":"什么是约束 约束：constraintMySQL中的约束，实则是对数据表中数据的限制条件 约束的作用 约束保证数据的完整性和一致性 比如：设计数据表时，要求username字段不允许重复，这时候就需要在CREATE数据表时加入相应的约束。再比如注册时候必须填写邮箱、性别等。 约束的分类按约束定义的位置可分 列级约束 表级约束 按约束的作用可分 主键 约束 PRIMARY KEY 外键 约束 FOREIGN KEY 非空 约束 NOT NULL 唯一 约束 UNIQUE KEY 默认 约束 DEFAULT","text":"什么是约束 约束：constraintMySQL中的约束，实则是对数据表中数据的限制条件 约束的作用 约束保证数据的完整性和一致性 比如：设计数据表时，要求username字段不允许重复，这时候就需要在CREATE数据表时加入相应的约束。再比如注册时候必须填写邮箱、性别等。 约束的分类按约束定义的位置可分 列级约束 表级约束 按约束的作用可分 主键 约束 PRIMARY KEY 外键 约束 FOREIGN KEY 非空 约束 NOT NULL 唯一 约束 UNIQUE KEY 默认 约束 DEFAULT 列级约束、表级约束区别 列级约束：只能应用于一列上。 表级约束：可以应用于一列上，也可以应用在一个表中的多个列上。 即：如果你创建的约束涉及到该表的多个属性列，则必须创建的是表级约束（必须定义在表级上）；否则既可以定义在列级上也可以定义在表级上此时只是SQL语句格式不同而已。 列级约束：包含在列定义中，直接跟在该列的其它定义之后 ，用空格分隔；不必指定列名。 表级约束：与列定义相互独立，不包含在列定义中；与定义用‘，’分隔；必须指出要约束的列的名称。 注：因为在创建列级约束时，只需将创建列约束的语句添加到该字段（列）的定义子句后面；而在创建表级约束时，需要将创建表级约束的语句添加到各个字段（列）定义语句的后面，因为并不是每个定义的字段都要创建约束，所以必须指明需要创建的约束的列名。 举例说明123456Create Table project(项目编号 INT CONSTRAINT pk_pno PRIMARY kEY，项目名称 CHAR(20)，项目负责人 CHAR(20)，CONSTRAINT un_pname_pm UNIQUE(项目名称，项目负责人)); 分析：“项目编号”字段设置为主键，主键约束名为pk_pno，此主键约束为列主键约束。“项目名称”和“项目负责人”的组合字段设置唯一性约束，此约束为表级约束） 具体说明一：既可以创建列级约束又可以创建表级约束的： 1、主键约束（primary key constraint）： （1）定义列约束：CONSTRAINT &lt;约束名&gt; PRIMARY KEY （2）定义表约束：[CONSTRAINT &lt;约束名&gt;] PRIMARY KEY( &lt;列名&gt; [{&lt;列名&gt;}]) 2、唯一性约束（unique key constraint）： （1）定义列约束：[CONSTRAINT &lt;约束名&gt;] UNIQUE [KEY] （2）定义表约束：CONSTRAINT &lt;约束名&gt; UNIQUE [KEY] ( &lt;列名&gt; [{&lt;列名&gt;}]) 3、外键约束（foreign key constraint）： 定义 列级约束：[CONSTRAINT &lt;约束名&gt;] FOREIGN KEY REFERENCES &lt;外表名&gt; 定义表级约束：[CONSTRAINT &lt;约束名&gt;] FOREIGN KEY REFERENCES &lt;外表名&gt;( &lt;列名&gt; [{&lt;列名&gt;}]) 二：只能创建列级约束的： 1，缺省约束（default constraint）： [CONSTRAINT &lt;约束名&gt;] DEFAULT 约束条件 2，NULL 约束： [CONSTRAINT &lt;约束名&gt;] [NULL | NOT NULL] 主键约束 PRIMARY KEY“主键（PRIMARY KEY）”的完整称呼是“主键约束”。MySQL 主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。 涉及术语 主键约束 主键字段 主键值 三种术语的关系： 表中的某个字段添加主键约束后，该字段为主键字段，主键字段中出现的每一个数据都称为主键值 特点 保证数据的实体完整性 要求 一张表应该有主键字段，如果没有，表示该表无效 主键值：是当前行数据的唯一标识、是当前行数据的身份证号 即使表中两行记录相关数据相同，但由于主键值不同，所以也认为是两行不同的记录 按主键约束的字段数量分类 在MySQL的一个表中只有唯一的一个主键，不能有多列主键，但可以有复合主键。一个表中可以：单列做主键、多列做主键（复合主键）。 单一主键：给一个字段添加主键约束 复合主键：给多个字段联合添加一个主键约束(只能用表级定义) 单一主键（列级定义）12345mysql&gt; create table t_user( -&gt; id int(10) primary key, -&gt; name varchar(32) -&gt; );Query OK, 0 rows affected (0.07 sec) 单一主键（表级定义）123456mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; constraint t_user_id_pk primary key(id) -&gt; );Query OK, 0 rows affected (0.01 sec) 复合主键（表级定义） 一定要在表级定义。 1234567mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; email varchar(128) unique, -&gt; primary key(id,name) -&gt; );Query OK, 0 rows affected (0.05 sec) 配合AUTO_INCREMENT 在MySQL数据库提供了一个自增的数字，专门用来自动生成主键值，主键值不用用户维护，自动生成，自增数从1开始，以1递增(auto_increment) 1234567891011121314151617181920mysql&gt; create table t_user( -&gt; id int(10) primary key auto_increment, -&gt; name varchar(32) not null -&gt; );Query OK, 0 rows affected (0.03 sec)/*插入两行记录，id主键值会自动增加*/mysql&gt; insert into t_user(name) values('jay');Query OK, 1 row affected (0.04 sec)mysql&gt; insert into t_user(name) values('man');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from t_user;+----+------+| id | name |+----+------+| 1 | jay || 2 | man |+----+------+2 rows in set (0.00 sec) 外键约束 FOREIGN KEY外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。 外键的主要作用是保持数据的一致性、完整性。例如，部门表 tb_dept 的主键是 id，在员工表 tb_emp5 中有一个键 deptId 与这个 id 关联。 主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表。 从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表。 快速理解之前创建表的时候都是在一张表中添加记录，比如如下表： 公司有3个部门，但是有1个亿的员工，那意味着部门这个字段需要重复存储，部门名字越长，越浪费。这个时候，解决方法：我们完全可以定义一个部门表，然后让员工信息表关联该表，如何关联，即foreign key。 我们可以将上表改为如下结构： 涉及到的术语 外键约束 外键字段 外键值 三种术语的关系： 某个字段添加外键约束之后，该字段称为外键字段，外键字段中每个数据都是外键值 特点 保持数据的一致性 完整性 实现一对一或者一对多关系 这也是为什么称为MySQL关系型数据库的原因 要求 ★父表（子表所参照的表）和子表（具有外键列的表）必须使用使用相同的存储引擎，而且禁止使用临时表。 ★外键对应的是参照完整性，一个表的外键可以为NULL，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。 ★定义外键时，创建先创建父表。定义外键后，插入先插入父表数据，同理，删除先删除子表数据。 数据表的存储引擎只能为InnoDB。（编辑数据库的默认存储引擎，修改完需要重启MySQL服务） 外键列（加FOREIGN KEY关键词的一列）和参照列（外键列参照的一列）必须具有相似的数据类型,如果是数字数据类型，则数字长度或者是否有符号位必须相同；如果为字符数据类型长度可以不同。 ★外键列和参照列（主键在创建的同时，会自动创建索引seq_in_index）必须创建索引。如果外键列不存在索引的话，MySQL将自动创建。 与主键的区别 一张表可以有多个外键，但是主键最多只有一个。 按外键约束的字段数量分类 单一外键：给一个字段添加外键约束 复合外键：给多个字段联合添加一个外键约束 表复合外键（表级定义）1FOREIGN KEY(classno) REFERENCES t_class(cno); 非空约束用NOT NULL约束的字段不能为NULL值，必须给定具体的数据。 注意的是 NULL，表示空，并不是字符串中的空。两者需要区分开。 实例12345678910mysql&gt; CREATE TABLE t12(id INT NOT NULL); #设置字段id不为空Query OK, 0 rows affected (0.03 sec)mysql&gt; DESC t12;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| id | int(11) | NO | | NULL | |+-------+---------+------+-----+---------+-------+row in set (0.01 sec) 验证 12mysql&gt; INSERT INTO t12 VALUES(); #不能插入空ERROR 1364 (HY000): Field 'id' doesn't have a default value 唯一约束UNIQUE约束的字段，具有唯一性，不可重复，但可以为NULL。 列级约束123456mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; email varchar(128) unique -&gt; );Query OK, 0 rows affected (0.03 sec) 表级约束123456mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; email varchar(128）， -&gt; unique(email) -&gt; ); 如果插入相同email会报错 12345mysql&gt; insert into t_user(id,name,email) values(1,'xlj','932834897@qq.com');Query OK, 1 row affected (0.00 sec)mysql&gt; insert into t_user(id,name,email) values(2,'jay','932834897@qq.com');ERROR 1062 (23000): Duplicate entry '932834897@qq.com' for key 'email' 扩展：联合唯一约束12345678910111213141516171819202122232425262728293031323334353637383940# 创建services表mysql&gt; create table services( id int, ip char(15), port int, unique(id), unique(ip,port) );Query OK, 0 rows affected (0.05 sec)mysql&gt; desc services;+-------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+----------+------+-----+---------+-------+| id | int(11) | YES | UNI | NULL | || ip | char(15) | YES | MUL | NULL | || port | int(11) | YES | | NULL | |+-------+----------+------+-----+---------+-------+rows in set (0.01 sec)#联合唯一，只要两列记录，有一列不同，既符合联合唯一的约束mysql&gt; insert into services values (1,'192,168,11,23',80), (2,'192,168,11,23',81), (3,'192,168,11,25',80);Query OK, 3 rows affected (0.01 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; select * from services;+------+---------------+------+| id | ip | port |+------+---------------+------+| 1 | 192,168,11,23 | 80 || 2 | 192,168,11,23 | 81 || 3 | 192,168,11,25 | 80 |+------+---------------+------+rows in set (0.00 sec)mysql&gt; insert into services values (4,'192,168,11,23',80);ERROR 1062 (23000): Duplicate entry '192,168,11,23-80' for key 'ip' 更多可参考 mysql 给表添加唯一约束、联合唯一约束，指定唯一约束的名字 默认约束为某一字段提供默认值。 创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值 实例1234create table tb1( id int not null, sex char defalut 'b'); 验证 1234567891011mysql&gt; insert into tb1(id) values(1); #给t11表插一个空的值Query OK, 1 row affected (0.00 sec)#查询结果如下mysql&gt; select * from t11;+------+------+| id | sex |+------+------+| 1 | b |+------+------+row in set (0.00 sec) 主要文献：[部分概念来自C语言中文网] http://c.biancheng.net/view/2440.html[大部分案例的代码块来自CSDN] https://blog.csdn.net/w_linux/article/details/79655073 注：案例中的SQL语句并非作者写的，存在规范问题，但不影响阅读。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[转]MySQL数据类型：UNSIGNED注意事项","slug":"转-MySQL数据类型：UNSIGNED注意事项","date":"2020-02-16T07:58:09.000Z","updated":"2020-02-16T08:00:19.716Z","comments":true,"path":"2020/02/16/转-MySQL数据类型：UNSIGNED注意事项/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/16/%E8%BD%AC-MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9AUNSIGNED%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"原文链接：https://www.cnblogs.com/blankqdb/archive/2012/11/03/blank_qdb.html","text":"原文链接：https://www.cnblogs.com/blankqdb/archive/2012/11/03/blank_qdb.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"HTML：基础网页开发语言","slug":"HTML基础网页开发语言","date":"2020-02-16T06:43:00.000Z","updated":"2020-02-17T14:36:05.092Z","comments":true,"path":"2020/02/16/HTML基础网页开发语言/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/16/HTML%E5%9F%BA%E7%A1%80%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/","excerpt":"概念HTML是最基础的网页开发语言 Hyper Text Markup Language 超文本标记语言 超文本 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本 标记语言 由标签构成的语言。 &lt;标签名称&gt; ,如 &lt;html&gt;，&lt;xml&gt; 标记语言不是编程语言 快速入门语法 html文档后缀名: .html 或者 .htm 标签分为 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt; 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt; 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 html的标签不区分大小写，但是建议使用小写html的标签 代码示例123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color='red'&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color='green'&gt;Hello World&lt;/font&gt; &lt;/body&gt;&lt;/html&gt;","text":"概念HTML是最基础的网页开发语言 Hyper Text Markup Language 超文本标记语言 超文本 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本 标记语言 由标签构成的语言。 &lt;标签名称&gt; ,如 &lt;html&gt;，&lt;xml&gt; 标记语言不是编程语言 快速入门语法 html文档后缀名: .html 或者 .htm 标签分为 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt; 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt; 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 html的标签不区分大小写，但是建议使用小写html的标签 代码示例123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color='red'&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color='green'&gt;Hello World&lt;/font&gt; &lt;/body&gt;&lt;/html&gt; 标签学习文件标签 构成html最基本的标签 html html文档的根标签 head 头标签。用于指定html文档的一些属性。引入外部的资源 title 标题标签。 body 体标签 html5中定义该文档是html文档 文本标签 和文本有关的标签 &lt;!-- --&gt;：注释 &lt;h1&gt;~&lt;h6&gt;：标题标签 h1~h6:字体大小逐渐递减 &lt;p&gt;：段落标签 &lt;br&gt;：换行标签 &lt;hr&gt;：展示一条水平线 属性： color：颜色 width：宽度 size：高度 align：对其方式 center：居中 left：左对齐 right：右对齐 &lt;b&gt;：字体加粗 &lt;i&gt;：字体斜体 &lt;center&gt;:文本居中 &lt;font&gt;:字体标签 属性： color：颜色 size：大小 face：字体 属性定义color 英文单词： red,green,blue rgb(值1，值2，值3)： 值的范围：0~255 如 rgb(0,0,255) #值1值2值3： 值的范围：00~FF之间。如： #FF00FF width 数值： width=’20’ ,数值的单位，默认是 px(像素) 数值% width=’20%’,占比相对于父元素的比例 图片标签&lt;img&gt;：展示图片 属性src：指定图片的位置 相对路径：以.开头的路径 ./:代表当前目录, 如 ./image/1.jpg ../:代表上一级目录 代码1234&lt;!--展示一张图片 img--&gt;&lt;img src=\"image/jingxuan_2.jpg\" align=\"right\" alt=\"古镇\" width=\"500\" height=\"500\"/&gt;&lt;img src=\"./image/jiangwai_1.jpg\"&gt;&lt;img src=\"../image/jiangwai_1.jpg\"&gt; 列表标签有序列表最外层用&lt;ol&gt;内层&lt;li&gt;：列表项 注意 默认为 数字1 开始排序。 可使用 type 属性，规定排序方式为“1/A/a/Ⅰ/ⅰ”。建议使用CSS样式。 也可以用 start 属性，规定起始位置。但是 HTML5 不赞成使用。建议使用CSS样式。 无序列表最外层用&lt;ul&gt;内层&lt;li&gt;：列表项 注意 默认列表项符号为 实心圆点· 。 可使用 type 属性，规定符号为“disc/square/circle” 。但是HTML5不支持。建议使用CSS样式。 链接标签&lt;a&gt;:定义一个超链接 属性 href：指定访问资源的URL(统一资源定位符) target：指定打开资源的方式 _self:默认值，在当前页面打开 _blank：在空白页面打开 代码1234567&lt;!-- 文本 --&gt;&lt;a href=\"http://www.itcast.cn\"&gt;点我&lt;/a&gt; &lt;a href=\"http://www.itcast.cn\" target=\"_self\"&gt;点我&lt;/a&gt;&lt;a href=\"http://www.itcast.cn\" target=\"_blank\"&gt;点我&lt;/a&gt; &lt;!-- 图片 --&gt;&lt;a href=\"http://www.itcast.cn\"&gt;&lt;img src=\"image/jiangwai_1.jpg\"&gt;&lt;/a&gt; div&lt;div&gt;:每一个div占满一整行。块级标签 属性align left right center justify 不赞成使用。请使用样式取而代之。 代码示例12345&lt;div class=\"news\"&gt; &lt;h2&gt;News headline 1&lt;/h2&gt; &lt;p&gt;some text. some text. some text...&lt;/p&gt; ... &lt;/div&gt; 注意/提示 是一个块级元素，也就是说，浏览器通常会在 div 元素前后放置一个换行符。 如果用 id 或 class 来标记 &lt;div&gt;，那么该标签的作用会变得更加有效。 提示：请使用 元素来组合块级元素，这样就可以使用样式对它们进行格式化。 全局属性 标签支持 HTML 中的[全局属性](https://www.w3school.com.cn/tags/html_ref_standardattributes.asp)。 事件属性 标签支持 HTML 中的[事件属性](https://www.w3school.com.cn/tags/html_ref_eventattributes.asp)。 span&lt;span&gt;:文本信息在一行展示，行内标签 内联标签 代码示例1&lt;p&gt;&lt;span&gt;some text.&lt;/span&gt;some other text.&lt;/p&gt; 注意/提示可以为 span 应用 id 或 class 属性，这样既可以增加适当的语义，又便于对 span 应用样式。 可以对同一个 元素应用 class 或 id 属性，但是更常见的情况是只应用其中一种。这两者的主要差异是，class 用于元素组（类似的元素，或者可以理解为某一类元素），而 id 用于标识单独的唯一的元素。 提示：事实上，您也许已经注意到了，W3School 站点上有一些文本的样式与其他文本是不同的。比如“提示”使用了粗体的橘红色。尽管实现这种效果的方法非常多，但是我们的做法是：使用“提示”使用 span 元素，然后对这个 span 元素的父元素，即 p 元素应用 class，这样就可以对这个类的子元素 span 应用相应的样式了。 HTML: 1&lt;p class=\"tip\"&gt;&lt;span&gt;提示：&lt;/span&gt;... ... ...&lt;/p&gt; CSS: 1234p.tip span { font-weight:bold; color:#ff9955; } 全局属性 标签支持 HTML 中的全局属性。 事件属性 标签支持 HTML 中的事件属性。 语义化标签html5中为了提高程序的可读性，提供了一些标签。 &lt;header&gt;：页眉 &lt;footer&gt;：页脚 表格标签 &lt;table&gt;：定义表格 width：宽度 border：边框 cellpadding：定义内容和单元格的距离 cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、 bgcolor：背景色 align：对齐方式 &lt;tr&gt;：定义行 bgcolor：背景色 align：对齐方式 &lt;td&gt;：定义单元格 colspan：合并列 rowspan：合并行 &lt;th&gt;：定义表头单元格 &lt;caption&gt;：表格标题 &lt;thead&gt;：表示表格的头部分 &lt;tbody&gt;：表示表格的体部分 &lt;tfoot&gt;：表示表格的脚部分 表单标签 概念：用于采集用户输入的数据的。用于和服务器进行交互。 &lt;form&gt;：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围 &lt;form&gt;中的属性 action：指定提交数据的URL method:指定提交方式 分类：一共7种，2种比较常用 get： 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。 请求参数大小是有限制的。 不太安全。 post： 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解) 请求参数的大小没有限制。 较为安全。 注意表单项中的数据要想被提交：必须指定其name属性 表单项标签&lt;input&gt;可以通过type属性值，改变元素展示的样式 type属性 text：文本输入框，默认值 placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 password：密码输入框 radio:单选框 注意： 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 checkbox：复选框 注意： 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 file：文件选择框 hidden：隐藏域，用于提交一些信息。 按钮： submit：提交按钮。可以提交表单 button：普通按钮 image：图片提交按钮 src属性指定图片的路径 &lt;label&gt;指定输入项的文字描述信息 注意：label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。 &lt;select&gt;下拉列表select 元素可创建单选或多选菜单。 注意：&lt;select&amp;&gt; 元素中的 &lt;option&gt; 标签用于定义列表中的可用选项。 &lt;textarea&gt;文本域 属性： cols：指定列数，每一行有多少个字符 rows：默认多少行 表单案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!--定义表单 form--&gt;&lt;form action=\"#\" method=\"post\"&gt;&lt;table&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"username\"&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"username\" id=\"username\" placeholder=\"请输入用户名\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"password\"&gt;密码&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"password\" name=\"password\" id=\"password\" placeholder=\"请输入密码\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"email\"&gt;Email&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"email\" name=\"email\" id=\"email\" placeholder=\"请输入邮箱\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"name\"&gt;姓名&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"name\" id=\"name\" placeholder=\"请输入姓名\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"tel\"&gt;手机号&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"tel\" id=\"tel\" placeholder=\"请输入手机号\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt; &lt;input type=\"radio\" name=\"gender\" value=\"male\"&gt; 男 &lt;input type=\"radio\" name=\"gender\" value=\"female\"&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"birthday\"&gt;出生日期&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"date\" name=\"birthday\" id=\"birthday\" placeholder=\"请输入出生日期\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"checkcode\" &gt;验证码&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"checkcode\" id=\"checkcode\" placeholder=\"请输入验证码\"&gt; &lt;img id=\"img_check\" src=\"img/verify_code.jpg\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\" align=\"center\"&gt;&lt;input type=\"submit\" id=\"btn_sub\" value=\"注册\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/form&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"}]},{"title":"Web 概述","slug":"Web 概述","date":"2020-02-16T03:17:00.000Z","updated":"2020-02-19T04:48:24.442Z","comments":true,"path":"2020/02/16/Web 概述/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/16/Web%20%E6%A6%82%E8%BF%B0/","excerpt":"JavaWeb使用Java语言开发基于互联网的项目 今后主要使用B/S架构 软件架构C/S：Clien/Server 客服端/服务器端在用户本地有一个客户端程序，在远程有一个服务器端。如：QQ，讯雷…… 优点 用户体验好 缺点 开发、安装、部署、维护，麻烦 ★B/S：Browser/Server 浏览器/服务器端只需要一个浏览器，用户通过不同的网站（URL），客户访问不同的服务器端程序 优点： 开发、安装、部署、维护，简单 缺点 如果应用过大，用户的体验可能会受到影响 对硬件要求过高（带宽要高，……）","text":"JavaWeb使用Java语言开发基于互联网的项目 今后主要使用B/S架构 软件架构C/S：Clien/Server 客服端/服务器端在用户本地有一个客户端程序，在远程有一个服务器端。如：QQ，讯雷…… 优点 用户体验好 缺点 开发、安装、部署、维护，麻烦 ★B/S：Browser/Server 浏览器/服务器端只需要一个浏览器，用户通过不同的网站（URL），客户访问不同的服务器端程序 优点： 开发、安装、部署、维护，简单 缺点 如果应用过大，用户的体验可能会受到影响 对硬件要求过高（带宽要高，……） B/S架构详解客户端浏览器通过URL，向服务器端发送请求，请求一些资源，资源就包括“静态资源”和“动态资源”。服务器端就会响应，返回这些资源。 B/S架构是JavaWeb开发中重要的架构 资源分类静态资源使用静态网页开发技术发布的资源 特点 所有用户访问，得到的结果是一样的 如：文本，图片，音频，视频，HTML，CSS，JavaScript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎 静态资源可以直接被浏览器解析 1.HTML，CSS，JavaScript 统称：静态网页开发技术，也称静态网页三剑客2.经过解析引擎解析后，可以在浏览器中浏览图片、文字、超链接等3.不同浏览器的解析引擎不同，最终显示的网页可能不同 HTML用于搭建基础网页，展示页面的内容 CSS用于美化页面，布局页面 JavaScript控制页面的元素，让页面有一些动态的效果 ★动态资源使用动态网页技术发布的资源 动态资源是今后学习JavaWeb的重点之一 特点 所用用户访问，得到的结果可能不一样 如：jsp/servlet，php，asp…… 如果用户请求的是动态资源，那么服务器会执行动态资源转换为静态资源，再发送给用户 学习动态资源前，必须学习静态资源！ 网络通信三要素IP 电子设备(计算机)在网络中的唯一标识 端口 应用程序在计算机中的唯一标识。 值范围：0~65536 传输协议 规定了数据传输的规则 基础协议： tcp：安全协议，三次握手。 速度稍慢。 udp：不安全协议。 速度快。 Web服务器软件服务器 安装了服务器软件的计算机 服务器软件 接收用户的请求，处理请求，做出响应 Web服务器软件 接收用户的请求，处理请求，做出响应。 在Web服务器软件中，可以部署Web项目，让用户通过浏览器来访问这些项目 Web容器 常见的Java相关的Web服务器软件 WebLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 WebSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Web","slug":"Web","permalink":"https://melodyjerry.github.io/blog/tags/Web/"}]},{"title":"MySQL的数据类型","slug":"MySQL的数据类型","date":"2020-02-15T12:42:25.000Z","updated":"2020-02-15T03:21:21.247Z","comments":true,"path":"2020/02/15/MySQL的数据类型/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/15/MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"MySQL的数据类型数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。 如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。 MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持所有标准SQL数值数据类型。 MySQL支持多种类型，大致可以分为三类： 数值 日期/时间 字符(串)类型。 数据类型分类 数值类型（整数类型和小数类型） 整数类型：包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT。 小数类型： 浮点数类型包括 FLOAT 和 DOUBLE。 定点数类型为 DECIMAL。 日期/时间类型 包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。 字符类型（文本字符串和二进制字符串） 字符串类型：包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。 二进制类型：包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。","text":"MySQL的数据类型数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。 如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。 MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持所有标准SQL数值数据类型。 MySQL支持多种类型，大致可以分为三类： 数值 日期/时间 字符(串)类型。 数据类型分类 数值类型（整数类型和小数类型） 整数类型：包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT。 小数类型： 浮点数类型包括 FLOAT 和 DOUBLE。 定点数类型为 DECIMAL。 日期/时间类型 包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。 字符类型（文本字符串和二进制字符串） 字符串类型：包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。 二进制类型：包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 数值类型MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值(整数)数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值(小数)数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 整数类型 整数类型又称数值型数据，数值型数据类型主要用来存储数字。 MySQL提供了多种数值型数据类型，不同的数据类型提供不同的取值范围，可以存储的值范围越大，所需的存储空间也会越大。 MySQL 主要提供的整数类型有 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，其属性字段可以添加 AUTO_INCREMENT 自增约束条件。下表中列出了 MySQL 中的数值类型。 类型名称 说明 存储需求 TINYINT 很小的整数 1个字节 SMALLINT 小的整数 2个宇节 MEDIUMINT 中等大小的整数 3个字节 INT (INTEGHR) 普通大小的整数 4个字节 BIGINT 大整数 8个字节 从上表中可以看到，不同类型的整数存储所需的字节数不相同，占用字节数最小的是 TINYINT 类型，占用字节最大的是 BIGINT 类型，占用的字节越多的类型所能表示的数值范围越大。 根据占用字节数可以求出每一种数据类型的取值范围。例如，TINYINT 需要 1 个字节（8bit）来存储，那么 TINYINT 无符号数的最大值为 28-1，即 255；TINYINT 有符号数的最大值为 27-1，即 127。其他类型的整数的取值范围计算方法相同，如下表所示。 类型名称 有符号值 无符号值 字节数 TINYINT -128〜127(-2^7 ~ 2^7-1) 0 〜255(0 ~ 2^8-1) 1 SMALLINT -32768〜32767(-2^15 ~ 2^15-1) 0〜65535(0 ~ 2^16-1) 2 MEDIUMINT -8388608〜8388607(-2^23 ~ 2^23-1) 0〜16777215(0 ~ 2^24-1) 3 INT (INTEGER) -2147483648〜2147483647(-2^31 ~ 2^31-1) 0〜4294967295(0 ~ 2^32-1) 4 BIGINT -9223372036854775808〜9223372036854775807(-2^63 ~ 2^63-1) 0〜18446744073709551615(0 ~ 2^64-1) 8 提示：显示宽度和数据类型的取值范围是无关的。显示宽度只是指明 MySQL 最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充。如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，year 字段插入 19999，当使用 SELECT 查询该列值的时候，MySQL 显示的将是完整的带有 5 位数字的 19999，而不是 4 位数字的值。 其他整型数据类型也可以在定义表结构时指定所需的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。 不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。 小数类型MySQL 中使用浮点数和定点数来表示小数。 浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL。 浮点类型和定点类型都可以用(M, D)来表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。 浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2），分别表示显示宽度和小数位数。M 和 D 在 FLOAT 和DOUBLE 中是可选的，FLOAT 和 DOUBLE 类型将被保存为硬件所支持的最大精度。DECIMAL 的默认 D 值为 0、M 值为 10。 下表中列出了 MySQL 中的小数类型和存储需求。 类型名称 说明 存储范围 存储需求 FLOAT 单精度浮点数，精确到大约7位小数位 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 DECIMAL 类型不同于 FLOAT 和 DOUBLE。DOUBLE 实际上是以字符串的形式存放的，DECIMAL 可能的最大取值范围与 DOUBLE 相同，但是有效的取值范围由 M 和 D 决定。如果改变 M 而固定 D，则取值范围将随 M 的变大而变大。 从上表中可以看到，DECIMAL 的存储空间并不是固定的，而由精度值 M 决定，占用 M+2 个字节。 FLOAT 类型的取值范围如下： 有符号的取值范围：-3.402823466E+38～-1.175494351E-38。 无符号的取值范围：0 和 -1.175494351E-38～-3.402823466E+38。 DOUBLE 类型的取值范围如下： 有符号的取值范围：-1.7976931348623157E+308～-2.2250738585072014E-308。 无符号的取值范围：0 和 -2.2250738585072014E-308～-1.7976931348623157E+308。 提示：不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。 FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。 浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。 最后再强调一下：在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。 日期/时间类型MySQL 中有多处表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。 每个时间类型有一个有效值范围和一个”零”值。当指定不合法的MySQL不能表示的值时，系统将“零”值插入数据库中。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP（时间戳） YYYY-MM-DD HH:MM:SS 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 4 个字节 YEAR 类型YEAR 类型是一个单字节类型，用于表示年，在存储时只需要 1 个字节。可以使用各种格式指定 YEAR，如下所示： 以 4 位字符串或者 4 位数字格式表示的 YEAR，范围为 ‘1901’～’2155’。输入格式为 ‘YYYY’ 或者 YYYY，例如，输入 ‘2010’ 或 2010，插入数据库的值均为 2010。 以 2 位字符串格式表示的 YEAR，范围为 ‘00’ 到 ‘99’。’00’～’69’ 和 ‘70’～’99’ 范围的值分别被转换为 2000～2069 和 1970～1999 范围的 YEAR 值。’0’ 与 ‘00’ 的作用相同。插入超过取值范围的值将被转换为 2000。 以 2 位数字表示的 YEAR，范围为 1～99。1～99 和 70～99 范围的值分别被转换为 2001～2069 和 1970～1999 范围的 YEAR 值。注意，在这里 0 值将被转换为 0000，而不是 2000。 提示：两位整数范围与两位字符串范围稍有不同。例如，插入 3000 年，读者可能会使用数字格式的 0 表示 YEAR，实际上，插入数据库的值为 0000，而不是所希望的 3000。只有使用字符串格式的 ‘0’ 或 ‘00’，才可以被正确解释为 3000，非法 YEAR值将被转换为 0000。 TIME 类型TIME 类型用于只需要时间信息的值，在存储时需要 3 个字节。格式为 HH:MM:SS。HH 表示小时，MM 表示分钟，SS 表示秒。 TIME 类型的取值范围为 -838：59：59～838：59：59，小时部分如此大的原因是 TIME 类型不仅可以用于表示一天的时间（必须小于 24 小时），还可能是某个事件过去的时间或两个事件之间的时间间隔（可大于 24 小时，或者甚至为负）。 可以使用各种格式指定 TIME 值，如下所示。 ‘D HH：MM：SS’ 格式的字符串。还可以使用这些“非严格”的语法：’HH：MM：SS’、’HH：MM’、’D HH’ 或 ‘SS’。这里的 D 表示日，可以取 0～34 之间的值。在插入数据库时，D 被转换为小时保存，格式为 “D*24+HH”。 ‘HHMMSS’ 格式、没有间隔符的字符串或者 HHMMSS 格式的数值，假定是有意义的时间。例如，’101112’ 被理解为’10：11：12’，但是 ‘106112’ 是不合法的（它有一个没有意义的分钟部分），在存储时将变为 00：00：00。 提示：为 TIME 列分配简写值时应注意：如果没有冒号，MySQL 解释值时，假定最右边的两位表示秒。（MySQL 解释 TIME 值为过去的时间而不是当前的时间）。例如，读者可能认为 ‘1112’ 和 1112 表示 11：12：00（即 11 点过 12 分钟），但MySQL 将它们解释为 00：11：12（即 11 分 12 秒）。同样 ‘12’ 和 12 被解释为00：00：12。相反，TIME 值中如果使用冒号则肯定被看作当天的时间，也就是说，’11：12’ 表示 11：12：00，而不是 00：11：12。 DATE 类型DATE 类型用于仅需要日期值时，没有时间部分，在存储时需要 3 个字节。日期格式为 ‘YYYY-MM-DD’，其中 YYYY 表示年，MM 表示月，DD 表示日。 在给 DATE 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATE 的日期格式即可。如下所示： 以 ‘YYYY-MM-DD’ 或者 ‘YYYYMMDD’ 字符中格式表示的日期，取值范围为 ‘1000-01-01’～’9999-12-3’。例如，输入 ‘2015-12-31’ 或者 ‘20151231’，插入数据库的日期为2015-12-31。 以 ‘YY-MM-DD’ 或者 ‘YYMMDD’ 字符串格式表示日期，在这里YY表示两位的年值。MySQL 解释两位年值的规则：’00～69’ 范围的年值转换为 ‘20002069’，’7099’ 范围的年值转换为 ‘1970～1999’。例如，输入 ‘15-12-31’，插入数据库的日期为 2015-12-31；输入 ‘991231’，插入数据库的日期为 1999-12-31。 以 YYMMDD 数字格式表示的日期，与前面相似，00~69 范围的年值转换为 2000～2069，80～99 范围的年值转换为 1980～1999。例如，输入 151231，插入数据库的日期为 2015-12-31，输入 991231，插入数据库的日期为 1999-12-31。 使用 CURRENT_DATE 或者 NOW()，插入当前系统日期。 提示：MySQL 允许“不严格”语法：任何标点符号都可以用作日期部分之间的间隔符。例如，’98-11-31’、’98.11.31’、’98/11/31’和‘98@11@31’ 是等价的，这些值也可以正确地插入数据库。 DATETIME 类型DATETIME 类型用于需要同时包含日期和时间信息的值，在存储时需要 8 个字节。日期格式为 ‘YYYY-MM-DD HH：MM：SS’，其中 YYYY 表示年，MM 表示月，DD 表示日，HH 表示小时，MM 表示分钟，SS 表示秒。 在给 DATETIME 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATETIME 的日期格式即可，如下所示。 以 ‘YYYY-MM-DD HH：MM：SS’ 或者 ‘YYYYMMDDHHMMSS’ 字符串格式表示的日期，取值范围为 ‘1000-01-01 00：00：00’～’9999-12-3 23：59：59’。例如，输入 ‘2014-12-31 05：05：05’ 或者 ‘20141231050505’，插入数据库的 DATETIME 值都为 2014-12-31 05：05：05。 以 ‘YY-MM-DD HH：MM：SS’ 或者 ‘YYMMDDHHMMSS’ 字符串格式表示的日期，在这里 YY 表示两位的年值。与前面相同，’00～79’ 范围的年值转换为 ‘2000～2079’，’80～99’ 范围的年值转换为 ‘1980～1999’。例如，输入 ‘14-12-31 05：05：05’，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。 以 YYYYMMDDHHMMSS 或者 YYMMDDHHMMSS 数字格式表示的日期和时间。例如，输入 20141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 140505050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。 提示：MySQL 允许“不严格”语法：任何标点符号都可用作日期部分或时间部分之间的间隔符。例如，’98-12-31 11：30：45’、’98.12.31 11+30+35’、’98/12/31 113045’ 和 ‘98@12@31 11^30^45’ 是等价的，这些值都可以正确地插入数据库。 TIMESTAMP 类型TIMESTAMP 的显示格式与 DATETIME 相同，显示宽度固定在 19 个字符，日期格式为 YYYY-MM-DD HH：MM：SS，在存储时需要 4 个字节。但是 TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，为 ‘1970-01-01 00：00：01’UTC～’2038-01-19 03：14：07’UTC。在插入数据时，要保证在合法的取值范围内。 提示：协调世界时（英：Coordinated Universal Time，法：Temps Universel Coordonné）又称为世界统一时间、世界标准时间、国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。 TIMESTAMP 与 DATETIME 除了存储字节和支持的范围不同外，还有一个最大的区别是： DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关； 而 TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。 提示：如果为一个 DATETIME 或 TIMESTAMP 对象分配一个 DATE 值，结果值的时间部分被设置为 ‘00：00：00’，因此 DATE 值未包含时间信息。如果为一个 DATE 对象分配一个 DATETIME 或 TIMESTAMP 值，结果值的时间部分被删除，因此DATE 值未包含时间信息。 字符类型MySQL 支持两类字符型数据：字符串类型和二进制类型 包括CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小/存储需求 说明/用途 CHAR 0-255字节 定长字符串 CHAR(M) M 字节，1&lt;=M&lt;=255 固定长度非二进制字符串 VARCHAR 0-65535 字节 变长字符串 1VARCHAR(M) L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255 变长非二进制字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 ENUM（枚举值） 1或2个字节，取决于枚举值的数目 (最大值为65535) 枚举类型，只能有一个枚举字符串值。一次从中只选择一个。 SET（集合） 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） 一个设置，字符串对象可以有零个或 多个SET成员。在集合中做任意的排列组合（任取一个或几个数据） CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 字符串类型 又称“文本字符串类型”。 字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据。字符串可以区分或者不区分大小写的串比较，还可以进行正则表达式的匹配查找。 MySQL 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。 下表中列出了 MySQL 中的字符串数据类型，括号中的M表示可以为其指定长度。 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1&lt;=M&lt;=255 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255 TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L&lt;2^8 TEXT 小的非二进制字符串 L+2字节，在此，L&lt;2^16 MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L&lt;2^24 LONGTEXT 大的非二进制字符串 L+4字节，在此，L&lt;2^32 ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） VARCHAR 和 TEXT 类型是变长类型，其存储需求取决于列值的实际长度（在前面的表格中用 L 表示），而不是取决于类型的最大可能尺寸。 例如，一个 VARCHAR(10) 列能保存一个最大长度为 10 个字符的字符串，实际的存储需要字符串的长度 L 加上一个字节以记录字符串的长度。对于字符 “abcd”，L 是 4，而存储要求 5 个字节。 CHAR 和 VARCHAR 类型CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255 个字符。 例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当检索到 CHAR 值时，尾部的空格将被删除。 VARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0～65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。 例如，VARCHAR(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。VARCHAR 在值保存和检索时尾部的空格仍保留。 【实例】下面将不同的字符串保存到 CHAR(4) 和 VARCHAR(4) 列，说明 CHAR 和 VARCHAR 之间的差别，如下表所示。 插入值 CHAR(4) 存储需求 VARCHAR(4) 存储需求 ‘ ‘ ‘ ‘ 4字节 ‘’ 1字节 ‘ab’ ‘ab ‘ 4字节 ‘ab’ 3字节 ‘abc’ ‘abc ‘ 4字节 ‘abc’ 4字节 ‘abcd’ ‘abcd’ 4字节 ‘abcd’ 5字节 ‘abcdef’ ‘abcd’ 4字节 ‘abcd’ 5字节 对比结果可以看到，CHAR(4) 定义了固定长度为 4 的列，无论存入的数据长度为多少，所占用的空间均为 4 个字节。VARCHAR(4) 定义的列所占的字节数为实际长度加 1。 TEXT 类型TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。 TEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。 TINYTEXT 表示长度为 255（28-1）字符的 TEXT 列。 TEXT 表示长度为 65535（216-1）字符的 TEXT 列。 MEDIUMTEXT 表示长度为 16777215（224-1）字符的 TEXT 列。 LONGTEXT 表示长度为 4294967295 或 4GB（232-1）字符的 TEXT 列。 ENUM 类型ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下： 1&lt;字段名&gt; ENUM( '值1', '值1', …, '值n' ) 字段名指将要定义的字段，值 n 指枚举列表中第 n 个值。 ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。 ENUM 值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号，枚举最多可以有 65535 个元素。 例如，定义 ENUM 类型的列（’first’，’second’，’third’），该列可以取的值和每个值的索引如下表所示。 值 索引 NULL NULL ‘’ 0 ’first 1 second 2 third 3 ENUM 值依照列索引顺序排列，并且空字符串排在非空字符串前，NULL 值排在其他所有枚举值前。 提示：ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。 SET 类型SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下： 1SET( '值1', '值2', …, '值n' ) 与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。 但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。 提示：如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。 二进制类型 二进制字符串类型有时候也直接被称为“二进制类型”。 MySQL 中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 下表中列出了 MySQL 中的二进制数据类型，括号中的M表示可以为其指定长度。 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)/8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L&lt;2^8 BLOB (M) 小 BLOB L+2 字节，在此，L&lt;2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L&lt;2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L&lt;2^32 BIT 类型位字段类型。M 表示每个值的位数，范围为 1～64。如果 M 被省略，默认值为 1。如果为 BIT(M) 列分配的值的长度小于 M 位，在值的左边用 0 填充。例如，为 BIT(6) 列分配一个值 b’101’，其效果与分配 b’000101’ 相同。 BIT 数据类型用来保存位字段值，例如以二进制的形式保存数据 13，13 的二进制形式为 1101，在这里需要位数至少为 4 位的 BIT 类型，即可以定义列类型为 BIT(4)。大于二进制 1111 的数据是不能插入 BIT(4) 类型的字段中的。 提示：默认情况下，MySQL 不可以插入超出该列允许范围的值，因而插入数据时要确保插入的值在指定的范围内。 BINARY 和 VARBINARY 类型BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字节字符串。使用的语法格式如下： 列名称 BINARY(M) 或者 VARBINARY(M) BINARY 类型的长度是固定的，指定长度后，不足最大长度的，将在它们右边填充 “\\0” 补齐，以达到指定长度。例如，指定列数据类型为 BINARY(3)，当插入 a 时，存储的内容实际为 “\\a0\\0”，当插入 ab 时，实际存储的内容为“ab\\0”，无论存储的内容是否达到指定的长度，存储空间均为指定的值 M。 VARBINARY 类型的长度是可变的，指定好长度之后，长度可以在 0 到最大值之间。例如，指定列数据类型为 VARBINARY(20)，如果插入的值长度只有 10，则实际存储空间为 10 加 1，实际占用的空间为字符串的实际长度加 1。 BLOB 类型BLOB 是一个二进制的对象，用来存储可变数量的数据。BLOB 类型分为 4 种：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB，它们可容纳值的最大长度不同，如下表所示。 数据类型 存储范围 TINYBLOB 最大长度为255 (28-1)字节 BLOB 最大长度为65535 (216-1)字节 MEDIUMBLOB 最大长度为16777215 (224-1)字节 LONGBLOB 最大长度为4294967295或4GB (231-1)字节BLOB 列存储的是二进制字符串（字节字符串），TEXT 列存储的是非进制字符串（字符字符串）。BLOB 列是字符集，并且排序和比较基于列值字节的数值；TEXT 列有一个字符集，并且根据字符集对值进行排序和比较。 以上笔记部分来自 C语言中文网 、百度知道、CSDN。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"hexo d后，网页出现乱码？","slug":"hexo d连后，网页出现乱码？","date":"2020-02-15T05:49:36.000Z","updated":"2020-02-15T05:52:15.140Z","comments":true,"path":"2020/02/15/hexo d连后，网页出现乱码？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/15/hexo%20d%E8%BF%9E%E5%90%8E%EF%BC%8C%E7%BD%91%E9%A1%B5%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81%EF%BC%9F/","excerpt":"问题如平时一样hexo d部署我的博客，但是当我去浏览时候，竟发现乱码。 解决重新hexo三连即可。","text":"问题如平时一样hexo d部署我的博客，但是当我去浏览时候，竟发现乱码。 解决重新hexo三连即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"![rejected]master->master(fetch first)问题的解决方案","slug":"rejected-master-master-fetch-first-问题的解决方案","date":"2020-02-14T11:08:32.000Z","updated":"2020-02-14T11:12:38.870Z","comments":true,"path":"2020/02/14/rejected-master-master-fetch-first-问题的解决方案/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/rejected-master-master-fetch-first-%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"今天在做git push -u origin master时出现了如下错误： 1! [rejected] master -&gt; master (fetch first) 分析原因，基本上可以确定是因为github上的远程库与本地库版本不一致（我对github上的文件做了编辑操作，且未更新到本地，当然也可能还有其他原因…），通过一番研究，找到了两种解决方案： 温柔型方案： 通过git pull先将本地库更新到与远程库一致的版本，但要注意本地库后来做的修改可能被覆盖，最好使用git fetch(不会自动合并)，查看更新情况再有选择合并，或者先将本地库修改过的文件备份，git pull后再重新修改； 再运行git push即可成功。 暴力型方案：git提供了一种强制上传的方式：git push -f，它会忽略版本不一致等问题，强制将本地库上传的远程库，但是一定要谨慎使用，因为-f会用本地库覆盖掉远程库，如果远程库上有重要更新，或者有其他同伴做的修改，也都会被覆盖，所以一定要在确定无严重后果的前提下使用此操作。","text":"今天在做git push -u origin master时出现了如下错误： 1! [rejected] master -&gt; master (fetch first) 分析原因，基本上可以确定是因为github上的远程库与本地库版本不一致（我对github上的文件做了编辑操作，且未更新到本地，当然也可能还有其他原因…），通过一番研究，找到了两种解决方案： 温柔型方案： 通过git pull先将本地库更新到与远程库一致的版本，但要注意本地库后来做的修改可能被覆盖，最好使用git fetch(不会自动合并)，查看更新情况再有选择合并，或者先将本地库修改过的文件备份，git pull后再重新修改； 再运行git push即可成功。 暴力型方案：git提供了一种强制上传的方式：git push -f，它会忽略版本不一致等问题，强制将本地库上传的远程库，但是一定要谨慎使用，因为-f会用本地库覆盖掉远程库，如果远程库上有重要更新，或者有其他同伴做的修改，也都会被覆盖，所以一定要在确定无严重后果的前提下使用此操作。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"}]},{"title":"[转]使用Cmder替换cmd,让开发更高效","slug":"转-使用Cmder替换cmd-让开发更高效","date":"2020-02-14T08:40:25.000Z","updated":"2020-02-14T13:13:08.822Z","comments":true,"path":"2020/02/14/转-使用Cmder替换cmd-让开发更高效/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/%E8%BD%AC-%E4%BD%BF%E7%94%A8Cmder%E6%9B%BF%E6%8D%A2cmd-%E8%AE%A9%E5%BC%80%E5%8F%91%E6%9B%B4%E9%AB%98%E6%95%88/","excerpt":"","text":"第一篇文章https://segmentfault.com/a/1190000021029858?utm_source=tag-newest 以下为第二篇文章的内容 一、为什么要更换为cmder在做项目时，有些时候我想复制控制台上面的代码时，cmd有的时候复制粘贴很麻烦，Cmder则不会，并且Cmder可以分屏多开窗口，可以设置窗口颜色,字体大小，并且很多快捷键和谷歌浏览器操作类似,等等很多功能。 二、官网下载地址: http://cmder.net/ 关于下载进入官网以后，有mini版和完整版，建议完整版，完整版功能更齐全，还可以使用git，下载好解压文件包以后就可以使用。 Cmder界面展示启动Cmder界面如下，当然我设置了背景色，透明度，字体样式，隐藏标签栏栏，增加底部的状态栏，以及分屏功能。 Cmder界面展示 三、关于cmder的一些配置1. 配置环境变量:在系统属性里面配置环境变量，将Cmder.exe所在文件路径添加至Path里 2. 配置右键快捷启动:以管理员身份打开cmd，执行以下命令即可，完了以后在任意地方点击右键即可使用cmder 12// 设置任意地方鼠标右键启动CmderCmder.exe /REGISTER ALL 鼠标右键启动Cmder 3. 界面效果的设置首先使用windows+alt+p进入界面设置 背景色设置 字体设置 背景透明度 隐藏标签栏 显示底部状态栏 将Cmder默认的命令提示符\"λ\"改为“$”， 在cmder\\vendor中的clink.lua内做如下修改”λ”替换成”$” 四、关于Cmder的一些常用快捷键12345678910111213141516171819202122232425Tab 自动路径补全Ctrl+T 建立新页签Ctrl+W 关闭页签Ctrl+Tab 切换页签Alt+F4 关闭所有页签Alt+Shift+1 开启cmd.exeAlt+Shift+2 开启powershell.exeAlt+Shift+3 开启powershell.exe (系统管理员权限)Ctrl+1 快速切换到第1个页签Ctrl+n 快速切换到第n个页签( n值无上限)Alt + enter 切换到全屏状态Ctr+r 历史命令搜索Tab 自动路径补全Ctrl+T 建立新页签Ctrl+W 关闭页签Ctrl+Tab 切换页签Alt+F4 关闭所有页签Alt+Shift+1 开启cmd.exeAlt+Shift+2 开启powershell.exeAlt+Shift+3 开启powershell.exe (系统管理员权限)Ctrl+1 快速切换到第1个页签Ctrl+n 快速切换到第n个页签( n值无上限)Alt + enter 切换到全屏状态Ctr+r 历史命令搜索Win+Alt+P 开启工具选项视窗 五、关于中文乱码问题：将下面的4行命令添加到cmder/config/aliases文件末尾,如果还是不行参考前面字体设置，将前面提到的字体设置里面的Monospace的复选框不选中。还有就是养成良好的编码习惯文件命名最好不要有中文。 123l=ls --show-control-chars la=ls -aF --show-control-chars ll=ls -alF --show-control-chars 作者：_123hhh链接：https://www.jianshu.com/p/5b7c985240a7来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"删除磁盘管理中的OEM分区","slug":"删除磁盘管理中的OEM分区","date":"2020-02-14T08:13:08.000Z","updated":"2020-02-14T08:14:04.000Z","comments":true,"path":"2020/02/14/删除磁盘管理中的OEM分区/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/%E5%88%A0%E9%99%A4%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84OEM%E5%88%86%E5%8C%BA/","excerpt":"用windows自带的工具-DISKPART来实现，而且不会破坏其他分区的数据，具体操作如下： 首先打开CMD，输入 diskpart.exe 回车 提示转入DISKPART 然后输入 rescan 回车 （扫描硬盘） 接着输入 list disk 回车 （硬盘列表，可以看到连接到该主机的硬盘列表） 选择一个磁盘： select disk 磁盘号 回车 显示磁盘中的分区： list partition 回车 选择一个分区： select partition 分区号 回车 删除分区： delete partition override 回车 基本就能删除OEM分区了。","text":"用windows自带的工具-DISKPART来实现，而且不会破坏其他分区的数据，具体操作如下： 首先打开CMD，输入 diskpart.exe 回车 提示转入DISKPART 然后输入 rescan 回车 （扫描硬盘） 接着输入 list disk 回车 （硬盘列表，可以看到连接到该主机的硬盘列表） 选择一个磁盘： select disk 磁盘号 回车 显示磁盘中的分区： list partition 回车 选择一个分区： select partition 分区号 回车 删除分区： delete partition override 回车 基本就能删除OEM分区了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"系统","slug":"系统","permalink":"https://melodyjerry.github.io/blog/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"[工具]ScreenToGif:一款小而实用的屏幕录制生成gif工具","slug":"工具-ScreenToGif-一款小而实用的屏幕录制生成gif工具","date":"2020-02-14T07:27:31.000Z","updated":"2020-02-14T07:29:46.801Z","comments":true,"path":"2020/02/14/工具-ScreenToGif-一款小而实用的屏幕录制生成gif工具/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/%E5%B7%A5%E5%85%B7-ScreenToGif-%E4%B8%80%E6%AC%BE%E5%B0%8F%E8%80%8C%E5%AE%9E%E7%94%A8%E7%9A%84%E5%B1%8F%E5%B9%95%E5%BD%95%E5%88%B6%E7%94%9F%E6%88%90gif%E5%B7%A5%E5%85%B7/","excerpt":"因为写博客或工作等原因，经常需要录制屏幕并制作gif图。ScreenToGif使用了小半年了，给我的感觉就是“小而实用”，大小仅2M多（压缩后才几百K），但却包含了录制及常用的gif处理功能。 ScreenToGif：仅从名字就可以了解到它是一款屏幕转gif图的软件。而事实上，它不仅可以录制屏幕，同时也包含了摄像头录制，白板书写录制等功能，并且在录制后，可以对录制内容进行增删、修改、压缩等处理。 ScreenToGif是一款免安装软件，下载并解压缩后，双击exe文件就可以运行。ScreenToGif还支持打开多次，以上Gif就是用一个ScreenToGif来录制另一个ScreenToGif界面。 上图是ScreenToGif编辑器主页，ScreenToGif分两大功能，录制和编辑，从上图可以看到其编辑功能还是蛮强大的，至少在常规gif制作的功能都包含了： 在编辑中有很多对帧的操作如:增加删除、循环、反转，特别是移除重复帧功能，能很好的减小gif占用内存大小； 而在图片选项中则包含了水印、微动、模糊、字幕、自由文本、自由绘制等功能； ScreenToGif还支持简单的过渡动画； 统计功能则提供了总帧数、总时长、帧大小、延时、帧分辨率等数据的统计； 如下图：在编辑结束后，我们可以根据需求选择适合的类型及编码进行保存； 到目前为止，ScreenToGif已适配20多种语言，并提供上传服务。 ScreenToGif是一个开源项目ScreenToGif Github，本文下方也提供目前最新的2.14.1版本免安装exe程序。 版本2.14.1下载地址 作者：ThinkinLiu_IT老五链接：https://www.jianshu.com/p/17121d0587fc来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","text":"因为写博客或工作等原因，经常需要录制屏幕并制作gif图。ScreenToGif使用了小半年了，给我的感觉就是“小而实用”，大小仅2M多（压缩后才几百K），但却包含了录制及常用的gif处理功能。 ScreenToGif：仅从名字就可以了解到它是一款屏幕转gif图的软件。而事实上，它不仅可以录制屏幕，同时也包含了摄像头录制，白板书写录制等功能，并且在录制后，可以对录制内容进行增删、修改、压缩等处理。 ScreenToGif是一款免安装软件，下载并解压缩后，双击exe文件就可以运行。ScreenToGif还支持打开多次，以上Gif就是用一个ScreenToGif来录制另一个ScreenToGif界面。 上图是ScreenToGif编辑器主页，ScreenToGif分两大功能，录制和编辑，从上图可以看到其编辑功能还是蛮强大的，至少在常规gif制作的功能都包含了： 在编辑中有很多对帧的操作如:增加删除、循环、反转，特别是移除重复帧功能，能很好的减小gif占用内存大小； 而在图片选项中则包含了水印、微动、模糊、字幕、自由文本、自由绘制等功能； ScreenToGif还支持简单的过渡动画； 统计功能则提供了总帧数、总时长、帧大小、延时、帧分辨率等数据的统计； 如下图：在编辑结束后，我们可以根据需求选择适合的类型及编码进行保存； 到目前为止，ScreenToGif已适配20多种语言，并提供上传服务。 ScreenToGif是一个开源项目ScreenToGif Github，本文下方也提供目前最新的2.14.1版本免安装exe程序。 版本2.14.1下载地址 作者：ThinkinLiu_IT老五链接：https://www.jianshu.com/p/17121d0587fc来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"[随笔]相信自己","slug":"随笔-相信自己","date":"2020-02-14T06:55:11.000Z","updated":"2020-02-14T08:20:09.438Z","comments":true,"path":"2020/02/14/随笔-相信自己/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/%E9%9A%8F%E7%AC%94-%E7%9B%B8%E4%BF%A1%E8%87%AA%E5%B7%B1/","excerpt":"下午，起兴想整理笔记本里的数据时，发现了一些有趣的东西，拿出一部分来记作随笔。 相信自己在个人文件夹中，发现一个名为“相信自己”的Word文档，点开来，里面就一句话，简简单单的一句“如果有时候怀疑了，觉得不知道自己为什么一开始要做这个选择，或者觉得自己付出太多不值得，那就想想当初自己做这个决定的初心。或许一切就能释然了”。 一起玩耍吧18年，在网上看到一个视频，教用一些简单VB代码来制作的小程序。 只有连续点击确定/是，才能结束程序。 用来表白/坑人，挺不错的hh 猜猜我用来干嘛呢 ( ͡° ͜ʖ ͡°)✧ ~ 演示👇 制作过程很简单，新建一个txt文本，粘贴我写好的代码，保存后修改后缀为.vbs，完事。 代码👇 12345678910111213msgbox \"我们可以一起玩吗？\",vbQuestion,\"在吗？\"msgbox (\"可以吗？\")dim jdo while j&lt;1Select Case msgbox(\"真的真的真的可以吗？\",68,\"请郑重的回答我\")Case 6 j=1Case 7 msgbox(\"别嘛，我就是要和你一起玩\")end Selectloopmsgbox(\"我就知道你会同意的，啦啦啦\")","text":"下午，起兴想整理笔记本里的数据时，发现了一些有趣的东西，拿出一部分来记作随笔。 相信自己在个人文件夹中，发现一个名为“相信自己”的Word文档，点开来，里面就一句话，简简单单的一句“如果有时候怀疑了，觉得不知道自己为什么一开始要做这个选择，或者觉得自己付出太多不值得，那就想想当初自己做这个决定的初心。或许一切就能释然了”。 一起玩耍吧18年，在网上看到一个视频，教用一些简单VB代码来制作的小程序。 只有连续点击确定/是，才能结束程序。 用来表白/坑人，挺不错的hh 猜猜我用来干嘛呢 ( ͡° ͜ʖ ͡°)✧ ~ 演示👇 制作过程很简单，新建一个txt文本，粘贴我写好的代码，保存后修改后缀为.vbs，完事。 代码👇 12345678910111213msgbox \"我们可以一起玩吗？\",vbQuestion,\"在吗？\"msgbox (\"可以吗？\")dim jdo while j&lt;1Select Case msgbox(\"真的真的真的可以吗？\",68,\"请郑重的回答我\")Case 6 j=1Case 7 msgbox(\"别嘛，我就是要和你一起玩\")end Selectloopmsgbox(\"我就知道你会同意的，啦啦啦\") 💗我爱你们，爸妈！💗看到，我才发现我原来备份了一部分19年七八两月的一些照片。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"IDEA添加jar包的三种方式(小结)","slug":"IDEA 添加jar包的三种方式(小结)","date":"2020-02-13T09:36:53.000Z","updated":"2020-02-23T03:44:14.081Z","comments":true,"path":"2020/02/13/IDEA 添加jar包的三种方式(小结)/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/13/IDEA%20%E6%B7%BB%E5%8A%A0jar%E5%8C%85%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F(%E5%B0%8F%E7%BB%93)/","excerpt":"相关文章： 1、https://www.jb51.net/article/145327.htm 2、https://blog.csdn.net/wangxinyao1997/article/details/87527391 3、https://blog.csdn.net/simple_start/article/details/92422833 4、https://blog.csdn.net/yogima/article/details/81186092?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task","text":"相关文章： 1、https://www.jb51.net/article/145327.htm 2、https://blog.csdn.net/wangxinyao1997/article/details/87527391 3、https://blog.csdn.net/simple_start/article/details/92422833 4、https://blog.csdn.net/yogima/article/details/81186092?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"绚丽彩虹播放器","slug":"绚丽彩虹播放器","date":"2020-02-13T08:16:30.000Z","updated":"2020-02-13T08:21:29.120Z","comments":true,"path":"2020/02/13/绚丽彩虹播放器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/13/%E7%BB%9A%E4%B8%BD%E5%BD%A9%E8%99%B9%E6%92%AD%E6%94%BE%E5%99%A8/","excerpt":"","text":"代码来自绚丽彩虹播放器 123456789101112&lt;!-- Your XlchPlayerKey --&gt;&lt;script&gt;XlchKey=\"O7NQ6f6YIg\";&lt;/script&gt;&lt;!-- font-awesome 4.2.0 --&gt;&lt;link href=\"https://lib.baomitu.com/font-awesome/4.2.0/css/font-awesome.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt;&lt;!-- JQuery 2.2.4 --&gt;&lt;script src=\"https://lib.baomitu.com/jquery/2.2.4/jquery.min.js\"&gt;&lt;/script&gt;&lt;!-- JQuery-mousewheel 3.1.9 --&gt;&lt;script src=\"https://lib.baomitu.com/jquery-mousewheel/3.1.9/jquery.mousewheel.min.js\"&gt;&lt;/script&gt;&lt;!-- Scrollbar --&gt;&lt;script src=\"https://static.https.badapple.top/BadApplePlayer/js/scrollbar.js\"&gt;&lt;/script&gt;&lt;!-- BadApplePlayer --&gt;&lt;script src=\"https://static.https.badapple.top/BadApplePlayer/Player.js\"&gt;&lt;/script&gt; 教程：https://www.liaofuzhan.com/posts/2636059693.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"动态时钟","slug":"动态时钟","date":"2020-02-13T05:28:19.000Z","updated":"2020-02-13T05:51:42.682Z","comments":true,"path":"2020/02/13/动态时钟/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/13/%E5%8A%A8%E6%80%81%E6%97%B6%E9%92%9F/","excerpt":"效果：","text":"效果： 在相应位置添加如下代码： 1234&lt;center&gt;&lt;div&gt;&lt;canvas id=\"canvas\" style=\"width:20%\" width=\"820\" height=\"250\"&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script async=\"\"&gt;!function(){function t(t){var r=[];a.fillStyle=\"#1bc3fb\";var h=new Date,u=70,s=30,v=h.getHours(),g=Math.floor(v/10),m=v%10;r.push({num:g}),r.push({num:m}),r.push({num:10});var c=h.getMinutes(),g=Math.floor(c/10),m=c%10;r.push({num:g}),r.push({num:m}),r.push({num:10});var M=h.getSeconds(),g=Math.floor(M/10),m=M%10;r.push({num:g}),r.push({num:m});for(var p=0;p&lt;r.length;p++)r[p].offsetX=u,u=f(u,s,r[p].num,t),p&lt;r.length-1&amp;&amp;10!=r[p].num&amp;&amp;10!=r[p+1].num&amp;&amp;(u+=l);if(0==i.length)i=r;else for(var C=0;C&lt;i.length;C++)i[C].num!=r[C].num&amp;&amp;(n(r[C]),i[C].num=r[C].num);return e(t),o(),h}function n(t){for(var n=t.num,e=m[n],o=0;o&lt;e.length;o++)for(var f=0;f&lt;e[o].length;f++)if(1==e[o][f]){var a={offsetX:t.offsetX+u+2*u*f,offsetY:30+u+2*u*o,color:g[Math.floor(Math.random()*g.length)],g:1.5+Math.random(),vx:4*Math.pow(-1,Math.ceil(10*Math.random()))+Math.random(),vy:-5};v.push(a)}}function e(t){for(var n=0;n&lt;v.length;n++)t.beginPath(),t.fillStyle=v[n].color,t.arc(v[n].offsetX,v[n].offsetY,u,0,2*Math.PI),t.fill()}function o(){for(var t=0,n=0;n&lt;v.length;n++){var e=v[n];e.offsetX+=e.vx,e.offsetY+=e.vy,e.vy+=e.g,e.offsetY&gt;h-u&amp;&amp;(e.offsetY=h-u,e.vy=-e.vy*s),e.offsetX&gt;u&amp;&amp;e.offsetX&lt;r-u&amp;&amp;(v[t]=v[n],t++)}for(;t&lt;v.length;t++)v.pop()}function f(t,n,e,o){for(var f=m[e],a=0;a&lt;f.length;a++)for(var r=0;r&lt;f[a].length;r++)1==f[a][r]&amp;&amp;(o.beginPath(),o.arc(t+u+2*u*r,n+u+2*u*a,u,0,2*Math.PI),o.fill());return o.beginPath(),t+=f[0].length*u*2}var a,r=820,h=250,u=7,l=10,s=.65,v=[];const g=[\"#33B5E5\",\"#0099CC\",\"#AA66CC\",\"#9933CC\",\"#99CC00\",\"#669900\",\"#FFBB33\",\"#FF8800\",\"#FF4444\",\"#CC0000\"];var i=[],m=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]],c=document.getElementById(\"canvas\");c.width=r,c.height=h,a=c.getContext(\"2d\");new Date;setInterval(function(){a.clearRect(0,0,a.canvas.width,a.canvas.height),t(a)},50)}()&lt;/script&gt;&lt;/center&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"[转]Hexo主题使用Valine-Admin管理评论和评论提醒","slug":"转-Hexo主题使用Valine-Admin管理评论和评论提醒","date":"2020-02-12T16:31:06.000Z","updated":"2020-02-12T17:20:04.551Z","comments":true,"path":"2020/02/13/转-Hexo主题使用Valine-Admin管理评论和评论提醒/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/13/%E8%BD%AC-Hexo%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8Valine-Admin%E7%AE%A1%E7%90%86%E8%AF%84%E8%AE%BA%E5%92%8C%E8%AF%84%E8%AE%BA%E6%8F%90%E9%86%92/","excerpt":"原文链接：https://segmentfault.com/a/1190000021474516?utm_source=tag-newest 前言原本今天在写文章，然后没事就去博客看了一下。突然发现有人在文章下面评论。是早上评论的但是我晚上才看到。 我的留言系统使用的是Valine,发现留言并没有提醒，只有回复了才会有提醒。 这不能忍。毕竟好不容易来个朋友竟然没有交流上你说难受不难受😡 然后我就去百度了一下Valine-Admin Valine-Admin 是一个对 Valine 评论系统的拓展应用，可增强 Valine 的邮件通知功能。基于 Leancloud 的云引擎与云函数。可以提供邮件 通知站长 和 @ 通知 的功能，而且还支持自定义邮件通知模板。 发现这个插件很不错我就研究了一下。下面是整合教程。","text":"原文链接：https://segmentfault.com/a/1190000021474516?utm_source=tag-newest 前言原本今天在写文章，然后没事就去博客看了一下。突然发现有人在文章下面评论。是早上评论的但是我晚上才看到。 我的留言系统使用的是Valine,发现留言并没有提醒，只有回复了才会有提醒。 这不能忍。毕竟好不容易来个朋友竟然没有交流上你说难受不难受😡 然后我就去百度了一下Valine-Admin Valine-Admin 是一个对 Valine 评论系统的拓展应用，可增强 Valine 的邮件通知功能。基于 Leancloud 的云引擎与云函数。可以提供邮件 通知站长 和 @ 通知 的功能，而且还支持自定义邮件通知模板。 发现这个插件很不错我就研究了一下。下面是整合教程。 使用首先其他的不错说了，在阅读本篇文章之前你最好已经整合了Valine留言。 由于我已经整合过了所以前面几个步骤的图片来源自@Valine-Admin 首先登陆账号，找到云引擎在点击设置。 复制仓库地址：https://github.com/zhaojun199… 把git仓库地址房子代码库输入框中。 切换到部署标签页，分支使用 master，点击部署。 接下来输入分支为master 部署完成之后就是设置环境变量 环境变量点击设置，找到自定义环境变量点击新增变量 SITE_NAME : 网站名称。 SITE_URL : 网站地址, 最后不要加 / 。 SMTP_USER : SMTP 服务用户名，一般为邮箱地址。 SMTP_PASS : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式 SMTP_SERVICE : 邮件服务提供商，支持 QQ、163、126、Gmail、\"Yahoo\"、...... ，全部支持请参考 : Nodemailer Supported services。 — 如这里没有你使用的邮件提供商，请查看自定义邮件服务器 SENDER_NAME : 寄件人名称。 TO_EMAIL：这个是填收邮件提醒的邮箱地址，若没有这个字段，则将邮件发到SMTP_USER。 TEMPLATE_NAME：设置提醒邮件的主题，目前内置了两款主题，分别为 default 与 rainbow。默认为 default 设置好以上变量之后 点击实例 然后重启项目，注意任何变动都要重启项目 然后看一下效果 还不错 自定义后台点击设置然后点击Web主机域名找到自己的后台地址 然后在存储-数据-_User表中增加账号， 只需要填写 email、password、username 其中邮箱必须设置为你的上面环境变量的邮箱 设置完之后登录就能在你的后台管理评论 解决休眠免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行： 每天必须休眠 6 个小时 30 分钟内没有外部请求，则休眠。 休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。 也就是如果服务器休眠了的话用户第一次评论是提醒不了的。 参考了Valine-Admin官网找到了解决办法。 首先在环境变量ADMIN_URL增加服务器地址，就是你的后台服务器地址 下面是你的服务器地址，可以自定义 同样登录后台 找到定时任务 然后点击创建任务，上面是我创建好的 选择self_wake函数，然后运行时间使用cron表达式 0 0/30 7-23 ? 表示每天6点到11点 每30分钟叫醒服务器一次 这样就完美的解决了服务器休眠的问题 那如果用户不在时间范围内发留言了怎么办？我们也可以创建一个捡漏的定时任务 创建捡漏定时任务 然后运行函数选择resend_mails,同样使用cron表达式 0 0 8 ? 表示每八个小时进行捡漏一次，这样如果有留言遗漏的话就能即使的提醒。 附 crontab 定时器代码：** 1*/20 7-23 * * * curl https://你配置的域名前缀.leanapp.cn 结语有人会说了不久一个破博客吗？都不知道有没有人看干嘛还要这么麻烦。其实并不麻烦，这只是一个态度而已。 欢迎关注我的公众号，也可在公众号进行留言会及时回复 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}],"author":{"name":"乱敲代码","url":"https://segmentfault.com/a/1190000021474516?utm_source=tag-newest"}},{"title":"一些关于halo博客的资源","slug":"一些关于halo博客的资源","date":"2020-02-11T08:23:57.000Z","updated":"2020-02-14T08:25:36.173Z","comments":true,"path":"2020/02/11/一些关于halo博客的资源/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/11/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8Ehalo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%B5%84%E6%BA%90/","excerpt":"https://github.com/halo-dev/halo-app/releases halo教程https://ryanc.cc/tags/halo Docker Compose 部署Halo教程https://ryanc.cc/archives/docker-compose-run-halo halo替换hexohttps://wenthywang.cn/archives/2019070217154001586/ halo替换hexohttps://www.shizuri.net/Z-Turn/halo.html","text":"https://github.com/halo-dev/halo-app/releases halo教程https://ryanc.cc/tags/halo Docker Compose 部署Halo教程https://ryanc.cc/archives/docker-compose-run-halo halo替换hexohttps://wenthywang.cn/archives/2019070217154001586/ halo替换hexohttps://www.shizuri.net/Z-Turn/halo.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"halo","slug":"halo","permalink":"https://melodyjerry.github.io/blog/tags/halo/"}]},{"title":"任正非:唯一有愧的是对不起父母","slug":"任正非-唯一有愧的是对不起父母","date":"2020-02-11T05:58:08.000Z","updated":"2020-02-13T05:16:48.084Z","comments":true,"path":"2020/02/11/任正非-唯一有愧的是对不起父母/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/11/%E4%BB%BB%E6%AD%A3%E9%9D%9E-%E5%94%AF%E4%B8%80%E6%9C%89%E6%84%A7%E7%9A%84%E6%98%AF%E5%AF%B9%E4%B8%8D%E8%B5%B7%E7%88%B6%E6%AF%8D/","excerpt":"前言​ 前几天，弟在做高考语文预测卷时，突然跟我说“老哥，你去看看任正非的文章《我的父亲母亲》，很有深意”。在看完文章后还有一篇作者是柳传志的读后感。对这两篇文章深有感触，所以专门开设并记录在博文里。","text":"前言​ 前几天，弟在做高考语文预测卷时，突然跟我说“老哥，你去看看任正非的文章《我的父亲母亲》，很有深意”。在看完文章后还有一篇作者是柳传志的读后感。对这两篇文章深有感触，所以专门开设并记录在博文里。 《我的父亲母亲》—— 任正非 《我的父亲母亲》 任正非 【一】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;上世纪末最后一天，我总算良心发现，在公务结束之后，买了一张从北京去昆明的机票，去看看妈妈。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;买好机票后，我没有给她打电话，我知道一打电话她一下午都会忙碌，不管多晚到达，都会给我做一些我小时候喜欢吃的东西。直到飞机起飞，我才告诉她，让她不要告诉别人，不要车来接，我自己坐出租车回家，目的就是好好陪陪她。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;前几年我每年也去看看妈妈，但一下飞机就给办事处接走了，说这个客户很重要，要拜见一下，那个客户很重要，要陪他们吃顿饭，忙来忙去，忙到上飞机时回家取行李，与父母匆匆告别。妈妈盼星星、盼月亮，盼唠唠家常，却一次又一次地落空。 【二】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;一个普通的早上，妈妈从菜市场出来，提着两小包菜，被汽车撞成重伤。我身在伊朗，飞机要多次中转才能回来，在巴林转机要待6.5个小时，真是心如煎熬，又遇巴林雷雨，飞机延误两个小时，到曼谷时又晚了10分钟，没有及时赶上回昆明的飞机，直到深夜才赶到昆明。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;回到昆明，就知道妈妈不行了，她的头部全部给撞坏了，当时的心跳、呼吸全是靠药物和机器维持，之所以在电话上不告诉我，是怕我在旅途中出事。我看见妈妈一声不响地安详地躺在病床上，不用操劳、烦心，好像她一生也没有这么休息过。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我真后悔没有在伊朗给妈妈打一个电话。因为以前不管我在国内、国外给她打电话时，她都唠叨：“你又出差了”，“非非你的身体还不如我好呢”，“非非你的皱纹比妈妈还多呢”，“非非你走路还不如我呢，你这么年纪轻轻就这么多病”，“非非，糖尿病参加宴会多了，坏得更快呢，你的心脏又不好”…… &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我想伊朗条件这么差，我一打电话，妈妈又唠叨，反正过不了几天就见面了，就没有打，而这是我一生中最大的憾事。如果我真打了，拖延她一两分钟出门，也许妈妈就躲过了这场灾难。这种悔恨的心情，真是难以形容。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我看了妈妈最后一眼，妈妈溘然去世。 【三】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1995年，我父亲在昆明街头的小摊上买了一瓶塑料包装的软饮料，喝后拉肚子，一直到全身衰竭去世。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;父亲任摩逊，尽职尽责一生，可以说是一个乡村教育家。妈妈程远昭，是一个陪伴父亲在贫困山区与穷孩子厮混了一生的一个普通得不能再普通的园丁。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;父亲穿着土改工作队的棉衣，随解放军剿匪部队一同进入贵州少数民族山区去筹建一所民族中学。一头扎进去就是几十年，他培养的学生不少成为党和国家的高级干部，有些还是中央院校的校级领导，而父亲还是那么位卑言微。 【四】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我与父母相处的青少年时代，印象最深的就是度过三年自然灾害的困难时期。今天想来还历历在目。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我们兄妹七个，加上父母共九人。全靠父母微薄的工资来生活，毫无其他来源。本来生活就十分困难，儿女一天天在长大，衣服一天天在变短，而且都要读书，开支很大，每个学期每人要交2-3元的学费，到交费时，妈妈每次都发愁。我经常看到妈妈月底就到处向人借钱度饥荒，而且常常走了几家都未必借到。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;直到高中毕业我没有穿过衬衣。有同学看到很热的天，我还穿着厚厚的外衣，就让我向妈妈要一件衬衣，我不敢，因为我知道做不到。我上大学时妈妈一次送我两件衬衣，我真想哭，因为，我有衬衣了，弟妹们就会更难了。我家当时是2-3人合用一条被盖，而且破旧的被单下面铺的是稻草。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;上大学我要拿走一条被子，就更困难了，因为那时还实行布票、棉花票管制，最少的一年，每人只发0.5米布票。没有被单，妈妈捡了毕业学生丢弃的几床破被单缝缝补补，洗干净，这条被单就在重庆陪我度过了五年的大学生活。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我们家当时每餐实行严格分饭制，控制所有人欲望的配给制，保证人人都能活下来。如果不是这样，总会有一个、两个弟妹活不到今天。我真正能理解活下去这句话的含义。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;高三快高考时，我有时在家复习功课，实在饿得受不了了，用米糠和菜合一下，烙着吃，被父亲碰上几次，他心疼了。其实那时我家穷得连一个可上锁的柜子都没有，粮食是用瓦缸装着，我也不敢去随便抓一把。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;高考前三个月，妈妈经常在早上塞给我一个小小的玉米饼，要我安心复习功课，我能考上大学，小玉米饼功劳巨大。如果不是这样，也许我就进不了华为这样的公司，社会上多了一名养猪能手，或街边多了一名能工巧匠而已。这个小小的玉米饼，是从父母与弟妹的口中抠出来的，我无以报答他们。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;“记住知识就是力量，别人不学，你要学，不要随大流。”“以后有能力要帮助弟妹。”背负着这种重托，我在当时的环境下，将樊映川的高等数学习题集从头到尾做了两遍，学习了逻辑、哲学。还自学了三门外语，当时已到可以阅读大学课本的程度，终因我不是语言天才，加之在军队服务时用不上，20多年荒废，完全忘光了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我当年穿走父亲的皮鞋，没念及父亲那时是做苦工的，泥里水里，冰冷潮湿，他更需要鞋子。现在回忆起来，感觉自己太自私了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;回顾我自己已走过的历史，唯一有愧的是对不起父母，没条件时没有照顾他们，有条件时也没有照顾他们。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;爸爸，妈妈，千声万声呼唤你们，千声万声唤不回。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;逝者已经逝去，活着的还要前行。 ​ ——2001年2月8日 于深圳 《要想富就要知道为何穷》——柳传志 《要想富就要知道为何穷》 柳传志 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;在手机上读着一篇任正非写的怀念他的父母亲的文章，而脑子里却想起了另一件事。那是2013年9月，我接到了一个邀请函。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;那天我是真的有事，但出于对老任发自内心的敬佩和尊重，我尽力挤开了别的事情，花了一个半小时的车程赶到了会场。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;老任的面子确实大，那天是贵州都匀一中的“校训研讨会”，真请来了不少领导和知名的企业家。他看见我来了显得非常高兴。我也高兴，那是因为在企业工作者里面，我们都是属于少有的“老家伙”序列里的人，相互都比较了解，然而又极少见面，所以紧紧的握手不愿松开。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;原来都匀一中就是任正非的母校，他的父亲在此曾任过三年校长，他毕生从事教育工作，50多年来倾注了全部的心血。在现任学校领导介绍学校的历史，介绍老任的父亲任摩逊先生事迹的时候，我注意盯着任正非，我想这样的内容他应该听过无数遍了，他却依然听得那么专注，那么动情! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;此刻我正在读他写的怀念他的父母的文章，我认真读这篇文章，是因为深深引起了我的共鸣。我和他是同年生人，我们的出生背景有所不同，但是上一辈在政治上受到的磨难和考验几乎是相同的。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;任正非谈到他的父亲在这考验的重压之下，依旧勤勤恳恳拼力地工作，为他自己后来在华为拼命地工作做出了表率，而父辈的榜样在他身上打下了深深的烙印。我的父亲也是我的榜样。给我最深刻的印象是在强大的政治压力下，他能够像以前教导我的那样，用行动做出表率-做一个正直的人。正直，这是一个多么平常的词藻，然而在特殊的考验面前，这个词就超过了千钧的分量。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1966年文化革命爆发的第一个年头，我亲眼看到我的父亲在威逼面前不肯诬陷当年的战友，被开除党籍。当时的气氛紧张惊恐。这深深地印在了我的脑海中，而我的父亲以身教的方式告诉了我如何做人，什么叫正直! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;联想发展到今天的三十年中，经过的风险无其数，尤其在早期还有一定的政策风险，我自诩是个敢担当的人，而在联想结出胜利果实时，我也以为自己是个舍得让利的人，这对联想能发展到今天也许有一定的影响。和任正非一样，我们能以身作则地把企业利益放在个人利益的前面。追根溯源，是我们的父辈给我们打下了如何做人的基础。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当我读到任正非的母亲是因为意外车祸辞世的，我的心一下子揪了起来。我能想象对他那是一种什么样的撕心裂肺! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;任正非讲到他在高三那年(也应该是我高三的那年吧，就是最困难的1961年)，母亲经常早上塞给他一个小小的玉米饼，他说我能考上大学，小玉米饼的功劳巨大，这个小小的玉米饼是从父母与弟妹的口中抠出来的，我无以报答他们。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我相信绝大多数的80后、90后的朋友是读不出玉米饼的感觉的，因为他们不懂什么叫饥饿。61年，我是北京25中的一名高三学生，我们中学生是早上8、9点钟的太阳，所以享受着最高待遇，一个月32斤粮，半斤油，半斤肉。知道什么叫一个月半斤油吗? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;那是在一锅熬白菜煮熟的时候，油瓶口顺着筷子点入几滴油，使锅里漂着油花，一个月下来，这半斤油就用完了。知道什么叫饿吗?那就是耗干净你身上的脂肪，然后再耗你的肌肉。有一天夜里，我饿的实在受不了，想起抽屉里有一盒中药是羚翘解毒丸，我就吃了两颗，几小时后药性发作，抽筋断肠，头痛欲裂。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;经过饥饿的人才知道什么叫从父母弟妹的嘴里面抠出的玉米饼。任正非想念着母亲，我何尝不想念自己的母亲、不想起在那最艰难的岁月里，母亲对我的慈爱。我的父母都已经去世了，我和老任一样也是老大，我会永远记住父母的恩德慈爱。我有兄弟姐妹四人，我们会永远相亲相爱。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我在想，读了老任的文章，是什么让我会拿起笔说了上边这段话，我想说给谁听呢? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;说给老任?让他知道我是他的知音?说给我的亲人、朋友、同学、同事?让我们更加珍惜今天的生活? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;好像是，但也不是。我明白，我最想说给那些年青、年少的，甚至是儿童，让他们长大了听。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我一直告诫自己不要成为一个碎嘴唠叨的老头。而说这些话，我估计孩子们是不爱听的。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;前些天，我看了一部叫“归来”的电影，写的是我亲眼看见过的年代，亲眼看见过的事情，电影演毕，潸然泪下。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;问过几个年青人是否看过这部片子，都说没有。有一个对我说：人总是要向前看么，老说那些老话，凄凄惨惨有什么意思?!他们爱看光鲜亮丽、富有、任性的电影，那是他们的追求。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;他们不爱看“归来”，不爱听我碎嘴唠叨，但我还是忍不住想对他们说，到底为了什么? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;因为我们这个民族就在不久以前还很苦，很凄惨，很窝囊。你要想今后过得富有光鲜亮丽，你就要知道过去为什么穷，为什么苦，为什么受人欺负。你就要懂得历史，你就要从中学到教训，我们已经是为数不多的见过那段历史的尾巴的人了，尽量还原真实的历史是我们的责任。不管你是哪国国籍，但你和你的子孙血管中流的是中国人的血，这是无法改变的事实! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我谈不上是高尚的人，更谈不上是纯粹的人。但我努力在做一个知恩图报的人，做一个懂廉耻、要自强的人。我希望几十年以后，今天年青、年少的人们能凭追求、凭团结、凭实力让中国富强，让自己过上光鲜亮丽富有的生活。 重要文献[1] 题目《任正非：唯一有愧的是对不起父母》，摘自百家号“金融界”， https://baijiahao.baidu.com/s?id=1644249222074823165&amp;wfr=spider&amp;for=pc [2] 原文，转自凤凰网，http://news.ifeng.com/c/7nKjN9F2Uy0 [3] 插图，来自网络 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"文章","slug":"文章","permalink":"https://melodyjerry.github.io/blog/tags/%E6%96%87%E7%AB%A0/"}]},{"title":"解决bash: hexo: command not found","slug":"解决bash-hexo-command-not-found","date":"2020-02-10T13:28:02.000Z","updated":"2020-02-11T10:56:14.938Z","comments":true,"path":"2020/02/10/解决bash-hexo-command-not-found/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/10/%E8%A7%A3%E5%86%B3bash-hexo-command-not-found/","excerpt":"记录一次离奇的车祸现场。 问题今天用hexo新建文章hexo new时git报错： 1bash: hexo: command not found 解决办法将G:\\blog_gitee\\node_modules\\.bin添加进PATH。 原因可能是因为我今天更新npm了？","text":"记录一次离奇的车祸现场。 问题今天用hexo新建文章hexo new时git报错： 1bash: hexo: command not found 解决办法将G:\\blog_gitee\\node_modules\\.bin添加进PATH。 原因可能是因为我今天更新npm了？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"[转]CentOS 7镜像下载","slug":"转-CentOS-7镜像下载","date":"2020-02-10T13:26:37.000Z","updated":"2020-02-11T10:56:14.946Z","comments":true,"path":"2020/02/10/转-CentOS-7镜像下载/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/10/%E8%BD%AC-CentOS-7%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD/","excerpt":"官网下载链接：http://isoredirect.centos.org/centos/7/isos/x86_64/ step1: 进入下载页，选择阿里云站点进行下载 Actual Country 国内资源 Nearby Countries 周边国家资源 阿里云站点：http://mirrors.aliyun.com/centos/7/isos/x86_64/ 每个链接都包括了镜像文件的地址、类型及版本号等信息 选择当前国家资源区站点下载，获取资源速度比较快 step1: 进入阿里云站点，选择 CentOS-7-x86_64-DVD-1804.iso下载 各个版本的ISO镜像文件说明： CentOS-7-x86_64-DVD-1708.iso 标准安装版（推荐） CentOS-7-x86_64-Everything-1708.iso 完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像） CentOS-7-x86_64-LiveGNOME-1708.iso GNOME桌面版 CentOS-7-x86_64-LiveKDE-1708.iso KDE桌面版 CentOS-7-x86_64-Minimal-1708.iso 精简版，自带的软件最少 CentOS-7-x86_64-NetInstall-1708.iso 网络安装版（从网络安装或者救援系统） 作者：Ada54链接：https://www.jianshu.com/p/a63f47e096e8来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","text":"官网下载链接：http://isoredirect.centos.org/centos/7/isos/x86_64/ step1: 进入下载页，选择阿里云站点进行下载 Actual Country 国内资源 Nearby Countries 周边国家资源 阿里云站点：http://mirrors.aliyun.com/centos/7/isos/x86_64/ 每个链接都包括了镜像文件的地址、类型及版本号等信息 选择当前国家资源区站点下载，获取资源速度比较快 step1: 进入阿里云站点，选择 CentOS-7-x86_64-DVD-1804.iso下载 各个版本的ISO镜像文件说明： CentOS-7-x86_64-DVD-1708.iso 标准安装版（推荐） CentOS-7-x86_64-Everything-1708.iso 完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像） CentOS-7-x86_64-LiveGNOME-1708.iso GNOME桌面版 CentOS-7-x86_64-LiveKDE-1708.iso KDE桌面版 CentOS-7-x86_64-Minimal-1708.iso 精简版，自带的软件最少 CentOS-7-x86_64-NetInstall-1708.iso 网络安装版（从网络安装或者救援系统） 作者：Ada54链接：https://www.jianshu.com/p/a63f47e096e8来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"镜像","slug":"镜像","permalink":"https://melodyjerry.github.io/blog/tags/%E9%95%9C%E5%83%8F/"}]},{"title":"给Hexo博客添加不蒜子统计","slug":"给Hexo博客添加不蒜子统计","date":"2020-02-10T05:46:31.000Z","updated":"2020-02-15T05:48:31.020Z","comments":true,"path":"2020/02/10/给Hexo博客添加不蒜子统计/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/10/%E7%BB%99Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1/","excerpt":"","text":"引入不蒜子1&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 这段代码可以写在footer.ejs里或者header.ejs里或者layout.ejs里 添加站点访问量通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里加上如下标签： 123&lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次&lt;/span&gt; 计算访问量的方法有两种： 算法a：pv的方式，单个用户连续点击n篇文章，记录 n次访问量。 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 添加文章访问量文章的访问量显示在文章里面，所以在article.ejs里加上文章访问量的标签： 123&lt;span id=\"busuanzi_container_page_pv\"&gt; 本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 这个标签里的汉字可以自行修改，还可以给标签写上你想要的样式。 参考： 不蒜子|不如 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"到博客里养鱼","slug":"到博客里养鱼","date":"2020-02-09T11:32:03.000Z","updated":"2020-02-19T11:47:19.302Z","comments":true,"path":"2020/02/09/到博客里养鱼/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E5%88%B0%E5%8D%9A%E5%AE%A2%E9%87%8C%E5%85%BB%E9%B1%BC/","excerpt":"鱼🐟","text":"鱼🐟 1&lt;!-- 底部加了小鱼&lt;・)))&gt;&lt;&lt;~ --&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372&lt;a name=\"top\"&gt;&lt;/a&gt;&lt;div id=\"page_begin_html\"&gt;&lt;marquee hspace=\"20\" vspace=\"20\" width=\"220\" bgcolor=\"White\"&gt;公告：欢迎访问我的博客😘，希望你在这里可以找到你需要的东西！本站内容为个人经验之谈，如有错误，欢迎指正！&lt;/marquee&gt; &lt;script type=\"text/javascript\"&gt;window['__document_write_ajax_callbacks__']['2']();&lt;/script&gt;&lt;script&gt;window['__document_write_ajax_callbacks__']['1']();&lt;/script&gt;&lt;/div&gt;&lt;!--done--&gt;&lt;!--end: home 自定义的最大容器 --&gt;&lt;div id=\"page_end_html\"&gt; &lt;script type=\"text/javascript\" src=\"https://js.users.noscript.cnitblog.com/20537745.js\"&gt;&lt;/script&gt; &lt;!-- 鼠标点击特效 --&gt; &lt;script src=\"https://example.com/cursor-effects.js\"&gt;&lt;/script&gt; &lt;!-- 鼠标点击特效end --&gt; &lt;!-- 页面点击小红心 --&gt; &lt;script&gt;!function(e,t,a){function n(){c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)}function o(){var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(\"div\");a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(\"style\");a.type=\"text/css\";try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(\"head\")[0].appendChild(a)}function s(){return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);&lt;/script&gt; &lt;!-- 底部加了小鱼&lt;・)))&gt;&lt;&lt;~ --&gt; &lt;script src=\"https://common.cnblogs.com/scripts/jquery-2.2.0.min.js\"&gt;&lt;/script&gt;&lt;!-- 底部加了小鱼&lt;・)))&gt;&lt;&lt;~ --&gt; &lt;div id=\"jsi-flying-fish-container\" class=\"container\"&gt;&lt;canvas width=\"1010\" height=\"153\"&gt;&lt;/canvas&gt;&lt;/div&gt; &lt;script src=\"https://blog-static.cnblogs.com/files/elkyo/fish.js\"&gt;&lt;/script&gt; &lt;script src=\"https://common.cnblogs.com/scripts/jquery-2.2.0.min.js\"&gt;&lt;/script&gt; &lt;div id=\"jsi-flying-fish-container\" class=\"container\"&gt;&lt;canvas width=\"1058\" height=\"158\"&gt;&lt;/canvas&gt;&lt;/div&gt; &lt;script&gt; var RENDERER = { POINT_INTERVAL : 5, FISH_COUNT : 3, MAX_INTERVAL_COUNT : 50, INIT_HEIGHT_RATE : 0.5, THRESHOLD : 50, init : function(){ this.setParameters(); this.reconstructMethods(); this.setup(); this.bindEvent(); this.render(); }, setParameters : function(){ this.$window = $(window); this.$container = $('#jsi-flying-fish-container'); this.$canvas = $('&lt;canvas /&gt;'); this.context = this.$canvas.appendTo(this.$container).get(0).getContext('2d'); this.points = []; this.fishes = []; this.watchIds = []; }, createSurfacePoints : function(){ var count = Math.round(this.width / this.POINT_INTERVAL); this.pointInterval = this.width / (count - 1); this.points.push(new SURFACE_POINT(this, 0)); for(var i = 1; i &lt; count; i++){ var point = new SURFACE_POINT(this, i * this.pointInterval), previous = this.points[i - 1]; point.setPreviousPoint(previous); previous.setNextPoint(point); this.points.push(point); } }, reconstructMethods : function(){ this.watchWindowSize = this.watchWindowSize.bind(this); this.jdugeToStopResize = this.jdugeToStopResize.bind(this); this.startEpicenter = this.startEpicenter.bind(this); this.moveEpicenter = this.moveEpicenter.bind(this); this.reverseVertical = this.reverseVertical.bind(this); this.render = this.render.bind(this); }, setup : function(){ this.points.length = 0; this.fishes.length = 0; this.watchIds.length = 0; this.intervalCount = this.MAX_INTERVAL_COUNT; this.width = this.$container.width(); this.height = this.$container.height(); this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500; this.$canvas.attr({width : this.width, height : this.height}); this.reverse = false; this.fishes.push(new FISH(this)); this.createSurfacePoints(); }, watchWindowSize : function(){ this.clearTimer(); this.tmpWidth = this.$window.width(); this.tmpHeight = this.$window.height(); this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL)); }, clearTimer : function(){ while(this.watchIds.length &gt; 0){ clearTimeout(this.watchIds.pop()); } }, jdugeToStopResize : function(){ var width = this.$window.width(), height = this.$window.height(), stopped = (width == this.tmpWidth &amp;&amp; height == this.tmpHeight); this.tmpWidth = width; this.tmpHeight = height; if(stopped){ this.setup(); } }, bindEvent : function(){ this.$window.on('resize', this.watchWindowSize); this.$container.on('mouseenter', this.startEpicenter); this.$container.on('mousemove', this.moveEpicenter); this.$container.on('click', this.reverseVertical); }, getAxis : function(event){ var offset = this.$container.offset(); return { x : event.clientX - offset.left + this.$window.scrollLeft(), y : event.clientY - offset.top + this.$window.scrollTop() }; }, startEpicenter : function(event){ this.axis = this.getAxis(event); }, moveEpicenter : function(event){ var axis = this.getAxis(event); if(!this.axis){ this.axis = axis; } this.generateEpicenter(axis.x, axis.y, axis.y - this.axis.y); this.axis = axis; }, generateEpicenter : function(x, y, velocity){ if(y &lt; this.height / 2 - this.THRESHOLD || y &gt; this.height / 2 + this.THRESHOLD){ return; } var index = Math.round(x / this.pointInterval); if(index &lt; 0 || index &gt;= this.points.length){ return; } this.points[index].interfere(y, velocity); }, reverseVertical : function(){ this.reverse = !this.reverse; for(var i = 0, count = this.fishes.length; i &lt; count; i++){ this.fishes[i].reverseVertical(); } }, controlStatus : function(){ for(var i = 0, count = this.points.length; i &lt; count; i++){ this.points[i].updateSelf(); } for(var i = 0, count = this.points.length; i &lt; count; i++){ this.points[i].updateNeighbors(); } if(this.fishes.length &lt; this.fishCount){ if(--this.intervalCount == 0){ this.intervalCount = this.MAX_INTERVAL_COUNT; this.fishes.push(new FISH(this)); } } }, render : function(){ requestAnimationFrame(this.render); this.controlStatus(); this.context.clearRect(0, 0, this.width, this.height); this.context.fillStyle = 'hsl(0, 0%, 95%)'; for(var i = 0, count = this.fishes.length; i &lt; count; i++){ this.fishes[i].render(this.context); } this.context.save(); this.context.globalCompositeOperation = 'xor'; this.context.beginPath(); this.context.moveTo(0, this.reverse ? 0 : this.height); for(var i = 0, count = this.points.length; i &lt; count; i++){ this.points[i].render(this.context); } this.context.lineTo(this.width, this.reverse ? 0 : this.height); this.context.closePath(); this.context.fill(); this.context.restore(); } }; var SURFACE_POINT = function(renderer, x){ this.renderer = renderer; this.x = x; this.init(); }; SURFACE_POINT.prototype = { SPRING_CONSTANT : 0.03, SPRING_FRICTION : 0.9, WAVE_SPREAD : 0.3, ACCELARATION_RATE : 0.01, init : function(){ this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE; this.height = this.initHeight; this.fy = 0; this.force = {previous : 0, next : 0}; }, setPreviousPoint : function(previous){ this.previous = previous; }, setNextPoint : function(next){ this.next = next; }, interfere : function(y, velocity){ this.fy = this.renderer.height * this.ACCELARATION_RATE * ((this.renderer.height - this.height - y) &gt;= 0 ? -1 : 1) * Math.abs(velocity); }, updateSelf : function(){ this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height); this.fy *= this.SPRING_FRICTION; this.height += this.fy; }, updateNeighbors : function(){ if(this.previous){ this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height); } if(this.next){ this.force.next = this.WAVE_SPREAD * (this.height - this.next.height); } }, render : function(context){ if(this.previous){ this.previous.height += this.force.previous; this.previous.fy += this.force.previous; } if(this.next){ this.next.height += this.force.next; this.next.fy += this.force.next; } context.lineTo(this.x, this.renderer.height - this.height); } }; var FISH = function(renderer){ this.renderer = renderer; this.init(); }; FISH.prototype = { GRAVITY : 0.4, init : function(){ this.direction = Math.random() &lt; 0.5; this.x = this.direction ? (this.renderer.width + this.renderer.THRESHOLD) : -this.renderer.THRESHOLD; this.previousY = this.y; this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1); if(this.renderer.reverse){ this.y = this.getRandomValue(this.renderer.height * 1 / 10, this.renderer.height * 4 / 10); this.vy = this.getRandomValue(2, 5); this.ay = this.getRandomValue(0.05, 0.2); }else{ this.y = this.getRandomValue(this.renderer.height * 6 / 10, this.renderer.height * 9 / 10); this.vy = this.getRandomValue(-5, -2); this.ay = this.getRandomValue(-0.2, -0.05); } this.isOut = false; this.theta = 0; this.phi = 0; }, getRandomValue : function(min, max){ return min + (max - min) * Math.random(); }, reverseVertical : function(){ this.isOut = !this.isOut; this.ay *= -1; }, controlStatus : function(context){ this.previousY = this.y; this.x += this.vx; this.y += this.vy; this.vy += this.ay; if(this.renderer.reverse){ if(this.y &gt; this.renderer.height * this.renderer.INIT_HEIGHT_RATE){ this.vy -= this.GRAVITY; this.isOut = true; }else{ if(this.isOut){ this.ay = this.getRandomValue(0.05, 0.2); } this.isOut = false; } }else{ if(this.y &lt; this.renderer.height * this.renderer.INIT_HEIGHT_RATE){ this.vy += this.GRAVITY; this.isOut = true; }else{ if(this.isOut){ this.ay = this.getRandomValue(-0.2, -0.05); } this.isOut = false; } } if(!this.isOut){ this.theta += Math.PI / 20; this.theta %= Math.PI * 2; this.phi += Math.PI / 30; this.phi %= Math.PI * 2; } this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY); if(this.vx &gt; 0 &amp;&amp; this.x &gt; this.renderer.width + this.renderer.THRESHOLD || this.vx &lt; 0 &amp;&amp; this.x &lt; -this.renderer.THRESHOLD){ this.init(); } }, render : function(context){ context.save(); context.translate(this.x, this.y); context.rotate(Math.PI + Math.atan2(this.vy, this.vx)); context.scale(1, this.direction ? 1 : -1); context.beginPath(); context.moveTo(-30, 0); context.bezierCurveTo(-20, 15, 15, 10, 40, 0); context.bezierCurveTo(15, -10, -20, -15, -30, 0); context.fill(); context.save(); context.translate(40, 0); context.scale(0.9 + 0.2 * Math.sin(this.theta), 1); context.beginPath(); context.moveTo(0, 0); context.quadraticCurveTo(5, 10, 20, 8); context.quadraticCurveTo(12, 5, 10, 0); context.quadraticCurveTo(12, -5, 20, -8); context.quadraticCurveTo(5, -10, 0, 0); context.fill(); context.restore(); context.save(); context.translate(-3, 0); context.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)); context.beginPath(); if(this.renderer.reverse){ context.moveTo(5, 0); context.bezierCurveTo(10, 10, 10, 30, 0, 40); context.bezierCurveTo(-12, 25, -8, 10, 0, 0); }else{ context.moveTo(-5, 0); context.bezierCurveTo(-10, -10, -10, -30, 0, -40); context.bezierCurveTo(12, -25, 8, -10, 0, 0); } context.closePath(); context.fill(); context.restore(); context.restore(); this.controlStatus(context); } }; $(function(){ RENDERER.init(); }); &lt;/script&gt; &lt;style&gt; @media only screen and (max-width: 767px){ #sidebar_search_box input[type=text]{width:calc(100% - 24px)} } &lt;/style&gt;&lt;/div&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"[转]MySQL数据库引擎","slug":"转-MySQL数据库引擎","date":"2020-02-09T10:43:52.000Z","updated":"2020-02-11T10:56:14.918Z","comments":true,"path":"2020/02/09/转-MySQL数据库引擎/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E8%BD%AC-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/","excerpt":"接下来介绍一下存储引擎的基本概念、MySQL支持的存储引擎、存储引擎的选择以及操作默认存储引擎。","text":"接下来介绍一下存储引擎的基本概念、MySQL支持的存储引擎、存储引擎的选择以及操作默认存储引擎。 什么是存储引擎数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。 现在许多数据库管理系统都支持多种不同的存储引擎。MySQL 的核心就是存储引擎。 提示：InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎。 MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。 MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。 MySQL 5.7 支持的存储引擎MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 SHOW ENGINES 语句来显示可用的数据库引擎和默认引擎。 MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。 MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。可以使用SHOW ENGINES语句查看系统所支持的引擎类型，结果如图所示。 Support 列的值表示某种引擎是否能使用，YES表示可以使用，NO表示不能使用，DEFAULT表示该引擎为当前默认的存储引擎。 如何选择 MySQL 存储引擎不同的存储引擎都有各自的特点，以适应不同的需求，如表所示。为了做出选择，首先要考虑每一个存储引擎提供了哪些不同的功能。 功能 MylSAM MEMORY InnoDB Archive 存储限制 256TB RAM 64TB None 支持事务 No No Yes No 支持全文索引 Yes No No No 支持树索引 Yes Yes Yes No 支持哈希索引 No Yes No No 支持数据缓存 No N/A Yes No 支持外键 No No Yes No 可以根据以下的原则来选择 MySQL 存储引擎： 如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。 如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。 如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。 如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎。 提示：使用哪一种引擎要根据需要灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。 MySQL 默认存储引擎InnoDB 是系统的默认引擎，支持可靠的事务处理。 使用下面的语句可以修改数据库临时的默认存储引擎 SET default_storage_engine=&lt; 存储引擎名 &gt; 例如，将 MySQL 数据库的临时默认存储引擎修改为 MyISAM，输入的 SQL 语句和运行结果如图所示。 此时，可以发现 MySQL 的默认存储引擎已经变成了 MyISAM。但是当再次重启客户端时，默认存储引擎仍然是 InnoDB。 原文链接：http://c.biancheng.net/view/2418.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[转]MySQL区别大小写字母的问题","slug":"转-MySQL区别大小写的问题","date":"2020-02-09T08:29:12.000Z","updated":"2020-02-11T10:56:14.921Z","comments":true,"path":"2020/02/09/转-MySQL区别大小写的问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E8%BD%AC-MySQL%E5%8C%BA%E5%88%AB%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"如果直接使用MYSQL客户端用SQL语句查询数据库中的数据，SQL语句中字段的大写或小写查出的数据是一样的，说明查询条件对字段的大小写是不敏感（默认）。 怎样让MYSQL对大小字母写敏感？解决方案一MYSQL区别大小写需要设置collate（校对） 。 collate规则： *_bin: 表示的是 binary casesensitive collation，也就是说是区分大小写的 *_cs: 表示的是 casesensitive collation，区分大小写 *_ci: 表示的是 caseinsensitive collation，不区分大小写 解决方法 可以将查询条件用binary()括起来。 比如： 1select * from emp where binary username= 'jack'; 可以修改该字段的collation 为 binary。比如： 1ALTER TABLE TABLENAME MODIFY COLUMN COLUMNNAME VARCHAR(50) BINARY CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL; 解决方案二 mysql查询默认是不区分大小写的 如: 12select * from emp where username=‘jack';select * from emp where username='JACK'; 得到的结果是一样的，如果我们需要进行区分的话可以按照如下方法来做： 第一种方法要让mysql查询区分大小写，可以： 12select * from emp where binary username='jack'select * from emp where binary username='JACK' 第二种方法在建表时时候加以标识 123create table emp( username varchar(20) binary) 原理：对于CHAR、VARCHAR和TEXT类型，BINARY属性可以为列分配该列字符集的校对规则。BINARY属性是指定列字符集的二元校对规则的简写。排序和比较基于数值字符值,因此也就自然区分了大小写。 原文链接：https://blog.csdn.net/qq_15160079/article/details/100976519","text":"如果直接使用MYSQL客户端用SQL语句查询数据库中的数据，SQL语句中字段的大写或小写查出的数据是一样的，说明查询条件对字段的大小写是不敏感（默认）。 怎样让MYSQL对大小字母写敏感？解决方案一MYSQL区别大小写需要设置collate（校对） 。 collate规则： *_bin: 表示的是 binary casesensitive collation，也就是说是区分大小写的 *_cs: 表示的是 casesensitive collation，区分大小写 *_ci: 表示的是 caseinsensitive collation，不区分大小写 解决方法 可以将查询条件用binary()括起来。 比如： 1select * from emp where binary username= 'jack'; 可以修改该字段的collation 为 binary。比如： 1ALTER TABLE TABLENAME MODIFY COLUMN COLUMNNAME VARCHAR(50) BINARY CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL; 解决方案二 mysql查询默认是不区分大小写的 如: 12select * from emp where username=‘jack';select * from emp where username='JACK'; 得到的结果是一样的，如果我们需要进行区分的话可以按照如下方法来做： 第一种方法要让mysql查询区分大小写，可以： 12select * from emp where binary username='jack'select * from emp where binary username='JACK' 第二种方法在建表时时候加以标识 123create table emp( username varchar(20) binary) 原理：对于CHAR、VARCHAR和TEXT类型，BINARY属性可以为列分配该列字符集的校对规则。BINARY属性是指定列字符集的二元校对规则的简写。排序和比较基于数值字符值,因此也就自然区分了大小写。 原文链接：https://blog.csdn.net/qq_15160079/article/details/100976519 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}],"author":{"name":"曼巴进化者","url":"https://blog.csdn.net/qq_15160079/article/details/100976519"}},{"title":"Navicat Premium连接MySQL失败？","slug":"Navicat-Premium连接MySQL失败？","date":"2020-02-09T07:42:25.000Z","updated":"2020-02-11T10:56:14.881Z","comments":true,"path":"2020/02/09/Navicat-Premium连接MySQL失败？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/Navicat-Premium%E8%BF%9E%E6%8E%A5MySQL%E5%A4%B1%E8%B4%A5%EF%BC%9F/","excerpt":"问题描述使用Navicat Premium连接MySQL失败，并弹窗提示👇 分析从错误信息可知caching_sha2_password不能加载。 以上报错是由于目前已有的客户端连接软件还不支持Mysql8新增加的加密方式caching_sha2_password，所以我们需要修改用户的加密方式，将其改为老的加密验证方式。 大安装Mysql数据库的主机上登录Mysql对应的用户，上面连接时用的用户为root，所以我们登录root用户。 解决 执行命令，查看当前用户的加密方式： 123use mysql;select user,plugin from user where user='root'; 可以看到当前用户的加密方式为caching_sha2_password。 登录MySQL后输入，执行命令： 123ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'YourPassword';FLUSH PRIVILEGES; 将用户的加密方式改为mysql_native_password。 再次尝试连接Mysql，连接成功。","text":"问题描述使用Navicat Premium连接MySQL失败，并弹窗提示👇 分析从错误信息可知caching_sha2_password不能加载。 以上报错是由于目前已有的客户端连接软件还不支持Mysql8新增加的加密方式caching_sha2_password，所以我们需要修改用户的加密方式，将其改为老的加密验证方式。 大安装Mysql数据库的主机上登录Mysql对应的用户，上面连接时用的用户为root，所以我们登录root用户。 解决 执行命令，查看当前用户的加密方式： 123use mysql;select user,plugin from user where user='root'; 可以看到当前用户的加密方式为caching_sha2_password。 登录MySQL后输入，执行命令： 123ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'YourPassword';FLUSH PRIVILEGES; 将用户的加密方式改为mysql_native_password。 再次尝试连接Mysql，连接成功。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"文章内跳转","slug":"文章内跳转","date":"2020-02-09T07:19:00.000Z","updated":"2020-02-20T07:35:51.960Z","comments":true,"path":"2020/02/09/文章内跳转/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E6%96%87%E7%AB%A0%E5%86%85%E8%B7%B3%E8%BD%AC/","excerpt":"点击我跳转 123451. 跳转起点[点击我跳转](#jump)2.跳转终点&lt;span id=\"jump\"&gt;&lt;font color='blue'&gt;[我是跳转内容]&lt;/font&gt;&lt;/span&gt;&lt;a href=\"#jump\" class=\"footnote-backref\"&gt;↩&lt;/a&gt; [我是跳转内容]↩ 参考文章： https://www.jianshu.com/p/4898c2e9a36d https://blog.csdn.net/qq_38276669/article/details/86748936","text":"点击我跳转 123451. 跳转起点[点击我跳转](#jump)2.跳转终点&lt;span id=\"jump\"&gt;&lt;font color='blue'&gt;[我是跳转内容]&lt;/font&gt;&lt;/span&gt;&lt;a href=\"#jump\" class=\"footnote-backref\"&gt;↩&lt;/a&gt; [我是跳转内容]↩ 参考文章： https://www.jianshu.com/p/4898c2e9a36d https://blog.csdn.net/qq_38276669/article/details/86748936 内容 在MarkDown中是通过 链接 和 标题 来实现页面内跳转的，所以先讲下MarkDown中 链接 和 标题 的语法，然后再讲 MarkDown 中实现页面内跳转的方法； 一. 链接的定义Markdown 支持两种形式的链接语法： 行内式 和 参考式 两种形式。 1. 行内式链接语法： 1行内式链接 = [内容](地址 \"标题\") 说明： 标题 是可选的，可以用单引号 或 双引号； 转换成HTML后，会生成如下标签： 1&lt;a href=\"地址\" title=\"标题\"&gt;内容&lt;/a&gt; 示例： 1[我的博客](https://www.jianshu.com/u/7ecaba2d594c \"郭斌勇的主页\") 渲染成HTML后，会生成如下标签： 1&lt;a href=\"https://www.jianshu.com/u/7ecaba2d594c\" title=\"郭斌勇的主页\"&gt;我的博客&lt;/a&gt; 效果如下： 我的博客 2. 参考式链接语法： 12参考式链接 = [内容][参考标识符]参考标识符 = [标识符]: 地址 \"标题\" 说明： 参考式链接 和 参考标识符 的定义没有先后顺序； [内容] 和 [参考标识符] 之间可以有一个空格，也可以没有空格； 如果 内容 和 参考标识符 一样，也可简写成 [参考标识符][] ; 标题 是可选的，可以用单引号、双引号或是圆括弧包着； 转换成HTML后，会生成如下标签： 1&lt;a href=\"地址\" title=\"标题\"&gt;内容&lt;/a&gt; 示例： 123[博客]: https://www.jianshu.com/u/7ecaba2d594c \"郭斌勇的主页\"[我的博客][博客][博客][] 渲染成HTML后，会生成如下标签： 12&lt;a href=\"https://www.jianshu.com/u/7ecaba2d594c\" title=\"郭斌勇的主页\"&gt;我的博客&lt;/a&gt;&lt;a href=\"https://www.jianshu.com/u/7ecaba2d594c\" title=\"郭斌勇的主页\"&gt;博客&lt;/a&gt; 效果如下： 我的博客 博客 三.页面内跳转MarkDown中是通过定义链接的方式来定义跳转的，在这里，跳转也称为锚点，跳转的目标称为锚点目标； 所以，在 MarkDown 中实现页面内跳转的方法就是：定义一个 锚点目标 和 对应的 锚点 ，用户点击 锚点 便可跳转到对应的 锚点目标 位置处； 锚点 和 锚点目标 的定义格式如下： 1. 锚点的定义锚点就是一个链接，另外，由于在MarkDown中可以直接写HTML，所以在MarkDown中实现锚点有两种方式：MarkDown方式 和 HTML方式； 1.1 MarkDown锚点MarkDown锚点本质上就是一个MarkDown链接，只是链接地址的格式为： 1链接地址 = #目标内容 所以 MarkDown锚点 的定义也有两种方式 行内式语法： 1锚点 = [内容](#目标内容 \"标题\") 说明： 标题 是可选的，可以用单引号 或 双引号； 转换成HTML后，会生成如下标签： 1&lt;a href=\"#目标内容\" title=\"标题\"&gt;内容&lt;/a&gt; 示例： 1[MarkDown方式的锚点](#MarkDown锚点) 渲染成HTML后，会生成如下标签： 1&lt;a href=\"#MarkDown锚点\" &gt;MarkDown方式的锚点&lt;/a&gt; 效果如下：点击下面的锚点 MarkDown方式的锚点 参考式语法： 12锚点 = [内容][参考标识符]参考标识符 = [标识符]: #目标内容 \"标题\" 说明： 锚点 和 参考标识符 的定义没有先后顺序； [内容] 和 [参考标识符] 之间可以有一个空格，也可以没有空格； 如果 内容 和 参考标识符 一样，也可简写成 [参考标识符][] ; 标题 是可选的，可以用单引号、双引号或是圆括弧包着； 转换成HTML后，会生成如下标签： 1&lt;a href=\"#目标内容\" title=\"标题\"&gt;内容&lt;/a&gt; 示例： 123[MarkDown方式的锚点]: #MarkDown锚点[MD锚点][MarkDown方式的锚点][MarkDown方式的锚点][] 渲染成HTML后，会生成如下标签： 12&lt;a href=\"#MarkDown锚点\"&gt;MD锚点&lt;/a&gt;&lt;a href=\"#MarkDown锚点\"&gt;MarkDown方式的锚点&lt;/a&gt; 效果如下： MD锚点 MarkDown方式的锚点 1.2 HTML锚点HTML锚点本质上就是一个a链接，格式为： 1&lt;a href=\"#目标内容\"&gt;内容&lt;/a&gt; 注意： HTML锚点 的目标锚点只能是 标签形式的锚点目标 示例： 1&lt;a href=\"#html锚点\"&gt;HTML方式的锚点&lt;/a&gt; 效果如下：点击下面的锚点 HTML方式的锚点 2. 锚点目标的定义锚点目标有2种定义方式：MarkDown形式 和 标签形式； MarkDown形式的锚点目标MarkDown形式的锚点目标的定义其实就是标题的定义，即：任何级别的标题可以直接作为锚点目标； 1标题内容 = 目标内容 所以，类Setext形式 和 类atx形式 的标题都可作为 锚点目标 ； 锚点目标定义的示例： 123456789101112这是一个锚点目标====这是一个锚点目标---# 这是一个锚点目标## 这是一个锚点目标### 这是一个锚点目标#### 这是一个锚点目标##### 这是一个锚点目标###### 这是一个锚点目标 注意： 锚点的 目标内容 中不能有大家字母和空格，所以如果锚点目标的 目标内容 中有大写字母或空格，则需要在定义锚点中的 目标内容 时，把大写字母改成小写字母，把空格改成 -； 锚点 的 1目标内容 中不能含有以下字符： 半角点(即英文中的句号). 标签形式的锚点目标因为MarkDown链接会被转成a标签，并且MarkDown中也可以写标签，所以可以利用HTML的锚点机制直接定义一个带 id 特性的任意标签 或 带 name 特性的 a 标签（注意：在HTML5中，a标签已经不再支持 name 特性）作为锚点目标，然后把MarkDown中的锚点地址的目标内容设置为 id 或 name 特性的值；这样便可以实现页面内跳转； 这种形式的锚点目标的定义格式为： 1&lt;标签名 id=\"目标内容\"&gt;元素内容&lt;/标签名&gt; 或 1&lt;a name=\"目标内容\"&gt;元素内容&lt;/a&gt; 注意： 标签形式的锚点目标的id特性值中是不能含有中文字符； name 特性只能应用在 a 标签上； HTML5不支持通过a标签的 name 特性来定义锚点目标； 示例： 1&lt;div id=\"这是锚点目标\"&gt;跳转到这里&lt;/div&gt; 或 1&lt;a name=\"这是锚点目标\"&gt;跳转到这里&lt;/a&gt; 四. 总结MarkDown中实现页面跳转的方法如下： 定义锚点目标；锚点目标的定义方式有4种：类Setext形式的标题、类atx形式的标题、带id特性的HTML标签（id特性的值为目标内容）、带name特性的a标签（name特性的值为目标内容）； 定义锚点；锚点的定义方式有3种：行内式链接、参考式链接、HTML的a链接； 说明： 锚点 和 锚点目标 的定义不分先后顺序； 注意： 锚点的 目标内容 中不能有大家字母和空格，所以如果锚点目标的 目标内容 中有大写字母或空格，则需要在定义锚点中的 目标内容 时，把大写字母改成小写字母，把空格改成 -； 锚点 的 1目标内容 中不能含有以下字符： 半角点(即英文中的句号). 标签形式的锚点目标的id特性值中是不能含有中文字符； name 特性只能应用在 a 标签上； HTML5不支持通过a标签的 name 特性来定义锚点目标； HTML锚点 的目标锚点只能是 标签形式的锚点目标 五. 示例示例1锚点： 1[跳转到个人简介](#个人简介) 锚点目标： 1# 个人简介 示例2锚点： 12[跳转到个人简介]: #个人简介[跳转到个人简介][] 锚点目标： 12个人简介===== 示例3锚点： 1[跳转到个人简介](#个人简介) 锚点目标： 1&lt;p id=\"个人简介\"&gt;这是个人简介&lt;/p&gt; 示例4锚点： 1[跳转到个人简介](#个人简介) 锚点目标： 1&lt;a name=\"个人简介\"&gt;这是个人简介&lt;/a&gt; 示例5锚点： 1&lt;a href=\"#个人简介\"&gt;跳转到个人简介&lt;/a&gt; 锚点目标： 12个人简介---- 示例6锚点： 1&lt;a href=\"#个人简介\"&gt;跳转到个人简介&lt;/a&gt; 锚点目标： 1&lt;h1 id=\"个人简介\"&gt;这是个人简介&lt;/h1&gt; 示例7锚点： 1&lt;a href=\"#个人简介\"&gt;跳转到个人简介&lt;/a&gt; 锚点目标： 1&lt;a name=\"个人简介\"&gt;这是个人简介&lt;/a&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"输入密码后登录不上MySQL？","slug":"输入密码后登录不上MySQL？","date":"2020-02-09T07:08:37.000Z","updated":"2020-02-11T10:56:14.924Z","comments":true,"path":"2020/02/09/输入密码后登录不上MySQL？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E5%90%8E%E7%99%BB%E5%BD%95%E4%B8%8D%E4%B8%8AMySQL%EF%BC%9F/","excerpt":"昨晚安装好MySQL后，可以登录。但是今天输入密码后，总是没办法登录。 刚开始我是用DOS窗口的，我检查了命令，命令也没输错啊。 接着转去MySQL Command Line Client试试，一直没反应。 我突然想到“是不是MySQL服务没有启动？” 果然！看了一下，这个时候MySQL需要手动启动，于是我把MySQL服务设置成开机自动启动，以后就省去手动启动这个麻烦。 回到DOS，输入mysql -h localhost -u root -p试试，可以正常登录MySQL了hh o(￣▽￣)o 除了上面这种到【服务】手动开启MySQL服务的方法外，也可以用PowerShell(管理员)来启动。 输入命令net start mysql，启动MySQL服务。启动成功会在左下角弹窗提示👇 一定是要带有管理员权限的PowerShell，否者只会是这个样子👇 输入net start mysql，按回车键，就能启动 MySQL 服务，停止服务的命令为net stop mysql。","text":"昨晚安装好MySQL后，可以登录。但是今天输入密码后，总是没办法登录。 刚开始我是用DOS窗口的，我检查了命令，命令也没输错啊。 接着转去MySQL Command Line Client试试，一直没反应。 我突然想到“是不是MySQL服务没有启动？” 果然！看了一下，这个时候MySQL需要手动启动，于是我把MySQL服务设置成开机自动启动，以后就省去手动启动这个麻烦。 回到DOS，输入mysql -h localhost -u root -p试试，可以正常登录MySQL了hh o(￣▽￣)o 除了上面这种到【服务】手动开启MySQL服务的方法外，也可以用PowerShell(管理员)来启动。 输入命令net start mysql，启动MySQL服务。启动成功会在左下角弹窗提示👇 一定是要带有管理员权限的PowerShell，否者只会是这个样子👇 输入net start mysql，按回车键，就能启动 MySQL 服务，停止服务的命令为net stop mysql。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[工具]文件加密软件","slug":"工具-文件加密软件","date":"2020-02-09T05:40:26.000Z","updated":"2020-02-11T10:56:14.889Z","comments":true,"path":"2020/02/09/工具-文件加密软件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E5%B7%A5%E5%85%B7-%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E8%BD%AF%E4%BB%B6/","excerpt":"Folder-locker这是一个小巧的文件上锁软件，没有压缩和加密过程，方便快捷。 功能展示 在想加密的文件夹上，右键则可呼出加密面板，输入两次密码确认加密。 在已加密的文件夹上，右键，输入密码，则取消加密 项目介绍项目分了两个目录： DButility 用于通过轻量极数据库SQLite 保存密码。 通过Md5算法对密码加密，通过SQL参数防止SQL注入。 folderLocker 用于实现业务逻辑。 软件使用 下载软件安装包 Folder Locker.exe 进行安装，建议安装在D盘。 可以右键使用，也可以打开软件主页面使用。 注意事项 密码保存在本机数据库，没有上传任何服务器。 删除软件会同时删除数据库，因而删除密码。 如果忘记密码： 如果密码遗失，文件被锁，可以通过命令行工具重命名： 12cd C:\\Users\\91991\\Musicren \"Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\" \"Test1\" 或者把文件复制出来。 1234cd C:\\Users\\91991\\Musiccd '.\\Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\\'lsmv .\\* ..\\Test1\\ 项目地址： https://github.com/Albert-W/Folder-locker 项目展示： https://albert-w.github.io/Folder-locker/","text":"Folder-locker这是一个小巧的文件上锁软件，没有压缩和加密过程，方便快捷。 功能展示 在想加密的文件夹上，右键则可呼出加密面板，输入两次密码确认加密。 在已加密的文件夹上，右键，输入密码，则取消加密 项目介绍项目分了两个目录： DButility 用于通过轻量极数据库SQLite 保存密码。 通过Md5算法对密码加密，通过SQL参数防止SQL注入。 folderLocker 用于实现业务逻辑。 软件使用 下载软件安装包 Folder Locker.exe 进行安装，建议安装在D盘。 可以右键使用，也可以打开软件主页面使用。 注意事项 密码保存在本机数据库，没有上传任何服务器。 删除软件会同时删除数据库，因而删除密码。 如果忘记密码： 如果密码遗失，文件被锁，可以通过命令行工具重命名： 12cd C:\\Users\\91991\\Musicren \"Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\" \"Test1\" 或者把文件复制出来。 1234cd C:\\Users\\91991\\Musiccd '.\\Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\\'lsmv .\\* ..\\Test1\\ 项目地址： https://github.com/Albert-W/Folder-locker 项目展示： https://albert-w.github.io/Folder-locker/ 教程这是国人开发的一款开源加密小程序，它只有一个功能，就是给文件夹上密码。 下载后安装，需要注意的是，软件默认安装到D盘，你可以改成其他盘，但不建议安装到C盘，因为可能导致数据库丢失，影响解密； 加密过程也很简单，右键需要加密的文件夹 – Folder locker – 输入密码– lock 即可； 加密后文件夹图标会变成锁，无法双击打开，需要解密的话，右键已加密文件夹 – Folder locker – 输入密码– unlock 即可； 整个过程没有任何数据上传，你的密码会通过Md5算法加密，并保存在本机数据库，卸载软件会同时删除数据库，导致密码丢失。 这个小程序原理非常简单，就是利用 Windows 的注册表修改了文件夹属性，使其不能直接已文件夹的形式打开，就像「上帝模式」一样，小程序并没有对文件夹内的文件做任何修改，没有压缩和加密过程，所以速度非常快。 但也正因为其简单，知道原理的话不需要程序也能解密。 忘记密码的解密方法： 以上就是使用这个小程序所有的方法，它的安全系数不高，不适用来加密非常重要的机密文件，但保护普通用户的小秘密应该是搓搓有余的。 目前这款软件好像在 Windows 2004 版本上失效了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}],"author":{"name":"Albert-W","url":"https://github.com/Albert-W/Folder-locker","avatar":"https://avatars0.githubusercontent.com/u/21038139?s=460&v=4"}},{"title":"登录MySQL","slug":"登录MySQL","date":"2020-02-08T14:54:46.000Z","updated":"2020-02-11T10:56:14.892Z","comments":true,"path":"2020/02/08/登录MySQL/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E7%99%BB%E5%BD%95MySQL/","excerpt":"安装好MySQL后，默认启动服务，这时候开始尝试登录MySQL数据库。 有两种登录方式： Power Shell 或 CMD（DOS窗口） 命令行客户端（MySQL Command Line Client）【安装软件时，一般会安装的】 Power Shell 启动 Power Shell 。 输入命令cd C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin（cd+空格+安装目录/bin），回车。 输入登录命令，回车。登录命令有4中，选其一即可： 12345678#第一种 服务器主机地址+不接密码mysql -h localhost -u root -p#第二种 服务器主机地址+密码mysql -h localhost -u root -proot#第三种 省略服务器主机地址+不接密码，默认localhostmysql -u root -p#第四种 省略服务器主机地址+密码，默认localhostmysql -u root -proot 提示：mysql 为登录命令，-h 后面的参数是服务器的主机地址，在这里客户端和服务器在同一台机器上，所以输入 localhost 或者 IP 地址；-u 后面跟登录数据库的用户名称，在这里为 root；-p 后面是用户登录密码。 在 DOS 窗口下运行该命令后，系统会提示输入密码。密码输入正确以后，即可登录到 MySQL 数据库。 可以在 mysql 命令中直接加上密码，该命令为 mysql -h localhost -u root -proot。这里的 -p 后面的 root 就是密码。此处特别注意 -p 和密码之间没有空格。如果出现空格，系统将不会把后面的字符串当成密码来对待。 系统提示输入密码。（若选用第二/四种方式进行登录，则跳过本步骤） 成功登录到MySQL数据库。登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，如下图所示。 登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，然后下面还有一些说明性的语句，如图所示。 这些说明性语句介绍如下： Commands end with; or\\g：说明 mysql 命令行下的命令是以分号（;）或“\\g”来结束的，遇到这个结束符就开始执行命令。 Your MySQL connection id is 3：id 表示 MySQL 数据库的连接次数。 Server version: 5. 7.29-log MySQL Community Server（GPL）：Server version 后面说明数据库的版本，这个版本为 5.7.29。Community 表示该版本是社区版。 Type ‘help;’ or ‘\\h’ for help：表示输入”help;“或者”\\h“可以看到帮助信息。 Type ‘\\c’ to clear the current input statement：表示遇到”\\c“就清除前面的命令。 提示：当窗口中出现如上图所示的说明信息，命令提示符变为“mysql&gt;”时，表明已经成功登录 MySQL 服务器，可以开始对数据库进行操作了。 输入命令exit，即可退出MySQL。 MySQL Command Line Client打开 MySQL Command Line Client 进入提示输入密码的界面，如图所示。 输入正确的密码后，登录到 MySQL 软件。如果以这种方式登录 MySQL，需要保证 MySQL 服务处于启动状态。","text":"安装好MySQL后，默认启动服务，这时候开始尝试登录MySQL数据库。 有两种登录方式： Power Shell 或 CMD（DOS窗口） 命令行客户端（MySQL Command Line Client）【安装软件时，一般会安装的】 Power Shell 启动 Power Shell 。 输入命令cd C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin（cd+空格+安装目录/bin），回车。 输入登录命令，回车。登录命令有4中，选其一即可： 12345678#第一种 服务器主机地址+不接密码mysql -h localhost -u root -p#第二种 服务器主机地址+密码mysql -h localhost -u root -proot#第三种 省略服务器主机地址+不接密码，默认localhostmysql -u root -p#第四种 省略服务器主机地址+密码，默认localhostmysql -u root -proot 提示：mysql 为登录命令，-h 后面的参数是服务器的主机地址，在这里客户端和服务器在同一台机器上，所以输入 localhost 或者 IP 地址；-u 后面跟登录数据库的用户名称，在这里为 root；-p 后面是用户登录密码。 在 DOS 窗口下运行该命令后，系统会提示输入密码。密码输入正确以后，即可登录到 MySQL 数据库。 可以在 mysql 命令中直接加上密码，该命令为 mysql -h localhost -u root -proot。这里的 -p 后面的 root 就是密码。此处特别注意 -p 和密码之间没有空格。如果出现空格，系统将不会把后面的字符串当成密码来对待。 系统提示输入密码。（若选用第二/四种方式进行登录，则跳过本步骤） 成功登录到MySQL数据库。登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，如下图所示。 登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，然后下面还有一些说明性的语句，如图所示。 这些说明性语句介绍如下： Commands end with; or\\g：说明 mysql 命令行下的命令是以分号（;）或“\\g”来结束的，遇到这个结束符就开始执行命令。 Your MySQL connection id is 3：id 表示 MySQL 数据库的连接次数。 Server version: 5. 7.29-log MySQL Community Server（GPL）：Server version 后面说明数据库的版本，这个版本为 5.7.29。Community 表示该版本是社区版。 Type ‘help;’ or ‘\\h’ for help：表示输入”help;“或者”\\h“可以看到帮助信息。 Type ‘\\c’ to clear the current input statement：表示遇到”\\c“就清除前面的命令。 提示：当窗口中出现如上图所示的说明信息，命令提示符变为“mysql&gt;”时，表明已经成功登录 MySQL 服务器，可以开始对数据库进行操作了。 输入命令exit，即可退出MySQL。 MySQL Command Line Client打开 MySQL Command Line Client 进入提示输入密码的界面，如图所示。 输入正确的密码后，登录到 MySQL 软件。如果以这种方式登录 MySQL，需要保证 MySQL 服务处于启动状态。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"博客中的icon","slug":"博客中的icon","date":"2020-02-08T13:45:34.000Z","updated":"2020-02-12T13:46:39.313Z","comments":true,"path":"2020/02/08/博客中的icon/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84icon/","excerpt":"在主题的配置文件中的 icon 是 fontawesome 图标名，你要显示什么图标，去 fontawesome.com 找免费版的就可以了。","text":"在主题的配置文件中的 icon 是 fontawesome 图标名，你要显示什么图标，去 fontawesome.com 找免费版的就可以了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"MySQL基础教学","slug":"MySQL基础教学","date":"2020-02-08T13:25:58.000Z","updated":"2020-02-11T10:56:14.874Z","comments":true,"path":"2020/02/08/MySQL基础教学/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/MySQL%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/","excerpt":"两个学习MySQL基础的网站： C语言中文网 菜鸟教程","text":"两个学习MySQL基础的网站： C语言中文网 菜鸟教程 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[转]MySQL安装","slug":"转-MySQL安装","date":"2020-02-08T12:58:45.000Z","updated":"2020-02-11T10:56:14.927Z","comments":true,"path":"2020/02/08/转-MySQL安装/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E8%BD%AC-MySQL%E5%AE%89%E8%A3%85/","excerpt":"转载一份非常详细的【MySQL】的安装教程。","text":"转载一份非常详细的【MySQL】的安装教程。 进入官网找到自己所需的安装包：https://dev.mysql.com/ ，路径：DOWNLOAD–&gt;MYSQL Community Edition(GRL)–&gt;MYSQL on Windows (Installer &amp; Tool) 找到所需的安装包: 点击download。这里选择的是安装版（mysql -install-community） 选择不登陆下载。 双击运行下载好的mysql-installer-community-5.7.19.0.msi，程序运行需要一些时间，请等待一下。 运行成功之后，进入欢迎的界面.选择我同意协议，不然无法进行下一步。 进入类型选择页面，本人需要mysql云服务就选择了developer default（7.1是默认安装的步骤），如果只想安装mysql server的就选择custom模式（7.2步骤是选择自己需要的服务器类型，所选择的用于做一些数据分析） 12345developer default（开发者默认）：安装mysql开发所需的所有产品server only（服务器）：只安装mysql服务器产品client only（客户端）：只安装没有服务器的mysql客户端产品full（完全）：安装所有包含的mysql产品和功能custom（手动）：手动选择系统上应安装的产品 7.1 开发者默认模式检测以下程序会安装不成功，点击下一步进入下一个安装流程—&gt;跳到第八步。 check requirements：以下产品的请求失败，安装程序将自动尝试解决其中一些问题。标记为手动的要求无法自动解决。单击这些项目以尝试手动恢复。 检测到不可安装的程序说明： Visual Studio：是一款代码编辑工具（可编写C#、Visual Basic、C++、TypeScript、F# ），如果你安装的话就安装要求去安装Visual Studio version：2012.2013.2015.2017其中一个版本 Connector/pyton 3.4：电脑有python3.6了就没选择3.4版本的。如果你没安装有python可按要求去安装一些内容。 7.2 选择mysql server（服务） 5.7.19 x64 选择mysql workbench(mysql 的工作薄) 6.3.9 x64 选择mysql notiyier(通知) 1.1.7 x86(因为这里只有一个选择所以选择了86)点击下一步进入下一个安装流程—&gt;跳到第九步。 当我们点击下一步的时候安装程序出现了提示：（一个或者移动产品要求没有得到满足，那些符合要求的产品将不会安装/升级。你想要继续吗），这里我选择的是：YES 在安装所选界面能看到我们接下来所需要安装的程序，点击execute 安装程序进度界面，安装需要一些时间。点击dide tails能看到安装日志 程序安装完成之后，点击next 在product configutration（产品配置）页面能看到需要配置的程序，点击next（页面英语介绍：现在我们将逐一介绍以下产品的配置向导。您可以随时取消，如果您希望离开此向导，而不必配置所有产品） 先配置mysql server的类型以及网络：type and networking（类型和网络），这里有两种mysql server类型，选择第一种类型点击next。 123456有两种类型简单介绍1.standalone mysql server/classic mysql replication：独立的mysql服务器/经典的mysql复制choose this option if you want to run the mysql server either standalone with the opportunity to later configure classic mysql replication：选择这个选项，如果你想运行mysql服务器是独立的，有机会以后配置经典的mysql复制2. innodb cluster sandbox thst setup(for testing only)：innodb集群沙箱thst设置（仅用于测试） 设置服务器配置类型以及连接端口：继续next 12Config Type:选择Development Machine，用于小型以及学习所用足够了。Port number：输入3306，也可以输入其他最好是3306-3309之间。 配置root的密码（该密码要记住），系统提示这密码虚弱 添加其他管理员，点击add user 输入账号密码点击ok（如果添加的管理员只允许在本地登录就将host改成local），回到界面之后点击next 配置mysql在windows系统中的名字，是否选择开机启动mysql服务，其它的没进行修改，点击“Next”. 配置插件和扩展页面没进行修改直接下一步： Mysql server :apply configuration（应用配置页面），选择execute进行安装配置 mysql server应用配置的log，选择finish 安装程序又回到了product configutration（产品配置）页面，此时我们看到mysql server安装成功的显示，继续下一步： 配置mysql router：勾选configure mysql route for innoDB cluster之后输入密码。（如果不想输入密码可直接点击点一下）点击下一步 Mysql router :apply configuration（应用配置页面）点击execute, 安装完成之后点击选择finish 检测root密码 12 安装一些server，老规矩点击execute，完成之后点击finish 程序回到产品配置页面。继续下一步： 安装程序完成界面。 双击运行之前下载的安装包，能看到我们所安装的产品。 配置mysql环境变量 12上面安装的是时候我们看到mysql默认安装路径是：C:\\Program Files\\MySQL\\MySQL Server 5.7我的电脑右键—&gt;属性à高级系统设置à环境变量à新建MYSQL_HOME,将安装目录输入： 1找到path编辑：输入%MYSQL_HOME%\\bin 12打开cmd输入mysql –u root –p输入root的密码 原文链接：https://www.cnblogs.com/xiaodingdong/p/7223245.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}],"author":{"name":"叮咚丶哈哈","url":"https://www.cnblogs.com/xiaodingdong/p/7223245.html"}},{"title":"元宵团圆饭","slug":"元宵团圆饭","date":"2020-02-08T09:13:43.000Z","updated":"2020-02-08T09:37:50.898Z","comments":true,"path":"2020/02/08/元宵团圆饭/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E5%85%83%E5%AE%B5%E5%9B%A2%E5%9C%86%E9%A5%AD/","excerpt":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！”","text":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"第一个元宵","slug":"第一个元宵","date":"2020-02-08T09:13:43.000Z","updated":"2020-02-08T10:52:37.428Z","comments":true,"path":"2020/02/08/第一个元宵/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E5%AE%B5/","excerpt":"🌸于我们，这是妈走后的第一个元宵。 🎈这次没有汤圆…… 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” 👍附上老爸的新作(暂时想不出名字来hh，反正好吃hh)","text":"🌸于我们，这是妈走后的第一个元宵。 🎈这次没有汤圆…… 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” 👍附上老爸的新作(暂时想不出名字来hh，反正好吃hh) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"[转]jsdelivr的使用","slug":"转-jsdelivr的使用","date":"2020-02-08T06:22:39.000Z","updated":"2020-02-11T10:56:14.933Z","comments":true,"path":"2020/02/08/转-jsdelivr的使用/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E8%BD%AC-jsdelivr%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"本文链接：https://blog.csdn.net/qq_36910987/article/details/89562291","text":"本文链接：https://blog.csdn.net/qq_36910987/article/details/89562291 12345678jsdelivr https://www.jsdelivr.com/下面就以举例子的方式说明我是用 jsdelivr 来访问 github的资源，做博客来着我的github https://github.com/yuDuChen/yuduchen下面直接说怎么用jsdelivr，就不提如何创建github了首先需要创建 releases 12创建完,随便进入到一个文件,注意地址名1 1234567https://github.com/yuDuChen/yuduchen/blob/v1.5.6/layui/layui.js 这个地址用jsdelivr来访问https://cdn.jsdelivr.net/gh/yuDuChen/yuduchen@v1.5.6/layui/layui.js 对比一下就发现怎么用了吧注* 不使用jsdelivr直接引用github的文件 content-type 是 text/plain 页面无法解析 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"jQuery","slug":"jQuery","permalink":"https://melodyjerry.github.io/blog/tags/jQuery/"}],"author":{"name":"羽渡尘","url":"https://blog.csdn.net/qq_36910987/article/details/89562291"}},{"title":"蓝桥杯-基础练习-01字串","slug":"蓝桥杯-基础练习-01字串","date":"2020-02-07T13:24:17.000Z","updated":"2020-02-08T10:53:52.613Z","comments":true,"path":"2020/02/07/蓝桥杯-基础练习-01字串/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-01%E5%AD%97%E4%B8%B2/","excerpt":"在刷蓝桥杯试题时候，有一道很意思又有丶烧脑的题目👇 资源限制时间限制：1.0s 内存限制：256.0MB 问题描述对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是： 00000 00001 00010 00011 00100 请按从小到大的顺序输出这32种01串。 输入格式本试题没有输入。 输出格式输出32行，按从小到大的顺序每行一个长度为5的01串。 样例输出00000000010001000011&lt;以下部分省略&gt;","text":"在刷蓝桥杯试题时候，有一道很意思又有丶烧脑的题目👇 资源限制时间限制：1.0s 内存限制：256.0MB 问题描述对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是： 00000 00001 00010 00011 00100 请按从小到大的顺序输出这32种01串。 输入格式本试题没有输入。 输出格式输出32行，按从小到大的顺序每行一个长度为5的01串。 样例输出00000000010001000011&lt;以下部分省略&gt; 提交代码（Java）暴力输出刚开始想不出什么好办法，就直接把32个都写出来。抱着玩的心态，试试暴力输出看看系统给不给过，但是没想到，还真给我过了hhh 123456789101112131415161718192021222324252627282930313233343536public class Main { public static void main(String[] args) { System.out.println(\"00000\"); System.out.println(\"00001\"); System.out.println(\"00010\"); System.out.println(\"00011\"); System.out.println(\"00100\"); System.out.println(\"00101\"); System.out.println(\"00110\"); System.out.println(\"00111\"); System.out.println(\"01000\"); System.out.println(\"01001\"); System.out.println(\"01010\"); System.out.println(\"01011\"); System.out.println(\"01100\"); System.out.println(\"01101\"); System.out.println(\"01110\"); System.out.println(\"01111\"); System.out.println(\"10000\"); System.out.println(\"10001\"); System.out.println(\"10010\"); System.out.println(\"10011\"); System.out.println(\"10100\"); System.out.println(\"10101\"); System.out.println(\"10110\"); System.out.println(\"10111\"); System.out.println(\"11000\"); System.out.println(\"11001\"); System.out.println(\"11010\"); System.out.println(\"11011\"); System.out.println(\"11100\"); System.out.println(\"11101\"); System.out.println(\"11110\"); System.out.println(\"11111\"); }} 五层循环这是我想到的第二个方法，就类似说的“逢二进一”吧 1234567891011public class Main { public static void main(String[] args) { int a,b,c,d,e; for(a=0;a&lt;2;++a) for(b=0;b&lt;2;++b) for(c=0;c&lt;2;++c) for(d=0;d&lt;2;++d) for(e=0;e&lt;2;++e) System.out.printf(\"%d%d%d%d%d\\n\",a,b,c,d,e); }} 以下两种方法均来自网络。 十进制转换二进制12345678910111213public class Main { public static void main(String[] args) { for(int i=0;i&lt;32;i++){ int a,b,c,d,e; a = i%32/16; b = i%16/8; c = i%8/4; d = i%4/2; e = i%2; System.out.printf(\"%d%d%d%d%d\\n\",a,b,c,d,e); } }} 以下标求1一共是32个串，给每个串设置0-31的下标。根据下标，寻找对应串中1出现的位置。👇 比如，下标3表示的串是“00011”，利用while循环可以找到出现1的下标是1、2 12345678910111213141516171819public class Main { public static void main(String[] args) { for(int i=0;i&lt;=31;i++){ int a[]= new int[5];// 默认初始化值为0 //或 int a[]= {0,0,0,0,0}; int temp=i; int index=0; while(temp!=0) { a[index]=temp%2; index++; temp/=2; } for(int idx=4;idx&gt;=0;idx--) System.out.print(a[idx]); System.out.println(); } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://melodyjerry.github.io/blog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"使用fancybox标签实现图片浏览器","slug":"使用-fancybox-标签实现图片浏览器","date":"2020-02-07T12:42:55.000Z","updated":"2020-02-07T15:20:51.233Z","comments":true,"path":"2020/02/07/使用-fancybox-标签实现图片浏览器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/%E4%BD%BF%E7%94%A8-fancybox-%E6%A0%87%E7%AD%BE%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E5%99%A8/","excerpt":"使用&lt;fancybox&gt;&lt;/fancybox&gt;标签实现图片浏览器 单张图，只提供放大🔍关闭❌两个按钮，见黄色标记👇 多张图，可幻灯片播放，见红色标记👇","text":"使用&lt;fancybox&gt;&lt;/fancybox&gt;标签实现图片浏览器 单张图，只提供放大🔍关闭❌两个按钮，见黄色标记👇 多张图，可幻灯片播放，见红色标记👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"蓝桥杯-入门训练-Fibonacci数列","slug":"蓝桥杯—-入门训练-Fibonacci数列","date":"2020-02-07T11:48:54.000Z","updated":"2020-02-07T15:20:51.243Z","comments":true,"path":"2020/02/07/蓝桥杯—-入门训练-Fibonacci数列/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E2%80%94-%E5%85%A5%E9%97%A8%E8%AE%AD%E7%BB%83-Fibonacci%E6%95%B0%E5%88%97/","excerpt":"资源限制时间限制：1.0s 内存限制：256.0MB 问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 样例输入10 样例输出55 样例输入22 样例输出7704 数据规模与约定1 &lt;= n &lt;= 1,000,000。","text":"资源限制时间限制：1.0s 内存限制：256.0MB 问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 样例输入10 样例输出55 样例输入22 样例输出7704 数据规模与约定1 &lt;= n &lt;= 1,000,000。 提交代码（Java）第一次提交第一次时候，我想使用递归的方式👇 123456789101112131415161718import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(F(n)%10007); sc.close(); } private static int F(int n) { if(n==1||n==2) return 1; else return F(n-1)+F(n-2); }} 提交后，系统提示【运行超时】👇 第二次提交使用递归来处理，比较耗时。 而且这次我按照题目的提示【说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。】来处理，就改用数组来实现👇 1234567891011121314151617181920import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int F[] = new int[n+2]; F[1] = F[2] = 1; if(n &gt; 2) { for(int i=3; i&lt;=n; i++) // F[i]直接计算到求余数的值，即保存余数 F[i]=(F[i-1]+F[i-2])%10007; } //F[n]即所求值 System.out.println(F[n]); sc.close(); }} 这次直接通过👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://melodyjerry.github.io/blog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java之printf格式化输出的例子","slug":"Java之printf格式化输出的例子","date":"2020-02-07T09:46:23.000Z","updated":"2020-02-07T15:20:51.226Z","comments":true,"path":"2020/02/07/Java之printf格式化输出的例子/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/Java%E4%B9%8Bprintf%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%9A%84%E4%BE%8B%E5%AD%90/","excerpt":"转载自菜鸟教程","text":"转载自菜鸟教程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import java.util.Date; /** * 使用printf输出 *//**关键技术点 * 使用java.io.PrintStream的printf方法实现C风格的输出 * printf 方法的第一个参数为输出的格式,第二个参数是可变长的,表示待输出的数据对象 */public class Printf { public static void main(String[] args) { /*** 输出字符串 ***/ // %s表示输出字符串，也就是将后面的字符串替换模式中的%s System.out.printf(\"%s\", new Integer(1212)); // %n表示换行 System.out.printf(\"%s%n\", \"end line\"); // 还可以支持多个参数 System.out.printf(\"%s = %s%n\", \"Name\", \"Zhangsan\"); // %S将字符串以大写形式输出 System.out.printf(\"%S = %s%n\", \"Name\", \"Zhangsan\"); // 支持多个参数时，可以在%s之间插入变量编号，1$表示第一个字符串，3$表示第3个字符串 System.out.printf(\"%1$s = %3$s %2$s%n\", \"Name\", \"san\", \"Zhang\"); /*** 输出boolean类型 ***/ System.out.printf(\"true = %b; false = \", true); System.out.printf(\"%b%n\", false); /*** 输出整数类型***/ Integer iObj = 342; // %d表示将整数格式化为10进制整数 System.out.printf(\"%d; %d; %d%n\", -500, 2343L, iObj); // %o表示将整数格式化为8进制整数 System.out.printf(\"%o; %o; %o%n\", -500, 2343L, iObj); // %x表示将整数格式化为16进制整数 System.out.printf(\"%x; %x; %x%n\", -500, 2343L, iObj); // %X表示将整数格式化为16进制整数，并且字母变成大写形式 System.out.printf(\"%X; %X; %X%n\", -500, 2343L, iObj); /*** 输出浮点类型***/ Double dObj = 45.6d; // %e表示以科学技术法输出浮点数 System.out.printf(\"%e; %e; %e%n\", -756.403f, 7464.232641d, dObj); // %E表示以科学技术法输出浮点数，并且为大写形式 System.out.printf(\"%E; %E; %E%n\", -756.403f, 7464.232641d, dObj); // %f表示以十进制格式化输出浮点数 System.out.printf(\"%f; %f; %f%n\", -756.403f, 7464.232641d, dObj); // 还可以限制小数点后的位数 System.out.printf(\"%.1f; %.3f; %f%n\", -756.403f, 7464.232641d, dObj); /*** 输出日期类型***/ // %t表示格式化日期时间类型，%T是时间日期的大写形式，在%t之后用特定的字母表示不同的输出格式 Date date = new Date(); long dataL = date.getTime(); // 格式化年月日 // %t之后用y表示输出日期的年份（2位数的年，如99） // %t之后用m表示输出日期的月份，%t之后用d表示输出日期的日号 System.out.printf(\"%1$ty-%1$tm-%1$td; %2$ty-%2$tm-%2$td%n\", date, dataL); // %t之后用Y表示输出日期的年份（4位数的年）， // %t之后用B表示输出日期的月份的完整名， %t之后用b表示输出日期的月份的简称 System.out.printf(\"%1$tY-%1$tB-%1$td; %2$tY-%2$tb-%2$td%n\", date, dataL); // 以下是常见的日期组合 // %t之后用D表示以 \"%tm/%td/%ty\"格式化日期 System.out.printf(\"%1$tD%n\", date); //%t之后用F表示以\"%tY-%tm-%td\"格式化日期 System.out.printf(\"%1$tF%n\", date); /*** 输出时间类型***/ // 输出时分秒 // %t之后用H表示输出时间的时（24进制），%t之后用I表示输出时间的时（12进制）， // %t之后用M表示输出时间的分，%t之后用S表示输出时间的秒 System.out.printf(\"%1$tH:%1$tM:%1$tS; %2$tI:%2$tM:%2$tS%n\", date, dataL); // %t之后用L表示输出时间的秒中的毫秒 System.out.printf(\"%1$tH:%1$tM:%1$tS %1$tL%n\", date); // %t之后p表示输出时间的上午或下午信息 System.out.printf(\"%1$tH:%1$tM:%1$tS %1$tL %1$tp%n\", date); // 以下是常见的时间组合 // %t之后用R表示以\"%tH:%tM\"格式化时间 System.out.printf(\"%1$tR%n\", date); // %t之后用T表示以\"%tH:%tM:%tS\"格式化时间 System.out.printf(\"%1$tT%n\", date); // %t之后用r表示以\"%tI:%tM:%tS %Tp\"格式化时间 System.out.printf(\"%1$tr%n\", date); /*** 输出星期***/ // %t之后用A表示得到星期几的全称 System.out.printf(\"%1$tF %1$tA%n\", date); // %t之后用a表示得到星期几的简称 System.out.printf(\"%1$tF %1$ta%n\", date); // 输出时间日期的完整信息 System.out.printf(\"%1$tc%n\", date); }}/** *printf方法中,格式为\"%s\"表示以字符串的形式输出第二个可变长参数的第一个参数值; *格式为\"%n\"表示换行;格式为\"%S\"表示将字符串以大写形式输出;在\"%s\"之间用\"n$\"表示 *输出可变长参数的第n个参数值.格式为\"%b\"表示以布尔值的形式输出第二个可变长参数 *的第一个参数值. *//** * 格式为\"%d\"表示以十进制整数形式输出;\"%o\"表示以八进制形式输出;\"%x\"表示以十六进制 * 输出;\"%X\"表示以十六进制输出,并且将字母(A、B、C、D、E、F)换成大写.格式为\"%e\"表 * 以科学计数法输出浮点数;格式为\"%E\"表示以科学计数法输出浮点数,而且将e大写;格式为 * \"%f\"表示以十进制浮点数输出,在\"%f\"之间加上\".n\"表示输出时保留小数点后面n位. *//** * 格式为\"%t\"表示输出时间日期类型.\"%t\"之后用y表示输出日期的二位数的年份(如99)、用m * 表示输出日期的月份,用d表示输出日期的日号;\"%t\"之后用Y表示输出日期的四位数的年份 * (如1999)、用B表示输出日期的月份的完整名,用b表示输出日期的月份的简称.\"%t\"之后用D * 表示以\"%tm/%td/%ty\"的格式输出日期、用F表示以\"%tY-%tm-%td\"的格式输出日期. *//** * \"%t\"之后用H表示输出时间的时(24进制),用I表示输出时间的时(12进制),用M表示输出时间 * 分,用S表示输出时间的秒,用L表示输出时间的秒中的毫秒数、用 p 表示输出时间的是上午还是 * 下午.\"%t\"之后用R表示以\"%tH:%tM\"的格式输出时间、用T表示以\"%tH:%tM:%tS\"的格式输出 * 时间、用r表示以\"%tI:%tM:%tS %Tp\"的格式输出时间. *//** * \"%t\"之后用A表示输出日期的全称,用a表示输出日期的星期简称. */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}],"author":{"name":"菜鸟教程","url":"https://www.runoob.com/"}},{"title":"给博客添加一些挂件","slug":"转-给博客添加一些挂件","date":"2020-02-05T14:40:27.000Z","updated":"2020-02-07T15:20:51.247Z","comments":true,"path":"2020/02/05/转-给博客添加一些挂件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/%E8%BD%AC-%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E6%8C%82%E4%BB%B6/","excerpt":"阅读了官方文档 和 TRHX‘S BLOG 等文档/文章后，搜集了一部分教程","text":"阅读了官方文档 和 TRHX‘S BLOG 等文档/文章后，搜集了一部分教程 自定义鼠标指针样式在 \\themes\\material-x\\source\\less\\_base.less 文件 body 样式里写入如下代码： 123456body { cursor: url(https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur),auto; background-color: @theme_background; ...... ......} 鼠标指针可以用 Axialis CursorWorkshop 这个软件自己制作，不同主题具体放的文件有所不同，确保在博客主体 body 的 CSS 文件中即可，其中的鼠标指针链接可替换成自己的，首先尝试加载 https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur ，如果该文件不存在或由于其他原因无效，那么 auto 会被使用，也就是自动默认效果，图片格式为.ico、.ani、.cur，建议使用.cur，如果使用.ani或者其他格式无效，原因是浏览器兼容问题，请阅读参考文档或者参考以下兼容表： 浏览器 最低版本 格式 Internet Explorer 6.0 .cur / .ani Firefox (Gecko), Windows and Linux 1.5 (1.8) .cur / .png / .gif / .jpg Firefox (Gecko) 4.0 (2.0) .cur / .png / .gif / .jpg / .svg Opera — — Safari (Webkit) 3.0 (522-523) .cur / .png / .gif / .jpg 拓展阅读：《CSS 鼠标样式 cursor属性》 （By：歪脖先生的博客） 打字特效（蓝色）123456&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.11\"&gt;&lt;/script&gt; &lt;script&gt;var typed = new Typed(\"#subtitle\", { strings: [\"Live a good life, write some good code !!!\", \"愿自己的努力终将获得回报。\", \"花开不是为了花落，而是为了开的更加灿烂。\", \"没有伞的孩子必须努力奔跑！\", \"欲望以提升热忱，毅力以磨平高山。\", \"如果放弃太早，你永远都不知道自己会错过什么。\", \"没有礁石，就没有美丽的浪花；没有挫折，就没有壮丽的人生。\"], startDelay: 1000, typeSpeed: 100, loop: !0, backSpeed: 60, backDelay: 2000, showCursor: !0 })&lt;/script&gt;&lt;div style=\"text-align: center;font-weight: bold;color: #1BC3FB;\"&gt; &lt;span id=\"subtitle\"&gt;没有伞的孩子必须努力奔跑！&lt;/span&gt;&lt;span class=\"typed-cursor typed-cursor--blink\"&gt;|&lt;/span&gt; &lt;span id=\"typed-cursor\"&gt;&lt;/span&gt; &lt;/div&gt; 效果 👇 var typed = new Typed(\"#subtitle\", { strings: [\"Live a good life, write some good code !!!\", \"愿自己的努力终将获得回报。\", \"花开不是为了花落，而是为了开的更加灿烂。\", \"没有伞的孩子必须努力奔跑！\", \"欲望以提升热忱，毅力以磨平高山。\", \"如果放弃太早，你永远都不知道自己会错过什么。\", \"没有礁石，就没有美丽的浪花；没有挫折，就没有壮丽的人生。\"], startDelay: 1000, typeSpeed: 100, loop: !0, backSpeed: 60, backDelay: 2000, showCursor: !0 }) 没有伞的孩子必须努力奔跑！| 网站访客地理信息 在.\\themes\\material-x\\layout\\layout.ejs中加入以下代码： 12&lt;!--网站访客地理信息--&gt;&lt;script type=\"text/javascript\" src=\"//rf.revolvermaps.com/0/0/8.js?i=5eqiqb8vl6p&amp;amp;m=2&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=33&amp;amp;z=17&amp;amp;rx=-40&amp;amp;lx=-540&amp;amp;ly=520&amp;amp;hi=60\" async=\"async\"&gt;&lt;/script&gt; 效果 👇 天气挂件 JS代码，用于将插件插入到网页内 123456789101112131415&lt;div id=\"tp-weather-widget\"&gt;&lt;/div&gt; &lt;script&gt; (function(a,h,g,f,e,d,c,b){b=function(){d=h.createElement(g);c=h.getElementsByTagName(g)[0];d.src=e;d.charset=\"utf-8\";d.async=1;c.parentNode.insertBefore(d,c)};a[\"SeniverseWeatherWidgetObject\"]=f;a[f]||(a[f]=function(){(a[f].q=a[f].q||[]).push(arguments)});a[f].l=+new Date();if(a.attachEvent){a.attachEvent(\"onload\",b)}else{a.addEventListener(\"load\",b,false)}}(window,document,\"script\",\"SeniverseWeatherWidget\",\"//cdn.sencdn.com/widget2/static/js/bundle.js?t=\"+parseInt((new Date().getTime() / 100000000).toString(),10))); window.SeniverseWeatherWidget('show', { flavor: \"bubble\", location: \"WS0E9D8WN298\", geolocation: true, language: \"zh-Hans\", unit: \"c\", theme: \"auto\", token: \"5fd5b254-57fe-4f8a-8a13-f92485efeb0b\", hover: \"enabled\", container: \"tp-weather-widget\" }) &lt;/script&gt; 插件网页版链接，用于嵌入到iframe或webview中 1&lt;iframe&gt;weather.seniverse.com/?token=5fd5b254-57fe-4f8a-8a13-f92485efeb0b&lt;/iframe&gt; 效果：见本博客页面左上角 背景添加动态线条效果在 .\\themes\\hexo-theme-spfk\\layout\\layout.ejs文件中添加如下代码： 1234&lt;!--动态线条背景--&gt;&lt;script type=\"text/javascript\"color=\"220,220,220\" opacity='0.7' zIndex=\"-2\" count=\"200\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt; 其中： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0） opacity：表示线条透明度（0~1），默认：0.5 count：表示线条的总数量，默认：150 zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1 人体时钟无意中发现了个有趣的人体时钟 HONE HONE CLOCK，作者是个日本人，点击此处访问作者博客，点击此处在作者原博客上查看动态样式，点击此处查看动态大图，如果你的博客上有合适的地方，加上一个人体时钟会很有趣的 实现代码： 12345&lt;!--人体时钟背景透明--&gt;&lt;script charset=\"Shift_JIS\" src=\"http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.js\"&gt;&lt;/script&gt;&lt;!--人体时钟背景白--&gt;&lt;script charset=\"Shift_JIS\" src=\"http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.js\"&gt;&lt;/script&gt; 背景动态彩带效果样式一是鼠标点击后彩带自动更换样式，样式二是飘动的彩带： 实现方法：在 \\themes\\material-x\\layout\\layout.ejs 文件的body前面添加如下代码： 12&lt;!-- 样式一（鼠标点击更换样式） --&gt;&lt;script src=\"https://g.joyinshare.com/hc/ribbon.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 12&lt;!-- 样式二（飘动的彩带） --&gt;&lt;script src=\"https://g.joyinshare.com/hc/piao.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 添加背景代码雨特效新建 DigitalRain.js，写入以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657复制window.onload = function(){ //获取画布对象 var canvas = document.getElementById(\"canvas\"); //获取画布的上下文 var context =canvas.getContext(\"2d\"); var s = window.screen; var W = canvas.width = s.width; var H = canvas.height; //获取浏览器屏幕的宽度和高度 //var W = window.innerWidth; //var H = window.innerHeight; //设置canvas的宽度和高度 canvas.width = W; canvas.height = H; //每个文字的字体大小 var fontSize = 12; //计算列 var colunms = Math.floor(W /fontSize); //记录每列文字的y轴坐标 var drops = []; //给每一个文字初始化一个起始点的位置 for(var i=0;i&lt;colunms;i++){ drops.push(0); } //运动的文字 var str =\"WELCOME TO WWW.ITRHX.COM\"; //4:fillText(str,x,y);原理就是去更改y的坐标位置 //绘画的函数 function draw(){ context.fillStyle = \"rgba(238,238,238,.08)\";//遮盖层 context.fillRect(0,0,W,H); //给字体设置样式 context.font = \"600 \"+fontSize+\"px Georgia\"; //给字体添加颜色 context.fillStyle = [\"#33B5E5\", \"#0099CC\", \"#AA66CC\", \"#9933CC\", \"#99CC00\", \"#669900\", \"#FFBB33\", \"#FF8800\", \"#FF4444\", \"#CC0000\"][parseInt(Math.random() * 10)];//randColor();可以rgb,hsl, 标准色，十六进制颜色 //写入画布中 for(var i=0;i&lt;colunms;i++){ var index = Math.floor(Math.random() * str.length); var x = i*fontSize; var y = drops[i] *fontSize; context.fillText(str[index],x,y); //如果要改变时间，肯定就是改变每次他的起点 if(y &gt;= canvas.height &amp;&amp; Math.random() &gt; 0.99){ drops[i] = 0; } drops[i]++; } }; function randColor(){//随机颜色 var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return \"rgb(\"+r+\",\"+g+\",\"+b+\")\"; } draw(); setInterval(draw,35);}; 在主题文件的相关css文件中（以 Material X 1.2.1 主题为例，在\\themes\\material-x-1.2.1\\source\\less_main.less 文件末尾）添加以下代码： 12345678910复制canvas { position: fixed; right: 0px; bottom: 0px; min-width: 100%; min-height: 100%; height: auto; width: auto; z-index: -1;} 然后在主题的 layout.ejs 文件中引入即可： 123复制&lt;!-- 数字雨 --&gt;&lt;canvas id=\"canvas\" width=\"1440\" height=\"900\" &gt;&lt;/canvas&gt;&lt;script type=\"text/javascript\" src=\"/js/DigitalRain.js\"&gt;&lt;/script&gt; 最终效果： 自定义一个不使用主题模板渲染的独立页面 有时候我们需要新建一个独立的页面，这个页面不使用主题的渲染，具有自己独立的样式，可以放一些自己的作品，相册什么的，以下就介绍这种独立页面的实现方法。 方法一： 使用 Hexo 提供的跳过渲染配置，在博客根目录的配置文件 _config.yml 里找到 skip_render 关键字，在后面添加想要跳过渲染的页面，比如我们创建 \\source\\about\\index.html， 配置文件填写：skip_render: about\\**，那么就表示 \\source\\about 里所有的文件将跳过渲染，里面的文件将会被直接复制到 public 文件夹，此时就会得到一个独立的 about 页面；官方文档：https://hexo.io/docs/configuration 方法二： 在文章头部的 Front-matter 里添加配置 layout: false 来跳过渲染配置，比如我们要使 about 页面跳过渲染，创建 \\source\\about\\index.md，将这个页面的相关 HTML 代码写进.md文件并保存，然后在 index.md 的头部写入： 123456789---layout: false---{% raw %}这里是 HTML 代码{% endraw %} PS：Front-matter 是 .md 文件最上方以 — 分隔的区域，用于指定个别文件的变量，官方文档：https://hexo.io/docs/front-matter 效果可以对比我的博客主页和关于页面 更改本地预览端口号hexo博客在执行 hexo s 进行本地预览的时候，默认端口号是4000，当该端口号被占用时会报错 Error: listen EADDRINUSE 0.0.0.0:4000 ，此时可以关闭占用该端口的进程，也可以更换端口号，更换端口号可以通过以下两种方法实现： 方法一：在根目录的 _config.yml 配置文件内加上如下代码更改 hexo s 运行时的端口号： 1234server: port: 5000 compress: true header: true 方法二：通过 hexo server -p 5000 命令来指定端口，这种方法只是本次执行有效 其他网页小挂件推荐 http://abowman.com/ 里面有很多有趣的小挂件，可以养养鱼、龟、狗、仓鼠等各式各样的虚拟宠物，能根据你的鼠标指针位置移动，直接复制代码就可以用 http://www.revolvermaps.com/ 它提供网站访客地理信息，可以以2D、3D等形式显示 http://www.amazingcounters.com/ 免费网站计数器，有非常多的样式供你选择，可以设置计数器初始数值，可以设置按访问量计数，也可以按独立访问者计数 https://www.seniverse.com/widget/get 心知天气提供基于Web的免费天气插件，可以为你的网站添加一项简洁美观的天气预报功能，并自动适配PC和手机上的浏览 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"[转]使用Hexo-Git-Backup插件备份你的Hexo博客","slug":"转-使用Hexo-Git-Backup插件备份你的Hexo博客","date":"2020-02-05T12:20:43.000Z","updated":"2020-02-07T15:20:51.244Z","comments":true,"path":"2020/02/05/转-使用Hexo-Git-Backup插件备份你的Hexo博客/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/%E8%BD%AC-%E4%BD%BF%E7%94%A8Hexo-Git-Backup%E6%8F%92%E4%BB%B6%E5%A4%87%E4%BB%BD%E4%BD%A0%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/","excerpt":"欢迎关注我的 CSDN 专栏：《个人博客搭建：Hexo+Github Pages》，从搭建到美化一条龙，帮你解决 Hexo 常见问题！ 由于 Hexo 博客是静态托管的，所有的原始数据都保存在本地，如果哪一天电脑坏了，或者是误删了本地数据，那就是叫天天不应叫地地不灵了，此时定时备份就显得比较重要了，常见的备份方法有：打包数据保存到U盘、云盘或者其他地方，但是早就有大神开发了备份插件：hexo-git-backup ，只需要一个命令就可以将所有数据包括主题文件备份到 github 了","text":"欢迎关注我的 CSDN 专栏：《个人博客搭建：Hexo+Github Pages》，从搭建到美化一条龙，帮你解决 Hexo 常见问题！ 由于 Hexo 博客是静态托管的，所有的原始数据都保存在本地，如果哪一天电脑坏了，或者是误删了本地数据，那就是叫天天不应叫地地不灵了，此时定时备份就显得比较重要了，常见的备份方法有：打包数据保存到U盘、云盘或者其他地方，但是早就有大神开发了备份插件：hexo-git-backup ，只需要一个命令就可以将所有数据包括主题文件备份到 github 了 首先进入你博客目录，输入命令 hexo version 查看 Hexo 版本，如图所示，我的版本是 3.7.1： 安装备份插件，如果你的 Hexo 版本是 2.x.x，则使用以下命令安装： 1$ npm install hexo-git-backup@0.0.91 --save 如果你的 Hexo 版本是 3.x.x，则使用以下命令安装： 1$ npm install hexo-git-backup --save 到 Hexo 博客根目录的 _config.yml 配置文件里添加以下配置： 1234567backup: type: git theme: material-x-1.2.1 message: Back up my www.itrhx.com blog repository: github: git@github.com:TRHX/TRHX.github.io.git,backup coding: git@git.dev.tencent.com:TRHX/TRHX.git,backup 参数解释： theme：你要备份的主题名称 message：自定义提交信息 repository：仓库名，注意仓库地址后面要添加一个分支名，比如我就创建了一个 backup 分支 最后使用以下命令备份你的博客： 1$ hexo backup 或者使用以下简写命令也可以： 1$ hexo b 备份成功后可以在你的仓库分支下看到备份的原始文件： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}],"author":{"name":"TRHX","avatar":"https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.9/images/trhx.png","url":"https://www.itrhx.com/"}},{"title":"RSS订阅(含转载内容)","slug":"RSS订阅-含转载内容","date":"2020-02-05T12:06:45.000Z","updated":"2020-02-07T15:20:51.229Z","comments":true,"path":"2020/02/05/RSS订阅-含转载内容/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/RSS%E8%AE%A2%E9%98%85-%E5%90%AB%E8%BD%AC%E8%BD%BD%E5%86%85%E5%AE%B9/","excerpt":"添加RSS订阅RSS订阅是站点用来和其他站点之间共享内容的一种简易方式，即Really Simple Syndication（简易信息聚合），如果不会使用，可以参见百度百科：https://baike.baidu.com/item/RSS%E8%AE%A2%E9%98%85/663114 ；首先我们安装feed插件，在本地hexo目录下右键git bash here，输入以下命令： 1$ npm install hexo-generator-feed 等待安装完成后，打开hexo目录下配置文件的_config.yml，在末尾添加以下配置： 12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 随后打开主题配置文件_config.yml，添加以下配置： 1rss: /atom.xml 至此，RSS订阅功能添加完成 【注】以下内容转载自互联网，其作者：奔跑中的奶酪 《可能是目前最全的RSS订阅源了》导读继上一篇文章《当我们谈论RSS时，我们在谈论什么？ 》发布后，阅读甚少，反响也是平平。奶酪不得不承认一个事实，RSS 做为一种“上古神器”，如果你经历过 RSS 的风光时期，你会一直喜欢它。但如果你对它了解甚少，尽管我再如何推荐，高使用门槛还是很难让你对RSS喜欢得起来。 RSS 高门槛的主要原因在于，优质RSS阅读器选择少，以及订阅源的缺失。上一期我极力推荐了一款在线 RSS 阅读器 Feeder.co，它已经足够的优秀了。所以接下来的问题，就是解决如何寻找订阅源的问题了，而本期内容正是解决如何查找RSS 订阅源的问题。","text":"添加RSS订阅RSS订阅是站点用来和其他站点之间共享内容的一种简易方式，即Really Simple Syndication（简易信息聚合），如果不会使用，可以参见百度百科：https://baike.baidu.com/item/RSS%E8%AE%A2%E9%98%85/663114 ；首先我们安装feed插件，在本地hexo目录下右键git bash here，输入以下命令： 1$ npm install hexo-generator-feed 等待安装完成后，打开hexo目录下配置文件的_config.yml，在末尾添加以下配置： 12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 随后打开主题配置文件_config.yml，添加以下配置： 1rss: /atom.xml 至此，RSS订阅功能添加完成 【注】以下内容转载自互联网，其作者：奔跑中的奶酪 《可能是目前最全的RSS订阅源了》导读继上一篇文章《当我们谈论RSS时，我们在谈论什么？ 》发布后，阅读甚少，反响也是平平。奶酪不得不承认一个事实，RSS 做为一种“上古神器”，如果你经历过 RSS 的风光时期，你会一直喜欢它。但如果你对它了解甚少，尽管我再如何推荐，高使用门槛还是很难让你对RSS喜欢得起来。 RSS 高门槛的主要原因在于，优质RSS阅读器选择少，以及订阅源的缺失。上一期我极力推荐了一款在线 RSS 阅读器 Feeder.co，它已经足够的优秀了。所以接下来的问题，就是解决如何寻找订阅源的问题了，而本期内容正是解决如何查找RSS 订阅源的问题。 一、万物皆可RSS如果你细心观察就会发现，提供 RSS 相关服务的网站都是国外的，国内与 RSS 相关的网站都相继宣布关闭了。你会发现国内提供 RSS 相关服务的网站都是个人或者小机构，这其中有一个叫 RSSHub 的网站，是这其中的集大成者，它的作用是可以给任何奇奇怪怪的内容生成 RSS 订阅源。 一般网站和博客： 1). 通常在顶部菜单、右侧菜单、底部菜单等地方会有RSS图标。 2). 如果没有，可以尝试在网站地址后面加上/rss或者/feed，有时会出现在二级域名里。 3). 如果还没有，可以使用奶酪制作的小书签来自动查找RSS订阅源，","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"将本地文件上传到GitHub","slug":"将本地文件上传到Github","date":"2020-02-05T11:28:23.000Z","updated":"2020-02-08T09:22:16.587Z","comments":true,"path":"2020/02/05/将本地文件上传到Github/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0Github/","excerpt":"百度“如何将文件上传到Github”，其中发现两篇很有用的教程： 使用git将项目上传到github（最简单方法）如何使用git把本地代码上传（更新）到github上","text":"百度“如何将文件上传到Github”，其中发现两篇很有用的教程： 使用git将项目上传到github（最简单方法）如何使用git把本地代码上传（更新）到github上 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"}]},{"title":"浏览器网页标签页图标显示","slug":"浏览器网页标签页图标显示","date":"2020-02-04T12:20:00.000Z","updated":"2020-02-07T15:20:51.240Z","comments":true,"path":"2020/02/04/浏览器网页标签页图标显示/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E9%A1%B5%E6%A0%87%E7%AD%BE%E9%A1%B5%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA/","excerpt":"","text":"对于IE浏览器：把需要显示的16x16像素的ICO图标命名为favicon.ICO放置在网站根目录下，浏览器会自动检索 对于其他浏览器通用的在标签页加入指定图标的方法：把favicon.ico图标放到网站根目录下，在网页的``&lt;head&gt;&lt;/head&gt;``中加入 1234&lt;!-- 地址栏显示 --&gt;&lt;link rel=\"Shortcut Icon\" href=\"./favicon.ico\" type=\"image/x-icon\" /&gt;&lt;!-- 收藏栏也显示 --&gt;&lt;link rel=\"Bookmark\" href=\"./favicon.ico\" type=\"image/x-icon\" /&gt; 火狐浏览器对图标格式没有那么严格，GIF和PNG格式的图标也可以显示，图标名称也可以不是favcion 链接在线的图片 1&lt;link rel=\"Shortcut Icon\" href=\"http://csdnimg.cn/www/images/favicon.ico\"&gt; 获取ico图标的资源网 http://sc.chinaz.com/ favicon在线制作网站 https://tool.lu/favicon/ 图标制作，经常搞一些图标替换桌面图标 http://www.faviconico.org/ 或者在html的head表头中加 &lt;link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\" /&gt; 如果icon是gif动态图需要修改type属性 &lt;link rel=\"icon\" href=\"gif_favicon.gif\" type=\"image/gif\" &gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"}]},{"title":"文章作者","slug":"文章作者","date":"2020-02-03T09:36:53.000Z","updated":"2020-02-08T09:37:28.999Z","comments":true,"path":"2020/02/03/文章作者/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E4%BD%9C%E8%80%85/","excerpt":"由于支持多作者共同维护一个博客，所以可以设置单独一篇文章的作者： 123456---author: name: 作者 avatar: https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png url: https://baidu.com---","text":"由于支持多作者共同维护一个博客，所以可以设置单独一篇文章的作者： 123456---author: name: 作者 avatar: https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png url: https://baidu.com--- document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"文章置顶","slug":"文章置顶","date":"2020-02-03T09:34:15.000Z","updated":"2020-02-08T09:36:28.899Z","comments":true,"path":"2020/02/03/文章置顶/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6/","excerpt":"在Front-matter中设置以下值： 1top: true 如果想自定义置顶标签的文字，可以直接设置为字符串，例如： 1top: 近期更新","text":"在Front-matter中设置以下值： 1top: true 如果想自定义置顶标签的文字，可以直接设置为字符串，例如： 1top: 近期更新 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"文章分类","slug":"文章分类","date":"2020-02-03T09:34:05.000Z","updated":"2020-02-08T09:36:28.898Z","comments":true,"path":"2020/02/03/文章分类/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/","excerpt":"多个分类有两种关系，一种是层级（等同于文件夹），一种是并列（等同于标签）。 多级分类 1categories: [分类A, 分类B] 或者 123categories: - 分类A - 分类B 并列分类 123categories: - [分类A] - [分类B] 多级+并列分类 123categories: - [分类A, 分类B] - [分类C, 分类D]","text":"多个分类有两种关系，一种是层级（等同于文件夹），一种是并列（等同于标签）。 多级分类 1categories: [分类A, 分类B] 或者 123categories: - 分类A - 分类B 并列分类 123categories: - [分类A] - [分类B] 多级+并列分类 123categories: - [分类A, 分类B] - [分类C, 分类D] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"文章音乐bgm","slug":"文章音乐bgm","date":"2020-02-03T09:14:27.000Z","updated":"2020-02-29T12:08:45.168Z","comments":true,"path":"2020/02/03/文章音乐bgm/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E9%9F%B3%E4%B9%90bgm/","excerpt":"标题右边显示迷你音乐播放器，支持的字段有：server、type、id，取值详见【进阶设定 -&gt; 第三方服务 -&gt; APlayer】。 示例123456789---music: enable: true # true（文章内和文章列表都显示） internal（只在文章内显示） autoplay: true # 自动播放。默认：false server: netease # netease（网易云音乐）tencent（QQ音乐） xiami（虾米） kugou（酷狗） type: song # song （单曲） album （专辑） playlist （歌单） search （搜索） id: 26664345 # 歌曲/专辑/歌单 ID volume: 0.3 #声音大小--- 实际效果见：《文章专属BGM》","text":"标题右边显示迷你音乐播放器，支持的字段有：server、type、id，取值详见【进阶设定 -&gt; 第三方服务 -&gt; APlayer】。 示例123456789---music: enable: true # true（文章内和文章列表都显示） internal（只在文章内显示） autoplay: true # 自动播放。默认：false server: netease # netease（网易云音乐）tencent（QQ音乐） xiami（虾米） kugou（酷狗） type: song # song （单曲） album （专辑） playlist （歌单） search （搜索） id: 26664345 # 歌曲/专辑/歌单 ID volume: 0.3 #声音大小--- 实际效果见：《文章专属BGM》 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"添加CNZZ统计代码","slug":"添加CNZZ统计代码","date":"2020-02-03T08:13:53.000Z","updated":"2020-02-07T15:20:51.245Z","comments":true,"path":"2020/02/03/添加CNZZ统计代码/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%B7%BB%E5%8A%A0CNZZ%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/","excerpt":"先在博客主题配置文件themes\\material-x_config.yml添加代码： 12#添加CNZZ统计cnzz: true 这里这个cnzz的名字可以自己取；然后在themes\\material-x\\layout_partial里面创建一个 cnzz.ejs文件；把cnzz给的代码复制进去； 123&lt;% if (theme.cnzz){ %&gt; //这里添加复制的CNZZ代码&lt;% } %&gt; 然后再在footer.ejs的后面添加上一行代码就可以显示了（这里的位置可以换，可以不是scripts.ejs，或者是head.ejs，看自己的喜好） 12&lt;!--CNZZ统计--&gt;&lt;%- partial('cnzz') %&gt; 对百度统计也可以进行同样的处理； 123&lt;% if (theme.cnzz){ %&gt;//前面要添加的代码//百度统计的代码&lt;% } %&gt; 与上面的操作基本一致只是取得名字不一样。 上面的是一种方法； 如果嫌麻烦的话直接就在footer.ejs的后面添加cnzz的代码；直接就可以显示了（同理，可以添加在其他位置），貌似添加在这里速度最快。 123&lt;% if (theme.cnzz){ %&gt; //前面要添加的代码//这里添加复制的CNZZ代码&lt;% } %&gt; //后面要添加的 参考链接：https://blog.csdn.net/whjkm/article/details/37884563","text":"先在博客主题配置文件themes\\material-x_config.yml添加代码： 12#添加CNZZ统计cnzz: true 这里这个cnzz的名字可以自己取；然后在themes\\material-x\\layout_partial里面创建一个 cnzz.ejs文件；把cnzz给的代码复制进去； 123&lt;% if (theme.cnzz){ %&gt; //这里添加复制的CNZZ代码&lt;% } %&gt; 然后再在footer.ejs的后面添加上一行代码就可以显示了（这里的位置可以换，可以不是scripts.ejs，或者是head.ejs，看自己的喜好） 12&lt;!--CNZZ统计--&gt;&lt;%- partial('cnzz') %&gt; 对百度统计也可以进行同样的处理； 123&lt;% if (theme.cnzz){ %&gt;//前面要添加的代码//百度统计的代码&lt;% } %&gt; 与上面的操作基本一致只是取得名字不一样。 上面的是一种方法； 如果嫌麻烦的话直接就在footer.ejs的后面添加cnzz的代码；直接就可以显示了（同理，可以添加在其他位置），貌似添加在这里速度最快。 123&lt;% if (theme.cnzz){ %&gt; //前面要添加的代码//这里添加复制的CNZZ代码&lt;% } %&gt; //后面要添加的 参考链接：https://blog.csdn.net/whjkm/article/details/37884563 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"即日起，博客双平台同步发布","slug":"即日起，博客双平台同步发布","date":"2020-02-03T05:36:56.000Z","updated":"2020-02-20T11:08:20.206Z","comments":true,"path":"2020/02/03/即日起，博客双平台同步发布/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E5%8D%B3%E6%97%A5%E8%B5%B7%EF%BC%8C%E5%8D%9A%E5%AE%A2%E5%8F%8C%E5%B9%B3%E5%8F%B0%E5%90%8C%E6%AD%A5%E5%8F%91%E5%B8%83/","excerpt":"为了确保博客网站的连接，经历6h的打造，现新增Gitee版，目前两个可用博客如下： Hexo+Github 版 https://melodyhub.ltd/ Hexo+Gitee 版 https://melodyjerry.gitee.io/（新增） 值得注意的是，除去连接速度的差异外，两个网站的区别： 后增的Gitee版暂无HomePage（动画主页），后续会计划加入 计划加入一些新的动画、特效等 优化部分cdn 调整卡片的透明度，计划值：80% 其他，略","text":"为了确保博客网站的连接，经历6h的打造，现新增Gitee版，目前两个可用博客如下： Hexo+Github 版 https://melodyhub.ltd/ Hexo+Gitee 版 https://melodyjerry.gitee.io/（新增） 值得注意的是，除去连接速度的差异外，两个网站的区别： 后增的Gitee版暂无HomePage（动画主页），后续会计划加入 计划加入一些新的动画、特效等 优化部分cdn 调整卡片的透明度，计划值：80% 其他，略 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"[转]Hexo 博客主题个性化","slug":"[转]Hexo 博客主题个性化","date":"2020-02-02T06:25:47.000Z","updated":"2020-02-07T15:20:51.231Z","comments":true,"path":"2020/02/02/[转]Hexo 博客主题个性化/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/02/[%E8%BD%AC]Hexo%20%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96/","excerpt":"permalink: https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/ 以下为原文的摘要： 本文将讲述一些博客主题的美化、实用功能的添加，本文以作者 luuman 的 spfk 主题和作者 xaoxuu 的 Material X 主题为例，文章会不定时进行更新。文章涉及有关参考资料、教程、链接如有侵权请联系我删除！ 本文在CSDN的链接：《Hexo 博客优化之博客美化》、《Hexo 博客优化之实用功能添加》，Hexo 博客专栏，从前期搭建到后期美化，帮您解决常见问题：《Github/Coding Pages + Hexo》，对您有帮助就点个赞吧❤️ 请注意：不同主题可能方法有些不同，相同主题不同版本，配置方法也有所差异！ 博客美化前提条件：有一定的前端基础，了解 HTML、CSS、JS，了解 CSS 预处理语言 Sass、Less、Stylus，搞懂 hexo 的目录结构。 博客美化通用步骤：选定主题，认真阅读主题文档，分析主题目录结构，了解每个文件是对应网页哪个部分的，认真阅读美化教程，美化教程本质上只为你提供核心代码和思路，具体代码要添加到哪个地方，需要你自己搞懂主题结构，添加到需要的、合适的位置！ 博客美化终极奥秘：创作第一，体验第二，避免繁杂，简洁为上！","text":"permalink: https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/ 以下为原文的摘要： 本文将讲述一些博客主题的美化、实用功能的添加，本文以作者 luuman 的 spfk 主题和作者 xaoxuu 的 Material X 主题为例，文章会不定时进行更新。文章涉及有关参考资料、教程、链接如有侵权请联系我删除！ 本文在CSDN的链接：《Hexo 博客优化之博客美化》、《Hexo 博客优化之实用功能添加》，Hexo 博客专栏，从前期搭建到后期美化，帮您解决常见问题：《Github/Coding Pages + Hexo》，对您有帮助就点个赞吧❤️ 请注意：不同主题可能方法有些不同，相同主题不同版本，配置方法也有所差异！ 博客美化前提条件：有一定的前端基础，了解 HTML、CSS、JS，了解 CSS 预处理语言 Sass、Less、Stylus，搞懂 hexo 的目录结构。 博客美化通用步骤：选定主题，认真阅读主题文档，分析主题目录结构，了解每个文件是对应网页哪个部分的，认真阅读美化教程，美化教程本质上只为你提供核心代码和思路，具体代码要添加到哪个地方，需要你自己搞懂主题结构，添加到需要的、合适的位置！ 博客美化终极奥秘：创作第一，体验第二，避免繁杂，简洁为上！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}],"author":{"name":"TRHX","avatar":"https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.9/images/trhx.png","url":"https://www.itrhx.com/"}},{"title":"[转]如何搭建基于Hexo的独立博客","slug":"[转]如何搭建基于Hexo的独立博客","date":"2020-02-01T06:25:47.000Z","updated":"2020-02-07T15:20:51.230Z","comments":true,"path":"2020/02/01/[转]如何搭建基于Hexo的独立博客/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/01/[%E8%BD%AC]%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/","excerpt":"permalink: https://xaoxuu.com/blog/2017-07-05-hexo-blog/","text":"permalink: https://xaoxuu.com/blog/2017-07-05-hexo-blog/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}],"author":{"name":"xaoxuu","avatar":"https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png","url":"https://xaoxuu.com"}},{"title":"第一个除夕","slug":"第一个除夕","date":"2020-01-24T10:15:53.000Z","updated":"2020-02-08T09:30:11.038Z","comments":true,"path":"2020/01/24/第一个除夕/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/01/24/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%99%A4%E5%A4%95/","excerpt":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！”","text":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"再见2019，你好2020","slug":"再见，2019；你好，2020","date":"2019-12-31T16:00:00.000Z","updated":"2020-02-23T09:18:28.382Z","comments":true,"path":"2020/01/01/再见，2019；你好，2020/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/01/01/%E5%86%8D%E8%A7%81%EF%BC%8C2019%EF%BC%9B%E4%BD%A0%E5%A5%BD%EF%BC%8C2020/","excerpt":"# 前言 这是作为我2019年最后一年博客，同时是2020的第一篇博客。 起手写这篇博客时候是2019年12月晚上8点57分，距离2019的结束约3个小时👇","text":"# 前言 这是作为我2019年最后一年博客，同时是2020的第一篇博客。 起手写这篇博客时候是2019年12月晚上8点57分，距离2019的结束约3个小时👇 概括用一个词来概括我的2019年，我想到的是“酸甜苦辣咸”。 没错，我整一年的经历就和这五种味道一样，多而杂…… 我在成长的路上，一步一步地，独自前进…… 没错，独自，我甚至是常常自己对自己聊天。 我的微信置顶是自己，把想说的就发给自己，这样舒服些了👇 基本每天都有，随笔、想说的话、计划、临时的想法……👇 这一年来到现在，因为经历、看清一些事情后，我性格有所改变，为人处事有了较大的变化。 最为突出的就是暑假和国庆这两段时间，我对我自己“重新洗牌”了。 思考是我最常做的事情之一，思考什么呢？ 我现在到底在做什么？ 我为什么做？ 我想做什么？ 我要做什么？ 我还有多少时间做？ 未来我会往哪里去，往哪里回？ 现在的我我是不是我要的那个“我”？ …… …… 还有很多，为什么呢？ “好好做人”“好好做人“ 是我从小听到大，被唠叨最多次的话之一就是它。 除了经常被爸妈唠叨，我最近一次看见听见是在一部网剧《一起同过窗》（背景是大一大二），里面的叶老师是班主任，他的口头禅就是“好好做人”，学生惹没惹事，他都挂嘴上。 可是，真的明白“好好做人”吗？ “好好”在这是副词，用来修饰动词“做人”。 今年经历了太多太多难以忘记的事情，我似乎开始懂得为什么爸妈在我七岁时候就开始教导我要“好好做人”。 想必他们可能花费了几十年的阅历才懂得为什么吧…… 感动、感谢、感恩初略地把涉及到”感动“、”感恩“、”感谢“的人列在这里~ “因为感动，所以感谢，更要感恩！”这是爸妈教育我的。 我凭我的记忆最大限度地检索了这些人，但一定还是会有漏的…… 家人：爸和妈、弟弟（妮）、外公外婆、奶奶、大姨一家人、二姨一家人、小姨、小姨丈、大舅一家人、小舅、奕剑叔、文燕姑姑姑、还有很多不记得称呼的亲戚…… 朋友：廖鑫圣、陈波、赖洁莹、何庆钊、冼俊贤、张桂源、刘千瑜、朱茜妍、吴嘉隆、蔡泽佳、钟叶茂、杨迎、杨天瑞、谢佳豪、冯皓明、梁大浩、袁舒恩、欧芝妍、陈晓霞、吴森、陈子平…… 师兄姐（归属于朋友）：邱海燕、纪秋荣、卢情波、海英姐（李海英）、海雯师姐、王梁兴、张康、林逸豪、何庄芸、键林、林金翼、王景华、钟榴炜、吴丹婷（广外）、周卓颖、陈庆鸿…… 老师：倪宇班主任、老罗（罗智杰老师）、陈鑫老师、廖老师（勤工网络中心）、郭世仁老师、史婷婷老师、曾宪贵老师、古笑珍老师（小学班数学兼两年班主任）、陈彩玉老师（初中三年数学老师）…… 愿望我在日记本、便签等等上写了很多愿望，其中有些是想在2020年实现的。 我直接copy了，会有重复的，以下是我对自己微信聊天中的部分愿望👇 2020我想当个好儿子、好哥哥、好朋友、好学生、好人。 希望能有人能了解、能理解并接受我的人。 秉承信念，好好做人。 常回家看看，多陪陪家人 我想做自己，我想做“吴锐杰” 不想做那些不符合我风格的事 想拿到国家励志奖学金 希望找到一个人来填补我内心的空白 2020年我要来考驾照了 改变自己，让自己多一些坚硬、刚正、远谋、顾己 好好赚钱、好好学习、好好生活 希望每个人都平安、健康、幸福、好运、快乐 珍惜当下、好好做人、万事生意 找到能陪伴、鼓励、支持我的人 我想拿奖助学金，很想要 还掉所有欠别人的钱 给老弟预留一万的存款，供9月份上大学 好好勤工、挣多点钱，多吃些肉，长胖些 学更多的知识、技能，听更多的歌 想要一副好的身体，能不能搞好我的皮肤病呢 …… …… END文字没法完全表述我想表达的，其他的就存在我的心、记忆里吧 我可以忘记很多东西，也可以记得很多东西 2019年发生的一些事我不会忘🧡…… 2020年，Jerry加油，给我冲冲冲💪…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"绚丽彩虹同学录V1.4公测版","slug":"绚丽彩虹同学录V1-4公测版","date":"2019-12-28T06:34:01.000Z","updated":"2020-02-13T08:17:13.188Z","comments":true,"path":"2019/12/28/绚丽彩虹同学录V1-4公测版/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/28/%E7%BB%9A%E4%B8%BD%E5%BD%A9%E8%99%B9%E5%90%8C%E5%AD%A6%E5%BD%95V1-4%E5%85%AC%E6%B5%8B%E7%89%88/","excerpt":"","text":"部分截图 版本更新 自动更新(推荐): 管理员登陆后，进入控制台，点击检查更新，如有新版本点击“一键更新”等待更新完成即可。 手动更新流程: 更新包地址: http://cdn.badapple.top/PHP/XlchClassbook/UpdatePack下载对应版本的更新包,手动解压覆盖更新包到同学录安装目录。 更新日志☆ 1.4 公测版 (1004) 更新内容： 重要提示：更新完毕后请到 管理员控制台-&gt;站点配置-&gt;保存，以刷新数据！ 修复:手机上传图片打开相机 修复:“对我留言”功能 修复:无法删除相册 修复:允许空名相册 修复:权限组配置错误导致的安全漏洞 修复:验证码大小写问题 增加:可选绚丽彩虹播放器 增加:自定义导航栏功能 增加:教师、班长等权限组 增加:畅言图床、sm.ms、七牛云存储上传 增加:评论回复支持表情 增加:导入似水年华V3数据 优化:图片流设计 优化:同学录页面卡片设计 优化:管理员可设置用户是否允许上传相册 优化:安装时自动修复数据表结构 优化:配置文件结构变更 优化:做了一点微小的工作(细节优化) 更新时间：2018-07-03 23:39:54 ☆ 1.3 公测版 (1003) 更新内容： 修复:后台修改用户组 提示“用户名已被使用” 修复:“对TA留言”功能 修复:验证码大小写问题 修复:代码逻辑错误导致的安全隐患 修复:代码逻辑错误导致的无法在后台更新到新版本 更新时间：2018-04-22 21:20:20 文章附件蓝奏网盘 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"文章内长图","slug":"文章内长图","date":"2019-12-23T09:36:53.000Z","updated":"2020-02-23T09:20:51.672Z","comments":true,"path":"2019/12/23/文章内长图/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/23/%E6%96%87%E7%AB%A0%E5%86%85%E9%95%BF%E5%9B%BE/","excerpt":"文章内长图，使用html来实现 1&lt;center&gt;&lt;div style=\"position:relative;width:400px; height:400px; overflow:auto\"&gt;&lt;img src =\"https://i.loli.net/2019/12/31/LiP98f6XqgoHmla.png\"&gt;&lt;/div&gt;&lt;/center&gt; 效果👇","text":"文章内长图，使用html来实现 1&lt;center&gt;&lt;div style=\"position:relative;width:400px; height:400px; overflow:auto\"&gt;&lt;img src =\"https://i.loli.net/2019/12/31/LiP98f6XqgoHmla.png\"&gt;&lt;/div&gt;&lt;/center&gt; 效果👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"2019冬至","slug":"2019冬至","date":"2019-12-22T09:57:04.000Z","updated":"2020-02-03T08:31:36.470Z","comments":true,"path":"2019/12/22/2019冬至/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/22/2019%E5%86%AC%E8%87%B3/","excerpt":"😄2019.12.20-22，三天，在小姨家度过了一个冬至小长假。 🧡周五下午从学校出发，骑着小蓝到地铁站乘地铁，经过3条（2、3、9线）地铁线、18（13+3+2）个站、2次（嘉禾望岗、 高增）换乘，来到花都的小姨家。 以下为20号下午抵达花都时发的随笔 #生活 #记录三个月来，第一次出学校出趟远门. ᶘ ͡°ᴥ͡°ᶅ 今天的天气真不错，音乐、风、云……都陪伴着我，特别轻松 (୨୧•͈ᴗ•͈) 因为想家了，但回深圳有些麻烦，先来趟花都吧 ( ´◔ ‸◔`) 海珠来花都，还是有丶远。到了花都就变得有丶冷了 💛","text":"😄2019.12.20-22，三天，在小姨家度过了一个冬至小长假。 🧡周五下午从学校出发，骑着小蓝到地铁站乘地铁，经过3条（2、3、9线）地铁线、18（13+3+2）个站、2次（嘉禾望岗、 高增）换乘，来到花都的小姨家。 以下为20号下午抵达花都时发的随笔 #生活 #记录三个月来，第一次出学校出趟远门. ᶘ ͡°ᴥ͡°ᶅ 今天的天气真不错，音乐、风、云……都陪伴着我，特别轻松 (୨୧•͈ᴗ•͈) 因为想家了，但回深圳有些麻烦，先来趟花都吧 ( ´◔ ‸◔`) 海珠来花都，还是有丶远。到了花都就变得有丶冷了 💛 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"phpEnv一款优雅强大的php集成开发环境","slug":"phpEnv一款优雅强大的php集成开发环境 (1)","date":"2019-12-21T05:47:34.000Z","updated":"2020-02-21T05:19:29.659Z","comments":true,"path":"2019/12/21/phpEnv一款优雅强大的php集成开发环境 (1)/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/21/phpEnv%E4%B8%80%E6%AC%BE%E4%BC%98%E9%9B%85%E5%BC%BA%E5%A4%A7%E7%9A%84php%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%20(1)/","excerpt":"","text":"phpEnv一款优雅强大的php集成开发环境php集成开发环境有很多种，例如phpstudy，wamp，xmapp等等，各有各的优点和缺点，本文并不是对各个 IDE 的使用和调试进行详细的对比和评测，因为每一款 IDE 均提供了大同小异的功能，只是在细节方面有所差异罢了，phpStudy程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+Zend Loader，一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境。该程序绿色小巧简易迷你仅有13M，有专门的控制面板。总之学习PHP只需一个包。但是当最近phpstudy爆出重大漏洞后门后，相信很多人都在寻找可替代品，这里推荐给大家一款希望能对大家的参考和选择有所助益： phpEnv软件界面颜值超高，简洁优雅，完全绿色化，不需要安装vc环境，在同等软件中清新脱俗。 突破端口限制，更有管理员模式解除Windows Service服务端口占用。 运行服务错误提示，快速定位错误，提高开发效率。 自带软件商店，PHP和MySQL版本应有尽有，还有Redis和其他工具等。 功能强大的站点管理，为每个网站配置不同的PHP版本，不同PHP版本的网站共存，可视化配置https等。 简洁优雅而不失强大的软件设置，大大提高了开发效率。 功能强大的cmd命令行，无须你再繁琐的配置环境变量。 可视化TCP端口进程列表，功能强大，快速查看端口监听情况。 能够和phpstudy媲美，和wamp相互比对， 本文分享自微信公众号 - 风帆（wdswhf） 原文出处及转载信息见文内详细说明，如有侵权，请联系 yunjia_community@tencent.com 删除。 原始发表时间：2019-09-23 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"[转]分享几款不错的浪漫素材","slug":"转-分享几款不错的浪漫素材","date":"2019-12-13T10:58:22.000Z","updated":"2020-02-13T11:08:50.495Z","comments":true,"path":"2019/12/13/转-分享几款不错的浪漫素材/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/13/%E8%BD%AC-%E5%88%86%E4%BA%AB%E5%87%A0%E6%AC%BE%E4%B8%8D%E9%94%99%E7%9A%84%E6%B5%AA%E6%BC%AB%E7%B4%A0%E6%9D%90/","excerpt":"原文链接：https://www.liaofuzhan.com/posts/3564551888.html 双旦将至，快找个暖冬又暖心的 TA 一起跨年吧！如果你还是一枚单身汪，那么再过几天的时间，又到了别人狂欢你孤单的圣诞之夜！再再再过几天时间，又双叒叕到了别人狂欢你孤单的跨年之夜！落单的人往往最怕过节，更何况双旦佳节的连环暴击，别人疯狂撒着狗粮，而你只能接受着来自情侣们的亿万点伤害，SO，与其不甘寂寞，何不为爱情放纵一次？撩个对象一起过双旦吧，2019 年最后一个脱单的机会，为你呈现 ！ 感谢 leafjame 和 EnfangZhong 提供的素材！ 本站只集成了以下四种，其它效果可下载源码后查看 表白专场","text":"原文链接：https://www.liaofuzhan.com/posts/3564551888.html 双旦将至，快找个暖冬又暖心的 TA 一起跨年吧！如果你还是一枚单身汪，那么再过几天的时间，又到了别人狂欢你孤单的圣诞之夜！再再再过几天时间，又双叒叕到了别人狂欢你孤单的跨年之夜！落单的人往往最怕过节，更何况双旦佳节的连环暴击，别人疯狂撒着狗粮，而你只能接受着来自情侣们的亿万点伤害，SO，与其不甘寂寞，何不为爱情放纵一次？撩个对象一起过双旦吧，2019 年最后一个脱单的机会，为你呈现 ！ 感谢 leafjame 和 EnfangZhong 提供的素材！ 本站只集成了以下四种，其它效果可下载源码后查看 表白专场 hexo 跳过渲染Hexo 默认会对根目录 /source/ 下所有页面应用主题模板渲染，但有一些前端作品或 demo 页我们不希望经过渲染，而是能保持完全自定义的样子，那该怎么用 Hexo 添加自定义的 web 页面呢？下面介绍两种方法 skip_render使用 Hexo 提供的跳过渲染配置。在站点 _config.yml 中找到 skip_render，这项是用来配置 /source/ 下需要跳过渲染的文件或目录，例如希望跳过 /source/love/ 里的所有文件，可以配置为 1skip_render: love/** 如果有多项，可以这样配置 1234skip_render: - README.md - love/** - test1/*.html 或者 1skip_render: [README.md, love/**, test1/*.html] 可参考 如何不处理 source 目录下某个子目录的所有文件 layout使用 layout 给单个文件添加不应用模板的标记。适用于个别需特殊处理的文件，可在文件头部添加 123---layout: false--- 这个文件就不会经过模板渲染，最终发布到 /public/ 里的文件就是去掉标记后的文件的样子。本站使用的是第一种配置方式，源码目录截图如下 访问域名 + 文件目录名即可出现效果，Enjoy ！ 表白专场 相关文章点击查看表白神器—JS生成的玫瑰花Hexo Next主题「哈林摇」特效Hexo NexT主题美化1.0随笔—过节那点事 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"素材","slug":"素材","permalink":"https://melodyjerry.github.io/blog/tags/%E7%B4%A0%E6%9D%90/"}],"author":{"name":"北宸","avatar":"https://www.liaofuzhan.com/images/beichen.png","url":"https://www.liaofuzhan.com/"}},{"title":"[工具]ASCII字符画制作工具","slug":"工具-ASCII-字符画制作工具","date":"2019-12-12T11:48:31.000Z","updated":"2020-02-12T12:12:19.736Z","comments":true,"path":"2019/12/12/工具-ASCII-字符画制作工具/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/12/%E5%B7%A5%E5%85%B7-ASCII-%E5%AD%97%E7%AC%A6%E7%94%BB%E5%88%B6%E4%BD%9C%E5%B7%A5%E5%85%B7/","excerpt":"想为自己的博客设计一个专属的ASCII字符画，便找到以下三款工具（含线上）","text":"想为自己的博客设计一个专属的ASCII字符画，便找到以下三款工具（含线上） 工具 http://patorjk.com/software/taag/ https://www.degraeve.com/img2txt.php 使用Ascii Generator 2制作，下载地址：https://sourceforge.net/projects/ascgen2/ 展示123456789101112131415161718192021 _ooOoo_ o8888888o 88\" · \"88 (| ^.^ |) O\\ = /O ____/`---'\\____ . ' \\\\| |// `. / \\\\||| : |||// \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | \\_| ''\\---/'' | | \\ .-\\__ `-` ___/-. / ___`. .' /--.--\\ `. . __ .\"\" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'\"\". | | : `- \\`.;`\\ _ /`;.`/ - `: | | \\ \\ `-. \\_ __\\ /__ _/ .-` / / `.____`-.___\\_____/___.-`____.-' ⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒ ............................................. 佛 祖 保 佑 代 码 无 BUG 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- s&amp;@@@@@@@@@@@#HX9hr: ;GM@@@@@@@@@@@@@@@@#MBA85i .G@@@@@@@@@@@@@@@@@@@@@@@@@@M9: .&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#1 h@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@, .;rssr, ,sA@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@88B@@@@@#5 .rHHA#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: rB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@i ,5B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X is&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X#@@@@@@@A ,s8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Hr M@@@@@@@B. .,1&amp;M@@@@@@@B#@@@@@@@@@@@@@@@@@@@8 ;@@@@@@@Hi. :1991: ,s9&amp;81;. , sA@@@@@@BG8XHB#@@@@@@@@@@@@@HS: 5@@@@@@@@i .;13XM@@#H#@H91;. :s3&amp;##A&amp;#@@MA8Ss: .5HAX#@M@#BHHBM#@@@@@@@@#&amp;Ah.. G@@@@@@@@G ,s9AMM@@@Xh;. .i9@@@BX9hr,.,ih9&amp;B@@@#s. :hM@@HBMBXSi. ..ShSM@@@@@@&amp;XBHsHMHS: .: 3@@@@@@@@8 ,;19H#BG5irB@@H3. r#@@@@@#@@B@@@BB@@@@M; 5H@@@9 ,r3ABM&amp;8Shsrii;;i;ir1h1. .iM@@@@@@@@91, ;S, sGXH@@@@@@@@X&amp;HM@@@9: X@@@@@#s &amp;@@@@@@G:s@A;.hM@@@@@A G@@@@@@h s#@@AXXXGGXGX#@@#@@Bs .r58&amp;HM@@@@@@@@@@@#BA8Sr. ,8@@#X@@@@@@Ariii5M@@H3. 8@@@@@@9 1B@@@@@@: H; &amp;@@@@@#h &amp;@@@@@Mi ,G@@@@X ;8#@#hrX@@X8M@@@@@@@@@@@@@@@@@@@@@@@M8SM@Hh.3@@@@M8. .H@@@@@Hi S@@@@@5 .SM@@@@S . H@@@@X: 5@@@@M; &amp;@@@@@@9 s#@@@@#r.9@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#3:9@@@@@@9 :M@@@@@@s 1@@@@s ,9#@@H ,M@@#h i@@@M; 3@@@@@Mi X@@@@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8 ;M@@@@M, rM@@i :G@@i i@@X: .B@M; :#@@@@r :#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M. ;M@@@X :B@: i&amp;S hMh GM; X@@@h S@@@@B#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B8@@@@h i#@@h ,1 ., ,: s@@3 .H@@MB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;A@@H r#@; HG r@#r&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S B@r s9 , 95G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@h;S 3@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@i r@@@@@@@H8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B. H@@@@@@#:;@@@@@@@@@@@@@@@@@@@@@@@@@@B8@@@@@@@S .;S@@@@@@@r ,M@@@@@@@@@@@@@@@@@@@@@@@@@X 9@@@@@@Mhi, .. ;831: .iSXM@@@@@@@#s .M@@@@@@@@@@@@@@@@@@@@@@@@@X 9@@@@@@@@#A91: i8AA1 :h, iBH. .5B@#8i. .iS&amp;M@@@@@@@@@@Ai i@@@@@@@@@@@@@@@@@@@@@@@@@@M, hB@@@@@@@@@@@H8h; ;9@@#s :&amp;@X, .B@@H359GX&amp;XGGM@@@@B9:,rSXM@@@@@@@@@@@B8s h@@@@@@@@@@@@@@@@@@@@@@@@@@@s .1GB@@@@@@@@@@@@BX5r,sA@@@@@MHAHBHHA&amp;#@@@9 iG@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@#H8h; S@@@@@@@@@@@@@@@@@@@@@@@@@@#s :19AM@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@h. 1B@@@@@@@@@@@@@@@@@@@@@@@@BXSr, 5#@@@@@@@@@@@@@@@@@@@@@@@@@@@#h .ih8A#@@@@@@@@@@@@@@@@@@@@@@M@@8 ,,,595i:i1S9G&amp;AHBMBAGSr, 9@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3 :13XHM###MMBHAX95SXBMGii, --&gt; 参考文章 让console充满情怀Chrome 控制台新玩法Tools for Web Developers浏览器控制台个性化输出 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Java—替换字符串右侧出现的第一个子串","slug":"Java—替换字符串右侧出现的第一个子串","date":"2019-12-08T04:46:08.000Z","updated":"2019-12-08T09:18:36.934Z","comments":true,"path":"2019/12/08/Java—替换字符串右侧出现的第一个子串/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/08/Java%E2%80%94%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%B3%E4%BE%A7%E5%87%BA%E7%8E%B0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%90%E4%B8%B2/","excerpt":"🔺需求 👇 编程实现一个方法，能把一个字符串src的右侧出现的第一个olds子串替换为news，并把替换后的结果返回。","text":"🔺需求 👇 编程实现一个方法，能把一个字符串src的右侧出现的第一个olds子串替换为news，并把替换后的结果返回。 🔺代码 👇 123456789101112131415161718192021public class StringReplaceLast { public static String replaceLast(String src, String olds, String news){ /* 实现一个尾部替换方法 */ System.out.println(src); StringBuffer sbsrc = new StringBuffer(src); int lenolds = olds.length(); int tail = src.lastIndexOf(olds); sbsrc = sbsrc.replace(tail,tail+lenolds, news); src = sbsrc.toString(); return src; } public static void main(String[] args) { System.out.println(replaceLast(\"goodJava,I love it, very good,Truly.\", \"good\", \"yes\" )); }} 🔺截图 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"文章视频（B站）","slug":"文章视频","date":"2019-12-07T16:00:00.000Z","updated":"2020-02-20T10:00:24.419Z","comments":true,"path":"2019/12/08/文章视频/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/08/%E6%96%87%E7%AB%A0%E8%A7%86%E9%A2%91/","excerpt":"目前博文主要引用的是B站视频👇 小窗口版、修改src即可👇 1&lt;iframe src=\"//player.bilibili.com/player.html?aid=76560081&amp;cid=130958803&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"&gt; &lt;/iframe&gt;&lt;br&gt; 浏览测试效果👇 大窗口版👇 1&lt;div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"&gt;&lt;iframe src=\"//player.bilibili.com/player.html?aid=76560081&amp;amp;page=0\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"&gt;&lt;/iframe&gt;&lt;/div&gt; 浏览测试效果👇","text":"目前博文主要引用的是B站视频👇 小窗口版、修改src即可👇 1&lt;iframe src=\"//player.bilibili.com/player.html?aid=76560081&amp;cid=130958803&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"&gt; &lt;/iframe&gt;&lt;br&gt; 浏览测试效果👇 大窗口版👇 1&lt;div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"&gt;&lt;iframe src=\"//player.bilibili.com/player.html?aid=76560081&amp;amp;page=0\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"&gt;&lt;/iframe&gt;&lt;/div&gt; 浏览测试效果👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"Java—转置数组","slug":"Java—转置数组","date":"2019-12-07T13:43:33.000Z","updated":"2019-12-08T14:07:45.921Z","comments":true,"path":"2019/12/07/Java—转置数组/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/07/Java%E2%80%94%E8%BD%AC%E7%BD%AE%E6%95%B0%E7%BB%84/","excerpt":"🔺需求 👇 编写一个程序，其功能是能随机生成一个数组、同时完成对该数组的转置并打印输出转置后的数组。","text":"🔺需求 👇 编写一个程序，其功能是能随机生成一个数组、同时完成对该数组的转置并打印输出转置后的数组。 🔺代码 👇 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import static java.lang.System.out;import java.util.Random;public class Reverse2dArray { static int[][] a; // 存放两位随机整数的int二维数组a /** * 构造方法，初始化数组a，r和c分别是行数和列数row column */ public Reverse2dArray(int r, int c){ a = new int[r][c]; buildRandArray(); } /** * 构造随机数组 */ public void buildRandArray(){ Random random = new Random(); for(int i = 0; i &lt; a.length; i++) for(int j = 0; j &lt; a[i].length; j++) a[i][j] = random.nextInt(100); } /** * 转置本类成员的二维数组a，并返回一个新的二维数组 * @return */ public int[][] reverse2dArray(){ int [][] b = new int [a[0].length] [a.length] ; for (int i = 0; i &lt; a.length; i++) { for (int j = 0; j &lt; a[0].length; j++) { b[j][i] = a[i][j] ; } } return b ; } /* 显示二维数组 */ public void showArray(int[][] c){ out.printf(\"=========%2d×%-2d=========%n\", c.length, c[0].length); for(int[] cr : c){ for(int cc : cr){ out.printf(\"%5d \", cc); } out.println(); } out.println(\"=======================\"); } public static void main(String[] args) { int row = 3, col = 4; Reverse2dArray me = new Reverse2dArray(row, col); me.showArray(a); // 显示原数组 int[][] r = me.reverse2dArray(); me.showArray(r); // 显示转置的数组 }} 🔺截图 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"【纪念】我的博客上线一个月","slug":"【纪念】我的博客上线一个月","date":"2019-12-06T16:41:29.000Z","updated":"2019-12-06T17:20:33.920Z","comments":true,"path":"2019/12/07/【纪念】我的博客上线一个月/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/07/%E3%80%90%E7%BA%AA%E5%BF%B5%E3%80%91%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E6%9C%88/","excerpt":"大致写完这文章时，已是2019年12月7日的夜晚00时41分。 从最简单的纯粹的文字，到文字加粗，到用图床（SM.MS）来插入图片，到利用HTML来丰富博客，等等……本小白的博客之旅早已开始，学习、生活，图文、视频、音乐，想写想分享的都不会少。 今天这篇文章，一是回顾这一个多月来写博客的点滴，二是对未来的一些期望、想法，三是纪念一个人！！！","text":"大致写完这文章时，已是2019年12月7日的夜晚00时41分。 从最简单的纯粹的文字，到文字加粗，到用图床（SM.MS）来插入图片，到利用HTML来丰富博客，等等……本小白的博客之旅早已开始，学习、生活，图文、视频、音乐，想写想分享的都不会少。 今天这篇文章，一是回顾这一个多月来写博客的点滴，二是对未来的一些期望、想法，三是纪念一个人！！！ 尝试 &amp; 第一篇博客2019十月的最后一天，那是我写博客的第一天。 第一篇博客，同时用来纪念我的开始。 https://blog.csdn.net/weixin_43438052/article/details/102841961 那篇博客的标签我给的是#尝试#。 没错，这是我第一次尝试写博客，一次伟大的尝试和开始。 博客的内容也很简单。 当然，这也是我人生以来 第一次全面地接触 MarkDown 语言。 又迈出一步 &amp; 小小的收获之后，先后在CSDN和简书上，又发表共5篇文章（含重复）。 我的CDSN主页：https://blog.csdn.net/weixin_43438052 我的简书主页： https://www.jianshu.com/u/a75808cbb13e 经过写这几篇博客，对于MD（Markdown）的使用越来越熟练。 这也让我收获一些东西，比如点击量、评论量、点赞数、收藏数等等。 虽然和那些大佬比起来微不足道，不过我还是很开心。 尤其是我合计了（双平台）全部文章的浏览量是1726。 截止到写这篇博客，有1726‬人看过我的文章。1726啊啊啊，大数字了hhhh 于是，我傻乎乎地打开计算器，用1726除了30，得到这个数‭57.53。 忍不住说了句 卧槽 ，平均每天有57人看我的文章。 57人啊，我也算是个小网红 (不算，那我自个变红) 了吧？！！ 此刻的我👉一时自恋+持续傻笑ing 大胆地想法 &amp; 勇敢地再尝试2019.11.1 我突然有个 大想法 ，和这三个字那么大的想法——我要搭建自己Blog（博客）。 那又是为什么呢？ 很简单，还是 尝试 。 然而，想法是好，实践起来，不容易啊。 起初是使用 Gridea 来撰写、发布博客。 不过，没多久被我舍弃了这个方案。并不是说Gridea不好，而是缺少了自定义。 我说的自定义是，可以给自己的博客加入一些其他的东西，比如页面动画之类的。 于是，在朋友的推荐下，我接触了 Hexo 。这是一个专门用来搭建博客的框架。 没错，就是框架。因为是框架，所以能直接、便利地搭建、撰写、发布博客文章。 更重要的是，Hexo提供现成的主题模板，你可以直接利用，甚至对其二次加工。 就这样，前前后后，在没课的时候、还有半夜，大概花了四天左右来研究Hexo，从命令行开始。 终于在2019.11.6初步搭建完成，隔天7号发布了第一篇文章。 同时也是记录我搭建博客的大致过程。 人生第一个域名 &amp; 一写小坎坷2019.11.6 也是我获取人生第一个专属域名【melodyhub.ltd】的日子。 43买了五年，真的很值很划算。 不过，在接下的两三天也遇到点麻烦。 第一个是DNS解析，这个还好办，查ip、到阿里云控制台改一下就好。 第二个是，每次``hexo d` 后，用域名总是404。每次都要到GitHub仓库里修改CNAME，太麻烦了。于是，我干脆就直接在Hexo的框架中写入CNAME文件，这样每次更新到远端（仓库）时，都会有正确的CNAME。机智的我 ( ͡° ͜ʖ ͡°)✧ 第三个，也是最麻烦的一个，浏览器打开我的网站，总是提示“证书失效 / 危险链接”等字段。这个懊恼了我两天，反复查了一堆东西，最后发现原来是主题模板中重定向到一个外国授权认证的网站去了。 真的是，整的我发愁，好在最后能够解决了。 进一步尝试优化到目前为止，我的网站一共经历两次大变化，一次是在11.8，另一次是11.24。 主要就是优化了主题模板中存在的一些问题，然后加入了一点自己想要的东西，还有一些待以后再实现。 具体的，主要的，大致在【博客v1.4上线】这篇博客中提到了。 其实，这个过程很难，一个是我对Hexo内部的设计的了解不是很深，另一个是对HTML语言不是精通。主要是前者，后者可以通过百度、书籍来学习。 反反复复，查阅各个文档、修改一堆文件、增删改n次代码。 总算是，得到了一个较为满意的博客。 期间，还丢失过几次代码和文件，折腾死我了。😂 奋笔疾书（敲键盘）写写写截至到写这篇博客，一共在自己的网站上发布了26篇正式博客。 但是由于目前还没不会使用“不蒜子” 的接口来显示浏览量，所以我页没法知道有多少人看过我的文章。 我就假装每天就一共吧，那就是我哈哈哈。 26篇博客文章，不仅提升为了我的打字速度，还让我更加地想搞IT。** 当然，我一向对IT感兴趣。** 写 ，这个过程让我在不断地遇到困难，然后解决它。 不懂的，就琢磨它。再不懂，找大佬、问大佬。 也就一步步地，收获了知识、也认识了几位大佬。 期望 &amp; 未来我的目标是成为以为IT技术大佬，目前的想法是能熟练Java+一种数据库+HTML+其他语言/技术。 这几个月来，因为一件事、一些人，重新洗牌了我的生活，同时也让我有了全新的目标、计划。 现如今，我有新的顾虑，我有家、有朋友的期望，我必须自强自立。放眼到以前，熟悉我的人也知道我一向比较执着于想做的事，虽然现在我也也是，不过更多了一些热情、勇气、认识。 这一个多月来，得到很多人的帮助、指导、建议。朋友啊、老师啊、师兄师姐啊…… 人总要向前看向前走，无论是失去某样东西，或者某个人，都得向前。 我在博客中用到一句话当【归档页】的副标题“生命不过三天：昨天、今天、明天”。 反思昨天，珍惜今天，把握明天。所以，但看到别人在向前走时，我就要跑、向前跑。 就这样，我也才给我的网站的主页设置了 “你用走 可是我用跑” . 我希望这句话能够在关键时候提醒我，你不能停还得跑。 同时我也希望，能够看到这里的你，也要向前向前再向前。 晚安计划分享截止到现在的所有【晚安计划】 👇 END😊 最后，希望 健康、平安、简单、快乐、好运。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"用JDBC连接数据库","slug":"用JDBC连接数据库","date":"2019-12-03T04:12:50.000Z","updated":"2020-02-09T16:02:16.381Z","comments":true,"path":"2019/12/03/用JDBC连接数据库/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/03/%E7%94%A8JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"简单理解JDBC（Java DataBase Connectivity）是 Java 和 数据库 之前的一座桥。 实则，JDBC 是用于Java编程语言和数据库之间的标准Java API。 三者之间的关系就如下图 👇","text":"简单理解JDBC（Java DataBase Connectivity）是 Java 和 数据库 之前的一座桥。 实则，JDBC 是用于Java编程语言和数据库之间的标准Java API。 三者之间的关系就如下图 👇 JDBC介绍官方文档：https://www.oracle.com/technetwork/java/javase/jdbc/index.htmlJava 原文👇 译文（可能有偏差）👇 数据库连接 （JDBC） Java 数据库连接 （JDBC） API 是 Java 编程语言与各种数据库 SQL 数据库和其他表格数据源（如电子表格或平面文件）之间的独立于数据库的连接的行业标准。JDBC API 为基于 SQL 的数据库访问提供了调用级 API。 JDBC 技术允许您使用 Java 编程语言来利用需要访问企业数据的应用程序的”一次写入，随处运行”功能。借助支持 JDBC 技术的驱动程序，即使在异构环境中，您也可以连接所有企业数据。 教程本文环境 OS IDE 数据库 Windows 10 专业版 Eclipse(v4.11.0)—jdk8 SQL server 2017 SQL Server 2017 设置【SQL 身份验证登录】 设置【登录名 sa】 的状态为【授予】和【启用】 关闭程序 SQL Server 配置管理器==因为SQL Server 2012装好后，默认协议是没有开启的，所以要打开SQL Server配置管理器中开启。== 打开【SQL server2017配置管理器】 启用【Named Pipes】 修改 【TCP/IP 属性】： 将【IP1 、IP10】中的【IP地址】改成【 127.0.0.1】，并将所有的【IPx】的【已启用】设置为【是】，将 【IPAII】中的【TCP端口】设成 【1433】，其余不变。 重启【SQL Server服务】 【win+r】打开【运行】，键入【cmd】，打开命令行，键入以下命令👇 1telnet 127.0.0.1 1433 提示【talent不是内部命令】，则【打开控制面版】-&gt;【程序】-&gt;【启用或关闭Windows功能】-&gt;【勾选talent】-&gt;【确定】。 重新【步骤4】，进入【telnet】。 JDBC驱动 下载驱动包：http://www.microsoft.com/zh-cn/download/details.aspx?id=11774 选择、下载【 sqljdbc_6.0.8112.200_chs.tar.gz】 解压上述压缩包，得到目录文件夹 复制【”sqljdbc_6.0\\chs\\jre8”】中的包【sqljdbc42.jar】，粘贴到IDE【Eclipse目录】下的【jdk1.8\\jre\\lib\\ext】中。 右键【我的电脑】-&gt;【高级系统设置】-&gt;【系统属性】-&gt;【高级】-&gt;【环境变量】，编辑【系统变量】中的【CLASSPATH】的【变量值】，加入【;路径】（该路径为步骤4中包的完整路径，注意路径前一定要加 ;）-&gt;【确定】。 Eclipse 【右键】工程项目-&gt;【Build Path】-&gt;【Configure Build Path】 选择【Libraries】页-&gt;【Add External JARs…】-&gt;【添加】前面粘贴jar包的路径-&gt;【Apply and Close】 实践新建一个class，复制粘贴一下代码👇 12345678910111213141516171819202122232425262728293031323334import java.sql.*;public class JDBC_Demo { // MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL //static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; //static final String DB_URL = \"jdbc:mysql://localhost:3306/数据库名\"; // MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL //static final String JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\"; //static final String DB_URL = \"jdbc:mysql://localhost:3306/数据库名?useSSL=false&amp;serverTimezone=UTC\"; // SQL Server数据库引擎 static final String JDBC_DRIVER = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\"; // 数据源！！！注意若出现加载或者连接数据库失败一般是这里出现问题 static final String DB_URL = \"dbc:sqlserver://localhost:1433;DatabaseName=数据库名\"; //【1】修改 数据库名 // 数据库的用户名与密码，需要根据自己的设置 static final String Name=\"登录名\";//【2】修改 登录名 static final String Pwd=\"密码\";//【3】修改 密码 public static void main(String[] args) { try { Class.forName(JDBC_DRIVER); Connection conn=DriverManager.getConnection(DB_URL,Name,Pwd); System.out.println(\"连接数据库成功\"); }catch(Exception e){ e.printStackTrace(); System.out.println(\"连接失败\"); } } } 运行截图👇 心得体会前前后后，总计花了差不多三天的时间来研究怎么用JDBC连接数据库。 期间，遇到好多问题。问过指导老师，老师说可能是SQL Server版本的问题。 实验要求是2014，而我的是2017。但我觉得这不是问题。 反反复复地，其他都配置好了，但是总是连接不上数据库。 后来关注点放在了Eclipse的Path上，注意到我用的是jdk12，于是我想换成jdk8。 一换、一 run ……咦，可以了哈哈哈哈。 期间参考了很多人的博客，但是那些都没有强调 IDE中的环境要设置为【jdk8】。 写博客不易，如果本文对你有帮助，可以考虑给我 打赏 哦 *( ͡° ͜ʖ ͡°)✧ * 2020.2.10 补充：关于JDBC连接MySQL的具体实例，可以前往 这里 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"https://melodyjerry.github.io/blog/tags/SQL-Server/"}]},{"title":"Java——API中文手册","slug":"Java-API中文手册","date":"2019-12-01T12:00:15.000Z","updated":"2019-12-02T12:56:16.300Z","comments":true,"path":"2019/12/01/Java-API中文手册/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/01/Java-API%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/","excerpt":"【Java 8中文版开发文档，Java 8中文版 API手册中文版】( http://www.matools.com/api/java8 )","text":"【Java 8中文版开发文档，Java 8中文版 API手册中文版】( http://www.matools.com/api/java8 ) L2Dwidget.init({\"model\":{\"jsonPath\":\"/blog/live2dw/assets/assets/haruto.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"tagMode\":false,\"debug\":false,\"mobile\":{\"show\":true},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\"}); 为了避免版权问题，再次声明：移植该文档，仅供学习交流，别无其它目的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"2019的最后一个月","slug":"2019年的最后一个月","date":"2019-12-01T05:32:39.000Z","updated":"2019-12-31T14:16:35.253Z","comments":true,"path":"2019/12/01/2019年的最后一个月/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/01/2019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88/","excerpt":"","text":"💛今天，2019年12月01日，是 今年最后一个月的第一天。 🔺回想去年的12月，经历了很多，一切都是从 【晚安计划】的短信 开始。时至今天，我仍保存着去年的“晚安计划”短信。 💙今晚开始，又是新的一轮【晚安计划】。不知道你有没有呢？ 🧡从国庆回到学校后，课多了、要处理的事情多了，总之这两个月来搞的东西太多了。 💚不过呢，也是有收哦的哦！像比如，现在这个博客(2019.11.07)就是之一。还有自己写的小玩意，以后会放出来。 💜忙完这最后的12月，也该是时候让自己出去走走了。总是待在宿舍、教学楼，会傻的hh。 💛最近很想家，很想回家。不过也要等到2020元旦之后啦，也快了快了。 最后，祝我自己和大家12月健康、平安、快乐、好运…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Java—(递归+非递归)阶层","slug":"Java—（递归-非递归）阶层","date":"2019-11-30T08:08:51.000Z","updated":"2019-12-01T01:01:56.156Z","comments":true,"path":"2019/11/30/Java—（递归-非递归）阶层/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94%EF%BC%88%E9%80%92%E5%BD%92-%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89%E9%98%B6%E5%B1%82/","excerpt":"递归阶层算法、非递归阶层算法 扩展①：求阶层的和 扩展②：寻找最高阶、打印阶层的计算过程","text":"递归阶层算法、非递归阶层算法 扩展①：求阶层的和 扩展②：寻找最高阶、打印阶层的计算过程 非递归阶层算法12345678910111213141516171819import java.util.Scanner;public class UnRecurrenceFactorial { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"input:\"); int n = sc.nextInt(); int a = 1; while(n != 1){ a = a*n; n--; } System.out.println(a); sc.close(); }} 递归阶层算法12345678910111213141516public class RecurrenceFactorial { public static void main(String[] args) { long fac = fac(k);//修改k的值即可 System.out.println(\"n的阶乘为:\" + fac); } public static long fac(int n){ if(n == 1){ return 1; }else{ return fac(n-1) * n; } }} 扩展①：求阶层的和🔺计算 1!+2!+3!+···+k! 的值： 123456789101112public static void main(String[] args) { int i,j; long sum = 0; for(i = 1; i &lt;= k; i++){ //修改k的值即可 int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } sum += t; } System.out.println(sum);} 扩展②：寻找最高阶、打印阶层的计算过程🔺题目： 指定一个整型数MAX，试编写一个程序求满足1!+2!+3!…+n!&lt;=MAX 的最大整数n。并把满足条件的求和式子和找到的最大整数n打印输出。 示例1：MAX=111时，输出 1!+2!+3!+4!=33 满足条件的最大整数:4 示例2：MAX=9876 1!+2!+3!+4!+5!+6!+7!=5,913 满足条件的最大整数:7 🔺代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;public class Du { public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.println(\"the value of MAX:\"); int MAX; MAX=input.nextInt(); System.out.println(\"满足条件的最大整数：\"+SUM(MAX)); input.close(); } public static int SUM(int MAX) { int i = 0,j; long sum = 0; for(i = 1; i &lt;= 10; i++){ int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } sum += t; if(sum&gt;MAX) break; } Print(i-1); return i-1; } /*打印阶层的计算过程*/ public static void Print(int k) { int i,j; long sum = 0; for(i = 1; i &lt;= k; i++){ //修改k的值即可 int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } System.out.printf(\"%d! + \",i); sum += t; } System.out.print(\"\\b\\b= \"+ sum);//退两个，删去最后一个+ System.out.println(); }} 🔺截图： 我的文章、代码简单，这里有更详细文章，见大佬👉Java实现n阶阶乘的计算 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java—向下/上取整","slug":"Java—-向下-上取整","date":"2019-11-30T05:44:08.000Z","updated":"2019-12-01T00:58:39.448Z","comments":true,"path":"2019/11/30/Java—-向下-上取整/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94-%E5%90%91%E4%B8%8B-%E4%B8%8A%E5%8F%96%E6%95%B4/","excerpt":"Java中对数的舍入也分有 向上舍入（向上取整） 向下舍入（向下取整） Java的Math类中包含数舍入的方法： ceil() floor() ceil()和floor() ceil() floor() 向上取整 向下取整 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 返回小于等于（&lt;=）给定参数的最大整数 。","text":"Java中对数的舍入也分有 向上舍入（向上取整） 向下舍入（向下取整） Java的Math类中包含数舍入的方法： ceil() floor() ceil()和floor() ceil() floor() 向上取整 向下取整 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 返回小于等于（&lt;=）给定参数的最大整数 。 看个栗子👇 关于Math类的说明，参考 Number &amp; Math 类方法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java—打印字母表","slug":"Java—打印字母表","date":"2019-11-30T03:46:31.000Z","updated":"2019-12-02T15:24:50.647Z","comments":true,"path":"2019/11/30/Java—打印字母表/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94%E6%89%93%E5%8D%B0%E5%AD%97%E6%AF%8D%E8%A1%A8/","excerpt":"A到Z的ASCII码值是65到90 a到z的ASCII码值是97到122","text":"A到Z的ASCII码值是65到90 a到z的ASCII码值是97到122 Demo123456789101112131415161718public class AlphabetDemo { public static void main(String[] args) { /*char和int类型能够相互转换，相信大家都明白 */ //A到Z的ASCII码是65到90，a到z的ASCII码值是97到122 for (char c = 0; c &lt; 128; c++) { //java里包装类的一个静态方法，确定c是字母还是小写！！！） if (Character.isLowerCase(c)) { System.out.printf(\"value: %3d char: %c\\n\", (int)c, c); //同上，判断c是大写 } else if (Character.isUpperCase(c)) { System.out.printf(\"value: %3d char: %c\\n\", (int)c, c); } } } } 注：关于isLowerCase和isUpperCase在文末有进一步的说明。 扩展 ①🔺题目： 🔺参考代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Scanner;public class Alphabet { public static void main(String[] args) { Scanner input=new Scanner(System.in); int n,level; System.out.println(\"the value of n:\"); n=input.nextInt(); level=(int)Math.ceil(26/n);//向上取整 System.out.println(\"======Upper========\"); char CH=65; for(int i=0;i&lt;=level;i++) { for(int j=0;j&lt;n;j++) { System.out.printf(\"%c \",CH); ++CH; if(CH&gt;=90) break; } System.out.println(); } System.out.println(); /* 另一个版本，这就看个人理解了！ System.out.println(\"======Upper========\"); char CH=65; for(int i=1;i&lt;=26;i++) { System.out.print(CH+\" \"); CH++; if(i%n==0) { System.out.println(); } } System.out.println(); */ System.out.println(\"======Lower========\"); char ch=97; for(int i=0;i&lt;=level;i++) { for(int j=0;j&lt;n;j++) { System.out.printf(\"%c \",ch); ++ch; if(ch&gt;=123) break; } System.out.println(); } System.out.println(); input.close(); }} 注意：Math.ceil();//向上取整 参考：我的另一篇博客：Java—向下/上取整 🔺执行截图： 扩展 ②上面常规思考题中的第6题是自左往右从上往下的水平顺序输出大写堆和小写堆字母表。假如想要按照自上而下从左往右的垂直顺序输出大写堆，该如何实现程序？ 即假如每列输出N=5个，则程序的输出情况如下： = = = Upper = = = A F K P U Z B G L Q V C H M R W D I N S X E J O T Y 试用一重循环编写程序，指定一个整型数N(1&lt;=N&lt;=26)，按示例规格输出列优先排序的大写字母表。 🔺代码： 123456789101112131415161718192021222324252627import java.util.Scanner;public class Aphabet { public static void main(String[] args) { System.out.println(\"======Upper========\"); Scanner input = new Scanner(System.in); int n,level; System.out.println(\"the value of n:\"); n = input.nextInt(); level = (int)Math.ceil(26/n);//向上取整 int j = 0; char ch = 65; p(1, n, ch); } public static void p(int x,int n,char ch) { if(x &gt; n) return; for(int i = x;i &lt;= 26;i += n){ ch = (char)(i + 64); System.out.print(ch + \" \"); } System.out.println(); ++x; p(x, n, ch); }} 下午做了半个多小时都没做出来，晚上玩了会游戏突然想到用递归，下午怎么就没想到呢？然后游戏就挂机被举报了，但一气呵成搞定了这题。说明思想不够灵活hhh 🔺截图： 补充：Java Character 类isLowerCase() 方法🔺作用：用于判断指定字符是否为小写字母。 🔺语法 1boolean isLowerCase(char ch) 🔺参数 ch – 要测试的字符。 🔺返回值 如果字符为小写，则返回 true；否则返回 false。 🔺实例 1234567public class Test { public static void main(String args[]) { System.out.println( Character.isLowerCase('a')); System.out.println( Character.isLowerCase('A')); }} 🔺以上程序执行结果为： 12truefalse isUpperCase() 方法 🔺作用：用于判断指定字符是否为大写字母。 🔺语法 1boolean isUpperCase(char ch) 🔺参数 ch – 要测试的字符。 🔺返回值 如果字符为大写，则返回 true；否则返回 false。 🔺实例 1234567public class Test { public static void main(String args[]) { System.out.println( Character.isUpperCase('b')); System.out.println( Character.isUpperCase('B')); }} 🔺以上程序执行结果为： 12falsetrue document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java—5种生成随机数的方法","slug":"Java—5种生成随机数的方法","date":"2019-11-30T02:33:25.000Z","updated":"2019-12-01T01:53:18.885Z","comments":true,"path":"2019/11/30/Java—5种生成随机数的方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%945%E7%A7%8D%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"5种生成随机数的简单方法 和一篇大佬的文章👇","text":"5种生成随机数的简单方法 和一篇大佬的文章👇 方法①🔺 通过java.Math包的random方法得到1-10的int随机数 🔺 公式： 最小值—最大值（整数）的随机数 (类型) 最小值+Math.random()*最大值 12345678910111213import java.util.Random;public class RandomDemo { public static void main(String[] args) { for (int i=0;i&lt;5;i++) { System.out.println((int)(1+Math.random()*10)); int k; k=(int)(1+Math.random()*10); } }} 方法②🔺借助java.util.Random类来产生一个随机数发生器，也是最常用的一种，构造函数有两个，Random()和Random(long seed)。第一个就是以当前时间为默认种子，第二个是以指定的种子值进行。产生之后，借助不同的语句产生不同类型的数。 🔺种子就是产生随机数的第一次使用值,机制是通过一个函数,将这个种子的值转化为随机数空间中的某一个点上,并且产生的随机数均匀的散布在空间中。以后产生的随机数都与前一个随机数有关 123456789101112131415import java.util.Random;public class RandomDemo { public static void main(String[] args) { Random r = new Random(); for(int i=0 ; i&lt;5 ; i++) { int ran1 = r.nextInt(100);//种子：100 System.out.println(ran1); } }} 注：类似的方法可参考 利用Random类来产生5个20~50之间的随机整数 方法③ 生成随机数需要使用到Java工具类中的Random类。 要求是随机x到y之间的整数，即指定范围，则使用Random类中的nextInt(int n)方法。 该方法生成从0（包括）到n（不包括）之间的随机整数，是一个伪随机数，并不是真正的随机数。 若x不为0，则需要在随机结果后加上x。参数n的值也需要加上1后减去x。最后结果才符合要求的范围。 1234567891011121314151617import java.util.Random;public class RandomDemo { public static final int START = 50; //定义范围开始数字 public static final int END = 99; //定义范围结束数字 public static void main(String[] args) { //创建Random类对象 Random random = new Random(); //产生随机数 int number = random.nextInt(END - START + 1) + START; //打印随机数 System.out.println(\"产生一个\"+START+\"到\"+END+\"之间的随机整数：\"+number); }} 注：更多方法可参考【Java工具类】—-产生随机数 方法④🔺 返回的数值是 [ 0.0 , 1.0 ) 的double型数值，由于double类数的精度很高，可以在一定程度下看做随机数，借助（int）来进行类型转换就可以得到整数随机数了 12345678public static void main(String[] args){ for (int i = 1; i &lt;= 10; i++) { int max=99,min=10;//生成两位随机正整数 int ran2 = (int) (Math.random()*(max-min)+min); System.out.println(ran2); }} 方法⑤🔺 返回从1970年1月1日0时0分0秒（这与OS有关）到现在的一个long型的毫秒数，取模之后即可得到所需范围内的随机数 12345678public static void main(String[] args) { int max=100,min=1; long randomNum = System.currentTimeMillis(); int ran3 = (int) (randomNum%(max-min)+min); System.out.println(ran3); } 大佬的文章这个大佬【peabits】的文章贼详细，可以好好琢磨琢磨 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java中的<<、>>和>>>","slug":"Java中的、-和","date":"2019-11-29T16:33:38.000Z","updated":"2019-11-29T17:14:55.054Z","comments":true,"path":"2019/11/30/Java中的、-和/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E4%B8%AD%E7%9A%84%E3%80%81-%E5%92%8C/","excerpt":"左移 左移运算符 &lt;&lt; 👉使指定值的所有位都左移规定的次数 左移m&lt;&lt;n，代表把数字m在无溢出的前提下乘以2的n次方 右移 右移运算符 &gt;&gt; 👉 使指定值的所有位都右移规定的次数 右移m&gt;&gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数 注意，如果是单数，也就是二进制末位为1，则结果是将m除以2的n次方的整数商 无符号右移 无符号右移运算符 &gt;&gt;&gt; 👉同右移，但是结果全变正数","text":"左移 左移运算符 &lt;&lt; 👉使指定值的所有位都左移规定的次数 左移m&lt;&lt;n，代表把数字m在无溢出的前提下乘以2的n次方 右移 右移运算符 &gt;&gt; 👉 使指定值的所有位都右移规定的次数 右移m&gt;&gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数 注意，如果是单数，也就是二进制末位为1，则结果是将m除以2的n次方的整数商 无符号右移 无符号右移运算符 &gt;&gt;&gt; 👉同右移，但是结果全变正数 Demo 以下内容转载于 Java中的&lt;&lt; 和 &gt;&gt; 和 &gt;&gt;&gt; 详细分析 详细分析&lt;&lt;表示左移，不分正负数，低位补0； 注：以下数据类型默认为byte-8位 左移时不管正负，低位补0 正数：r = 20 &lt;&lt; 2 20的二进制补码：0001 0100 向左移动两位后：0101 0000 结果：r = 80 负数：r = -20 &lt;&lt; 2 -20 的二进制原码 ：1001 0100 -20 的二进制反码 ：1110 1011 -20 的二进制补码 ：1110 1100 左移两位后的补码：1011 0000 反码：1010 1111 原码：1101 0000 结果：r = -80 &gt;&gt;表示右移，如果该数为正，则高位补0，若为负数，则高位补1； 注：以下数据类型默认为byte-8位 正数：r = 20 &gt;&gt; 2 20的二进制补码：0001 0100 向右移动两位后：0000 0101 结果：r = 5 负数：r = -20 &gt;&gt; 2 -20 的二进制原码 ：1001 0100 -20 的二进制反码 ：1110 1011 -20 的二进制补码 ：1110 1100 右移两位后的补码：1111 1011 反码：1111 1010 原码：1000 0101 结果：r = -5 &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0 正数： r = 20 &gt;&gt;&gt; 2 的结果与 r = 20 &gt;&gt; 2 相同； 负数： r = -20 &gt;&gt;&gt; 2 注：以下数据类型默认为int 32位 -20:源码：10000000 00000000 00000000 00010100 反码：11111111 11111111 11111111 11101011 补码：11111111 11111111 11111111 11101100 右移：00111111 11111111 11111111 11111011 结果：r = 1073741819 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java用最有效率的方法计算2乘以8","slug":"Java—用最有效率的方法计算2乘以8","date":"2019-11-29T16:24:00.000Z","updated":"2019-12-01T01:58:23.398Z","comments":true,"path":"2019/11/30/Java—用最有效率的方法计算2乘以8/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%972%E4%B9%98%E4%BB%A58/","excerpt":"","text":"最有效率的方法 👉 2 &lt;&lt; 3 其中，左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方 再比如，31 * num 等价于( num &lt;&lt; 5 ) – num 左移5位相当于乘以2的5次方（32），再减去自身（-1），这一过程就相当于乘以31 注：关于移位运算符，可参考我的下一篇博客 Java中的&lt;&lt;、&gt;&gt;和&gt;&gt;&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java笔记—static关键字","slug":"Java笔记—static关键字","date":"2019-11-28T09:24:41.000Z","updated":"2020-02-15T14:06:51.884Z","comments":true,"path":"2019/11/28/Java笔记—static关键字/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/28/Java%E7%AC%94%E8%AE%B0%E2%80%94static%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"static 关键字static类型，又叫类类型。 修饰目标 (成员数据/方法/成员内部类/代码块)属于类的 静态类 静态块 静态方法 静态变量 static 成员内部类 static 代码块 static 成员方法 static 成员变量 直接通过类就可以访问。所有对象共享该类 只能出现在类中不能出现方法体中，类加载后初始化时被执行一次。注意:区分构造代码块，每次构造都被执行 直接通过类就可以调用。不用等创建了实例后 类加载时在Java方法区分配空间，所有对象共享 区别：无static关键字成员属于具体的对象实例： 实例变量、实例方法(只能通过对象调用)、实例成员内部类(只能通过对象引用) 静态的特点 随着类的加载而加载 也就是，说静态会随着类的消失而消失，说明静态的生命周期最长。 优先于对象的存在 明确一点：静态是先存在的，对象是后存在的。 被所有对象共享。 可以直接被类名多调用。 static 成员的访问格式一般要通过 *“ 类名. ” * 的形式来访问 静态变量 静态方法 静态成员内部类 类名.静态变量 类名.静态方法 类名.静态成员内部类 注意事项🔺 static成员方法/代码块：静态方法 只能 使用静态成员变量(或内部类)或调用静态方法。（任课老师称： 静者恒静） 🔺非静态方法可以访问静态、也可以访问非静态。 🔺 static成员方法/代码块：方法体中不能出现this(当前对象)或super(基类对象)。因为静态优先于对象存在，所以静态方法中不可以出现this、super关键字。 实例变量和类变量的区别 存放位置 类变量随着类的加载存在于方法区中，实例变量随着对象的对象的建立存在于堆内存里 生命周期 类变量生命周期最长，随着“类”的加载而加载，随着类的消失而消失 实例变量随着“对象”的消失而消失 静态的利弊 利：1、对对象的共享数据进行单独空间的存储，节省空间，没有必要没一个对象中都存储一份。2、可以直接被类名所调用。 弊：生命周期过长，访问出现局限性（只能访问静态）","text":"static 关键字static类型，又叫类类型。 修饰目标 (成员数据/方法/成员内部类/代码块)属于类的 静态类 静态块 静态方法 静态变量 static 成员内部类 static 代码块 static 成员方法 static 成员变量 直接通过类就可以访问。所有对象共享该类 只能出现在类中不能出现方法体中，类加载后初始化时被执行一次。注意:区分构造代码块，每次构造都被执行 直接通过类就可以调用。不用等创建了实例后 类加载时在Java方法区分配空间，所有对象共享 区别：无static关键字成员属于具体的对象实例： 实例变量、实例方法(只能通过对象调用)、实例成员内部类(只能通过对象引用) 静态的特点 随着类的加载而加载 也就是，说静态会随着类的消失而消失，说明静态的生命周期最长。 优先于对象的存在 明确一点：静态是先存在的，对象是后存在的。 被所有对象共享。 可以直接被类名多调用。 static 成员的访问格式一般要通过 *“ 类名. ” * 的形式来访问 静态变量 静态方法 静态成员内部类 类名.静态变量 类名.静态方法 类名.静态成员内部类 注意事项🔺 static成员方法/代码块：静态方法 只能 使用静态成员变量(或内部类)或调用静态方法。（任课老师称： 静者恒静） 🔺非静态方法可以访问静态、也可以访问非静态。 🔺 static成员方法/代码块：方法体中不能出现this(当前对象)或super(基类对象)。因为静态优先于对象存在，所以静态方法中不可以出现this、super关键字。 实例变量和类变量的区别 存放位置 类变量随着类的加载存在于方法区中，实例变量随着对象的对象的建立存在于堆内存里 生命周期 类变量生命周期最长，随着“类”的加载而加载，随着类的消失而消失 实例变量随着“对象”的消失而消失 静态的利弊 利：1、对对象的共享数据进行单独空间的存储，节省空间，没有必要没一个对象中都存储一份。2、可以直接被类名所调用。 弊：生命周期过长，访问出现局限性（只能访问静态） Demo：类内使用1234567891011121314151617181920212223import static java.lang.System.*; //静态导入静态方法或对象 public class StaticDemo1 { static int a = 3, b, i = 0; // 静态变量 char ch = 'Y'; // 实例变量 static void meth(int x) { // 静态方法 out.println(\"x = \" + x); //out.println(\"ch = \" + ch);//【1】Error! } static { // 静态代码块-类加载时只执行1次 out.println(\"静态块初始化：仅1次\"); b = a * 4; //out.println(\"ch = \" + ch);//【1】Error! } public static void main(String[] args) { meth(42); //静态方法调用静态方法 new StaticDemo1(); //创建匿名对象1 new StaticDemo1(); //创建匿名对象2 } { out.println(\"ch = \" + ch);//【2】OK! out.printf(\"构造代码块：第%d次构造第%1$d次执行\\n\", (++i)); } }} 注意： 🔺特别注意：类的静态代码块仅在类在加载后初始化时被执行1次 🔺第一次new一个类时才加载该类 🔺静态方法、静态块不能访问非静态的成员（即，静者恒静）。如上述代码中的注释【1】 🔺静态块初始化：仅1次 Demo：类外使用和静态块执行时机1234567891011121314151617181920212223import static java.lang.System.out;class MyD{ private static int m; public static int n; static{ // 静态代码块【2】 m = n = 0; out.println(\"仅1次\"); } public static void callMe(){ out.printf(\"m=%d,n=%d\", m, n); }}public class StaticDemo2 { public static void main(String[] args) { MyD d; //【0】MyD被加载，但未主动使用 d = new MyD(); //【1】这里才【主动使用】MyD，于是执行其静态代码块【2】 MyD.n++; //最佳：类名.静态变量 MyD.callMe(); //最佳：类名.静态方法 }} 特别留意： 🔺用一个类声明一个类对象变量，至多会加载该类，但还未主动使用🔺老师说：【主动使用】，是一个比较高级的专题，暂不深入 DEMO：静态方法的声明12345678910111213141516171819202122232425262728293031class Person{ String name; //定义name属性 private static String nation = \"中国\"; //定义静态属性nation int age; //定义age属性 public Person(String name, int age){//声明一个有参的构造方法 this.name = name; this.age = age; } public String talk(){ //声明了一个talk()方法 return \"我是：\" + this.name + \"，今年：\" + this.age + \"岁，来自：\" + nation; } public static void setNation(String nat){//声明一个静态方法，给静态变量赋值 nation = nat; }}public class StaticMethod{ public static void main(String[] args){ Person p1 = new Person(\"张三\", 25); Person p2 = new Person(\"李四\", 30); Person p3 = new Person(\"王五\", 35); System.out.println(\"修改之前信息：\" + p1.talk()); System.out.println(\"修改之前信息：\" + p2.talk()); System.out.println(\"修改之前信息：\" + p3.talk()); System.out.println(\" ***********修改之后信息***********\"); // 修改后的信息 Person.setNation(\"美国\"); System.out.println(\"修改之后信息：\" + p1.talk()); System.out.println(\"修改之后信息：\" + p2.talk()); System.out.println(\"修改之后信息：\" + p3.talk()); }} DEMO：调用外部类定义的方法（有static+无static）首先定义方法 12345678public class Dy { public int Add(int x,int y) { //定义Add(),该方法没有被static修饰 return x+y; } public static int Sub(int x,int y) {//定义Sub(),该方法被static修饰 return x-y; }} 调用方法 1234567891011121314public class Test { public static void main(String[] args){ int a=5; int b=4; int result=0; //通过实例化调用外部类的Add方法 Dy dy=new Dy(); result=dy.Add(a, b); System.out.println(result); //直接调用外部类的Sub方法 result=Dy.Sub(a, b); System.out.println(result); }} 🔺static main方法调用外部方法/成员变量： 有static：“类名.”形式调用 无static：“对象.”形式调用 综上 什么时候使用静态？ 因为静态修饰的内容有成员变量和方法。 什么时候定义静态变量（类变量）呢？ 当对象中出现共享数据时，该数据被静态所修饰，对象中的特有数据要定义成非静态存在于堆内存中。 什么时候定义静态函数？ 当功能内部没有访问到非静态数据（或者称为对象的特有数据） 那么该功能可以定义成静态的。 注：前面的几篇Java笔记中也有提到static，后来上课老师再小结static关键词，结合前面的笔记食用效果更佳。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java笔记—this关键字","slug":"Java笔记—this关键字","date":"2019-11-28T09:11:18.000Z","updated":"2019-11-29T17:36:57.692Z","comments":true,"path":"2019/11/28/Java笔记—this关键字/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/28/Java%E7%AC%94%E8%AE%B0%E2%80%94this%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"this 关键字三个形式上的用途，但本质上就两个： 调用重载的其他构造方法：放置在构造方法体首行的this()或this(实参列表) 作为当前对象，引用成员（数据、方法等）：区分同名变量等 作为当前对象，方法返回当前对象的引用，形成链式调用","text":"this 关键字三个形式上的用途，但本质上就两个： 调用重载的其他构造方法：放置在构造方法体首行的this()或this(实参列表) 作为当前对象，引用成员（数据、方法等）：区分同名变量等 作为当前对象，方法返回当前对象的引用，形成链式调用 案 例 ： 123456789101112131415161718192021222324252627282930313233public class ThisDemo { private int a = 1; private String name = \"good\"; private int i = 0; public ThisDemo(){ System.out.println(\"无参构造子\" + this); } public ThisDemo(int a, String name){ this(); // 【1】调用无参构造子 this.a = a; // 【2】当前对象，引用成员 this.name = name; } public ThisDemo setA(int a){ this.a = a; return this; // 【3】返回当前对象 } public ThisDemo setName(String name){ this.name = name; return this; } public ThisDemo inc(){ i++; return this; } public static void main(String[] args) { ThisDemo t1 = new ThisDemo(); t1.setA(100).setName(\"guo\").inc().inc(); System.out.println(t1.i); ThisDemo t2 = new ThisDemo(2, \"Tom\"); t2.inc().setA(8).inc().inc(); //【4】链式调用 System.out.println(t2.i); }} 特别注意，案例中的【3】和【4】。 注：前面的几篇Java笔记中也有提到this，后来上课老师再小结this关键词，结合前面的笔记食用效果更佳。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"对SQL的触发器的浅理解","slug":"浅谈SQLServer触发器","date":"2019-11-26T05:08:18.000Z","updated":"2019-11-28T11:22:43.203Z","comments":true,"path":"2019/11/26/浅谈SQLServer触发器/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/26/%E6%B5%85%E8%B0%88SQLServer%E8%A7%A6%E5%8F%91%E5%99%A8/","excerpt":"","text":"个人理解如果需要做一些特定的增删改操作，就可以使用触发器。 触发 ，当做了某种预设的操作时才会执行触发器的命令。 栗子：假设现在有个员工基础信息表，里面有员工的身份证号码，手机等基本信息。那么，当你换了身份证或手机，需要修改号码的时候，肯定是去修改员工的基础资料表。假设你现在有别的地方，比如人事档案啊之类的，同样使用了员工的手机等信息，难道还要再去修改一次档案表么？那么如果还有其他地方使用了呢？而在这种时候有触发器就好解决了。如果设置一个触发器来判断，如果修改了基础表的信息，那么就同步把其他使用了基础表的关联信息也更改成最新的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"SQL Server","slug":"SQL-Server","permalink":"https://melodyjerry.github.io/blog/tags/SQL-Server/"}]},{"title":"G.E.M.邓紫棋《句号》MV首播！","slug":"G.E.M.邓紫棋《句号》MV首播！","date":"2019-11-25T14:21:12.000Z","updated":"2019-11-29T04:53:27.657Z","comments":true,"path":"2019/11/25/G.E.M.邓紫棋《句号》MV首播！/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/25/G.E.M.%E9%82%93%E7%B4%AB%E6%A3%8B%E3%80%8A%E5%8F%A5%E5%8F%B7%E3%80%8BMV%E9%A6%96%E6%92%AD%EF%BC%81/","excerpt":"G.E.M.邓紫棋《句号》MV首播！ 🧡点击破亿『全创作天后』G.E.M.邓紫棋和过去告别，向未来大步迈开，开启音乐版图新起点的一个“句号”。 这是华语乐坛前所未见的真实披露之作，她用&lt;句号&gt;这首歌，预告了全新的音乐篇章，翻页之后，就要开始。 榜单Top 1 💗邓紫棋新歌《句号》上线颇有波折，国内几大音乐平台推迟上线，但在唯一上线的Apple Music平台，已经超过霉霉新歌《lover》，一举拿下 榜单 Top1！ 官方MV视频第一发布于微博： GEM鄧紫棋 2019.11.28更换 1 网页视频源： B站官方合作发布","text":"G.E.M.邓紫棋《句号》MV首播！ 🧡点击破亿『全创作天后』G.E.M.邓紫棋和过去告别，向未来大步迈开，开启音乐版图新起点的一个“句号”。 这是华语乐坛前所未见的真实披露之作，她用&lt;句号&gt;这首歌，预告了全新的音乐篇章，翻页之后，就要开始。 榜单Top 1 💗邓紫棋新歌《句号》上线颇有波折，国内几大音乐平台推迟上线，但在唯一上线的Apple Music平台，已经超过霉霉新歌《lover》，一举拿下 榜单 Top1！ 官方MV视频第一发布于微博： GEM鄧紫棋 2019.11.28更换 1 网页视频源： B站官方合作发布 ( ͡° ͜ʖ ͡°)✧我已经 循环 MV几天了，等待网易云上架。 听说 “连Siri都被圈粉？有网友发现现在向Siri提出“播放世界第一的歌曲”，结果直接是《句号》” 有iPhone的，赶紧试试看吧 ( ͡° ͜ʖ ͡°)✧ 1.第一次发这篇文章的第二天发现视频链接失效，研究了一下，发现微博视频用的是临时链接，就是生命周期只有1天的临时链接，于是我改由B站的视频 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"音乐","slug":"音乐","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"[电影]《Ladybird》演绎完整18岁的青春","slug":"电影-《Ladybird》演绎完整18岁的青春","date":"2019-11-23T13:33:12.000Z","updated":"2020-02-11T06:44:37.415Z","comments":true,"path":"2019/11/23/电影-《Ladybird》演绎完整18岁的青春/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/23/%E7%94%B5%E5%BD%B1-%E3%80%8ALadybird%E3%80%8B%E6%BC%94%E7%BB%8E%E5%AE%8C%E6%95%B418%E5%B2%81%E7%9A%84%E9%9D%92%E6%98%A5/","excerpt":"《LadyBird》，2017年的青春轻喜剧，烂番茄指数高达99%！","text":"《LadyBird》，2017年的青春轻喜剧，烂番茄指数高达99%！ ​ 该电影讲的是一个入不敷出的家庭，强势严厉的Mom，慈祥宽容却患有抑郁症的Dad，自称LadyBird的叛逆少女Christian克里斯汀，从高中步入大学时期所经历的亲情、友情、爱情，酸甜苦辣。 ​ 虽然欧美家庭的相处方式离我们很远，但影片展现的青春经历却与我们都有可对照之处。 ​ Christian不喜欢父母取的名字，自己取名为LadyBird，盼望自己化身为鸟，渴望获得自由。她横冲直撞，怼哥哥，怼老师，怼修女，公然挑衅和搞恶作剧。18岁的第一天，就去买了骆驼香烟，一张彩票，一本成人杂志，站在家乡萨克拉门托的阳光下，体会成长放纵的快感。她想逃离家乡，去纽约，去外面的世界闯荡，瞒着妈妈偷偷申请纽约的学校。 ​ 她不去考虑别人地感受，想要的太多，对得到的总是不够满足。当然，她也有自卑虚荣的一面。会纠结自己不够出众的长相，“为什么我看起来不像是杂志里的女孩？”，不喜欢贫寒的出身，把男朋友外婆家的dreamhouse说成是自己家；为了接近乐队的凯尔，成为同样酷酷的类型，她和珍娜套近乎而疏远了自己最好的朋友。 ​ 两次恋爱纷纷落空。第一次是个贴心男友，交往顺利，却被发现是个同性恋。第二次是个俊俏阴郁乐队选手（是有点帅），但性生活不够严肃，上完床两人就分了一半了吧。直到在去舞会的路上，男友和他的朋友们想中途逃出来，LadyBird却对舞会充满期待。其实就是三观不合啊！她开始同意，却也意识到，坚持自己内心的感受，不适合跟这些人做朋友。生活就是这样啊，我们期待、努力、相信又落空。谁的青春没遇上过渣男，只是帅不帅而已。 ​ LadyBird和老妈的冲突贯穿影片。强势得老妈常常扮演成长中的“黑脸角色”，总是试图把自己的意念强加给孩子：上一秒还被广播感动的母女二人，下一秒迅速争执起来，LadyBird用跳车的方式宣扬自己的逃离和叛逆；衣服不叠会被老妈骂，走路的姿势会被嫌弃，穿什么衣服都得不到赞扬，浴室不能反锁门，进屋从来不敲门……青春期的孩子都渴望自由，太想脱离大人的管教——“告诉我你抚养花了多少钱！等我长大了努力赚钱都还给你！这样我就再也不用和你讲话！” ​ 这份冲突的亲情在最后得到了和解。平安夜不在家过看得出妈妈最难过；会在半夜为女儿修剪裙边；暗自用没有语法韵律的信件记录下对女儿的冲突和爱意；当LadyBird真的去上大学，表面保持冷漠严肃，车都不下，实际内心有满满地不舍。一切地情感在试衣间前得到合理地解释： “I want you to be the best version of yourself you can be.” “What if this is the best version?” ​ 这也是每个家长对我们地期待吧。然而，对于家长地对我们地改变，我们总是无意识就反驳，就对抗。你有你的唠叨，我有我的骄傲！ ​ 失业、并长期患有抑郁症的老爸是影片温情的存在，是家里的“好人角色”担当。记得在女儿十八岁生日时送上生日蛋糕；瞒着妈妈帮女儿申请纽约的学校，是女儿地‘同党’；问是否要和门外那个按喇叭的男孩走，虽然爸爸内心是不喜欢的，但依然会尊重女儿；影片最后，悄悄把妈妈写的信放进Ladybird书包，告诉她，妈妈其实是多么爱她——这也是促进母女关系和解的重要一环。 ​ 这是一个与自己、与家人和解的故事，像极了青春期的我们。影片的最后，她真的到达纽约。在家乡，这个女孩给自己取名为LadyBird，向所有人宣称自己的叛逆，想像鸟一样自由挣脱；而到了纽约，她要像鸟一样开始漂泊时，又叫回Christian。因未来而出走，因出走而怀乡。 影片的最后，她在电话里说“妈妈，我发现我从来没有意识到，萨克拉门托是那么美的地方。似乎每一处细节，每一个弯道，都是那么的美丽。” ​ 我们总想为逃离自己的家庭出身而奋斗，终有一天会觉得，走得再远，都想再回到最初的地方。蜷局于母体时的安全是最安全。 大二上学期《英语影视鉴赏》课结作业。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"电影","slug":"电影","permalink":"https://melodyjerry.github.io/blog/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"Java笔记—包","slug":"Java笔记—包","date":"2019-11-23T05:54:59.000Z","updated":"2019-11-29T17:36:24.562Z","comments":true,"path":"2019/11/23/Java笔记—包/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/23/Java%E7%AC%94%E8%AE%B0%E2%80%94%E5%8C%85/","excerpt":"Java笔记——包创建时间：2019.11.23 说明：持续更新ing 概念 包(package) 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 ✔ 用来组织和管理类、接口、枚举和注解✔ 有三方面作用：1)便于组织,比如按功能、按团队等；2)解决命名冲突；3)进行访问权限控制(同包可用，包外不可见等) 如同类似OS的文件夹(或目录或路径)一样，包也采用了树形目录的存储方式。","text":"Java笔记——包创建时间：2019.11.23 说明：持续更新ing 概念 包(package) 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 ✔ 用来组织和管理类、接口、枚举和注解✔ 有三方面作用：1)便于组织,比如按功能、按团队等；2)解决命名冲突；3)进行访问权限控制(同包可用，包外不可见等) 如同类似OS的文件夹(或目录或路径)一样，包也采用了树形目录的存储方式。 作用 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 🔺 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 同一个包中类名字是不同的，不同包中类的名字可以相同，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 语法格式 123package 包名或package 父包名[.子包名][.孙包名][.层次下去] 🔸包名符合标识符命名规范，一般由小写字母组成🔹必须出现在源文件的第一行(忽略注释语句)🔸每个源文件至多只能出现一个package语句🔹如果没有package语句，那就使用无名包(或称默认包:所在的当前目录)🔸包的背后对应着操作系统的路径名称 示例： 12345678910111213package ch08.web.sample; public class Person { String name; int age; //省略部分代码 } class Dog { String name; int age; //省略部分代码} 🔺package ch08.web.sample; 这个层级的文件夹必须先存在：即ch08/web/sample 包的使用 🔺import 关键字 为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。 为了使用另外一个包中的成员(主要是类)，可以明确import该成员。 避免重复使用完整路径的类名。 语法格式： 1import package1[.package2…].(classname|*); 注意： 必须紧跟在package语句之后(若有的话，若无package，则import出现在源文件头部)。 可以使用 * 来表示导入当前一层包中的所有类。但是* 不可以连续使用。 1import java.*.*; // Error! 不表示可以继续导入当前包的子包。如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。 类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。 Java常用包 🔵JavaAPI的类库也是按照包的方式组织的 包名 描述 备注 Java.lang Java语言进行程序设计的基础类(核心类库)，它是默认导入的包 Runnable接口和Object、Math、String、StringBuffer、System、Thread、Throwable类 Java.util 实用工具类包 定义系统特性、随机数、日期时间、日历、集合类等 Java.io IO类包 包含能提供多种输入输出的文件读写类 Java.net 网络编程API Java.sql 数据库操作包 Java.text 文本处理相关类 包含了一些用来处理文本、数字和消息的类和接口 Java.awt 提供创建界面和绘制图形图像的所有类 Javax.asing awt上封装的GUI包 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"推荐3款文本编辑器","slug":"文本编辑器","date":"2019-11-22T02:34:04.000Z","updated":"2019-11-29T17:38:00.468Z","comments":true,"path":"2019/11/22/文本编辑器/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/22/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/","excerpt":"前言今天作者推荐两款文本编辑器。 我先后使用的Notepad 3、Sublime、Atom、VS Code、Vim。 这里作者就只推荐Notepad 3、Sublime和Atom。 关于VS Code和Vim，文末有两篇教程供大家入手。","text":"前言今天作者推荐两款文本编辑器。 我先后使用的Notepad 3、Sublime、Atom、VS Code、Vim。 这里作者就只推荐Notepad 3、Sublime和Atom。 关于VS Code和Vim，文末有两篇教程供大家入手。 //截断文章 Notepad 3 虽然 Windows 操作系统在过去几年中有了显著变化，但是，默认的 Windows 记事本却鲜有更新。如果您需要一个简单且适于编程的文本编辑器，Notepad3 将是一个不错的选择！ Notepad3是一款轻便快捷的基于 Scintilla 的文本编辑器，具有语法高亮、代码折叠、括号匹配、自动缩进、编码转换、换行格式转换、多次撤销或重做、书签、基于正则表达式的查找和替换等实用功能。它占用的内存很小，但功能强大，足以处理大多数编程工作。 Notepad 3 的界面 可能 是我见过所有主流文本编辑器里最最最简单清爽的吧？ 蓝奏云：下载链接（作者提供了已经汉化过的便携版本） （注意：Notepad 3和Notepad++没有关系 ） Sublime官方的介绍简单又粗暴 一款用于代码、标记和散文的精致文本编辑器 Sublime支持 Windows 、Mac 平台。插件是程序员的灵魂，Sublime不失这点。类似于 Eclipse，IDEA，它有着丰富的插件系统，完全可以满足各种开发编辑需求。1）安装 官网关于Sublime的介绍语下就是win版的下载入口或者点击这里快速下载最新版==Sublime Text 3 (Build 3207)== 下载得到的是exe，双击开始安装。 安装导向界面，点击【Next】继续安装。选择Sublime Text 3安装位置，您可以点击【Next】，软件会自动安装。或者您可以单击【Browse】，在弹出的安装位置窗口中，您可以自己选择Sublime Text安装位置，选择完成后点击【Next】。这里可选择 添加到资源管理器上下文菜单 。 安装完后可以在桌面或者开始菜单中找到Sublime。 2）使用Sublime的界面特别简洁，让人看着很舒服。这里，作者已经汉化过了。初始语言是English。 3）汉化 sublime 的插件的强大之处，sublime 通过 package control来统一管理安装的插件。现版本sublime 3自带package control功能。 将English变成Chinese，也可以通过Sublime的插件实现。 作者已经汉化过。为了教程，故在win7虚拟机上教大家如何实现汉化。 官网下载，并安装好, 刚安装好的是没有 Package Control 选项 找到 Tools-&gt;Install Package Control 选项，即可调出 Package Contro 不能直接找到 Install Package Control，去找“Tools-&gt;Command Palette…”选项 输入 ipc ,点击 Install Package Control，即可调出 Package Control 等待完成 找到 Preferences-&gt;Package Control 选项弹出命令行输入框，输入ip，点击“install Package 弹出命令行输入框，输入clz，点击“ChineseLocalizations” 搞定，设置成中文了 开开心心地食用汉化地Sublime吧 o(￣▽￣)o Atom Atom 是 Github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持CSS，HTML，JavaScript等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。 官网在这里👈友情链接：w3school之Atom教程Atom 中文社区 1）安装官网地Downloa或者点击这里快速下载最新版==Atom (1.41.0)== 下载得到exe，双击开始安装。安装过程很简单，直接省略。 2）使用Atom 的界面也比较简洁。Atom提供了侧栏、标签栏，可提高效率。Atom还能链接到GitHub，这真是GitHub用户的福利。(当然，Atom本来就是Github推出的hhhh)3）汉化Atom的汉化有两种方法： 方法一 打开软件后，点击 File&gt; Settings&gt; install 搜索 chinese，安装两个插件 重启软件因为插件托管在国外，可能因为网速原因，会非常慢，因此推荐下载中文插件包，请看方法二👇 方法二 打开https://atom.io/packages/去官网下载中文包，搜索【Chinese】，找到【atom-simplified-chinese-menu】点击进入主页（如上图），然后再点【Verions】，之后，找到最新版本，点【zip】包下载即可。。作者在这已经准备好中文包了，点击这里下载 将下载好了的压缩包解压到 C:/user/&lt;用户名&gt;/.atom/packages/目录下面 打开Atom，发现已经Chinese了。 综上主流的文本编辑器有很多。每个人的需求不一样，找到合适自己的才是好的。Notepad 3、Sublime、Atom、VS Code、Vim、Notepad++（前段时间闹事，作者不方便再提） VS Code：传送门 Vim：传送门 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Java笔记—继承","slug":"Java笔记—继承","date":"2019-11-21T09:54:59.000Z","updated":"2019-11-29T17:36:14.410Z","comments":true,"path":"2019/11/21/Java笔记—继承/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/21/Java%E7%AC%94%E8%AE%B0%E2%80%94%E7%BB%A7%E6%89%BF/","excerpt":"Java笔记——继承 创建时间：2019.11.21 说明：持续更新ing 继承源于自然 就比如：兔子和羊属于食草动物类，狮子和豹属于食肉动物类。食草动物和食肉动物又是属于动物类。虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以 子类会具有父类的一般特性也会具有自身的特性。","text":"Java笔记——继承 创建时间：2019.11.21 说明：持续更新ing 继承源于自然 就比如：兔子和羊属于食草动物类，狮子和豹属于食肉动物类。食草动物和食肉动物又是属于动物类。虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以 子类会具有父类的一般特性也会具有自身的特性。 //截断文章 概念、目的、本质、特性 概念 它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 其主要作用在于，在已有基础上继续进行功能的扩充。（即，以存在的类为基础定义新的类，新类即拥有基类的数据成员和成员方法） 目的 继承的目的是代码重用 本质 描述了自然界中广泛存在的一种关系——类属关系（is-a），对应还有一种has-a关系即组合（聚合）关系。 特性 Java 继承的特性 子类拥有父类非private的属性，方法 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展 子类可以用自己的方式实现父类的方法 Java的继承是单继承，【但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性】 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系） 继承的关键字 继承可以使用 extends(单继承) 和 implements（变相的多继承）， 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 （1）extends关键字 Java只支持单继承，即：一个子类只能有一个父类.但可以有多个间接祖先类。 语法格式： 123456权限修饰符 class 父类名 { //父类体}权限修饰符 class 子类名 extends 父类名 { //子类体} 实例： 123456789101112public class Animal { private String name; private int id; public Animal(String myName, String myid) { //初始化属性值 } public void eat() { //吃东西方法的具体实现 } public void sleep() { //睡觉方法的具体实现 } } public class Penguin extends Animal{ } —————————————————————— 我 是 分 割 线 ——————————————————————— （2）implements关键字 变相地使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 public interface A { public void eat(); public void sleep(); } public interface B { public void show(); } public class C implements A,B { } &lt;!--￼2--&gt; 执行结果： &lt;!--￼3--&gt; —————————————————————— 我 是 分 割 线 ——————————————————————— （4）this关键字 指向”自己的引用“。 实例： 123456789101112131415161718192021222324class Animal { void eat() { System.out.println(\"animal : eat\"); }} class Dog extends Animal { void eat() { System.out.println(\"dog : eat\"); } void eatTest() { this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 }} public class Test { public static void main(String[] args) { Animal a = new Animal(); a.eat(); Dog d = new Dog(); d.eatTest(); }} 输出结果： 123animal : eatdog : eatanimal : eat ——————————————————————————— 我 是 分 割 线 ———————————————————————————— （5）final关键字 声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。 继承类型 Java 不支持多继承，但支持多重继承 （ 一般不会超过三层 ）。 继承的限制 🔺 Java只允许单继承、不允许多继承（一个子类继承一个父类）。 🔺 子类对象在进行实例化前首先调用父类构造方法，再调用子类构造方法实例化子类对象。 🔺 在继承时，子类会继承父类的所有结构。 在进行继承的时候，子类会继承父类的所有结构（包括私有属性、构造方法、普通方法）显示继承：所有非私有操作属于显示继承（可以直接调用）。隐式继承：所有私有操作属于隐式继承（不可以直接调用，需要通过其它形式调用（get或者set））。 子类能够使用的是所有非private操作，而所有的private操作无法被直接使用，所以称为隐式继承。 继承中“域的隐藏” 在子类中重新定义( 同 名 )继承自父类的域. 🔺子类继承父类非私域。 🔺子类定义与从父类继承下来的同名域，在子类中用该名直接访问就只能访问到子类定义的域，即隐藏了同名的继承下来的父类域。 🔺如果要访问同名父类域：通过父类方法，或者使用“*super . *” 实例： 123456789101112131415161718192021222324import static java.lang.System.*;class Super{ private int v1 = 1; int v2 = 2; public int getV1() { return v1; }}class Sub extends Super{ int v1 = 11; int v2 = 22; public void show() { out.println(v1); //out.println(super.v1); out.println(getV1()); out.println(v2); out.println(super.v2); }}public class FHTest{ public static void main(String[] args) { new Sub().show(); }} 继承情况的构造 首先🔺类初始化时,继承链上(包括当前类)的全部静态代码块最先执行一次。之后不再执行，除非程序又重启。(按链序和声明序且仅1次) 其次🔺创建子类实例时,会先进行父类的构造(要么显式进行，要么隐式用super()进行) 最后🔺类的构造顺序：构造代码块(按声明序) ➡ 构造方法 总体🔺父类静态块 ➡ 子类静态块 ➡ 父类构造块 ➡ 父类构造子 ➡ 子类构造块 ➡ 子类构造子（下划线”__”部分， 仅执行一次） 总结 1、为什么使用继承 从已有的类派生出新的类，称为继承。 在不同的类中也可能会有共同的特征和动作，可以把这些共同的特征和动作放在一个类中，让其它类共享。 因此可以定义一个通用类，然后将其扩展为其它多个特定类，这些特定类继承通用类中的特征和动作。 继承是 Java 中实现软件重用的重要手段，避免重复，易于维护，易于理解。 2、父类和子类 如果类 B 从类 A 派生，或者说类 B 扩展自类 A，或者说类 B 继承类 A， 则称类 A 为”父类”，也称为超类、基类； 称类 B 为”子类”，也称为次类、扩展类、派生类。 子类从它的父类中继承可访问的数据域和方法，也可以添加新的数据域和新的方法。 定义继承的语法： 1修饰符 class 子类名 extends 父类名 例如：Shape 类是父类，其子类可以有 Circle 类、Rectangle 类、Triangle 类，等等。 继承的注意点： 子类不是父类的子集，子类一般比父类包含更多的数据域和方法。 父类中的 private 数据域在子类中是不可见的，因此在子类中不能直接使用它们。 继承是为”是一个”的关系建模的，父类和其子类间必须存在”是一个”的关系，否则不能用继承。 但也并不是所有”是一个”的关系都应该用继承。例如，正方形是一个矩形，但不能让 Square 类来继承 Rectangle 类，因为正方形不能从矩形扩展得到任何东西。正确的继承关系是 Square 类继承 Shape 类 Java 只允许单一继承（即一个子类只能有一个直接父类），C++ 可以多重继承（即一个子类有多个直接父类）。 3、super 关键字 super 表示使用它的类的父类。super 可用于： 调用父类的构造方法； 调用父类的方法（子类覆盖了父类的方法时）； 访问父类的数据域（可以这样用但没有必要这样用）。 调用父类的构造方法语法： 12345super(); 或 super(参数列表); 注意：super 语句必须是子类构造方法的第一条语句。不能在子类中使用父类构造方法名来调用父类构造方法。 父类的构造方法不被子类继承。调用父类的构造方法的唯一途径是使用 super 关键字，如果子类中没显式调用，则编译器自动将 super(); 作为子类构造方法的第一条语句。这会形成一个构造方法链。 静态方法中不能使用 super 关键字。 调用父类的方法语法： 1super.方法名(参数列表); 如果是继承的方法，是没有必要使用 super 来调用，直接即可调用。但如果子类覆盖或重写了父类的方法，则只有使用 super 才能在子类中调用父类中的被重写的方法。 4、this 关键字 this 关键字表示当前对象。可用于： 调用当前类的构造方法，并且必须是方法的第一条语句。如：this(); 调用默认构造方法。this(参数); 调用带参构造方法。 限定当前对象的数据域变量。一般用于方法内的局部变量与对象的数据域变量同名的情况。如 this.num = num。this.num 表示当前对象的数据域变量 num，而 num 表示方法中的局部变量。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java笔记—数组","slug":"Java笔记—数组","date":"2019-11-20T04:54:46.000Z","updated":"2019-11-29T17:36:21.566Z","comments":true,"path":"2019/11/20/Java笔记—数组/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/20/Java%E7%AC%94%E8%AE%B0%E2%80%94%E6%95%B0%E7%BB%84/","excerpt":"Java笔记——数组创建时间：2019.11.20 说明：持续更新ing ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 数组 数组是一组相同类型的变量（元素）的集合。可以用来存放一组相同类型的数据。数组的学习涉及数组的定义、赋值和使用。再扩展一点就是二维数组的应用。数组既是一种重要的数据类型，也是一种重要的数据结构。 数组（array）————一组相同类型的变量(元素)集合 相同的任意类型 (包括基本类型、类类型等) 这组变量被连续地存放在Java堆区的内存空间 数组是一种引用类型，数组名是一个地址的别名 数组需要创建（new），否则不会被分配堆空间 数组名对应的地址单元中存放上述连续堆区空间的首地址 🔺 对程序员而言, 数组总体有三样东西：数组名+数组长度+数组元素","text":"Java笔记——数组创建时间：2019.11.20 说明：持续更新ing ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 数组 数组是一组相同类型的变量（元素）的集合。可以用来存放一组相同类型的数据。数组的学习涉及数组的定义、赋值和使用。再扩展一点就是二维数组的应用。数组既是一种重要的数据类型，也是一种重要的数据结构。 数组（array）————一组相同类型的变量(元素)集合 相同的任意类型 (包括基本类型、类类型等) 这组变量被连续地存放在Java堆区的内存空间 数组是一种引用类型，数组名是一个地址的别名 数组需要创建（new），否则不会被分配堆空间 数组名对应的地址单元中存放上述连续堆区空间的首地址 🔺 对程序员而言, 数组总体有三样东西：数组名+数组长度+数组元素 “声明、创建、初始化、访问”数组 声明数组： 🔺只给数组变量(由数组名描述)分配空间，而不会给数组按要存放的元素的多少来分配空间。 有两种形式——&gt;推荐第一种： 数据类型[] 数组名 12345//数据类型[] 数组名int[] a;//数据类型 数组名[]int a[]; ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 创建数组：用new运算符，同对象的创建。 有两种形式——&gt; 123456//先声明，后创建int[] a; //声明存放int型数据的数组aa = new int[10]; //在Java堆区中创建10个int型元素空间(共40个字节)//声明和创建合一int[] test = new int[12]; 注意： 🔺声明数组，仅仅创建数组变量🔺创建数组，才在堆区中分配空间 [ ]中必须是非负整数，否则执行时异常。可以是字面常量、也可以是变量，只要保证其值是非负整数。 创建数组之后，各元素的默认初始值是：数值型为0(0.0)；字符型’\\0’；引用类型null；布尔型false ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 初始化数组：在创建好的数组元素空间中存放初始值.否则按默认值初始化。 🔺数组创建时（即new时使用）初始化器语法：{元素值列表}。 12//声明存放int型数据的数组aMonth并初始化int[] aMonth = new int[]{1,2,3,4,5,6,7,8,9,10,11,12}; 注意： 使用了初始化器之后不能显式指定长度 即 new int[12]{…} ，不对 12345int[] a; //先声明数组aa = new int[2]{1,2}; // Error,不能显式指明长度[2]a = {1,2}; // Errora = new int[]{1,2}; // OK!int[] b = {1, 2}; // OK!此方式用得最多 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 访问数组： 🔺数组元素：数组中的每一个变量，也被称为下标变量，索引变量 🔺下标从0开始：用[ ]运算符访问元素，即 数组名 [ 数组下标 ] 🔺既然是变量，所以数组元素可以作为左值也可以作为右值，比如a[i]++、b[0]=5;、a=b[0]+2;等等。 数组长度属性 🔺数组唯一的一个 只读 属性：length 存有数组元素个数值。 🔺*数组名.length * 遍历数组 🔺增强版for语句：foreach语句（JDK5开始提供） 🔺适用于遍历数组、集合元素等形式 123for(元素的数据类型 遍历变量x : 遍历对象obj){ //x是自定义遍历变量名 引用了x的Java语句; //循环体 } 注意： foreach语句是for的简化,任何foreach语句都可以改用for语句，反之不行。 foreach语句不关注下标。 用foreach的遍历变量不能修改元素值。 123456789public class Demo { public static void main(String[] args) { int[] a = {1, 3, 4, 5, 6, 8, 10}; /* 循环输出a */ for(int n : a){ // 利用变量n遍历数组a System.out.printf(\"%4d \", n); // n表示数组a的每一个元素值 } } } 二维数组、多维数组 Arrays 类 主要功能： 🔺java.util.Arrays类： 数组操作实用类,它提供了一系列静态方法 equals()方法:比较两个数组长度是否相同和对应索引上的元素值是否相同. fill()方法:向数组中填充数据. copyOf()方法:复制一个数组的部分元素并生成一个新的数组返回 sort()方法:若是基本类型则把数组元素按自然顺序升序排列.若是引用类型,其该实现了Comparable接口才能调用sort方法,否则报异常. binarySearch()方法:对已排序数组使用二分查找算法查找指定元素. asList()方法:返回数组的List对象形式. toString()方法:返回包含所有元素信息的字符串 parallelSort()方法:开启多线程的排序. deepEquals()方法:深度比较两个数组是否相同.适于任何深度的多维(嵌套)数组. 问：数组可以作为方法的参数或返回值吗？ 当然是可以的 。答案来源 m博客 数组作为方法参数 🔺数组作为方法参数传递，传递的参数是数组内存的地址。 123456789101112public static void main(String[] args) { int[] arr = {11, 22, 33, 44, 55}; System.out.println(\"1位置: \" + arr); printArray(arr); // 数组作为方法参数传递，传递的参数是数组内存的地址}public static void printArray(int[] arr) { System.out.println(\"2位置: \" + arr); for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); }}1234567891011 数组作为方法返回值 🔺数组作为方法的返回值，返回的是数组的内存地址。 123456789101112131415161718public static void main(String[] args) { //调用方法，接收数组的返回值 //接收到的是数组的内存地址 int[] arr = getArray(); for (int i = 0; i &lt; arr.length; i++) {System.out.println(arr[i]); }}/* 创建方法，返回值是数组类型 return返回数组的地址*/public static int[] getArray() { int[] arr = { 1, 3, 5, 7, 9 }; //返回数组的地址，返回到调用者 return arr;}1234567891011121314151617 该博主的延伸阅读： Java–数组的定义和访问、Java–数组原理内存图、Java–数组的常见操作 判断： Java中数组可以动态改变长度？ 错误。 Java中的数组的定义就是相同类型，固定长度的一组数据，一旦被初始化，长度不可更改。 10. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"教会你怎么安装和使用 Visio 哦 ~ ~","slug":"Visio教程","date":"2019-11-19T01:34:04.000Z","updated":"2019-11-29T17:38:35.080Z","comments":true,"path":"2019/11/19/Visio教程/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/19/Visio%E6%95%99%E7%A8%8B/","excerpt":"前言 很多学生会在编程、设计或其他时候可能使用到【制图工具】。最好用的莫不过【微软的Visio】了。但是很多学生不会使用Visio，甚至不会安装Visio。 &gt; Visio 这么好的工具，一定要会用。 今天，作者写一份教程，教会大家了解如何安装和使用 ==Visio==。 在正式教程之前，我们先介绍 Visio。 Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。 &gt; Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。","text":"前言 很多学生会在编程、设计或其他时候可能使用到【制图工具】。最好用的莫不过【微软的Visio】了。但是很多学生不会使用Visio，甚至不会安装Visio。 &gt; Visio 这么好的工具，一定要会用。 今天，作者写一份教程，教会大家了解如何安装和使用 ==Visio==。 在正式教程之前，我们先介绍 Visio。 Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。 &gt; Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。 //截断文章 安装1. 【下载资源】 网上也有很多资源，但是包是不完整的。版本也很多，要激活也不容易。 作者在这里已经打包好“Visio 2019”和“激活工具”了，点击这里(提取码: rwtr)开始下载。 由于现在的笔记本都是预装win10的，所以不用担心Visio 2019合不合适。毕竟Visio 2019在win7上是安装不了的。2. 【解压】 下载得到压缩包，解压，打开文件夹。 3. 【打开Setup】 打开“Visio 2019”，右键“Setup”选中“以管理员身份运行”。（似乎不用管理员也行？？？） 4. 【正在安装】 等待就好，很快的。 5. 【安装完成】 安装结束，点击“关闭”。 6. 【激活】 Visio 2019是==必须激活==才可以使用的。 否则，会一直弹窗提示激活的。 激活工具在另一个文件夹里。 补充一些关于KMS： KMS（全称:Key Management Service），这个是微软的一种新型产品激活机制，目的是为了Microsoft更好的遏制非法软件授权行为(盗版)。 当然作者不提倡破解、或盗版。 对于有能力的人，还是支持正版。但是学生嘛，能用就好了。 使用激活工具前，作者建议： ==最好关闭杀毒软件，如果有的话。== 作者没安装360那些，很流畅地激活成功。 ==激活工具无毒的。不关闭的话，可能被误报。== 1).【打开】 界面如下： 这个激活工具还可以xxxxxx。（你懂的） 我啥都没说哦hh 2).【激活】 简单一按，等待激活成功就好。 补充：可能有的电脑打开软件时会提示这个。解决很简单，安装框架就好。 （1）打开“控制面板”。（2）找到并点击“程序和功能”项，在打开的页面中，点击“启用或关闭Windows功能”。（3）在打开的“Windows功能”对话框中，找到并勾选“Microsoft.Net Framework”服务，单击“确定”即可。 使用激活后，就可以安安心心、大大方方地使用 Visio 了。o(￣▽￣)o 【打开】 【新建】新建页面，有一些初始模板可以使用。一般选择“基本框图”就好，然后“新建”。 【制图】 左侧可以选择很多官方自带的形状，当然还可以自己建立自己的模型。 右侧可以对图形自定义，包括颜色、线条、端点等等。 结尾使用 Visio 来制图真的很爽。但是，如果只是临时制图使用 Visio ，还得安装确实不太方便。因此 作者还收藏了几个线上制图的网站，在这提供给大家临时使用。 1. https://www.draw.io/ 2. https://zh.numberempire.com/graphingcalculator.php 3. https://www.processon.com 4. 当然用电脑自带的【画图】也是可以的，你看。 emmm只是好难看啊hhhh。 这就是结尾：如果教程上有什么不足的或者有问题的，可以私信我。谢谢你的阅读！ 本博客第一次发表于【简书】： https://www.jianshu.com/p/32648bcc6f1c 。现转载到作者的网站上。谢谢阅读！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"百合","slug":"百日","date":"2019-11-16T12:54:59.000Z","updated":"2019-11-25T12:23:15.221Z","comments":true,"path":"2019/11/16/百日/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/16/%E7%99%BE%E6%97%A5/","excerpt":"2019.11.16 星期六 晴天","text":"2019.11.16 星期六 晴天 💙汪曾祺老人的散文《活着多好呀》中“活着多好呀”为汪老一句名言。这位老人不管遇到什么环境，永远不消沉沮丧，守护心中的热情与生机，兴致盎然地生活。💛时光机，这个世界不存在的理想物品。可是我多希望有这东西，真是可惜无法回到两三年前，“时间就是让人猝不及防的东西”……💜有段时间，喜欢黑暗安静的环境。肚子一个人发呆，内室里一个窗户也不开，杜绝所有来往。但已经走出来那段抑郁期，今后不知道，但是现在我挺好的。恍惚发现，最好掩盖哭的方式，除了偷偷一个人，就是洗澡的时候。💚或记日记或写随笔或向月亮倾诉或对空气说说，~生活不易，但也没那么糟糕。柏拉图说：没有什么比健康更快乐的了，虽然在他们生病之前并不曾觉得那是最大的快乐。💗“谢谢你的不告而别”。下辈子，我们再会 ! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"解除课程中心看视频时的“ 窗口获取焦点事件 ”","slug":"解除课程中心看视频时的“ 窗口获取焦点事件 ”","date":"2019-11-16T09:54:59.000Z","updated":"2019-11-23T02:16:39.416Z","comments":true,"path":"2019/11/16/解除课程中心看视频时的“ 窗口获取焦点事件 ”/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/16/%E8%A7%A3%E9%99%A4%E8%AF%BE%E7%A8%8B%E4%B8%AD%E5%BF%83%E7%9C%8B%E8%A7%86%E9%A2%91%E6%97%B6%E7%9A%84%E2%80%9C%20%E7%AA%97%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6%20%E2%80%9D/","excerpt":"前言前段时间，在观看课程中心的马克思视频，因为要至少看到80%以上。 发现那我挂着刷不就得了？偏偏。。。。。 发现这个课程中心存在某个机制——一定要使视频一直处于“置顶”的状态，否者会自动暂停视频。","text":"前言前段时间，在观看课程中心的马克思视频，因为要至少看到80%以上。 发现那我挂着刷不就得了？偏偏。。。。。 发现这个课程中心存在某个机制——一定要使视频一直处于“置顶”的状态，否者会自动暂停视频。 //截断文章 就像下图这样： 操作鼠标前——&gt; 操作鼠标后——&gt; 你会注意到，视频的播放状态跟鼠标的行为有关，准确来说是==和鼠标点击的位置（焦点）有关==。 第一时间想到“这不就是windows的“窗口获取焦点”吗？ 补充先补充补充什么是窗口获取焦点？ 在你浏览其他窗口页面、或是浏览器最小化、又或是点击了程序窗口时，等等都算是浏览器窗口失去焦点，这时候 window.onblur 事件就会触发。 当然，当你的页面获得焦点的时候一样也会触发window.onfocus。 应该有人会注意到过，当你点击不同窗口时，窗口栏会有不同的颜色反馈，就比如win 10的资源管理器，前置窗口和后置窗口的窗口颜色是不是不一样？ 寻找直接按下F12，打开控制台，查看Elements…… emmmmmm结果，没找到对应的代码（或许我没仔细去挖hh） 再试那我直接Console。不就是当前窗口获取了焦点吗？？？？直接暴力敲下代码，并Enter，嘿嘿…… 1javascript:window.onblur=null;void 0 //有无`void 0`，都可以 当我Enter时，诶，成功了hhh效果就是这样。 后续测试了一段时间后，成功率基本达97%左右。后来就分享到班群，让更多人试试效果。两天刷完所有马克思的视频哈哈有木有？ 建议 一次最多同时两个视频在看，因为后台有个计时器再加上我不会写自动播放、自动静音的脚本hhhhh（有时间再去琢磨哈） 一旦刷新页面，就得重新Enter脚本 极小几率会失败，原因我也不清楚，失败重新Enter即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://melodyjerry.github.io/blog/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"Java笔记—对象、类","slug":"Java笔记—对象、类","date":"2019-11-15T04:54:59.000Z","updated":"2019-11-30T10:18:12.578Z","comments":true,"path":"2019/11/15/Java笔记—对象、类/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/15/Java%E7%AC%94%E8%AE%B0%E2%80%94%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB/","excerpt":"Java笔记——对象、类创建时间：2019.11.11 说明：持续更新ing 对象和类的概念。 对象：对象是类的一个实例（实实在在存在的个体），有属性（状态）和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 属性(property)： 静态特征行为(behavior)： 动态特征 类：类是对现实生活中事物的描述。类是一个模板，它描述一类对象的行为和状态。同种类型对象共性的抽象","text":"Java笔记——对象、类创建时间：2019.11.11 说明：持续更新ing 对象和类的概念。 对象：对象是类的一个实例（实实在在存在的个体），有属性（状态）和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 属性(property)： 静态特征行为(behavior)： 动态特征 类：类是对现实生活中事物的描述。类是一个模板，它描述一类对象的行为和状态。同种类型对象共性的抽象 用老师的话来说，就是下面这样——&gt; 下图中男孩（boy）、女孩（girl）为类（class），而具体的每个人为该类的对象（object）： 【定义类】 Java中的类 类可以看成是创建Java对象的模板。 通过下面一个简单的类来理解下Java中类的定义： 123456789101112public class Student { int id; String name; double score1, score2, score3; public Student(int id, String name) { this.id = id; this.name = name; } public double getAverageScore() { return (score1 ＋ score2 + score3) / 3; } } 一个类可以包含以下类型变量： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。一个类可以拥有多个方法。 Java中的对象现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。对比现实对象和软件对象，它们之间十分相似。 软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 创建对象——&gt; 1234567891011/*有两种基本形式*//*1.对象声明和创建*/类名 对象名 = new 类名();Student xiaoming = new Student ();/*2.先声明,后创建*/类名 对象名; // 类(对象)变量对象名 = new 类名(); //实例化Student xiaobai ;xiaobai = new Student(); 类和对象的关系：类是具有相同==属性和方法==的集合，是对对象的抽象描述。 现实生活中的对象：张三、李四。 【想要描述】提取对象中的共性内容。对具体的抽象。 【描述时】这些对象的共性有：姓名、学号、年龄、性别、学习Java等等。（即定义类：描述事物的属性和行为，就是在定义属性和行为。属性和行为共同成为类中的成员（成员变量和成员方法）。） 映射到Java中，描述就是class定义的类，具体对象就是new建立的实体。 这些描述在Java当中是用类的形式来体现的。而对象是通过Java的new操作符所产生的一个实体，这个的实体存在于==堆内存==当中。 12345678910111213141516171819202122232425//定义类，就是描述事物，就是在定义属性和行为。属性和行为共同成为类中的成员（成员变量和成员方法）。//需求：描述车汽车（颜色，轮胎数）。class Car { //描述颜色 String color = \"red\"; //描述轮胎数 int num = 4; //运行行为。 void run() { System.out.println(color+\"..\"+num); }}class CarDemo { public static void main(String[] args){ //生产汽车：在Java中通过new操作符来完成。 //其实就是在堆内存中产生一个实体。 Car c = new Car(); //c就是一个【类类型】变量。记住：类类型变量只想对象。 //需求：将已有车的颜色的颜色改成蓝色。指定该对象做使用。 //在Java指挥方式是：【对象.对象成员】 c.color = \"blue\"; //需求：想要车运行起来。 c.run(); }} Car c = new Car();在内存中的示意图——&gt; c.run();——&gt;输出这个车的颜色“蓝色”和轮胎数“4”。 (1)倘若在c.run();后加入Car c1=new Car();c1.run();——&gt; (2)若main的代码块改为： 123456789class CarDemo { public static void main(String[] args){ Car c = new Car(); c.num = 5; Car c1 = c; c1.color = \"green\"; c.run(); }} 在内存中的示意图——&gt; 对对象调用的基本概念：用new建立对象，在堆内存中产生对象。那么对象的特点在于封装数据，数据包含属性和行为。想要操作对象中的内容就指挥对象做事，指挥哪个对象要明确，操作什么也要明确，用对象.xyz的形式就能完成。 【注意】：如下图， 以前定义在函数里面，现在定义在函数外面 【方法】 方法的定义： 方法是类或对象的行为特征的抽象。 Java中的方法不能独立存在，所有的方法必须定义在类中。 使用 “类名.方法” 或 “对象.方法” 的形式调用。 语法格式： 1234权限修饰符 返回值类型 方法名（参数类型 参数名1,参数类型 参数名2,...） { // 方法体 方法语句序列//当返回类型非void时,最后一条被执行语句必须是return语句,返回对应类型的值} 访问权限/权限修饰符（4P权限）： 访问权限 类内 包层内 子类 包层外 public √ √ √ √ protected √ √ √ × package （缺省） √ √ × × private √ × × × return语句： 结束方法调用，并返回值。 return 表达式; return; 🔺方法被调用时,执行到方法内的return语句,则不论方法里是否还有语句未执行,立即结束方法的调用,并将return 后的表达式的值返回方法调用者🔺利用return 语句返回值，仅能返回一个值🔺return语句仅结束方法的执行 🔺void型方法 方法分类： 无参数无返回值 有参数无返回值 无参数有返回值 有参数有返回值 123456789101112131415161718192021222324252627282930public class Method { public void aMethod() { System.out.println(\"无参数无返回值的方法\"); } public void bMethod(int b) { System.out.println(\"有参数无返回值的方法\"); } public int cMethod() { System.out.println(\"无参数有返回值的方法\"); return 10; } public int dMethod(int d) { System.out.println(\"有参数有返回值的方法\"); return d; } public static void main(String[] args) { int ret; // 创建Method类的对象 Method md = new Method(); // 通过对象.方法调用 md.aMethod(); md.bMethod(10); ret = md.cMethod(); ret = md.dMethod(10); System.out.println(ret); }} 方法的参数： 方法可以没有参数，或者有多个参数，参数类型可以是任意类型 方法参数也是局部变量 参数为引用数据类型4时： 当对象实例作为参数传递给方法时，传递的是对象的引用，为地址传递，接受参数的方法可以改变参数的值。 参数为简单数据类型时： 传递的是参数的副本，为值传递，接受参数的方法中不会改变参数的值。 123456789101112131415161718192021222324252627282930313233343536373839public class MethodParam { /** * 方法的参数为基本数据类型时，传递的是值的副本（值拷贝） * 方法中不会改变元参数的值 */ public void swap(int a, int b) {//a, b为形参 int tmp; tmp = a; a = b; b = tmp; } int x = 100, y = 200; /** * 方法的参数为引用数据类型时，传递的对象的引用（传地址） * 方法中可以改变参数的值 */ public void swap2(MethodParam mp) { int tmp = mp.x; mp.x = mp.y; mp.y = tmp; } public static void main(String[] args) { MethodParam mp = new MethodParam(); int m = 10, n = 20; System.out.println(\"交换前：a = \"+m+\",b = \"+n); mp.swap(m, n);// m,n为实参 System.out.println(\"交换后：a = \"+m+\",b = \"+n); System.out.println(\"交换前：x = \"+mp.x+\",y = \"+mp.y); mp.swap2(mp); System.out.println(\"交换后：x = \"+mp.x+\",y = \"+mp.y); }} 普通方法调用——&gt; 成员方法和成员变量的关系——&gt; 【成员方法】和【构造方法】 【成员方法】 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【构造方法】 构造方法需满足以下三个条件 ： 1、方法名与类名同名 2、在方法中不能使用 return 语句，即无返回值 3、在方法名的前面*没有返回值的类型声明 * （有看到“ 构造方法无返回值也不可以加void，但其实返回的是首地址 ”这话还得去证实，先放在这里） ==老师推荐==：显式无参构造子,作为一种良好实践,定义了其他构造子，那就准备一个无参构造子 12345678910111213package me;public class Me { private String name; //成员变量 public Me(String name){ //构造方法 this.name = name; } public String getName() { //成员方法 return name; } public void setName(String name) {//成员方法 this.name = name; }} 我如果我在添加一age 如下 添加方法依然是成员方法 , 1234567891011121314151617181920package me;public class Me { private String name; //成员变量 private String age; //成员变量 public Me(String name){ //构造方法 this.name = name; } public String getName() { //成员方法 return name; } public void setName(String name) {//成员方法 this.name = name; } public String getAge() {//成员方法 return age; } public void setAge(String age) {//成员方法 this.age = age; }} 个人理解：无论多少方法，==除了构造方法外，其余都是成员方法==，当然这样理解可能有点偏见.. 它们的区别： 构造方法一般是给对象的数据进行初始化,没有返回值 成员方法一般实现对类中成员变量的操作，提供某些功能,有返回类型，可以为void类型 成员方法与构造方法调用的区别 123456789package me;public class Book { public static void main(String[] args) { Me me = new Me(\"张三\");//构造方法调用 System.out.println(me); me.setName(\"李四\");//成员方法调用 System.out.println(me.getName()); }} 从上面的demo中可以看出，==构造方法通过new运算符调用==，==成员方法通过对象调用==。 注意：类中除了构造方法以外的方法都是成员方法。原因是在类中，除了变量外的基本都是成员方法。 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【this 关键字】 https://i.loli.net/2019/11/16/49d7AMODXhKbsuy.png ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【重载构造方法之间的调用】 【含对象成员的构造方法调用】 【无继承情况下的对象初始化顺序】 【创建对象】 对象是根据类创建的。在Java中，使用关键字new 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 下面是一个创建对象的例子： 12345678910public class Puppy{ public Puppy(String name){ //这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public static void main(String[] args){ // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( \"tommy\" ); } } 编译并运行上面的程序，会打印出下面的结果： 1小狗的名字是 : tommy ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【访问实例变量和方法】 通过已创建的对象来访问成员变量和成员方法，如下所示： 123456/* 实例化对象 */ Object referenceVariable = new Constructor(); /* 访问类中的变量 */ referenceVariable.variableName; /* 访问类中的方法 */ referenceVariable.methodName(); ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【访问实例变量】和【调用成员方法】： 1234567891011121314151617181920212223public class Puppy{ int puppyAge; public Puppy(String name){ // 这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public void setAge( int age ){ puppyAge = age; } public int getAge( ){ System.out.println(\"小狗的年龄为 : \" + puppyAge ); return puppyAge; } public static void main(String[] args){ /* 创建对象 */ Puppy myPuppy = new Puppy( \"tommy\" ); /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println(\"变量值 : \" + myPuppy.puppyAge ); } } 编译并运行上面的程序，产生如下结果： 123小狗的名字是 : tommy小狗的年龄为 : 2变量值 : 2 【方法重载，重构，覆盖，重写的区别】 方法重载还是比较好理解的，就是在类的内部，定义多个方法，这些方法的方法名字相同，参数类型、参数顺序、参数个数不同，注意，返回值类型并不能区分重载 。 123456789public void show(int a,double b){}public void show(double c){} public int show(double d){ return 1;} //报错，方法已经定义了 方法重写（override)方法重写和方法覆盖都是一个道理，发生在子类继承父类或者实现接口的类，要求的是： 1.方法名字相同，2.参数个数不同，3.返回值类型不同 ， 代码： 方法重构 定义：在不改变外界外界访问的情况下对代码进行修改，但是不改变原方法的效果，提高其性能，使程序更加易读，可维护。重构是在不改变软件可观察行为的前提下改善其内部结构重构通常不是一次性的，它贯穿软件的整个生命周期，只要觉得不合理都是重构的时机。 题目：下面说法中，错误的有（ ） ​ A. Java面向对象语言容许单独的过程与函数存在； ​ B. Java面向对象语言容许单独的方法存在； ​ C. Java语言中的方法属于类中的成员（member）； ​ D. Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同。 答案：ABC 解释： 方法与函数：这两个概念不严格区分，就是一个东西，通过对象调用的，就是方法，直接调用，就是函数； 在java中，everything is object 所以，方法，函数，必须隶属于某一个类或对象， java中没有过程。（类中的代码块不知道算不算，就算代码块是过程，也是必须在类中才有的） 对于C选项，方法分为静态方法和非静态方法，静态方法属于类成员，非静态方法属于实例成员。 类其实一种类型，它封装了数据和操作。 对象是类的实例 一个对象比属于某个类 一个类可以声明多个对象 问：构造方法可以调用本类的其他方法吗？ 1,构造方法可以调用本类的其他方法。既然可以调用本类的属性,那么也就可以调用属于本类的其他方法。 2,需要注意的是,如果要在构造方法里调用一个非静态方法时,应该将该方法声明为private。因为如果这个类被其他类继承成为父类时,这个方法不是private的又被子类所重载，这样在实际创建子类的过程中递归调用到了父类的构造器时，父类构造器对这个方法的调用就会由于多态而实际上调用了子类的方法，当这个子类方法需要用到子类中实例变量1的时候，就会由于变量没有初始化而出现异常（子类中的实例变量没有初始化这种情况还是会遇见的），这是Java不想看到的情况。 一个类的构造方法有多个，在其他类中是否可以被调用？ 只要不是私有的构造函数，在其他类中就可以调用。 传对应的参数就行了 。 12345678910class` `A{ ``public` `A(String s){} ``public` `A(``int` `n){} ``public` `A(String s, ``int` `n){}}class` `B{ ``A a1 = ``new` `A(``\"abc\"``); ``A a2 = ``new` `A(``1``); ``A a3 = ``new` `A(``\"aaa\"``,``2``);} 类是一种引用类型。 Java的引用类型只有三种，分别是 类(class) 接口(interface) 数组 参考资料 问：方法一定是在类内部被定义的？ 所有方法必须写在类体里，也包括构造方法2的。 static方法同样属于类，叫类方法或静态方法，它与类一同被加载时，处于内存的公共代码区中，无需创建实例来调用，只需用类名引用即可。 static方法既可以通过类名来调用，也可以通过类的实例调用。 Java一切都是以类的形式存在，方法是类的一部分，需要通过类才能进行方法的调用。 从内存存储角度来说，java中找对应方法时，都是先找对应类实例，类实例是根据类来初始化内存的。如果方法在类外部，则无法找到该方法。 所以方法必须在类体里。 注意： 可以在其他类里使用这个类的方法（在不同的包下就要引ltem这个类），继承就是一个类从另一个类继承通过关键字extends 来实现 问：构造方法中可不可以有return语句呢? （这个解释有问题？）可以。而是我们写成这个样子就OK了：return; 其实，在任何的void类型的方法的最后你都可以写上：return; 问：非构造方法的一般成员方法必须有return语句？ 错。 （待补充……） 问：类中的数据成员可以按需选择任意类型，包括类本身？ 可以。可以参考下图，图源于陈三千的博客 问：Java中构造函数的权限可以是private吗？ 可以，这个类就不能再外部被new了，如果需要这个类的实例化对象，就只能在类内部提供静态方法生产这个类的对象了。 问：构造方法能不能被重载，构造方法能不能被重写？ 在回答这两个问题之前，首先先回顾：什么是构造方法？构造方法的特点是什么？ 概述：构造方法存在于类中，给对象数据（属性）初始化； 特点：方法名与类名一样；无返回值无void; 默认构造方法：我们不创建一个构造方法时，系统默认提供一个无参构造；当我们创建一个构造方法时，系统不再提供无参构造，所以在实际项目中，全部手动给出无参构造 其次\\什么是重载？什么是重写？** 重载：存在于在一个类中，方法名相同，方法参数的类型或个数不同 重写：存在于子父类中，方法名、方法参数、返回值全部相同 所以：构造方法可以重载，不能重写 在一个类中，可以有多个构造方法（方法参数不同） ，即重载，来实现对象属性不同的初始化； 但是子类中不能定义一个方法无void无返回值的方法，编译错误，即子类无法继承构造方法，但是子类的构造器中可以调用父类的构造方法（默认自动调用无参构造） 注意：回答来源于 CSDN博客 Java中可以定义一个空类（即没有数据成员和成员方法） 。 问： 下面这个类有几个构造方法？ 1class A{} 1个。（待补充……） 问：Java 类可以作为（ C ） A．类型定义机制 B．数据封装机制 C．类型定义机制和数据封装机制 D．上述都不对 用于定义类头的修饰符可以是public、abstract、final或者是默认(friendly) 题目：下列说法错误的有（ CD ） A． 在类方法中可用this来调用本类的类方法B． 在类方法中调用本类的类方法时可直接调用 C． 在类方法中只能调用本类中的类方法 D． 在类方法中绝对不能调用实例方法 C：类方法可以调用外部其他类的方法。D：只要实力化对象，也是可以调用实例方法的。 判断： 只有基本类型的参数传递使用值传递。 错误。 引用类型参数的传递，依然是值传递。但因为是地址值，所以会指向同一个对象实例。 Java中方法的参数传递是值传递（pass by value），并且为单向传递。 《Java 变量参数传入方法，修改后是否影响外面的值》。参考 博客 《某个变量当作函数的参数传递后，函数内部修改了。到底这个变量是否受影响》。参考 博客 问：类设计get方法和set方法的作用是什么？ 答1：一般类的成员变量被设置为private（私有的），这样设置安全性比较高，但是设置为私有的后其他的类和对象则无法调用该对象了，所以会有get和set方法，这两个方法一般设置为public，在其他的类中通过对象调用set或get方法即可操作私有的变量，增强程序的安全性，set为给对象赋值的方法，而get则是取得变量值的方法！ 答2：get set常用在自定义类，类创建了一个实例对象后，用set设置对象的某一个属性，get得到对象某一属性。如果不使用get set，你就得用点，点出来还得是个方法。其实就是给get set换个名而已。而且get set作为内部方法，可以访问私有数据 答3：别说的那么专业化了，理解都要半天。就这么理解吧，面向对象中，想对类的成员变量设置访问一些权限，于是，就将该字段设置为private的，这样别的类就不能访问了，然后在该内定义两个方法，一个专门用于获取，一个用于修改，这样，在你不想让别人乱动该字段的时候，就在该方法内写一些限制条件。而为了规范起见（团队开发需要嘛），就根据人家老外的习惯，将方法名设置为set+字段名，get+字段名（名字乱改没问题），既然规范了，那就是别人都叫这名了，于是，有些框架给对象赋值就有方法了，方法名称由get或set开始的又有private变量名的，就找出来调用。hibernate1框架就这样弄得，至于后面的版本是不是这样就不大清楚了。JavaBean就是一个JAVA类，既然是JAVA类就不需要什么组件了，这玩意直接深入到虚拟机了的 Java的包装类： 【包装类的概念】 【Integer类的用法】 【自动装箱机制和自动拆箱机制】 匿名对象： 使用方法： 当对对象的方法只调用一次，可以使用匿名对象来完成，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。 可以将匿名对象作为实际参数进行传递。 注脚：1.实例变量（全局变量）、成员变量、实例变量、属性 ↩2.java的构造方法、java的构造方法、Java入门：构造方法 ↩3.来创建一个新的对象。创建对象需要以下三步： ↩3.java之new的用处 ↩4.JAVA中基本数据类型和引用数据类型区别 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java笔记—面向对象","slug":"Java笔记—面向对象","date":"2019-11-13T04:54:46.000Z","updated":"2019-11-29T17:35:40.535Z","comments":true,"path":"2019/11/13/Java笔记—面向对象/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/13/Java%E7%AC%94%E8%AE%B0%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"Java笔记——面向对象创建时间：2019.11.11 说明：持续更新ing Java作为一种面向对象语言。支持以下基本概念： 多态 | 继承 | 封装 | 抽象 类 | 对象 | 实例 | 方法 | 重载 “面向对象”和“面向过程”的区别： 面向过程：如 C/C++ 例子：冰箱装大象。1、打开冰箱门；2、放进大象；3、关上冰箱门。强调过程，“打开”、“存储”、“关闭”三个动作。注重过程，注重的是过程涉及的行为（即功能）。 面向对象：如 Java 将功能封装进对象，强调具备了功能的对象。 面向对象是基于面向过程的。","text":"Java笔记——面向对象创建时间：2019.11.11 说明：持续更新ing Java作为一种面向对象语言。支持以下基本概念： 多态 | 继承 | 封装 | 抽象 类 | 对象 | 实例 | 方法 | 重载 “面向对象”和“面向过程”的区别： 面向过程：如 C/C++ 例子：冰箱装大象。1、打开冰箱门；2、放进大象；3、关上冰箱门。强调过程，“打开”、“存储”、“关闭”三个动作。注重过程，注重的是过程涉及的行为（即功能）。 面向对象：如 Java 将功能封装进对象，强调具备了功能的对象。 面向对象是基于面向过程的。 使用不同思想，对“冰箱装大象”的理解——&gt; 问：“人开冰箱”事件，其中人、冰箱都是实物（对象），开是动作。若使用面向对象思维，“开”的这个动作是属于“人”还是属于“冰箱”？ 答：属于“冰箱”，“人”只是调用了“冰箱”的“开”的方法（或功能），用力作用了门一下并将门打开了。 1234567891011121314人开门：名词提炼法。/*人{ 开门（门）{ 门.开（）; }}门{ 开（）{ 操作门轴; ……等等; }}*/ 面向对象的三个特征：封装、继承、多态。 以后开发：其实就是找对象使用，没有对象就创建一个对象。 找对象，建立对象，使用对象，维护对象的关系。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java笔记—语法","slug":"Java笔记—语法","date":"2019-11-13T04:54:20.000Z","updated":"2019-11-29T17:36:18.031Z","comments":true,"path":"2019/11/13/Java笔记—语法/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/13/Java%E7%AC%94%E8%AE%B0%E2%80%94%E8%AF%AD%E6%B3%95/","excerpt":"Java笔记——语法创建时间：2019.11.11说明：持续更新ing 单引号’’中存放一个字符，不能存放字符串。双引号””中存放字符串。 Java是强类型语言。对于每一种数据都定义了明确的具体数据类型，在内存中总分配了不同的内存空间。 布尔型常量只有2个值：true、false 标识符由字母：26个，大小写；数字：0- 8；符号：$ _ 组成。 标识符不能数字开头、不能使用关键字 main不是关键字，但是是被JVM识别的名字，是程序的入口 Java中的名称规范： 包名：多单词组成，全为小写 xxxyyyy 类名接口： 多单词组成，所有单词的首字母大写 XxxYyyZzz 变量名和函数名：多单词组成时，第一个单词的首字母小写，其余首字母大写 xxxYyyZzz 常量名：所有字母都大写。每个单词用_隔开 XXX_YYY_ZZZ","text":"Java笔记——语法创建时间：2019.11.11说明：持续更新ing 单引号’’中存放一个字符，不能存放字符串。双引号””中存放字符串。 Java是强类型语言。对于每一种数据都定义了明确的具体数据类型，在内存中总分配了不同的内存空间。 布尔型常量只有2个值：true、false 标识符由字母：26个，大小写；数字：0- 8；符号：$ _ 组成。 标识符不能数字开头、不能使用关键字 main不是关键字，但是是被JVM识别的名字，是程序的入口 Java中的名称规范： 包名：多单词组成，全为小写 xxxyyyy 类名接口： 多单词组成，所有单词的首字母大写 XxxYyyZzz 变量名和函数名：多单词组成时，第一个单词的首字母小写，其余首字母大写 xxxYyyZzz 常量名：所有字母都大写。每个单词用_隔开 XXX_YYY_ZZZ //截断文章 注释，写在代码前面 对于整数：Java有三种表现形式。· 十进制：0-9，满10进1· 八进制：0-7，满8进1，用0开头表示· 十六进制：0-9，A-F或a-f（A\\a是10，B\\b是11…F\\f是15），满16进1，用0x开头表示 null常量：只有一个值null。在对象、引用数据类型时会用上。 二进制。一个字节8位0、1组合。 八进制：3位二进制位代表1位八进制位；十六进制：4位二进制位代表1位十六进制位。进制转换：进制越大，表示越短，更方便地表示数据。 二进制计算：5 + 4 = 9 负数地二进制表现形式：对应的整数二进制取反加1。负数的最高位都是1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"博客v1.4上线","slug":"博客v1.4","date":"2019-11-08T14:30:21.000Z","updated":"2019-11-29T17:39:13.419Z","comments":true,"path":"2019/11/08/博客v1.4/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/08/%E5%8D%9A%E5%AE%A2v1.4/","excerpt":"搞了半天时间，优化一些模板上的问题后，新博客1.4版本上线了","text":"搞了半天时间，优化一些模板上的问题后，新博客1.4版本上线了 //截断文章 新增 主页动画，点击体验效果（这里） 文字跳动（menu、head中的文字均可跳动）,比如顶部的“你用走，可是我用跑”…… 新增Valine评论（可以使用表情；发送前浏览）。想用别的，但是暂时先着Valine。可以试着来骚扰我（滑稽~~ 有评论，邮件提示(还未测试)。接入Leancloud（文档）。 底部开启鼠标滑动渲染 开启“一言”api。menu中作者名（Melody Jerry）下面随机显示一句话。同时，使用文字扭曲动画。 修复 1.重写三个按钮（menu、搜索、回到顶部）的代码，现在可以正常使用了。 更新menu的Github的url 修复移动端提示证书错误的问题（移动端重定向太多次了，难怪hhh） 主页和首页分仓（也不算是修复，不知道写哪而已） 已知问题（加粗的为重要问题） menu中的“分类”、“标签”、“关于”，仍然无法正常使用（原因未知） menu的Email仍旧无法mailto 文章增加标签或类名，无法被tags或categories绑定 浏览人数、浏览次数，无法使用（接口有问题？） 文字截断，异常。（原因位置） 等待发现 未来加入 音乐控件（自动？手动？浮窗？嵌入？音源线上还是本地？） 实时颜色 加载网页时、侧栏、搜索、进度条等动画 留言板？ 友情链接？快速导航？ 嵌入播放（这个很想要，链接一些学习视频） 天气控件 等待脑洞大开 最后从早上9点搞到下午4点，午饭还没吃hh，就一直坐在电脑前。找模板中的问题代码、修改代码，还是很麻烦的。最后分享一首今天网易日推的英文歌（版权原因，没法生成外联播放器）I’ll Be There-Jess Glynne对于我的博客有问题或建议，欢迎在评论或邮件中告诉我。谢谢每一位读者。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"多图片滚动测试","slug":"多图片滚动测试","date":"2019-11-07T23:10:13.000Z","updated":"2019-12-01T06:31:24.901Z","comments":true,"path":"2019/11/08/多图片滚动测试/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/08/%E5%A4%9A%E5%9B%BE%E7%89%87%E6%BB%9A%E5%8A%A8%E6%B5%8B%E8%AF%95/","excerpt":"","text":"无缝滚动 *{margin: 0;padding: 0;} #div1{position: relative;border:1px solid #0ff;width:800px; height: 180px;margin:50px auto 0;overflow: hidden;} /* 修改容器规模 */ #div1 ul{position: absolute;left: 0;} #div1 ul li{list-style: none;width:200px;float: left;padding: 10px;height: 160px;} #div1 ul li img{width:100%;} window.onload=function(){ var oDiv=document.getElementById('div1'); var oUl=oDiv.getElementsByTagName('ul')[0]; var aLi=oUl.getElementsByTagName('li'); var aA=document.getElementsByTagName('a');//获取向右向左的箭头 var timer=null; var iSpeed=10; oUl.innerHTML+=oUl.innerHTML;//定义图片可以循环播放 oUl.style.width=aLi.length*aLi[0].offsetWidth+'px';//定义外层ul的宽度，根据图片的个数和每个图片的宽度计算，保证总宽度是可调整的 function fnMove(){ if(oUl.offsetLeft0){ oUl.style.left=-oUl.offsetWidth/2+'px'; }//定义到边界的时候，实现无缝衔接 oUl.style.left=oUl.offsetLeft+iSpeed+'px'; //定义图片的右边距随着速度不断不断增加，或减小，实现运动的效果 } timer=setInterval(fnMove,30); aA[0].onclick=function(){ iSpeed=-10; //按下左箭头，定义向左运动 } aA[1].onclick=function(){ iSpeed=10; //按下右箭头，定义向右运动 } oDiv.onmouseover=function(){ clearInterval(timer); //鼠标移动到图片上，清除定时器，停止运动 } oDiv.onmouseout=function(){ timer=setInterval(fnMove,30); //鼠标移出，重新开启定时器，重新运动 } }; ←→！！！方向选择按钮异常！！！L2Dwidget.init({\"model\":{\"jsonPath\":\"/blog/live2dw/assets/assets/haruto.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"tagMode\":false,\"debug\":false,\"mobile\":{\"show\":true},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\"}); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"网页视频测试","slug":"网页视频测试","date":"2019-11-07T16:00:00.000Z","updated":"2020-02-20T09:46:04.960Z","comments":true,"path":"2019/11/08/网页视频测试/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/08/%E7%BD%91%E9%A1%B5%E8%A7%86%E9%A2%91%E6%B5%8B%E8%AF%95/","excerpt":"浏览测试效果👇","text":"浏览测试效果👇 video大窗口 video小窗口 embed窗口 iframe窗口 测试完毕 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"使用Hexo+GitHub建站","slug":"Hexo+GitHub","date":"2019-11-07T11:24:01.000Z","updated":"2019-12-06T15:32:21.356Z","comments":true,"path":"2019/11/07/Hexo+GitHub/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/07/Hexo+GitHub/","excerpt":"前言： 使用CSDN平台撰写博客似乎是一件美事，只不过个人觉得太过于依赖他人平台，不如就自己搭建一个属于自己的博客。","text":"前言： 使用CSDN平台撰写博客似乎是一件美事，只不过个人觉得太过于依赖他人平台，不如就自己搭建一个属于自己的博客。 安装篇 一、安装 【hexo】 前的准备安装hexo前的必要工作1).安装以下两个程序： 程序 下载地址 说明 Git Git - Downloads 网速的同学，可以自行百度移步到国内镜像 Node.js Node.js - Downloads 有LTS和Current两个版本，安装 LTS 版即可 注意：关于Git和Node.js的安装可能会有问题，尤其是Git的安装。这里贴上几张安装界面的截图（来源见水印，作者GroovRain）。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 2).配置（可以在未来部署，并非一定现在） 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 $ git config --global user.name \"your name\"` $ git config --global user.email \"your Email\"二、正式安装【hexo】 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。——官方 准备工作完成后，来安装hexo框架吧！ == 主要根据hexo官方的文档来安装hexo == ==使用 npm 安装 Hexo== $ npm install -g hexo-cli 这样,【hexo】就安装完成了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"}]},{"title":"博客文章太长？截断！","slug":"文章截断","date":"2019-11-06T08:49:56.000Z","updated":"2020-01-04T01:51:09.574Z","comments":true,"path":"2019/11/06/文章截断/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/06/%E6%96%87%E7%AB%A0%E6%88%AA%E6%96%AD/","excerpt":"写的md文章太长，担心放到首页上浏览效果不好，怎么办？ 那就直接截断文章。 截断按钮文字不是通过配置文件_config.yml实现的，而是在文章内容里实现。 只要在需要被截断的文章位置加上： 1&lt;!-- more --&gt; 就可以了！ 效果就像下面的这个按钮 可以点点看哦👇","text":"写的md文章太长，担心放到首页上浏览效果不好，怎么办？ 那就直接截断文章。 截断按钮文字不是通过配置文件_config.yml实现的，而是在文章内容里实现。 只要在需要被截断的文章位置加上： 1&lt;!-- more --&gt; 就可以了！ 效果就像下面的这个按钮 可以点点看哦👇 插入测试代码 （无任何作用、意义，仅提供该页面测试用） 12345678910111213141516171819202122232425262728293031javascript:window.onblur=null;void 0;//allvar open_all_chapter = document.getElementsByClassName(\"fold_chapter\");for (var i = 1; i &lt; open_all_chapter.length; i++) {open_all_chapter[i].click()}//eachvar chapters = document.getElementsByClassName(\"rate_box\");var count = 0;chapters[++count].click();setInterval(() =&gt; {// var playButton = document.getElementById(\"div_play_wrapper\");// if (playButton) {// playButton.click();// }var TC = document.getElementsByClassName(\"layui-layer-close1\");if (TC.length &gt; 0) {console.log(\"检测到弹窗\");TC[0].click();}console.log(\"正在\" + count + \"个\");var isFinish = chapters[count].getElementsByClassName(\"round_complete\");if (isFinish.length &gt; 0) {chapters[++count].click()console.log(\"进入下\");if(chapters[count].className===\"rate_box\"){chapters[++count].click()}}}, 5000); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]}]}