{"meta":{"title":"MelodyHub","subtitle":"你用走 可是我用跑","description":"","author":"Melody Jerry","url":"https://melodyjerry.github.io/blog","root":"/blog/"},"pages":[{"title":"404 Not Found","date":"2020-02-13T05:06:58.070Z","updated":"2020-02-13T05:06:58.070Z","comments":true,"path":"404.html","permalink":"https://melodyjerry.github.io/blog/404.html","excerpt":"","text":"404 Not Found 您访问的页面，呃，鬼知道跑哪去了(´･ω･`) 可能是因为： 你的节操掉光啦~~~ 手残⑨级输错了地址~~~ 或该地址已被删除~~~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"分类","date":"2020-02-01T09:53:46.111Z","updated":"2020-02-01T09:53:46.111Z","comments":true,"path":"categories/index.html","permalink":"https://melodyjerry.github.io/blog/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"关于","date":"2020-02-03T11:09:01.460Z","updated":"2020-02-03T11:09:01.460Z","comments":true,"path":"about/index.html","permalink":"https://melodyjerry.github.io/blog/about/index.html","excerpt":"","text":"关……于……？ 关于啥呢？ 关于我这个小渣渣？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-02-01T09:54:48.381Z","updated":"2020-02-01T09:54:48.381Z","comments":true,"path":"mylist/index.html","permalink":"https://melodyjerry.github.io/blog/mylist/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"我的朋友们","date":"2020-02-07T16:31:06.579Z","updated":"2020-02-07T16:31:06.579Z","comments":true,"path":"friends/index.html","permalink":"https://melodyjerry.github.io/blog/friends/index.html","excerpt":"","text":"工具箱 MCTool.cn在线工具 http://tool.liumingye.cn/ 兔二工具 http://www.tool2.cn/ 精准云工具 https://jingzhunyun.com/ 图床 SM.MS https://sm.ms/ 图片压缩 压缩图 https://www.yasuotu.com/ 建站 站长素材 http://sc.chinaz.com/ 游戏 2048-Game（作者：Tomotoes） https://tomotoes.com/2048/ 小霸王游戏免费玩 https://www.yikm.net/ 简历 xaoxuu制作 https://mxclub.github.io/resume/ Simon Ma制作 - document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"项目","date":"2020-02-03T11:07:02.044Z","updated":"2020-02-03T11:07:02.044Z","comments":true,"path":"projects/index.html","permalink":"https://melodyjerry.github.io/blog/projects/index.html","excerpt":"","text":"一枚 小渣渣 ，目前啥都没有~~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"标签","date":"2020-02-01T09:54:04.836Z","updated":"2020-02-01T09:54:04.836Z","comments":true,"path":"tags/index.html","permalink":"https://melodyjerry.github.io/blog/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"绚丽彩虹同学录V1.4公测版","slug":"绚丽彩虹同学录V1-4公测版","date":"2020-02-13T06:34:01.000Z","updated":"2020-02-13T06:35:47.487Z","comments":true,"path":"2020/02/13/绚丽彩虹同学录V1-4公测版/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/13/%E7%BB%9A%E4%B8%BD%E5%BD%A9%E8%99%B9%E5%90%8C%E5%AD%A6%E5%BD%95V1-4%E5%85%AC%E6%B5%8B%E7%89%88/","excerpt":"","text":"部分截图 版本更新 自动更新(推荐): 管理员登陆后，进入控制台，点击检查更新，如有新版本点击“一键更新”等待更新完成即可。 手动更新流程: 更新包地址: http://cdn.badapple.top/PHP/XlchClassbook/UpdatePack下载对应版本的更新包,手动解压覆盖更新包到同学录安装目录。 更新日志☆ 1.4 公测版 (1004) 更新内容： 重要提示：更新完毕后请到 管理员控制台-&gt;站点配置-&gt;保存，以刷新数据！ 修复:手机上传图片打开相机 修复:“对我留言”功能 修复:无法删除相册 修复:允许空名相册 修复:权限组配置错误导致的安全漏洞 修复:验证码大小写问题 增加:可选绚丽彩虹播放器 增加:自定义导航栏功能 增加:教师、班长等权限组 增加:畅言图床、sm.ms、七牛云存储上传 增加:评论回复支持表情 增加:导入似水年华V3数据 优化:图片流设计 优化:同学录页面卡片设计 优化:管理员可设置用户是否允许上传相册 优化:安装时自动修复数据表结构 优化:配置文件结构变更 优化:做了一点微小的工作(细节优化) 更新时间：2018-07-03 23:39:54 ☆ 1.3 公测版 (1003) 更新内容： 修复:后台修改用户组 提示“用户名已被使用” 修复:“对TA留言”功能 修复:验证码大小写问题 修复:代码逻辑错误导致的安全隐患 修复:代码逻辑错误导致的无法在后台更新到新版本 更新时间：2018-04-22 21:20:20 文章附件蓝奏网盘 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"动态时钟","slug":"动态时钟","date":"2020-02-13T05:28:19.000Z","updated":"2020-02-13T05:51:42.682Z","comments":true,"path":"2020/02/13/动态时钟/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/13/%E5%8A%A8%E6%80%81%E6%97%B6%E9%92%9F/","excerpt":"效果：","text":"效果： 在相应位置添加如下代码： 1234&lt;center&gt;&lt;div&gt;&lt;canvas id=\"canvas\" style=\"width:20%\" width=\"820\" height=\"250\"&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script async=\"\"&gt;!function(){function t(t){var r=[];a.fillStyle=\"#1bc3fb\";var h=new Date,u=70,s=30,v=h.getHours(),g=Math.floor(v/10),m=v%10;r.push({num:g}),r.push({num:m}),r.push({num:10});var c=h.getMinutes(),g=Math.floor(c/10),m=c%10;r.push({num:g}),r.push({num:m}),r.push({num:10});var M=h.getSeconds(),g=Math.floor(M/10),m=M%10;r.push({num:g}),r.push({num:m});for(var p=0;p&lt;r.length;p++)r[p].offsetX=u,u=f(u,s,r[p].num,t),p&lt;r.length-1&amp;&amp;10!=r[p].num&amp;&amp;10!=r[p+1].num&amp;&amp;(u+=l);if(0==i.length)i=r;else for(var C=0;C&lt;i.length;C++)i[C].num!=r[C].num&amp;&amp;(n(r[C]),i[C].num=r[C].num);return e(t),o(),h}function n(t){for(var n=t.num,e=m[n],o=0;o&lt;e.length;o++)for(var f=0;f&lt;e[o].length;f++)if(1==e[o][f]){var a={offsetX:t.offsetX+u+2*u*f,offsetY:30+u+2*u*o,color:g[Math.floor(Math.random()*g.length)],g:1.5+Math.random(),vx:4*Math.pow(-1,Math.ceil(10*Math.random()))+Math.random(),vy:-5};v.push(a)}}function e(t){for(var n=0;n&lt;v.length;n++)t.beginPath(),t.fillStyle=v[n].color,t.arc(v[n].offsetX,v[n].offsetY,u,0,2*Math.PI),t.fill()}function o(){for(var t=0,n=0;n&lt;v.length;n++){var e=v[n];e.offsetX+=e.vx,e.offsetY+=e.vy,e.vy+=e.g,e.offsetY&gt;h-u&amp;&amp;(e.offsetY=h-u,e.vy=-e.vy*s),e.offsetX&gt;u&amp;&amp;e.offsetX&lt;r-u&amp;&amp;(v[t]=v[n],t++)}for(;t&lt;v.length;t++)v.pop()}function f(t,n,e,o){for(var f=m[e],a=0;a&lt;f.length;a++)for(var r=0;r&lt;f[a].length;r++)1==f[a][r]&amp;&amp;(o.beginPath(),o.arc(t+u+2*u*r,n+u+2*u*a,u,0,2*Math.PI),o.fill());return o.beginPath(),t+=f[0].length*u*2}var a,r=820,h=250,u=7,l=10,s=.65,v=[];const g=[\"#33B5E5\",\"#0099CC\",\"#AA66CC\",\"#9933CC\",\"#99CC00\",\"#669900\",\"#FFBB33\",\"#FF8800\",\"#FF4444\",\"#CC0000\"];var i=[],m=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]],c=document.getElementById(\"canvas\");c.width=r,c.height=h,a=c.getContext(\"2d\");new Date;setInterval(function(){a.clearRect(0,0,a.canvas.width,a.canvas.height),t(a)},50)}()&lt;/script&gt;&lt;/center&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"任正非:唯一有愧的是对不起父母","slug":"任正非-唯一有愧的是对不起父母","date":"2020-02-11T05:58:08.000Z","updated":"2020-02-13T05:16:48.084Z","comments":true,"path":"2020/02/11/任正非-唯一有愧的是对不起父母/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/11/%E4%BB%BB%E6%AD%A3%E9%9D%9E-%E5%94%AF%E4%B8%80%E6%9C%89%E6%84%A7%E7%9A%84%E6%98%AF%E5%AF%B9%E4%B8%8D%E8%B5%B7%E7%88%B6%E6%AF%8D/","excerpt":"前言​ 前几天，弟在做高考语文预测卷时，突然跟我说“老哥，你去看看任正非的文章《我的父亲母亲》，很有深意”。在看完文章后还有一篇作者是柳传志的读后感。对这两篇文章深有感触，所以专门开设并记录在博文里。","text":"前言​ 前几天，弟在做高考语文预测卷时，突然跟我说“老哥，你去看看任正非的文章《我的父亲母亲》，很有深意”。在看完文章后还有一篇作者是柳传志的读后感。对这两篇文章深有感触，所以专门开设并记录在博文里。 《我的父亲母亲》—— 任正非 《我的父亲母亲》 任正非 【一】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;上世纪末最后一天，我总算良心发现，在公务结束之后，买了一张从北京去昆明的机票，去看看妈妈。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;买好机票后，我没有给她打电话，我知道一打电话她一下午都会忙碌，不管多晚到达，都会给我做一些我小时候喜欢吃的东西。直到飞机起飞，我才告诉她，让她不要告诉别人，不要车来接，我自己坐出租车回家，目的就是好好陪陪她。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;前几年我每年也去看看妈妈，但一下飞机就给办事处接走了，说这个客户很重要，要拜见一下，那个客户很重要，要陪他们吃顿饭，忙来忙去，忙到上飞机时回家取行李，与父母匆匆告别。妈妈盼星星、盼月亮，盼唠唠家常，却一次又一次地落空。 【二】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;一个普通的早上，妈妈从菜市场出来，提着两小包菜，被汽车撞成重伤。我身在伊朗，飞机要多次中转才能回来，在巴林转机要待6.5个小时，真是心如煎熬，又遇巴林雷雨，飞机延误两个小时，到曼谷时又晚了10分钟，没有及时赶上回昆明的飞机，直到深夜才赶到昆明。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;回到昆明，就知道妈妈不行了，她的头部全部给撞坏了，当时的心跳、呼吸全是靠药物和机器维持，之所以在电话上不告诉我，是怕我在旅途中出事。我看见妈妈一声不响地安详地躺在病床上，不用操劳、烦心，好像她一生也没有这么休息过。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我真后悔没有在伊朗给妈妈打一个电话。因为以前不管我在国内、国外给她打电话时，她都唠叨：“你又出差了”，“非非你的身体还不如我好呢”，“非非你的皱纹比妈妈还多呢”，“非非你走路还不如我呢，你这么年纪轻轻就这么多病”，“非非，糖尿病参加宴会多了，坏得更快呢，你的心脏又不好”…… &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我想伊朗条件这么差，我一打电话，妈妈又唠叨，反正过不了几天就见面了，就没有打，而这是我一生中最大的憾事。如果我真打了，拖延她一两分钟出门，也许妈妈就躲过了这场灾难。这种悔恨的心情，真是难以形容。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我看了妈妈最后一眼，妈妈溘然去世。 【三】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1995年，我父亲在昆明街头的小摊上买了一瓶塑料包装的软饮料，喝后拉肚子，一直到全身衰竭去世。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;父亲任摩逊，尽职尽责一生，可以说是一个乡村教育家。妈妈程远昭，是一个陪伴父亲在贫困山区与穷孩子厮混了一生的一个普通得不能再普通的园丁。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;父亲穿着土改工作队的棉衣，随解放军剿匪部队一同进入贵州少数民族山区去筹建一所民族中学。一头扎进去就是几十年，他培养的学生不少成为党和国家的高级干部，有些还是中央院校的校级领导，而父亲还是那么位卑言微。 【四】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我与父母相处的青少年时代，印象最深的就是度过三年自然灾害的困难时期。今天想来还历历在目。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我们兄妹七个，加上父母共九人。全靠父母微薄的工资来生活，毫无其他来源。本来生活就十分困难，儿女一天天在长大，衣服一天天在变短，而且都要读书，开支很大，每个学期每人要交2-3元的学费，到交费时，妈妈每次都发愁。我经常看到妈妈月底就到处向人借钱度饥荒，而且常常走了几家都未必借到。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;直到高中毕业我没有穿过衬衣。有同学看到很热的天，我还穿着厚厚的外衣，就让我向妈妈要一件衬衣，我不敢，因为我知道做不到。我上大学时妈妈一次送我两件衬衣，我真想哭，因为，我有衬衣了，弟妹们就会更难了。我家当时是2-3人合用一条被盖，而且破旧的被单下面铺的是稻草。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;上大学我要拿走一条被子，就更困难了，因为那时还实行布票、棉花票管制，最少的一年，每人只发0.5米布票。没有被单，妈妈捡了毕业学生丢弃的几床破被单缝缝补补，洗干净，这条被单就在重庆陪我度过了五年的大学生活。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我们家当时每餐实行严格分饭制，控制所有人欲望的配给制，保证人人都能活下来。如果不是这样，总会有一个、两个弟妹活不到今天。我真正能理解活下去这句话的含义。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;高三快高考时，我有时在家复习功课，实在饿得受不了了，用米糠和菜合一下，烙着吃，被父亲碰上几次，他心疼了。其实那时我家穷得连一个可上锁的柜子都没有，粮食是用瓦缸装着，我也不敢去随便抓一把。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;高考前三个月，妈妈经常在早上塞给我一个小小的玉米饼，要我安心复习功课，我能考上大学，小玉米饼功劳巨大。如果不是这样，也许我就进不了华为这样的公司，社会上多了一名养猪能手，或街边多了一名能工巧匠而已。这个小小的玉米饼，是从父母与弟妹的口中抠出来的，我无以报答他们。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;“记住知识就是力量，别人不学，你要学，不要随大流。”“以后有能力要帮助弟妹。”背负着这种重托，我在当时的环境下，将樊映川的高等数学习题集从头到尾做了两遍，学习了逻辑、哲学。还自学了三门外语，当时已到可以阅读大学课本的程度，终因我不是语言天才，加之在军队服务时用不上，20多年荒废，完全忘光了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我当年穿走父亲的皮鞋，没念及父亲那时是做苦工的，泥里水里，冰冷潮湿，他更需要鞋子。现在回忆起来，感觉自己太自私了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;回顾我自己已走过的历史，唯一有愧的是对不起父母，没条件时没有照顾他们，有条件时也没有照顾他们。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;爸爸，妈妈，千声万声呼唤你们，千声万声唤不回。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;逝者已经逝去，活着的还要前行。 ​ ——2001年2月8日 于深圳 《要想富就要知道为何穷》——柳传志 《要想富就要知道为何穷》 柳传志 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;在手机上读着一篇任正非写的怀念他的父母亲的文章，而脑子里却想起了另一件事。那是2013年9月，我接到了一个邀请函。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;那天我是真的有事，但出于对老任发自内心的敬佩和尊重，我尽力挤开了别的事情，花了一个半小时的车程赶到了会场。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;老任的面子确实大，那天是贵州都匀一中的“校训研讨会”，真请来了不少领导和知名的企业家。他看见我来了显得非常高兴。我也高兴，那是因为在企业工作者里面，我们都是属于少有的“老家伙”序列里的人，相互都比较了解，然而又极少见面，所以紧紧的握手不愿松开。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;原来都匀一中就是任正非的母校，他的父亲在此曾任过三年校长，他毕生从事教育工作，50多年来倾注了全部的心血。在现任学校领导介绍学校的历史，介绍老任的父亲任摩逊先生事迹的时候，我注意盯着任正非，我想这样的内容他应该听过无数遍了，他却依然听得那么专注，那么动情! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;此刻我正在读他写的怀念他的父母的文章，我认真读这篇文章，是因为深深引起了我的共鸣。我和他是同年生人，我们的出生背景有所不同，但是上一辈在政治上受到的磨难和考验几乎是相同的。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;任正非谈到他的父亲在这考验的重压之下，依旧勤勤恳恳拼力地工作，为他自己后来在华为拼命地工作做出了表率，而父辈的榜样在他身上打下了深深的烙印。我的父亲也是我的榜样。给我最深刻的印象是在强大的政治压力下，他能够像以前教导我的那样，用行动做出表率-做一个正直的人。正直，这是一个多么平常的词藻，然而在特殊的考验面前，这个词就超过了千钧的分量。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1966年文化革命爆发的第一个年头，我亲眼看到我的父亲在威逼面前不肯诬陷当年的战友，被开除党籍。当时的气氛紧张惊恐。这深深地印在了我的脑海中，而我的父亲以身教的方式告诉了我如何做人，什么叫正直! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;联想发展到今天的三十年中，经过的风险无其数，尤其在早期还有一定的政策风险，我自诩是个敢担当的人，而在联想结出胜利果实时，我也以为自己是个舍得让利的人，这对联想能发展到今天也许有一定的影响。和任正非一样，我们能以身作则地把企业利益放在个人利益的前面。追根溯源，是我们的父辈给我们打下了如何做人的基础。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当我读到任正非的母亲是因为意外车祸辞世的，我的心一下子揪了起来。我能想象对他那是一种什么样的撕心裂肺! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;任正非讲到他在高三那年(也应该是我高三的那年吧，就是最困难的1961年)，母亲经常早上塞给他一个小小的玉米饼，他说我能考上大学，小玉米饼的功劳巨大，这个小小的玉米饼是从父母与弟妹的口中抠出来的，我无以报答他们。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我相信绝大多数的80后、90后的朋友是读不出玉米饼的感觉的，因为他们不懂什么叫饥饿。61年，我是北京25中的一名高三学生，我们中学生是早上8、9点钟的太阳，所以享受着最高待遇，一个月32斤粮，半斤油，半斤肉。知道什么叫一个月半斤油吗? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;那是在一锅熬白菜煮熟的时候，油瓶口顺着筷子点入几滴油，使锅里漂着油花，一个月下来，这半斤油就用完了。知道什么叫饿吗?那就是耗干净你身上的脂肪，然后再耗你的肌肉。有一天夜里，我饿的实在受不了，想起抽屉里有一盒中药是羚翘解毒丸，我就吃了两颗，几小时后药性发作，抽筋断肠，头痛欲裂。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;经过饥饿的人才知道什么叫从父母弟妹的嘴里面抠出的玉米饼。任正非想念着母亲，我何尝不想念自己的母亲、不想起在那最艰难的岁月里，母亲对我的慈爱。我的父母都已经去世了，我和老任一样也是老大，我会永远记住父母的恩德慈爱。我有兄弟姐妹四人，我们会永远相亲相爱。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我在想，读了老任的文章，是什么让我会拿起笔说了上边这段话，我想说给谁听呢? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;说给老任?让他知道我是他的知音?说给我的亲人、朋友、同学、同事?让我们更加珍惜今天的生活? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;好像是，但也不是。我明白，我最想说给那些年青、年少的，甚至是儿童，让他们长大了听。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我一直告诫自己不要成为一个碎嘴唠叨的老头。而说这些话，我估计孩子们是不爱听的。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;前些天，我看了一部叫“归来”的电影，写的是我亲眼看见过的年代，亲眼看见过的事情，电影演毕，潸然泪下。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;问过几个年青人是否看过这部片子，都说没有。有一个对我说：人总是要向前看么，老说那些老话，凄凄惨惨有什么意思?!他们爱看光鲜亮丽、富有、任性的电影，那是他们的追求。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;他们不爱看“归来”，不爱听我碎嘴唠叨，但我还是忍不住想对他们说，到底为了什么? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;因为我们这个民族就在不久以前还很苦，很凄惨，很窝囊。你要想今后过得富有光鲜亮丽，你就要知道过去为什么穷，为什么苦，为什么受人欺负。你就要懂得历史，你就要从中学到教训，我们已经是为数不多的见过那段历史的尾巴的人了，尽量还原真实的历史是我们的责任。不管你是哪国国籍，但你和你的子孙血管中流的是中国人的血，这是无法改变的事实! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我谈不上是高尚的人，更谈不上是纯粹的人。但我努力在做一个知恩图报的人，做一个懂廉耻、要自强的人。我希望几十年以后，今天年青、年少的人们能凭追求、凭团结、凭实力让中国富强，让自己过上光鲜亮丽富有的生活。 重要文献[1] 题目《任正非：唯一有愧的是对不起父母》，摘自百家号“金融界”， https://baijiahao.baidu.com/s?id=1644249222074823165&amp;wfr=spider&amp;for=pc [2] 原文，转自凤凰网，http://news.ifeng.com/c/7nKjN9F2Uy0 [3] 插图，来自网络 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"文章","slug":"文章","permalink":"https://melodyjerry.github.io/blog/tags/%E6%96%87%E7%AB%A0/"}]},{"title":"解决bash: hexo: command not found","slug":"解决bash-hexo-command-not-found","date":"2020-02-10T13:28:02.000Z","updated":"2020-02-11T10:56:14.938Z","comments":true,"path":"2020/02/10/解决bash-hexo-command-not-found/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/10/%E8%A7%A3%E5%86%B3bash-hexo-command-not-found/","excerpt":"记录一次离奇的车祸现场。 问题今天用hexo新建文章hexo new时git报错： 1bash: hexo: command not found 解决办法将G:\\blog_gitee\\node_modules\\.bin添加进PATH。 原因可能是因为我今天更新npm了？","text":"记录一次离奇的车祸现场。 问题今天用hexo新建文章hexo new时git报错： 1bash: hexo: command not found 解决办法将G:\\blog_gitee\\node_modules\\.bin添加进PATH。 原因可能是因为我今天更新npm了？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"[转]CentOS 7镜像下载","slug":"转-CentOS-7镜像下载","date":"2020-02-10T13:26:37.000Z","updated":"2020-02-11T10:56:14.946Z","comments":true,"path":"2020/02/10/转-CentOS-7镜像下载/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/10/%E8%BD%AC-CentOS-7%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD/","excerpt":"官网下载链接：http://isoredirect.centos.org/centos/7/isos/x86_64/ step1: 进入下载页，选择阿里云站点进行下载 Actual Country 国内资源 Nearby Countries 周边国家资源 阿里云站点：http://mirrors.aliyun.com/centos/7/isos/x86_64/ 每个链接都包括了镜像文件的地址、类型及版本号等信息 选择当前国家资源区站点下载，获取资源速度比较快 step1: 进入阿里云站点，选择 CentOS-7-x86_64-DVD-1804.iso下载 各个版本的ISO镜像文件说明： CentOS-7-x86_64-DVD-1708.iso 标准安装版（推荐） CentOS-7-x86_64-Everything-1708.iso 完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像） CentOS-7-x86_64-LiveGNOME-1708.iso GNOME桌面版 CentOS-7-x86_64-LiveKDE-1708.iso KDE桌面版 CentOS-7-x86_64-Minimal-1708.iso 精简版，自带的软件最少 CentOS-7-x86_64-NetInstall-1708.iso 网络安装版（从网络安装或者救援系统） 作者：Ada54链接：https://www.jianshu.com/p/a63f47e096e8来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","text":"官网下载链接：http://isoredirect.centos.org/centos/7/isos/x86_64/ step1: 进入下载页，选择阿里云站点进行下载 Actual Country 国内资源 Nearby Countries 周边国家资源 阿里云站点：http://mirrors.aliyun.com/centos/7/isos/x86_64/ 每个链接都包括了镜像文件的地址、类型及版本号等信息 选择当前国家资源区站点下载，获取资源速度比较快 step1: 进入阿里云站点，选择 CentOS-7-x86_64-DVD-1804.iso下载 各个版本的ISO镜像文件说明： CentOS-7-x86_64-DVD-1708.iso 标准安装版（推荐） CentOS-7-x86_64-Everything-1708.iso 完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像） CentOS-7-x86_64-LiveGNOME-1708.iso GNOME桌面版 CentOS-7-x86_64-LiveKDE-1708.iso KDE桌面版 CentOS-7-x86_64-Minimal-1708.iso 精简版，自带的软件最少 CentOS-7-x86_64-NetInstall-1708.iso 网络安装版（从网络安装或者救援系统） 作者：Ada54链接：https://www.jianshu.com/p/a63f47e096e8来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"镜像","slug":"镜像","permalink":"https://melodyjerry.github.io/blog/tags/%E9%95%9C%E5%83%8F/"}]},{"title":"MySQL的数据类型？","slug":"MySQL的数据类型","date":"2020-02-09T12:42:25.000Z","updated":"2020-02-11T10:56:14.886Z","comments":true,"path":"2020/02/09/MySQL的数据类型/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"MySQL的数据类型数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。 如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。 MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持所有标准SQL数值数据类型。 MySQL支持多种类型，大致可以分为三类： 数值 日期/时间 字符(串)类型。 数据类型分类 数值类型（整数类型和小数类型） 整数类型：包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT。 小数类型： 浮点数类型包括 FLOAT 和 DOUBLE。 定点数类型为 DECIMAL。 日期/时间类型 包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。 字符类型（文本字符串和二进制字符串） 字符串类型：包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。 二进制类型：包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。","text":"MySQL的数据类型数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。 如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。 MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持所有标准SQL数值数据类型。 MySQL支持多种类型，大致可以分为三类： 数值 日期/时间 字符(串)类型。 数据类型分类 数值类型（整数类型和小数类型） 整数类型：包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT。 小数类型： 浮点数类型包括 FLOAT 和 DOUBLE。 定点数类型为 DECIMAL。 日期/时间类型 包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。 字符类型（文本字符串和二进制字符串） 字符串类型：包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。 二进制类型：包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 数值类型MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 整数类型 整数类型又称数值型数据，数值型数据类型主要用来存储数字。 MySQL提供了多种数值型数据类型，不同的数据类型提供不同的取值范围，可以存储的值范围越大，所需的存储空间也会越大。 MySQL 主要提供的整数类型有 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，其属性字段可以添加 AUTO_INCREMENT 自增约束条件。下表中列出了 MySQL 中的数值类型。 类型名称 说明 存储需求 TINYINT 很小的整数 1个字节 SMALLINT 小的整数 2个宇节 MEDIUMINT 中等大小的整数 3个字节 INT (INTEGHR) 普通大小的整数 4个字节 BIGINT 大整数 8个字节 从上表中可以看到，不同类型的整数存储所需的字节数不相同，占用字节数最小的是 TINYINT 类型，占用字节最大的是 BIGINT 类型，占用的字节越多的类型所能表示的数值范围越大。 根据占用字节数可以求出每一种数据类型的取值范围。例如，TINYINT 需要 1 个字节（8bit）来存储，那么 TINYINT 无符号数的最大值为 28-1，即 255；TINYINT 有符号数的最大值为 27-1，即 127。其他类型的整数的取值范围计算方法相同，如下表所示。 类型名称 说明 存储需求 TINYINT -128〜127 0 〜255 SMALLINT -32768〜32767 0〜65535 MEDIUMINT -8388608〜8388607 0〜16777215 INT (INTEGER) -2147483648〜2147483647 0〜4294967295 BIGINT -9223372036854775808〜9223372036854775807 0〜18446744073709551615 提示：显示宽度和数据类型的取值范围是无关的。显示宽度只是指明 MySQL 最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充。如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，year 字段插入 19999，当使用 SELECT 查询该列值的时候，MySQL 显示的将是完整的带有 5 位数字的 19999，而不是 4 位数字的值。 其他整型数据类型也可以在定义表结构时指定所需的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。 不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。 小数类型MySQL 中使用浮点数和定点数来表示小数。 浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL。 浮点类型和定点类型都可以用(M, D)来表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。 浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2），分别表示显示宽度和小数位数。M 和 D 在 FLOAT 和DOUBLE 中是可选的，FLOAT 和 DOUBLE 类型将被保存为硬件所支持的最大精度。DECIMAL 的默认 D 值为 0、M 值为 10。 下表中列出了 MySQL 中的小数类型和存储需求。 类型名称 说明 存储需求 FLOAT 单精度浮点数 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 DECIMAL 类型不同于 FLOAT 和 DOUBLE。DOUBLE 实际上是以字符串的形式存放的，DECIMAL 可能的最大取值范围与 DOUBLE 相同，但是有效的取值范围由 M 和 D 决定。如果改变 M 而固定 D，则取值范围将随 M 的变大而变大。 从上表中可以看到，DECIMAL 的存储空间并不是固定的，而由精度值 M 决定，占用 M+2 个字节。 FLOAT 类型的取值范围如下： 有符号的取值范围：-3.402823466E+38～-1.175494351E-38。 无符号的取值范围：0 和 -1.175494351E-38～-3.402823466E+38。 DOUBLE 类型的取值范围如下： 有符号的取值范围：-1.7976931348623157E+308～-2.2250738585072014E-308。 无符号的取值范围：0 和 -2.2250738585072014E-308～-1.7976931348623157E+308。 提示：不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。 FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。 浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。 最后再强调一下：在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。 日期/时间类型MySQL 中有多处表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。 每个时间类型有一个有效值范围和一个”零”值。当指定不合法的MySQL不能表示的值时，系统将“零”值插入数据库中。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP YYYY-MM-DD HH:MM:SS 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 4 个字节 YEAR 类型YEAR 类型是一个单字节类型，用于表示年，在存储时只需要 1 个字节。可以使用各种格式指定 YEAR，如下所示： 以 4 位字符串或者 4 位数字格式表示的 YEAR，范围为 ‘1901’～’2155’。输入格式为 ‘YYYY’ 或者 YYYY，例如，输入 ‘2010’ 或 2010，插入数据库的值均为 2010。 以 2 位字符串格式表示的 YEAR，范围为 ‘00’ 到 ‘99’。’00’～’69’ 和 ‘70’～’99’ 范围的值分别被转换为 2000～2069 和 1970～1999 范围的 YEAR 值。’0’ 与 ‘00’ 的作用相同。插入超过取值范围的值将被转换为 2000。 以 2 位数字表示的 YEAR，范围为 1～99。1～99 和 70～99 范围的值分别被转换为 2001～2069 和 1970～1999 范围的 YEAR 值。注意，在这里 0 值将被转换为 0000，而不是 2000。 提示：两位整数范围与两位字符串范围稍有不同。例如，插入 3000 年，读者可能会使用数字格式的 0 表示 YEAR，实际上，插入数据库的值为 0000，而不是所希望的 3000。只有使用字符串格式的 ‘0’ 或 ‘00’，才可以被正确解释为 3000，非法 YEAR值将被转换为 0000。 TIME 类型TIME 类型用于只需要时间信息的值，在存储时需要 3 个字节。格式为 HH:MM:SS。HH 表示小时，MM 表示分钟，SS 表示秒。 TIME 类型的取值范围为 -838：59：59～838：59：59，小时部分如此大的原因是 TIME 类型不仅可以用于表示一天的时间（必须小于 24 小时），还可能是某个事件过去的时间或两个事件之间的时间间隔（可大于 24 小时，或者甚至为负）。 可以使用各种格式指定 TIME 值，如下所示。 ‘D HH：MM：SS’ 格式的字符串。还可以使用这些“非严格”的语法：’HH：MM：SS’、’HH：MM’、’D HH’ 或 ‘SS’。这里的 D 表示日，可以取 0～34 之间的值。在插入数据库时，D 被转换为小时保存，格式为 “D*24+HH”。 ‘HHMMSS’ 格式、没有间隔符的字符串或者 HHMMSS 格式的数值，假定是有意义的时间。例如，’101112’ 被理解为’10：11：12’，但是 ‘106112’ 是不合法的（它有一个没有意义的分钟部分），在存储时将变为 00：00：00。 提示：为 TIME 列分配简写值时应注意：如果没有冒号，MySQL 解释值时，假定最右边的两位表示秒。（MySQL 解释 TIME 值为过去的时间而不是当前的时间）。例如，读者可能认为 ‘1112’ 和 1112 表示 11：12：00（即 11 点过 12 分钟），但MySQL 将它们解释为 00：11：12（即 11 分 12 秒）。同样 ‘12’ 和 12 被解释为00：00：12。相反，TIME 值中如果使用冒号则肯定被看作当天的时间，也就是说，’11：12’ 表示 11：12：00，而不是 00：11：12。 DATE 类型DATE 类型用于仅需要日期值时，没有时间部分，在存储时需要 3 个字节。日期格式为 ‘YYYY-MM-DD’，其中 YYYY 表示年，MM 表示月，DD 表示日。 在给 DATE 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATE 的日期格式即可。如下所示： 以 ‘YYYY-MM-DD’ 或者 ‘YYYYMMDD’ 字符中格式表示的日期，取值范围为 ‘1000-01-01’～’9999-12-3’。例如，输入 ‘2015-12-31’ 或者 ‘20151231’，插入数据库的日期为2015-12-31。 以 ‘YY-MM-DD’ 或者 ‘YYMMDD’ 字符串格式表示日期，在这里YY表示两位的年值。MySQL 解释两位年值的规则：’00～69’ 范围的年值转换为 ‘20002069’，’7099’ 范围的年值转换为 ‘1970～1999’。例如，输入 ‘15-12-31’，插入数据库的日期为 2015-12-31；输入 ‘991231’，插入数据库的日期为 1999-12-31。 以 YYMMDD 数字格式表示的日期，与前面相似，00~69 范围的年值转换为 2000～2069，80～99 范围的年值转换为 1980～1999。例如，输入 151231，插入数据库的日期为 2015-12-31，输入 991231，插入数据库的日期为 1999-12-31。 使用 CURRENT_DATE 或者 NOW()，插入当前系统日期。 提示：MySQL 允许“不严格”语法：任何标点符号都可以用作日期部分之间的间隔符。例如，’98-11-31’、’98.11.31’、’98/11/31’和‘98@11@31’ 是等价的，这些值也可以正确地插入数据库。 DATETIME 类型DATETIME 类型用于需要同时包含日期和时间信息的值，在存储时需要 8 个字节。日期格式为 ‘YYYY-MM-DD HH：MM：SS’，其中 YYYY 表示年，MM 表示月，DD 表示日，HH 表示小时，MM 表示分钟，SS 表示秒。 在给 DATETIME 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATETIME 的日期格式即可，如下所示。 以 ‘YYYY-MM-DD HH：MM：SS’ 或者 ‘YYYYMMDDHHMMSS’ 字符串格式表示的日期，取值范围为 ‘1000-01-01 00：00：00’～’9999-12-3 23：59：59’。例如，输入 ‘2014-12-31 05：05：05’ 或者 ‘20141231050505’，插入数据库的 DATETIME 值都为 2014-12-31 05：05：05。 以 ‘YY-MM-DD HH：MM：SS’ 或者 ‘YYMMDDHHMMSS’ 字符串格式表示的日期，在这里 YY 表示两位的年值。与前面相同，’00～79’ 范围的年值转换为 ‘2000～2079’，’80～99’ 范围的年值转换为 ‘1980～1999’。例如，输入 ‘14-12-31 05：05：05’，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。 以 YYYYMMDDHHMMSS 或者 YYMMDDHHMMSS 数字格式表示的日期和时间。例如，输入 20141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 140505050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。 提示：MySQL 允许“不严格”语法：任何标点符号都可用作日期部分或时间部分之间的间隔符。例如，’98-12-31 11：30：45’、’98.12.31 11+30+35’、’98/12/31 113045’ 和 ‘98@12@31 11^30^45’ 是等价的，这些值都可以正确地插入数据库。 TIMESTAMP 类型TIMESTAMP 的显示格式与 DATETIME 相同，显示宽度固定在 19 个字符，日期格式为 YYYY-MM-DD HH：MM：SS，在存储时需要 4 个字节。但是 TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，为 ‘1970-01-01 00：00：01’UTC～’2038-01-19 03：14：07’UTC。在插入数据时，要保证在合法的取值范围内。 提示：协调世界时（英：Coordinated Universal Time，法：Temps Universel Coordonné）又称为世界统一时间、世界标准时间、国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。 TIMESTAMP 与 DATETIME 除了存储字节和支持的范围不同外，还有一个最大的区别是： DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关； 而 TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。 提示：如果为一个 DATETIME 或 TIMESTAMP 对象分配一个 DATE 值，结果值的时间部分被设置为 ‘00：00：00’，因此 DATE 值未包含时间信息。如果为一个 DATE 对象分配一个 DATETIME 或 TIMESTAMP 值，结果值的时间部分被删除，因此DATE 值未包含时间信息。 字符类型MySQL 支持两类字符型数据：字符串类型和二进制类型 包括CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小/存储需求 说明/用途 CHAR 0-255字节 定长字符串 CHAR(M) M 字节，1&lt;=M&lt;=255 固定长度非二进制字符串 VARCHAR 0-65535 字节 变长字符串 1VARCHAR(M) L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255 变长非二进制字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 ENUM 1或2个字节，取决于枚举值的数目 (最大值为65535) 枚举类型，只能有一个枚举字符串值 SET 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） 一个设置，字符串对象可以有零个或 多个SET成员 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 字符串类型 又称“文本字符串类型”。 字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据。字符串可以区分或者不区分大小写的串比较，还可以进行正则表达式的匹配查找。 MySQL 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。 下表中列出了 MySQL 中的字符串数据类型，括号中的M表示可以为其指定长度。 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1&lt;=M&lt;=255 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255 TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L&lt;2^8 TEXT 小的非二进制字符串 L+2字节，在此，L&lt;2^16 MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L&lt;2^24 LONGTEXT 大的非二进制字符串 L+4字节，在此，L&lt;2^32 ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） VARCHAR 和 TEXT 类型是变长类型，其存储需求取决于列值的实际长度（在前面的表格中用 L 表示），而不是取决于类型的最大可能尺寸。 例如，一个 VARCHAR(10) 列能保存一个最大长度为 10 个字符的字符串，实际的存储需要字符串的长度 L 加上一个字节以记录字符串的长度。对于字符 “abcd”，L 是 4，而存储要求 5 个字节。 CHAR 和 VARCHAR 类型CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255 个字符。 例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当检索到 CHAR 值时，尾部的空格将被删除。 VARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0～65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。 例如，VARCHAR(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。VARCHAR 在值保存和检索时尾部的空格仍保留。 【实例】下面将不同的字符串保存到 CHAR(4) 和 VARCHAR(4) 列，说明 CHAR 和 VARCHAR 之间的差别，如下表所示。 插入值 CHAR(4) 存储需求 VARCHAR(4) 存储需求 ‘ ‘ ‘ ‘ 4字节 ‘’ 1字节 ‘ab’ ‘ab ‘ 4字节 ‘ab’ 3字节 ‘abc’ ‘abc ‘ 4字节 ‘abc’ 4字节 ‘abcd’ ‘abcd’ 4字节 ‘abcd’ 5字节 ‘abcdef’ ‘abcd’ 4字节 ‘abcd’ 5字节 对比结果可以看到，CHAR(4) 定义了固定长度为 4 的列，无论存入的数据长度为多少，所占用的空间均为 4 个字节。VARCHAR(4) 定义的列所占的字节数为实际长度加 1。 TEXT 类型TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。 TEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。 TINYTEXT 表示长度为 255（28-1）字符的 TEXT 列。 TEXT 表示长度为 65535（216-1）字符的 TEXT 列。 MEDIUMTEXT 表示长度为 16777215（224-1）字符的 TEXT 列。 LONGTEXT 表示长度为 4294967295 或 4GB（232-1）字符的 TEXT 列。 ENUM 类型ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下： 1&lt;字段名&gt; ENUM( '值1', '值1', …, '值n' ) 字段名指将要定义的字段，值 n 指枚举列表中第 n 个值。 ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。 ENUM 值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号，枚举最多可以有 65535 个元素。 例如，定义 ENUM 类型的列（’first’，’second’，’third’），该列可以取的值和每个值的索引如下表所示。 值 索引 NULL NULL ‘’ 0 ’first 1 second 2 third 3 ENUM 值依照列索引顺序排列，并且空字符串排在非空字符串前，NULL 值排在其他所有枚举值前。 提示：ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。 SET 类型SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下： 1SET( '值1', '值2', …, '值n' ) 与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。 但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。 提示：如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。 二进制类型 二进制字符串类型有时候也直接被称为“二进制类型”。 MySQL 中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 下表中列出了 MySQL 中的二进制数据类型，括号中的M表示可以为其指定长度。 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)/8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L&lt;2^8 BLOB (M) 小 BLOB L+2 字节，在此，L&lt;2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L&lt;2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L&lt;2^32 BIT 类型位字段类型。M 表示每个值的位数，范围为 1～64。如果 M 被省略，默认值为 1。如果为 BIT(M) 列分配的值的长度小于 M 位，在值的左边用 0 填充。例如，为 BIT(6) 列分配一个值 b’101’，其效果与分配 b’000101’ 相同。 BIT 数据类型用来保存位字段值，例如以二进制的形式保存数据 13，13 的二进制形式为 1101，在这里需要位数至少为 4 位的 BIT 类型，即可以定义列类型为 BIT(4)。大于二进制 1111 的数据是不能插入 BIT(4) 类型的字段中的。 提示：默认情况下，MySQL 不可以插入超出该列允许范围的值，因而插入数据时要确保插入的值在指定的范围内。 BINARY 和 VARBINARY 类型BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字节字符串。使用的语法格式如下： 列名称 BINARY(M) 或者 VARBINARY(M) BINARY 类型的长度是固定的，指定长度后，不足最大长度的，将在它们右边填充 “\\0” 补齐，以达到指定长度。例如，指定列数据类型为 BINARY(3)，当插入 a 时，存储的内容实际为 “\\a0\\0”，当插入 ab 时，实际存储的内容为“ab\\0”，无论存储的内容是否达到指定的长度，存储空间均为指定的值 M。 VARBINARY 类型的长度是可变的，指定好长度之后，长度可以在 0 到最大值之间。例如，指定列数据类型为 VARBINARY(20)，如果插入的值长度只有 10，则实际存储空间为 10 加 1，实际占用的空间为字符串的实际长度加 1。 BLOB 类型BLOB 是一个二进制的对象，用来存储可变数量的数据。BLOB 类型分为 4 种：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB，它们可容纳值的最大长度不同，如下表所示。 数据类型 存储范围 TINYBLOB 最大长度为255 (28-1)字节 BLOB 最大长度为65535 (216-1)字节 MEDIUMBLOB 最大长度为16777215 (224-1)字节 LONGBLOB 最大长度为4294967295或4GB (231-1)字节 BLOB 列存储的是二进制字符串（字节字符串），TEXT 列存储的是非进制字符串（字符字符串）。 BLOB 列是字符集，并且排序和比较基于列值字节的数值；TEXT 列有一个字符集，并且根据字符集对值进行排序和比较。 以上笔记部分来自 C语言中文网 、百度知道、CSDN。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[转]MySQL数据库引擎","slug":"转-MySQL数据库引擎","date":"2020-02-09T10:43:52.000Z","updated":"2020-02-11T10:56:14.918Z","comments":true,"path":"2020/02/09/转-MySQL数据库引擎/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E8%BD%AC-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/","excerpt":"接下来介绍一下存储引擎的基本概念、MySQL支持的存储引擎、存储引擎的选择以及操作默认存储引擎。","text":"接下来介绍一下存储引擎的基本概念、MySQL支持的存储引擎、存储引擎的选择以及操作默认存储引擎。 什么是存储引擎数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。 现在许多数据库管理系统都支持多种不同的存储引擎。MySQL 的核心就是存储引擎。 提示：InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎。 MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。 MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。 MySQL 5.7 支持的存储引擎MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 SHOW ENGINES 语句来显示可用的数据库引擎和默认引擎。 MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。 MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。可以使用SHOW ENGINES语句查看系统所支持的引擎类型，结果如图所示。 Support 列的值表示某种引擎是否能使用，YES表示可以使用，NO表示不能使用，DEFAULT表示该引擎为当前默认的存储引擎。 如何选择 MySQL 存储引擎不同的存储引擎都有各自的特点，以适应不同的需求，如表所示。为了做出选择，首先要考虑每一个存储引擎提供了哪些不同的功能。 功能 MylSAM MEMORY InnoDB Archive 存储限制 256TB RAM 64TB None 支持事务 No No Yes No 支持全文索引 Yes No No No 支持树索引 Yes Yes Yes No 支持哈希索引 No Yes No No 支持数据缓存 No N/A Yes No 支持外键 No No Yes No 可以根据以下的原则来选择 MySQL 存储引擎： 如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。 如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。 如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。 如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎。 提示：使用哪一种引擎要根据需要灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。 MySQL 默认存储引擎InnoDB 是系统的默认引擎，支持可靠的事务处理。 使用下面的语句可以修改数据库临时的默认存储引擎 SET default_storage_engine=&lt; 存储引擎名 &gt; 例如，将 MySQL 数据库的临时默认存储引擎修改为 MyISAM，输入的 SQL 语句和运行结果如图所示。 此时，可以发现 MySQL 的默认存储引擎已经变成了 MyISAM。但是当再次重启客户端时，默认存储引擎仍然是 InnoDB。 原文链接：http://c.biancheng.net/view/2418.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[转]MySQL区别大小写字母的问题","slug":"转-MySQL区别大小写的问题","date":"2020-02-09T08:29:12.000Z","updated":"2020-02-11T10:56:14.921Z","comments":true,"path":"2020/02/09/转-MySQL区别大小写的问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E8%BD%AC-MySQL%E5%8C%BA%E5%88%AB%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"如果直接使用MYSQL客户端用SQL语句查询数据库中的数据，SQL语句中字段的大写或小写查出的数据是一样的，说明查询条件对字段的大小写是不敏感（默认）。 怎样让MYSQL对大小字母写敏感？解决方案一MYSQL区别大小写需要设置collate（校对） 。 collate规则： *_bin: 表示的是 binary casesensitive collation，也就是说是区分大小写的 *_cs: 表示的是 casesensitive collation，区分大小写 *_ci: 表示的是 caseinsensitive collation，不区分大小写 解决方法 可以将查询条件用binary()括起来。 比如： 1select * from emp where binary username= 'jack'; 可以修改该字段的collation 为 binary。比如： 1ALTER TABLE TABLENAME MODIFY COLUMN COLUMNNAME VARCHAR(50) BINARY CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL; 解决方案二 mysql查询默认是不区分大小写的 如: 12select * from emp where username=‘jack';select * from emp where username='JACK'; 得到的结果是一样的，如果我们需要进行区分的话可以按照如下方法来做： 第一种方法要让mysql查询区分大小写，可以： 12select * from emp where binary username='jack'select * from emp where binary username='JACK' 第二种方法在建表时时候加以标识 123create table emp( username varchar(20) binary) 原理：对于CHAR、VARCHAR和TEXT类型，BINARY属性可以为列分配该列字符集的校对规则。BINARY属性是指定列字符集的二元校对规则的简写。排序和比较基于数值字符值,因此也就自然区分了大小写。 原文链接：https://blog.csdn.net/qq_15160079/article/details/100976519","text":"如果直接使用MYSQL客户端用SQL语句查询数据库中的数据，SQL语句中字段的大写或小写查出的数据是一样的，说明查询条件对字段的大小写是不敏感（默认）。 怎样让MYSQL对大小字母写敏感？解决方案一MYSQL区别大小写需要设置collate（校对） 。 collate规则： *_bin: 表示的是 binary casesensitive collation，也就是说是区分大小写的 *_cs: 表示的是 casesensitive collation，区分大小写 *_ci: 表示的是 caseinsensitive collation，不区分大小写 解决方法 可以将查询条件用binary()括起来。 比如： 1select * from emp where binary username= 'jack'; 可以修改该字段的collation 为 binary。比如： 1ALTER TABLE TABLENAME MODIFY COLUMN COLUMNNAME VARCHAR(50) BINARY CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL; 解决方案二 mysql查询默认是不区分大小写的 如: 12select * from emp where username=‘jack';select * from emp where username='JACK'; 得到的结果是一样的，如果我们需要进行区分的话可以按照如下方法来做： 第一种方法要让mysql查询区分大小写，可以： 12select * from emp where binary username='jack'select * from emp where binary username='JACK' 第二种方法在建表时时候加以标识 123create table emp( username varchar(20) binary) 原理：对于CHAR、VARCHAR和TEXT类型，BINARY属性可以为列分配该列字符集的校对规则。BINARY属性是指定列字符集的二元校对规则的简写。排序和比较基于数值字符值,因此也就自然区分了大小写。 原文链接：https://blog.csdn.net/qq_15160079/article/details/100976519 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}],"author":{"name":"曼巴进化者","url":"https://blog.csdn.net/qq_15160079/article/details/100976519"}},{"title":"Navicat Premium连接MySQL失败？","slug":"Navicat-Premium连接MySQL失败？","date":"2020-02-09T07:42:25.000Z","updated":"2020-02-11T10:56:14.881Z","comments":true,"path":"2020/02/09/Navicat-Premium连接MySQL失败？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/Navicat-Premium%E8%BF%9E%E6%8E%A5MySQL%E5%A4%B1%E8%B4%A5%EF%BC%9F/","excerpt":"问题描述使用Navicat Premium连接MySQL失败，并弹窗提示👇 分析从错误信息可知caching_sha2_password不能加载。 以上报错是由于目前已有的客户端连接软件还不支持Mysql8新增加的加密方式caching_sha2_password，所以我们需要修改用户的加密方式，将其改为老的加密验证方式。 大安装Mysql数据库的主机上登录Mysql对应的用户，上面连接时用的用户为root，所以我们登录root用户。 解决 执行命令，查看当前用户的加密方式： 123use mysql;select user,plugin from user where user='root'; 可以看到当前用户的加密方式为caching_sha2_password。 登录MySQL后输入，执行命令： 123ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'YourPassword';FLUSH PRIVILEGES; 将用户的加密方式改为mysql_native_password。 再次尝试连接Mysql，连接成功。","text":"问题描述使用Navicat Premium连接MySQL失败，并弹窗提示👇 分析从错误信息可知caching_sha2_password不能加载。 以上报错是由于目前已有的客户端连接软件还不支持Mysql8新增加的加密方式caching_sha2_password，所以我们需要修改用户的加密方式，将其改为老的加密验证方式。 大安装Mysql数据库的主机上登录Mysql对应的用户，上面连接时用的用户为root，所以我们登录root用户。 解决 执行命令，查看当前用户的加密方式： 123use mysql;select user,plugin from user where user='root'; 可以看到当前用户的加密方式为caching_sha2_password。 登录MySQL后输入，执行命令： 123ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'YourPassword';FLUSH PRIVILEGES; 将用户的加密方式改为mysql_native_password。 再次尝试连接Mysql，连接成功。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"输入密码后登录不上MySQL？","slug":"输入密码后登录不上MySQL？","date":"2020-02-09T07:08:37.000Z","updated":"2020-02-11T10:56:14.924Z","comments":true,"path":"2020/02/09/输入密码后登录不上MySQL？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E5%90%8E%E7%99%BB%E5%BD%95%E4%B8%8D%E4%B8%8AMySQL%EF%BC%9F/","excerpt":"昨晚安装好MySQL后，可以登录。但是今天输入密码后，总是没办法登录。 刚开始我是用DOS窗口的，我检查了命令，命令也没输错啊。 接着转去MySQL Command Line Client试试，一直没反应。 我突然想到“是不是MySQL服务没有启动？” 果然！看了一下，这个时候MySQL需要手动启动，于是我把MySQL服务设置成开机自动启动，以后就省去手动启动这个麻烦。 回到DOS，输入mysql -h localhost -u root -p试试，可以正常登录MySQL了hh o(￣▽￣)o 除了上面这种到【服务】手动开启MySQL服务的方法外，也可以用PowerShell(管理员)来启动。 输入命令net start mysql，启动MySQL服务。启动成功会在左下角弹窗提示👇 一定是要带有管理员权限的PowerShell，否者只会是这个样子👇 输入net start mysql，按回车键，就能启动 MySQL 服务，停止服务的命令为net stop mysql。","text":"昨晚安装好MySQL后，可以登录。但是今天输入密码后，总是没办法登录。 刚开始我是用DOS窗口的，我检查了命令，命令也没输错啊。 接着转去MySQL Command Line Client试试，一直没反应。 我突然想到“是不是MySQL服务没有启动？” 果然！看了一下，这个时候MySQL需要手动启动，于是我把MySQL服务设置成开机自动启动，以后就省去手动启动这个麻烦。 回到DOS，输入mysql -h localhost -u root -p试试，可以正常登录MySQL了hh o(￣▽￣)o 除了上面这种到【服务】手动开启MySQL服务的方法外，也可以用PowerShell(管理员)来启动。 输入命令net start mysql，启动MySQL服务。启动成功会在左下角弹窗提示👇 一定是要带有管理员权限的PowerShell，否者只会是这个样子👇 输入net start mysql，按回车键，就能启动 MySQL 服务，停止服务的命令为net stop mysql。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[工具]文件加密软件","slug":"工具-文件加密软件","date":"2020-02-09T05:40:26.000Z","updated":"2020-02-11T10:56:14.889Z","comments":true,"path":"2020/02/09/工具-文件加密软件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E5%B7%A5%E5%85%B7-%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E8%BD%AF%E4%BB%B6/","excerpt":"Folder-locker这是一个小巧的文件上锁软件，没有压缩和加密过程，方便快捷。 功能展示 在想加密的文件夹上，右键则可呼出加密面板，输入两次密码确认加密。 在已加密的文件夹上，右键，输入密码，则取消加密 项目介绍项目分了两个目录： DButility 用于通过轻量极数据库SQLite 保存密码。 通过Md5算法对密码加密，通过SQL参数防止SQL注入。 folderLocker 用于实现业务逻辑。 软件使用 下载软件安装包 Folder Locker.exe 进行安装，建议安装在D盘。 可以右键使用，也可以打开软件主页面使用。 注意事项 密码保存在本机数据库，没有上传任何服务器。 删除软件会同时删除数据库，因而删除密码。 如果忘记密码： 如果密码遗失，文件被锁，可以通过命令行工具重命名： 12cd C:\\Users\\91991\\Musicren \"Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\" \"Test1\" 或者把文件复制出来。 1234cd C:\\Users\\91991\\Musiccd '.\\Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\\'lsmv .\\* ..\\Test1\\ 项目地址： https://github.com/Albert-W/Folder-locker 项目展示： https://albert-w.github.io/Folder-locker/","text":"Folder-locker这是一个小巧的文件上锁软件，没有压缩和加密过程，方便快捷。 功能展示 在想加密的文件夹上，右键则可呼出加密面板，输入两次密码确认加密。 在已加密的文件夹上，右键，输入密码，则取消加密 项目介绍项目分了两个目录： DButility 用于通过轻量极数据库SQLite 保存密码。 通过Md5算法对密码加密，通过SQL参数防止SQL注入。 folderLocker 用于实现业务逻辑。 软件使用 下载软件安装包 Folder Locker.exe 进行安装，建议安装在D盘。 可以右键使用，也可以打开软件主页面使用。 注意事项 密码保存在本机数据库，没有上传任何服务器。 删除软件会同时删除数据库，因而删除密码。 如果忘记密码： 如果密码遗失，文件被锁，可以通过命令行工具重命名： 12cd C:\\Users\\91991\\Musicren \"Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\" \"Test1\" 或者把文件复制出来。 1234cd C:\\Users\\91991\\Musiccd '.\\Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\\'lsmv .\\* ..\\Test1\\ 项目地址： https://github.com/Albert-W/Folder-locker 项目展示： https://albert-w.github.io/Folder-locker/ 教程这是国人开发的一款开源加密小程序，它只有一个功能，就是给文件夹上密码。 下载后安装，需要注意的是，软件默认安装到D盘，你可以改成其他盘，但不建议安装到C盘，因为可能导致数据库丢失，影响解密； 加密过程也很简单，右键需要加密的文件夹 – Folder locker – 输入密码– lock 即可； 加密后文件夹图标会变成锁，无法双击打开，需要解密的话，右键已加密文件夹 – Folder locker – 输入密码– unlock 即可； 整个过程没有任何数据上传，你的密码会通过Md5算法加密，并保存在本机数据库，卸载软件会同时删除数据库，导致密码丢失。 这个小程序原理非常简单，就是利用 Windows 的注册表修改了文件夹属性，使其不能直接已文件夹的形式打开，就像「上帝模式」一样，小程序并没有对文件夹内的文件做任何修改，没有压缩和加密过程，所以速度非常快。 但也正因为其简单，知道原理的话不需要程序也能解密。 忘记密码的解密方法： 以上就是使用这个小程序所有的方法，它的安全系数不高，不适用来加密非常重要的机密文件，但保护普通用户的小秘密应该是搓搓有余的。 目前这款软件好像在 Windows 2004 版本上失效了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}],"author":{"name":"Albert-W","url":"https://github.com/Albert-W/Folder-locker","avatar":"https://avatars0.githubusercontent.com/u/21038139?s=460&v=4"}},{"title":"登录MySQL","slug":"登录MySQL","date":"2020-02-08T14:54:46.000Z","updated":"2020-02-11T10:56:14.892Z","comments":true,"path":"2020/02/08/登录MySQL/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E7%99%BB%E5%BD%95MySQL/","excerpt":"安装好MySQL后，默认启动服务，这时候开始尝试登录MySQL数据库。 有两种登录方式： Power Shell 或 CMD（DOS窗口） 命令行客户端（MySQL Command Line Client）【安装软件时，一般会安装的】 Power Shell 启动 Power Shell 。 输入命令cd C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin（cd+空格+安装目录/bin），回车。 输入登录命令，回车。登录命令有4中，选其一即可： 12345678#第一种 服务器主机地址+不接密码mysql -h localhost -u root -p#第二种 服务器主机地址+密码mysql -h localhost -u root -proot#第三种 省略服务器主机地址+不接密码，默认localhostmysql -u root -p#第四种 省略服务器主机地址+密码，默认localhostmysql -u root -proot 提示：mysql 为登录命令，-h 后面的参数是服务器的主机地址，在这里客户端和服务器在同一台机器上，所以输入 localhost 或者 IP 地址；-u 后面跟登录数据库的用户名称，在这里为 root；-p 后面是用户登录密码。 在 DOS 窗口下运行该命令后，系统会提示输入密码。密码输入正确以后，即可登录到 MySQL 数据库。 可以在 mysql 命令中直接加上密码，该命令为 mysql -h localhost -u root -proot。这里的 -p 后面的 root 就是密码。此处特别注意 -p 和密码之间没有空格。如果出现空格，系统将不会把后面的字符串当成密码来对待。 系统提示输入密码。（若选用第二/四种方式进行登录，则跳过本步骤） 成功登录到MySQL数据库。登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，如下图所示。 登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，然后下面还有一些说明性的语句，如图所示。 这些说明性语句介绍如下： Commands end with; or\\g：说明 mysql 命令行下的命令是以分号（;）或“\\g”来结束的，遇到这个结束符就开始执行命令。 Your MySQL connection id is 3：id 表示 MySQL 数据库的连接次数。 Server version: 5. 7.29-log MySQL Community Server（GPL）：Server version 后面说明数据库的版本，这个版本为 5.7.29。Community 表示该版本是社区版。 Type ‘help;’ or ‘\\h’ for help：表示输入”help;“或者”\\h“可以看到帮助信息。 Type ‘\\c’ to clear the current input statement：表示遇到”\\c“就清除前面的命令。 提示：当窗口中出现如上图所示的说明信息，命令提示符变为“mysql&gt;”时，表明已经成功登录 MySQL 服务器，可以开始对数据库进行操作了。 输入命令exit，即可退出MySQL。 MySQL Command Line Client打开 MySQL Command Line Client 进入提示输入密码的界面，如图所示。 输入正确的密码后，登录到 MySQL 软件。如果以这种方式登录 MySQL，需要保证 MySQL 服务处于启动状态。","text":"安装好MySQL后，默认启动服务，这时候开始尝试登录MySQL数据库。 有两种登录方式： Power Shell 或 CMD（DOS窗口） 命令行客户端（MySQL Command Line Client）【安装软件时，一般会安装的】 Power Shell 启动 Power Shell 。 输入命令cd C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin（cd+空格+安装目录/bin），回车。 输入登录命令，回车。登录命令有4中，选其一即可： 12345678#第一种 服务器主机地址+不接密码mysql -h localhost -u root -p#第二种 服务器主机地址+密码mysql -h localhost -u root -proot#第三种 省略服务器主机地址+不接密码，默认localhostmysql -u root -p#第四种 省略服务器主机地址+密码，默认localhostmysql -u root -proot 提示：mysql 为登录命令，-h 后面的参数是服务器的主机地址，在这里客户端和服务器在同一台机器上，所以输入 localhost 或者 IP 地址；-u 后面跟登录数据库的用户名称，在这里为 root；-p 后面是用户登录密码。 在 DOS 窗口下运行该命令后，系统会提示输入密码。密码输入正确以后，即可登录到 MySQL 数据库。 可以在 mysql 命令中直接加上密码，该命令为 mysql -h localhost -u root -proot。这里的 -p 后面的 root 就是密码。此处特别注意 -p 和密码之间没有空格。如果出现空格，系统将不会把后面的字符串当成密码来对待。 系统提示输入密码。（若选用第二/四种方式进行登录，则跳过本步骤） 成功登录到MySQL数据库。登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，如下图所示。 登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，然后下面还有一些说明性的语句，如图所示。 这些说明性语句介绍如下： Commands end with; or\\g：说明 mysql 命令行下的命令是以分号（;）或“\\g”来结束的，遇到这个结束符就开始执行命令。 Your MySQL connection id is 3：id 表示 MySQL 数据库的连接次数。 Server version: 5. 7.29-log MySQL Community Server（GPL）：Server version 后面说明数据库的版本，这个版本为 5.7.29。Community 表示该版本是社区版。 Type ‘help;’ or ‘\\h’ for help：表示输入”help;“或者”\\h“可以看到帮助信息。 Type ‘\\c’ to clear the current input statement：表示遇到”\\c“就清除前面的命令。 提示：当窗口中出现如上图所示的说明信息，命令提示符变为“mysql&gt;”时，表明已经成功登录 MySQL 服务器，可以开始对数据库进行操作了。 输入命令exit，即可退出MySQL。 MySQL Command Line Client打开 MySQL Command Line Client 进入提示输入密码的界面，如图所示。 输入正确的密码后，登录到 MySQL 软件。如果以这种方式登录 MySQL，需要保证 MySQL 服务处于启动状态。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"MySQL基础教学","slug":"MySQL基础教学","date":"2020-02-08T13:25:58.000Z","updated":"2020-02-11T10:56:14.874Z","comments":true,"path":"2020/02/08/MySQL基础教学/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/MySQL%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/","excerpt":"两个学习MySQL基础的网站： C语言中文网 菜鸟教程","text":"两个学习MySQL基础的网站： C语言中文网 菜鸟教程 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[转]MySQL安装","slug":"转-MySQL安装","date":"2020-02-08T12:58:45.000Z","updated":"2020-02-11T10:56:14.927Z","comments":true,"path":"2020/02/08/转-MySQL安装/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E8%BD%AC-MySQL%E5%AE%89%E8%A3%85/","excerpt":"转载一份非常详细的【MySQL】的安装教程。","text":"转载一份非常详细的【MySQL】的安装教程。 进入官网找到自己所需的安装包：https://dev.mysql.com/ ，路径：DOWNLOAD–&gt;MYSQL Community Edition(GRL)–&gt;MYSQL on Windows (Installer &amp; Tool) 找到所需的安装包: 点击download。这里选择的是安装版（mysql -install-community） 选择不登陆下载。 双击运行下载好的mysql-installer-community-5.7.19.0.msi，程序运行需要一些时间，请等待一下。 运行成功之后，进入欢迎的界面.选择我同意协议，不然无法进行下一步。 进入类型选择页面，本人需要mysql云服务就选择了developer default（7.1是默认安装的步骤），如果只想安装mysql server的就选择custom模式（7.2步骤是选择自己需要的服务器类型，所选择的用于做一些数据分析） 12345developer default（开发者默认）：安装mysql开发所需的所有产品server only（服务器）：只安装mysql服务器产品client only（客户端）：只安装没有服务器的mysql客户端产品full（完全）：安装所有包含的mysql产品和功能custom（手动）：手动选择系统上应安装的产品 7.1 开发者默认模式检测以下程序会安装不成功，点击下一步进入下一个安装流程—&gt;跳到第八步。 check requirements：以下产品的请求失败，安装程序将自动尝试解决其中一些问题。标记为手动的要求无法自动解决。单击这些项目以尝试手动恢复。 检测到不可安装的程序说明： Visual Studio：是一款代码编辑工具（可编写C#、Visual Basic、C++、TypeScript、F# ），如果你安装的话就安装要求去安装Visual Studio version：2012.2013.2015.2017其中一个版本 Connector/pyton 3.4：电脑有python3.6了就没选择3.4版本的。如果你没安装有python可按要求去安装一些内容。 7.2 选择mysql server（服务） 5.7.19 x64 选择mysql workbench(mysql 的工作薄) 6.3.9 x64 选择mysql notiyier(通知) 1.1.7 x86(因为这里只有一个选择所以选择了86)点击下一步进入下一个安装流程—&gt;跳到第九步。 当我们点击下一步的时候安装程序出现了提示：（一个或者移动产品要求没有得到满足，那些符合要求的产品将不会安装/升级。你想要继续吗），这里我选择的是：YES 在安装所选界面能看到我们接下来所需要安装的程序，点击execute 安装程序进度界面，安装需要一些时间。点击dide tails能看到安装日志 程序安装完成之后，点击next 在product configutration（产品配置）页面能看到需要配置的程序，点击next（页面英语介绍：现在我们将逐一介绍以下产品的配置向导。您可以随时取消，如果您希望离开此向导，而不必配置所有产品） 先配置mysql server的类型以及网络：type and networking（类型和网络），这里有两种mysql server类型，选择第一种类型点击next。 123456有两种类型简单介绍1.standalone mysql server/classic mysql replication：独立的mysql服务器/经典的mysql复制choose this option if you want to run the mysql server either standalone with the opportunity to later configure classic mysql replication：选择这个选项，如果你想运行mysql服务器是独立的，有机会以后配置经典的mysql复制2. innodb cluster sandbox thst setup(for testing only)：innodb集群沙箱thst设置（仅用于测试） 设置服务器配置类型以及连接端口：继续next 12Config Type:选择Development Machine，用于小型以及学习所用足够了。Port number：输入3306，也可以输入其他最好是3306-3309之间。 配置root的密码（该密码要记住），系统提示这密码虚弱 添加其他管理员，点击add user 输入账号密码点击ok（如果添加的管理员只允许在本地登录就将host改成local），回到界面之后点击next 配置mysql在windows系统中的名字，是否选择开机启动mysql服务，其它的没进行修改，点击“Next”. 配置插件和扩展页面没进行修改直接下一步： Mysql server :apply configuration（应用配置页面），选择execute进行安装配置 mysql server应用配置的log，选择finish 安装程序又回到了product configutration（产品配置）页面，此时我们看到mysql server安装成功的显示，继续下一步： 配置mysql router：勾选configure mysql route for innoDB cluster之后输入密码。（如果不想输入密码可直接点击点一下）点击下一步 Mysql router :apply configuration（应用配置页面）点击execute, 安装完成之后点击选择finish 检测root密码 12 安装一些server，老规矩点击execute，完成之后点击finish 程序回到产品配置页面。继续下一步： 安装程序完成界面。 双击运行之前下载的安装包，能看到我们所安装的产品。 配置mysql环境变量 12上面安装的是时候我们看到mysql默认安装路径是：C:\\Program Files\\MySQL\\MySQL Server 5.7我的电脑右键—&gt;属性à高级系统设置à环境变量à新建MYSQL_HOME,将安装目录输入： 1找到path编辑：输入%MYSQL_HOME%\\bin 12打开cmd输入mysql –u root –p输入root的密码 原文链接：https://www.cnblogs.com/xiaodingdong/p/7223245.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}],"author":{"name":"叮咚丶哈哈","url":"https://www.cnblogs.com/xiaodingdong/p/7223245.html"}},{"title":"元宵团圆饭","slug":"元宵团圆饭","date":"2020-02-08T09:13:43.000Z","updated":"2020-02-08T09:37:50.898Z","comments":true,"path":"2020/02/08/元宵团圆饭/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E5%85%83%E5%AE%B5%E5%9B%A2%E5%9C%86%E9%A5%AD/","excerpt":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！”","text":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"第一个元宵","slug":"第一个元宵","date":"2020-02-08T09:13:43.000Z","updated":"2020-02-08T10:52:37.428Z","comments":true,"path":"2020/02/08/第一个元宵/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E5%AE%B5/","excerpt":"🌸于我们，这是妈走后的第一个元宵。 🎈这次没有汤圆…… 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” 👍附上老爸的新作(暂时想不出名字来hh，反正好吃hh)","text":"🌸于我们，这是妈走后的第一个元宵。 🎈这次没有汤圆…… 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” 👍附上老爸的新作(暂时想不出名字来hh，反正好吃hh) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"[转]jsdelivr的使用","slug":"转-jsdelivr的使用","date":"2020-02-08T06:22:39.000Z","updated":"2020-02-11T10:56:14.933Z","comments":true,"path":"2020/02/08/转-jsdelivr的使用/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E8%BD%AC-jsdelivr%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"本文链接：https://blog.csdn.net/qq_36910987/article/details/89562291","text":"本文链接：https://blog.csdn.net/qq_36910987/article/details/89562291 12345678jsdelivr https://www.jsdelivr.com/下面就以举例子的方式说明我是用 jsdelivr 来访问 github的资源，做博客来着我的github https://github.com/yuDuChen/yuduchen下面直接说怎么用jsdelivr，就不提如何创建github了首先需要创建 releases 12创建完,随便进入到一个文件,注意地址名1 1234567https://github.com/yuDuChen/yuduchen/blob/v1.5.6/layui/layui.js 这个地址用jsdelivr来访问https://cdn.jsdelivr.net/gh/yuDuChen/yuduchen@v1.5.6/layui/layui.js 对比一下就发现怎么用了吧注* 不使用jsdelivr直接引用github的文件 content-type 是 text/plain 页面无法解析 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"jQuery","slug":"jQuery","permalink":"https://melodyjerry.github.io/blog/tags/jQuery/"}],"author":{"name":"羽渡尘","url":"https://blog.csdn.net/qq_36910987/article/details/89562291"}},{"title":"蓝桥杯-基础练习-01字串","slug":"蓝桥杯-基础练习-01字串","date":"2020-02-07T13:24:17.000Z","updated":"2020-02-08T10:53:52.613Z","comments":true,"path":"2020/02/07/蓝桥杯-基础练习-01字串/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-01%E5%AD%97%E4%B8%B2/","excerpt":"在刷蓝桥杯试题时候，有一道很意思又有丶烧脑的题目👇 资源限制时间限制：1.0s 内存限制：256.0MB 问题描述对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是： 00000 00001 00010 00011 00100 请按从小到大的顺序输出这32种01串。 输入格式本试题没有输入。 输出格式输出32行，按从小到大的顺序每行一个长度为5的01串。 样例输出00000000010001000011&lt;以下部分省略&gt;","text":"在刷蓝桥杯试题时候，有一道很意思又有丶烧脑的题目👇 资源限制时间限制：1.0s 内存限制：256.0MB 问题描述对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是： 00000 00001 00010 00011 00100 请按从小到大的顺序输出这32种01串。 输入格式本试题没有输入。 输出格式输出32行，按从小到大的顺序每行一个长度为5的01串。 样例输出00000000010001000011&lt;以下部分省略&gt; 提交代码（Java）暴力输出刚开始想不出什么好办法，就直接把32个都写出来。抱着玩的心态，试试暴力输出看看系统给不给过，但是没想到，还真给我过了hhh 123456789101112131415161718192021222324252627282930313233343536public class Main { public static void main(String[] args) { System.out.println(\"00000\"); System.out.println(\"00001\"); System.out.println(\"00010\"); System.out.println(\"00011\"); System.out.println(\"00100\"); System.out.println(\"00101\"); System.out.println(\"00110\"); System.out.println(\"00111\"); System.out.println(\"01000\"); System.out.println(\"01001\"); System.out.println(\"01010\"); System.out.println(\"01011\"); System.out.println(\"01100\"); System.out.println(\"01101\"); System.out.println(\"01110\"); System.out.println(\"01111\"); System.out.println(\"10000\"); System.out.println(\"10001\"); System.out.println(\"10010\"); System.out.println(\"10011\"); System.out.println(\"10100\"); System.out.println(\"10101\"); System.out.println(\"10110\"); System.out.println(\"10111\"); System.out.println(\"11000\"); System.out.println(\"11001\"); System.out.println(\"11010\"); System.out.println(\"11011\"); System.out.println(\"11100\"); System.out.println(\"11101\"); System.out.println(\"11110\"); System.out.println(\"11111\"); }} 五层循环这是我想到的第二个方法，就类似说的“逢二进一”吧 1234567891011public class Main { public static void main(String[] args) { int a,b,c,d,e; for(a=0;a&lt;2;++a) for(b=0;b&lt;2;++b) for(c=0;c&lt;2;++c) for(d=0;d&lt;2;++d) for(e=0;e&lt;2;++e) System.out.printf(\"%d%d%d%d%d\\n\",a,b,c,d,e); }} 以下两种方法均来自网络。 十进制转换二进制12345678910111213public class Main { public static void main(String[] args) { for(int i=0;i&lt;32;i++){ int a,b,c,d,e; a = i%32/16; b = i%16/8; c = i%8/4; d = i%4/2; e = i%2; System.out.printf(\"%d%d%d%d%d\\n\",a,b,c,d,e); } }} 以下标求1一共是32个串，给每个串设置0-31的下标。根据下标，寻找对应串中1出现的位置。👇 比如，下标3表示的串是“00011”，利用while循环可以找到出现1的下标是1、2 12345678910111213141516171819public class Main { public static void main(String[] args) { for(int i=0;i&lt;=31;i++){ int a[]= new int[5];// 默认初始化值为0 //或 int a[]= {0,0,0,0,0}; int temp=i; int index=0; while(temp!=0) { a[index]=temp%2; index++; temp/=2; } for(int idx=4;idx&gt;=0;idx--) System.out.print(a[idx]); System.out.println(); } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://melodyjerry.github.io/blog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"使用fancybox标签实现图片浏览器","slug":"使用-fancybox-标签实现图片浏览器","date":"2020-02-07T12:42:55.000Z","updated":"2020-02-07T15:20:51.233Z","comments":true,"path":"2020/02/07/使用-fancybox-标签实现图片浏览器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/%E4%BD%BF%E7%94%A8-fancybox-%E6%A0%87%E7%AD%BE%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E5%99%A8/","excerpt":"使用&lt;fancybox&gt;&lt;/fancybox&gt;标签实现图片浏览器 单张图，只提供放大🔍关闭❌两个按钮，见黄色标记👇 多张图，可幻灯片播放，见红色标记👇","text":"使用&lt;fancybox&gt;&lt;/fancybox&gt;标签实现图片浏览器 单张图，只提供放大🔍关闭❌两个按钮，见黄色标记👇 多张图，可幻灯片播放，见红色标记👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"蓝桥杯-入门训练-Fibonacci数列","slug":"蓝桥杯—-入门训练-Fibonacci数列","date":"2020-02-07T11:48:54.000Z","updated":"2020-02-07T15:20:51.243Z","comments":true,"path":"2020/02/07/蓝桥杯—-入门训练-Fibonacci数列/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E2%80%94-%E5%85%A5%E9%97%A8%E8%AE%AD%E7%BB%83-Fibonacci%E6%95%B0%E5%88%97/","excerpt":"资源限制时间限制：1.0s 内存限制：256.0MB 问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 样例输入10 样例输出55 样例输入22 样例输出7704 数据规模与约定1 &lt;= n &lt;= 1,000,000。","text":"资源限制时间限制：1.0s 内存限制：256.0MB 问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 样例输入10 样例输出55 样例输入22 样例输出7704 数据规模与约定1 &lt;= n &lt;= 1,000,000。 提交代码（Java）第一次提交第一次时候，我想使用递归的方式👇 123456789101112131415161718import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(F(n)%10007); sc.close(); } private static int F(int n) { if(n==1||n==2) return 1; else return F(n-1)+F(n-2); }} 提交后，系统提示【运行超时】👇 第二次提交使用递归来处理，比较耗时。 而且这次我按照题目的提示【说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。】来处理，就改用数组来实现👇 1234567891011121314151617181920import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int F[] = new int[n+2]; F[1] = F[2] = 1; if(n &gt; 2) { for(int i=3; i&lt;=n; i++) // F[i]直接计算到求余数的值，即保存余数 F[i]=(F[i-1]+F[i-2])%10007; } //F[n]即所求值 System.out.println(F[n]); sc.close(); }} 这次直接通过👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://melodyjerry.github.io/blog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java之printf格式化输出的例子","slug":"Java之printf格式化输出的例子","date":"2020-02-07T09:46:23.000Z","updated":"2020-02-07T15:20:51.226Z","comments":true,"path":"2020/02/07/Java之printf格式化输出的例子/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/Java%E4%B9%8Bprintf%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%9A%84%E4%BE%8B%E5%AD%90/","excerpt":"转载自菜鸟教程","text":"转载自菜鸟教程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import java.util.Date; /** * 使用printf输出 *//**关键技术点 * 使用java.io.PrintStream的printf方法实现C风格的输出 * printf 方法的第一个参数为输出的格式,第二个参数是可变长的,表示待输出的数据对象 */public class Printf { public static void main(String[] args) { /*** 输出字符串 ***/ // %s表示输出字符串，也就是将后面的字符串替换模式中的%s System.out.printf(\"%s\", new Integer(1212)); // %n表示换行 System.out.printf(\"%s%n\", \"end line\"); // 还可以支持多个参数 System.out.printf(\"%s = %s%n\", \"Name\", \"Zhangsan\"); // %S将字符串以大写形式输出 System.out.printf(\"%S = %s%n\", \"Name\", \"Zhangsan\"); // 支持多个参数时，可以在%s之间插入变量编号，1$表示第一个字符串，3$表示第3个字符串 System.out.printf(\"%1$s = %3$s %2$s%n\", \"Name\", \"san\", \"Zhang\"); /*** 输出boolean类型 ***/ System.out.printf(\"true = %b; false = \", true); System.out.printf(\"%b%n\", false); /*** 输出整数类型***/ Integer iObj = 342; // %d表示将整数格式化为10进制整数 System.out.printf(\"%d; %d; %d%n\", -500, 2343L, iObj); // %o表示将整数格式化为8进制整数 System.out.printf(\"%o; %o; %o%n\", -500, 2343L, iObj); // %x表示将整数格式化为16进制整数 System.out.printf(\"%x; %x; %x%n\", -500, 2343L, iObj); // %X表示将整数格式化为16进制整数，并且字母变成大写形式 System.out.printf(\"%X; %X; %X%n\", -500, 2343L, iObj); /*** 输出浮点类型***/ Double dObj = 45.6d; // %e表示以科学技术法输出浮点数 System.out.printf(\"%e; %e; %e%n\", -756.403f, 7464.232641d, dObj); // %E表示以科学技术法输出浮点数，并且为大写形式 System.out.printf(\"%E; %E; %E%n\", -756.403f, 7464.232641d, dObj); // %f表示以十进制格式化输出浮点数 System.out.printf(\"%f; %f; %f%n\", -756.403f, 7464.232641d, dObj); // 还可以限制小数点后的位数 System.out.printf(\"%.1f; %.3f; %f%n\", -756.403f, 7464.232641d, dObj); /*** 输出日期类型***/ // %t表示格式化日期时间类型，%T是时间日期的大写形式，在%t之后用特定的字母表示不同的输出格式 Date date = new Date(); long dataL = date.getTime(); // 格式化年月日 // %t之后用y表示输出日期的年份（2位数的年，如99） // %t之后用m表示输出日期的月份，%t之后用d表示输出日期的日号 System.out.printf(\"%1$ty-%1$tm-%1$td; %2$ty-%2$tm-%2$td%n\", date, dataL); // %t之后用Y表示输出日期的年份（4位数的年）， // %t之后用B表示输出日期的月份的完整名， %t之后用b表示输出日期的月份的简称 System.out.printf(\"%1$tY-%1$tB-%1$td; %2$tY-%2$tb-%2$td%n\", date, dataL); // 以下是常见的日期组合 // %t之后用D表示以 \"%tm/%td/%ty\"格式化日期 System.out.printf(\"%1$tD%n\", date); //%t之后用F表示以\"%tY-%tm-%td\"格式化日期 System.out.printf(\"%1$tF%n\", date); /*** 输出时间类型***/ // 输出时分秒 // %t之后用H表示输出时间的时（24进制），%t之后用I表示输出时间的时（12进制）， // %t之后用M表示输出时间的分，%t之后用S表示输出时间的秒 System.out.printf(\"%1$tH:%1$tM:%1$tS; %2$tI:%2$tM:%2$tS%n\", date, dataL); // %t之后用L表示输出时间的秒中的毫秒 System.out.printf(\"%1$tH:%1$tM:%1$tS %1$tL%n\", date); // %t之后p表示输出时间的上午或下午信息 System.out.printf(\"%1$tH:%1$tM:%1$tS %1$tL %1$tp%n\", date); // 以下是常见的时间组合 // %t之后用R表示以\"%tH:%tM\"格式化时间 System.out.printf(\"%1$tR%n\", date); // %t之后用T表示以\"%tH:%tM:%tS\"格式化时间 System.out.printf(\"%1$tT%n\", date); // %t之后用r表示以\"%tI:%tM:%tS %Tp\"格式化时间 System.out.printf(\"%1$tr%n\", date); /*** 输出星期***/ // %t之后用A表示得到星期几的全称 System.out.printf(\"%1$tF %1$tA%n\", date); // %t之后用a表示得到星期几的简称 System.out.printf(\"%1$tF %1$ta%n\", date); // 输出时间日期的完整信息 System.out.printf(\"%1$tc%n\", date); }}/** *printf方法中,格式为\"%s\"表示以字符串的形式输出第二个可变长参数的第一个参数值; *格式为\"%n\"表示换行;格式为\"%S\"表示将字符串以大写形式输出;在\"%s\"之间用\"n$\"表示 *输出可变长参数的第n个参数值.格式为\"%b\"表示以布尔值的形式输出第二个可变长参数 *的第一个参数值. *//** * 格式为\"%d\"表示以十进制整数形式输出;\"%o\"表示以八进制形式输出;\"%x\"表示以十六进制 * 输出;\"%X\"表示以十六进制输出,并且将字母(A、B、C、D、E、F)换成大写.格式为\"%e\"表 * 以科学计数法输出浮点数;格式为\"%E\"表示以科学计数法输出浮点数,而且将e大写;格式为 * \"%f\"表示以十进制浮点数输出,在\"%f\"之间加上\".n\"表示输出时保留小数点后面n位. *//** * 格式为\"%t\"表示输出时间日期类型.\"%t\"之后用y表示输出日期的二位数的年份(如99)、用m * 表示输出日期的月份,用d表示输出日期的日号;\"%t\"之后用Y表示输出日期的四位数的年份 * (如1999)、用B表示输出日期的月份的完整名,用b表示输出日期的月份的简称.\"%t\"之后用D * 表示以\"%tm/%td/%ty\"的格式输出日期、用F表示以\"%tY-%tm-%td\"的格式输出日期. *//** * \"%t\"之后用H表示输出时间的时(24进制),用I表示输出时间的时(12进制),用M表示输出时间 * 分,用S表示输出时间的秒,用L表示输出时间的秒中的毫秒数、用 p 表示输出时间的是上午还是 * 下午.\"%t\"之后用R表示以\"%tH:%tM\"的格式输出时间、用T表示以\"%tH:%tM:%tS\"的格式输出 * 时间、用r表示以\"%tI:%tM:%tS %Tp\"的格式输出时间. *//** * \"%t\"之后用A表示输出日期的全称,用a表示输出日期的星期简称. */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}],"author":{"name":"菜鸟教程","url":"https://www.runoob.com/"}},{"title":"给博客添加一些挂件","slug":"转-给博客添加一些挂件","date":"2020-02-05T14:40:27.000Z","updated":"2020-02-07T15:20:51.247Z","comments":true,"path":"2020/02/05/转-给博客添加一些挂件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/%E8%BD%AC-%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E6%8C%82%E4%BB%B6/","excerpt":"阅读了官方文档 和 TRHX‘S BLOG 等文档/文章后，搜集了一部分教程","text":"阅读了官方文档 和 TRHX‘S BLOG 等文档/文章后，搜集了一部分教程 自定义鼠标指针样式在 \\themes\\material-x\\source\\less\\_base.less 文件 body 样式里写入如下代码： 123456body { cursor: url(https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur),auto; background-color: @theme_background; ...... ......} 鼠标指针可以用 Axialis CursorWorkshop 这个软件自己制作，不同主题具体放的文件有所不同，确保在博客主体 body 的 CSS 文件中即可，其中的鼠标指针链接可替换成自己的，首先尝试加载 https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur ，如果该文件不存在或由于其他原因无效，那么 auto 会被使用，也就是自动默认效果，图片格式为.ico、.ani、.cur，建议使用.cur，如果使用.ani或者其他格式无效，原因是浏览器兼容问题，请阅读参考文档或者参考以下兼容表： 浏览器 最低版本 格式 Internet Explorer 6.0 .cur / .ani Firefox (Gecko), Windows and Linux 1.5 (1.8) .cur / .png / .gif / .jpg Firefox (Gecko) 4.0 (2.0) .cur / .png / .gif / .jpg / .svg Opera — — Safari (Webkit) 3.0 (522-523) .cur / .png / .gif / .jpg 拓展阅读：《CSS 鼠标样式 cursor属性》 （By：歪脖先生的博客） 打字特效（蓝色）123456&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.11\"&gt;&lt;/script&gt; &lt;script&gt;var typed = new Typed(\"#subtitle\", { strings: [\"Live a good life, write some good code !!!\", \"愿自己的努力终将获得回报。\", \"花开不是为了花落，而是为了开的更加灿烂。\", \"没有伞的孩子必须努力奔跑！\", \"欲望以提升热忱，毅力以磨平高山。\", \"如果放弃太早，你永远都不知道自己会错过什么。\", \"没有礁石，就没有美丽的浪花；没有挫折，就没有壮丽的人生。\"], startDelay: 1000, typeSpeed: 100, loop: !0, backSpeed: 60, backDelay: 2000, showCursor: !0 })&lt;/script&gt;&lt;div style=\"text-align: center;font-weight: bold;color: #1BC3FB;\"&gt; &lt;span id=\"subtitle\"&gt;没有伞的孩子必须努力奔跑！&lt;/span&gt;&lt;span class=\"typed-cursor typed-cursor--blink\"&gt;|&lt;/span&gt; &lt;span id=\"typed-cursor\"&gt;&lt;/span&gt; &lt;/div&gt; 效果 👇 var typed = new Typed(\"#subtitle\", { strings: [\"Live a good life, write some good code !!!\", \"愿自己的努力终将获得回报。\", \"花开不是为了花落，而是为了开的更加灿烂。\", \"没有伞的孩子必须努力奔跑！\", \"欲望以提升热忱，毅力以磨平高山。\", \"如果放弃太早，你永远都不知道自己会错过什么。\", \"没有礁石，就没有美丽的浪花；没有挫折，就没有壮丽的人生。\"], startDelay: 1000, typeSpeed: 100, loop: !0, backSpeed: 60, backDelay: 2000, showCursor: !0 }) 没有伞的孩子必须努力奔跑！| 网站访客地理信息 在.\\themes\\material-x\\layout\\layout.ejs中加入以下代码： 12&lt;!--网站访客地理信息--&gt;&lt;script type=\"text/javascript\" src=\"//rf.revolvermaps.com/0/0/8.js?i=5eqiqb8vl6p&amp;amp;m=2&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=33&amp;amp;z=17&amp;amp;rx=-40&amp;amp;lx=-540&amp;amp;ly=520&amp;amp;hi=60\" async=\"async\"&gt;&lt;/script&gt; 效果 👇 天气挂件 JS代码，用于将插件插入到网页内 123456789101112131415&lt;div id=\"tp-weather-widget\"&gt;&lt;/div&gt; &lt;script&gt; (function(a,h,g,f,e,d,c,b){b=function(){d=h.createElement(g);c=h.getElementsByTagName(g)[0];d.src=e;d.charset=\"utf-8\";d.async=1;c.parentNode.insertBefore(d,c)};a[\"SeniverseWeatherWidgetObject\"]=f;a[f]||(a[f]=function(){(a[f].q=a[f].q||[]).push(arguments)});a[f].l=+new Date();if(a.attachEvent){a.attachEvent(\"onload\",b)}else{a.addEventListener(\"load\",b,false)}}(window,document,\"script\",\"SeniverseWeatherWidget\",\"//cdn.sencdn.com/widget2/static/js/bundle.js?t=\"+parseInt((new Date().getTime() / 100000000).toString(),10))); window.SeniverseWeatherWidget('show', { flavor: \"bubble\", location: \"WS0E9D8WN298\", geolocation: true, language: \"zh-Hans\", unit: \"c\", theme: \"auto\", token: \"5fd5b254-57fe-4f8a-8a13-f92485efeb0b\", hover: \"enabled\", container: \"tp-weather-widget\" }) &lt;/script&gt; 插件网页版链接，用于嵌入到iframe或webview中 1&lt;iframe&gt;weather.seniverse.com/?token=5fd5b254-57fe-4f8a-8a13-f92485efeb0b&lt;/iframe&gt; 效果：见本博客页面左上角 背景添加动态线条效果在 .\\themes\\hexo-theme-spfk\\layout\\layout.ejs文件中添加如下代码： 1234&lt;!--动态线条背景--&gt;&lt;script type=\"text/javascript\"color=\"220,220,220\" opacity='0.7' zIndex=\"-2\" count=\"200\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt; 其中： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0） opacity：表示线条透明度（0~1），默认：0.5 count：表示线条的总数量，默认：150 zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1 人体时钟无意中发现了个有趣的人体时钟 HONE HONE CLOCK，作者是个日本人，点击此处访问作者博客，点击此处在作者原博客上查看动态样式，点击此处查看动态大图，如果你的博客上有合适的地方，加上一个人体时钟会很有趣的 实现代码： 12345&lt;!--人体时钟背景透明--&gt;&lt;script charset=\"Shift_JIS\" src=\"http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.js\"&gt;&lt;/script&gt;&lt;!--人体时钟背景白--&gt;&lt;script charset=\"Shift_JIS\" src=\"http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.js\"&gt;&lt;/script&gt; 背景动态彩带效果样式一是鼠标点击后彩带自动更换样式，样式二是飘动的彩带： 实现方法：在 \\themes\\material-x\\layout\\layout.ejs 文件的body前面添加如下代码： 12&lt;!-- 样式一（鼠标点击更换样式） --&gt;&lt;script src=\"https://g.joyinshare.com/hc/ribbon.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 12&lt;!-- 样式二（飘动的彩带） --&gt;&lt;script src=\"https://g.joyinshare.com/hc/piao.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 添加背景代码雨特效新建 DigitalRain.js，写入以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657复制window.onload = function(){ //获取画布对象 var canvas = document.getElementById(\"canvas\"); //获取画布的上下文 var context =canvas.getContext(\"2d\"); var s = window.screen; var W = canvas.width = s.width; var H = canvas.height; //获取浏览器屏幕的宽度和高度 //var W = window.innerWidth; //var H = window.innerHeight; //设置canvas的宽度和高度 canvas.width = W; canvas.height = H; //每个文字的字体大小 var fontSize = 12; //计算列 var colunms = Math.floor(W /fontSize); //记录每列文字的y轴坐标 var drops = []; //给每一个文字初始化一个起始点的位置 for(var i=0;i&lt;colunms;i++){ drops.push(0); } //运动的文字 var str =\"WELCOME TO WWW.ITRHX.COM\"; //4:fillText(str,x,y);原理就是去更改y的坐标位置 //绘画的函数 function draw(){ context.fillStyle = \"rgba(238,238,238,.08)\";//遮盖层 context.fillRect(0,0,W,H); //给字体设置样式 context.font = \"600 \"+fontSize+\"px Georgia\"; //给字体添加颜色 context.fillStyle = [\"#33B5E5\", \"#0099CC\", \"#AA66CC\", \"#9933CC\", \"#99CC00\", \"#669900\", \"#FFBB33\", \"#FF8800\", \"#FF4444\", \"#CC0000\"][parseInt(Math.random() * 10)];//randColor();可以rgb,hsl, 标准色，十六进制颜色 //写入画布中 for(var i=0;i&lt;colunms;i++){ var index = Math.floor(Math.random() * str.length); var x = i*fontSize; var y = drops[i] *fontSize; context.fillText(str[index],x,y); //如果要改变时间，肯定就是改变每次他的起点 if(y &gt;= canvas.height &amp;&amp; Math.random() &gt; 0.99){ drops[i] = 0; } drops[i]++; } }; function randColor(){//随机颜色 var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return \"rgb(\"+r+\",\"+g+\",\"+b+\")\"; } draw(); setInterval(draw,35);}; 在主题文件的相关css文件中（以 Material X 1.2.1 主题为例，在\\themes\\material-x-1.2.1\\source\\less_main.less 文件末尾）添加以下代码： 12345678910复制canvas { position: fixed; right: 0px; bottom: 0px; min-width: 100%; min-height: 100%; height: auto; width: auto; z-index: -1;} 然后在主题的 layout.ejs 文件中引入即可： 123复制&lt;!-- 数字雨 --&gt;&lt;canvas id=\"canvas\" width=\"1440\" height=\"900\" &gt;&lt;/canvas&gt;&lt;script type=\"text/javascript\" src=\"/js/DigitalRain.js\"&gt;&lt;/script&gt; 最终效果： 自定义一个不使用主题模板渲染的独立页面 有时候我们需要新建一个独立的页面，这个页面不使用主题的渲染，具有自己独立的样式，可以放一些自己的作品，相册什么的，以下就介绍这种独立页面的实现方法。 方法一： 使用 Hexo 提供的跳过渲染配置，在博客根目录的配置文件 _config.yml 里找到 skip_render 关键字，在后面添加想要跳过渲染的页面，比如我们创建 \\source\\about\\index.html， 配置文件填写：skip_render: about\\**，那么就表示 \\source\\about 里所有的文件将跳过渲染，里面的文件将会被直接复制到 public 文件夹，此时就会得到一个独立的 about 页面；官方文档：https://hexo.io/docs/configuration 方法二： 在文章头部的 Front-matter 里添加配置 layout: false 来跳过渲染配置，比如我们要使 about 页面跳过渲染，创建 \\source\\about\\index.md，将这个页面的相关 HTML 代码写进.md文件并保存，然后在 index.md 的头部写入： 123456789---layout: false---{% raw %}这里是 HTML 代码{% endraw %} PS：Front-matter 是 .md 文件最上方以 — 分隔的区域，用于指定个别文件的变量，官方文档：https://hexo.io/docs/front-matter 效果可以对比我的博客主页和关于页面 更改本地预览端口号hexo博客在执行 hexo s 进行本地预览的时候，默认端口号是4000，当该端口号被占用时会报错 Error: listen EADDRINUSE 0.0.0.0:4000 ，此时可以关闭占用该端口的进程，也可以更换端口号，更换端口号可以通过以下两种方法实现： 方法一：在根目录的 _config.yml 配置文件内加上如下代码更改 hexo s 运行时的端口号： 1234server: port: 5000 compress: true header: true 方法二：通过 hexo server -p 5000 命令来指定端口，这种方法只是本次执行有效 其他网页小挂件推荐 http://abowman.com/ 里面有很多有趣的小挂件，可以养养鱼、龟、狗、仓鼠等各式各样的虚拟宠物，能根据你的鼠标指针位置移动，直接复制代码就可以用 http://www.revolvermaps.com/ 它提供网站访客地理信息，可以以2D、3D等形式显示 http://www.amazingcounters.com/ 免费网站计数器，有非常多的样式供你选择，可以设置计数器初始数值，可以设置按访问量计数，也可以按独立访问者计数 https://www.seniverse.com/widget/get 心知天气提供基于Web的免费天气插件，可以为你的网站添加一项简洁美观的天气预报功能，并自动适配PC和手机上的浏览 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"[转]使用Hexo-Git-Backup插件备份你的Hexo博客","slug":"转-使用Hexo-Git-Backup插件备份你的Hexo博客","date":"2020-02-05T12:20:43.000Z","updated":"2020-02-07T15:20:51.244Z","comments":true,"path":"2020/02/05/转-使用Hexo-Git-Backup插件备份你的Hexo博客/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/%E8%BD%AC-%E4%BD%BF%E7%94%A8Hexo-Git-Backup%E6%8F%92%E4%BB%B6%E5%A4%87%E4%BB%BD%E4%BD%A0%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/","excerpt":"欢迎关注我的 CSDN 专栏：《个人博客搭建：Hexo+Github Pages》，从搭建到美化一条龙，帮你解决 Hexo 常见问题！ 由于 Hexo 博客是静态托管的，所有的原始数据都保存在本地，如果哪一天电脑坏了，或者是误删了本地数据，那就是叫天天不应叫地地不灵了，此时定时备份就显得比较重要了，常见的备份方法有：打包数据保存到U盘、云盘或者其他地方，但是早就有大神开发了备份插件：hexo-git-backup ，只需要一个命令就可以将所有数据包括主题文件备份到 github 了","text":"欢迎关注我的 CSDN 专栏：《个人博客搭建：Hexo+Github Pages》，从搭建到美化一条龙，帮你解决 Hexo 常见问题！ 由于 Hexo 博客是静态托管的，所有的原始数据都保存在本地，如果哪一天电脑坏了，或者是误删了本地数据，那就是叫天天不应叫地地不灵了，此时定时备份就显得比较重要了，常见的备份方法有：打包数据保存到U盘、云盘或者其他地方，但是早就有大神开发了备份插件：hexo-git-backup ，只需要一个命令就可以将所有数据包括主题文件备份到 github 了 首先进入你博客目录，输入命令 hexo version 查看 Hexo 版本，如图所示，我的版本是 3.7.1： 安装备份插件，如果你的 Hexo 版本是 2.x.x，则使用以下命令安装： 1$ npm install hexo-git-backup@0.0.91 --save 如果你的 Hexo 版本是 3.x.x，则使用以下命令安装： 1$ npm install hexo-git-backup --save 到 Hexo 博客根目录的 _config.yml 配置文件里添加以下配置： 1234567backup: type: git theme: material-x-1.2.1 message: Back up my www.itrhx.com blog repository: github: git@github.com:TRHX/TRHX.github.io.git,backup coding: git@git.dev.tencent.com:TRHX/TRHX.git,backup 参数解释： theme：你要备份的主题名称 message：自定义提交信息 repository：仓库名，注意仓库地址后面要添加一个分支名，比如我就创建了一个 backup 分支 最后使用以下命令备份你的博客： 1$ hexo backup 或者使用以下简写命令也可以： 1$ hexo b 备份成功后可以在你的仓库分支下看到备份的原始文件： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}],"author":{"name":"TRHX","avatar":"https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.9/images/trhx.png","url":"https://www.itrhx.com/"}},{"title":"RSS订阅(含转载内容)","slug":"RSS订阅-含转载内容","date":"2020-02-05T12:06:45.000Z","updated":"2020-02-07T15:20:51.229Z","comments":true,"path":"2020/02/05/RSS订阅-含转载内容/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/RSS%E8%AE%A2%E9%98%85-%E5%90%AB%E8%BD%AC%E8%BD%BD%E5%86%85%E5%AE%B9/","excerpt":"添加RSS订阅RSS订阅是站点用来和其他站点之间共享内容的一种简易方式，即Really Simple Syndication（简易信息聚合），如果不会使用，可以参见百度百科：https://baike.baidu.com/item/RSS%E8%AE%A2%E9%98%85/663114 ；首先我们安装feed插件，在本地hexo目录下右键git bash here，输入以下命令： 1$ npm install hexo-generator-feed 等待安装完成后，打开hexo目录下配置文件的_config.yml，在末尾添加以下配置： 12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 随后打开主题配置文件_config.yml，添加以下配置： 1rss: /atom.xml 至此，RSS订阅功能添加完成 【注】以下内容转载自互联网，其作者：奔跑中的奶酪 《可能是目前最全的RSS订阅源了》导读继上一篇文章《当我们谈论RSS时，我们在谈论什么？ 》发布后，阅读甚少，反响也是平平。奶酪不得不承认一个事实，RSS 做为一种“上古神器”，如果你经历过 RSS 的风光时期，你会一直喜欢它。但如果你对它了解甚少，尽管我再如何推荐，高使用门槛还是很难让你对RSS喜欢得起来。 RSS 高门槛的主要原因在于，优质RSS阅读器选择少，以及订阅源的缺失。上一期我极力推荐了一款在线 RSS 阅读器 Feeder.co，它已经足够的优秀了。所以接下来的问题，就是解决如何寻找订阅源的问题了，而本期内容正是解决如何查找RSS 订阅源的问题。","text":"添加RSS订阅RSS订阅是站点用来和其他站点之间共享内容的一种简易方式，即Really Simple Syndication（简易信息聚合），如果不会使用，可以参见百度百科：https://baike.baidu.com/item/RSS%E8%AE%A2%E9%98%85/663114 ；首先我们安装feed插件，在本地hexo目录下右键git bash here，输入以下命令： 1$ npm install hexo-generator-feed 等待安装完成后，打开hexo目录下配置文件的_config.yml，在末尾添加以下配置： 12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 随后打开主题配置文件_config.yml，添加以下配置： 1rss: /atom.xml 至此，RSS订阅功能添加完成 【注】以下内容转载自互联网，其作者：奔跑中的奶酪 《可能是目前最全的RSS订阅源了》导读继上一篇文章《当我们谈论RSS时，我们在谈论什么？ 》发布后，阅读甚少，反响也是平平。奶酪不得不承认一个事实，RSS 做为一种“上古神器”，如果你经历过 RSS 的风光时期，你会一直喜欢它。但如果你对它了解甚少，尽管我再如何推荐，高使用门槛还是很难让你对RSS喜欢得起来。 RSS 高门槛的主要原因在于，优质RSS阅读器选择少，以及订阅源的缺失。上一期我极力推荐了一款在线 RSS 阅读器 Feeder.co，它已经足够的优秀了。所以接下来的问题，就是解决如何寻找订阅源的问题了，而本期内容正是解决如何查找RSS 订阅源的问题。 一、万物皆可RSS如果你细心观察就会发现，提供 RSS 相关服务的网站都是国外的，国内与 RSS 相关的网站都相继宣布关闭了。你会发现国内提供 RSS 相关服务的网站都是个人或者小机构，这其中有一个叫 RSSHub 的网站，是这其中的集大成者，它的作用是可以给任何奇奇怪怪的内容生成 RSS 订阅源。 一般网站和博客： 1). 通常在顶部菜单、右侧菜单、底部菜单等地方会有RSS图标。 2). 如果没有，可以尝试在网站地址后面加上/rss或者/feed，有时会出现在二级域名里。 3). 如果还没有，可以使用奶酪制作的小书签来自动查找RSS订阅源，","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"将本地文件上传到GitHub","slug":"将本地文件上传到Github","date":"2020-02-05T11:28:23.000Z","updated":"2020-02-08T09:22:16.587Z","comments":true,"path":"2020/02/05/将本地文件上传到Github/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0Github/","excerpt":"百度“如何将文件上传到Github”，其中发现两篇很有用的教程： 使用git将项目上传到github（最简单方法）如何使用git把本地代码上传（更新）到github上","text":"百度“如何将文件上传到Github”，其中发现两篇很有用的教程： 使用git将项目上传到github（最简单方法）如何使用git把本地代码上传（更新）到github上 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"}]},{"title":"浏览器网页标签页图标显示","slug":"浏览器网页标签页图标显示","date":"2020-02-04T12:20:00.000Z","updated":"2020-02-07T15:20:51.240Z","comments":true,"path":"2020/02/04/浏览器网页标签页图标显示/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E9%A1%B5%E6%A0%87%E7%AD%BE%E9%A1%B5%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA/","excerpt":"","text":"对于IE浏览器：把需要显示的16x16像素的ICO图标命名为favicon.ICO放置在网站根目录下，浏览器会自动检索 对于其他浏览器通用的在标签页加入指定图标的方法：把favicon.ico图标放到网站根目录下，在网页的``&lt;head&gt;&lt;/head&gt;``中加入 1234&lt;!-- 地址栏显示 --&gt;&lt;link rel=\"Shortcut Icon\" href=\"./favicon.ico\" type=\"image/x-icon\" /&gt;&lt;!-- 收藏栏也显示 --&gt;&lt;link rel=\"Bookmark\" href=\"./favicon.ico\" type=\"image/x-icon\" /&gt; 火狐浏览器对图标格式没有那么严格，GIF和PNG格式的图标也可以显示，图标名称也可以不是favcion 链接在线的图片 1&lt;link rel=\"Shortcut Icon\" href=\"http://csdnimg.cn/www/images/favicon.ico\"&gt; 获取ico图标的资源网 http://sc.chinaz.com/ favicon在线制作网站 https://tool.lu/favicon/ 图标制作，经常搞一些图标替换桌面图标 http://www.faviconico.org/ 或者在html的head表头中加 &lt;link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\" /&gt; 如果icon是gif动态图需要修改type属性 &lt;link rel=\"icon\" href=\"gif_favicon.gif\" type=\"image/gif\" &gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"}]},{"title":"文章作者","slug":"文章作者","date":"2020-02-03T09:36:53.000Z","updated":"2020-02-08T09:37:28.999Z","comments":true,"path":"2020/02/03/文章作者/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E4%BD%9C%E8%80%85/","excerpt":"由于支持多作者共同维护一个博客，所以可以设置单独一篇文章的作者： 123456---author: name: 作者 avatar: https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png url: https://baidu.com---","text":"由于支持多作者共同维护一个博客，所以可以设置单独一篇文章的作者： 123456---author: name: 作者 avatar: https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png url: https://baidu.com--- document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"文章置顶","slug":"文章置顶","date":"2020-02-03T09:34:15.000Z","updated":"2020-02-08T09:36:28.899Z","comments":true,"path":"2020/02/03/文章置顶/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6/","excerpt":"在Front-matter中设置以下值： 1top: true 如果想自定义置顶标签的文字，可以直接设置为字符串，例如： 1top: 近期更新","text":"在Front-matter中设置以下值： 1top: true 如果想自定义置顶标签的文字，可以直接设置为字符串，例如： 1top: 近期更新 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"文章分类","slug":"文章分类","date":"2020-02-03T09:34:05.000Z","updated":"2020-02-08T09:36:28.898Z","comments":true,"path":"2020/02/03/文章分类/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/","excerpt":"多个分类有两种关系，一种是层级（等同于文件夹），一种是并列（等同于标签）。 多级分类 1categories: [分类A, 分类B] 或者 123categories: - 分类A - 分类B 并列分类 123categories: - [分类A] - [分类B] 多级+并列分类 123categories: - [分类A, 分类B] - [分类C, 分类D]","text":"多个分类有两种关系，一种是层级（等同于文件夹），一种是并列（等同于标签）。 多级分类 1categories: [分类A, 分类B] 或者 123categories: - 分类A - 分类B 并列分类 123categories: - [分类A] - [分类B] 多级+并列分类 123categories: - [分类A, 分类B] - [分类C, 分类D] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"文章音乐bgm","slug":"文章音乐bgm","date":"2020-02-03T09:14:27.000Z","updated":"2020-02-08T09:40:09.545Z","comments":true,"path":"2020/02/03/文章音乐bgm/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E9%9F%B3%E4%B9%90bgm/","excerpt":"标题右边显示迷你音乐播放器，支持的字段有：server、type、id，取值详见【进阶设定 -&gt; 第三方服务 -&gt; APlayer】。 示例1234567---music: enable: true # true（文章内和文章列表都显示） internal（只在文章内显示） server: netease # netease（网易云音乐）tencent（QQ音乐） xiami（虾米） kugou（酷狗） type: song # song （单曲） album （专辑） playlist （歌单） search （搜索） id: 26664345 # 歌曲/专辑/歌单 ID--- 实际效果见：《文章专属BGM》","text":"标题右边显示迷你音乐播放器，支持的字段有：server、type、id，取值详见【进阶设定 -&gt; 第三方服务 -&gt; APlayer】。 示例1234567---music: enable: true # true（文章内和文章列表都显示） internal（只在文章内显示） server: netease # netease（网易云音乐）tencent（QQ音乐） xiami（虾米） kugou（酷狗） type: song # song （单曲） album （专辑） playlist （歌单） search （搜索） id: 26664345 # 歌曲/专辑/歌单 ID--- 实际效果见：《文章专属BGM》 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"添加CNZZ统计代码","slug":"添加CNZZ统计代码","date":"2020-02-03T08:13:53.000Z","updated":"2020-02-07T15:20:51.245Z","comments":true,"path":"2020/02/03/添加CNZZ统计代码/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%B7%BB%E5%8A%A0CNZZ%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/","excerpt":"先在博客主题配置文件themes\\material-x_config.yml添加代码： 12#添加CNZZ统计cnzz: true 这里这个cnzz的名字可以自己取；然后在themes\\material-x\\layout_partial里面创建一个 cnzz.ejs文件；把cnzz给的代码复制进去； 123&lt;% if (theme.cnzz){ %&gt; //这里添加复制的CNZZ代码&lt;% } %&gt; 然后再在footer.ejs的后面添加上一行代码就可以显示了（这里的位置可以换，可以不是scripts.ejs，或者是head.ejs，看自己的喜好） 12&lt;!--CNZZ统计--&gt;&lt;%- partial('cnzz') %&gt; 对百度统计也可以进行同样的处理； 123&lt;% if (theme.cnzz){ %&gt;//前面要添加的代码//百度统计的代码&lt;% } %&gt; 与上面的操作基本一致只是取得名字不一样。 上面的是一种方法； 如果嫌麻烦的话直接就在footer.ejs的后面添加cnzz的代码；直接就可以显示了（同理，可以添加在其他位置），貌似添加在这里速度最快。 123&lt;% if (theme.cnzz){ %&gt; //前面要添加的代码//这里添加复制的CNZZ代码&lt;% } %&gt; //后面要添加的 参考链接：https://blog.csdn.net/whjkm/article/details/37884563","text":"先在博客主题配置文件themes\\material-x_config.yml添加代码： 12#添加CNZZ统计cnzz: true 这里这个cnzz的名字可以自己取；然后在themes\\material-x\\layout_partial里面创建一个 cnzz.ejs文件；把cnzz给的代码复制进去； 123&lt;% if (theme.cnzz){ %&gt; //这里添加复制的CNZZ代码&lt;% } %&gt; 然后再在footer.ejs的后面添加上一行代码就可以显示了（这里的位置可以换，可以不是scripts.ejs，或者是head.ejs，看自己的喜好） 12&lt;!--CNZZ统计--&gt;&lt;%- partial('cnzz') %&gt; 对百度统计也可以进行同样的处理； 123&lt;% if (theme.cnzz){ %&gt;//前面要添加的代码//百度统计的代码&lt;% } %&gt; 与上面的操作基本一致只是取得名字不一样。 上面的是一种方法； 如果嫌麻烦的话直接就在footer.ejs的后面添加cnzz的代码；直接就可以显示了（同理，可以添加在其他位置），貌似添加在这里速度最快。 123&lt;% if (theme.cnzz){ %&gt; //前面要添加的代码//这里添加复制的CNZZ代码&lt;% } %&gt; //后面要添加的 参考链接：https://blog.csdn.net/whjkm/article/details/37884563 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"即日起，博客双平台同步发布","slug":"即日起，博客双平台同步发布","date":"2020-02-03T05:36:56.000Z","updated":"2020-02-09T13:21:26.845Z","comments":true,"path":"2020/02/03/即日起，博客双平台同步发布/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E5%8D%B3%E6%97%A5%E8%B5%B7%EF%BC%8C%E5%8D%9A%E5%AE%A2%E5%8F%8C%E5%B9%B3%E5%8F%B0%E5%90%8C%E6%AD%A5%E5%8F%91%E5%B8%83/","excerpt":"为了确保博客网站的连接，经历6h的打造，现新增Gitee版，目前两个可用博客如下： Hexo+Github 版 https://melodyhub.ltd/ Hexo+Gitee 版 https://melodyjerry.gitee.io/（新增） 值得注意的是，除去连接速度的差异外，两个网站的区别： 后增的Gitee版暂无HomePage（动画主页），后续会计划加入 计划加入一些新的动画、特效等 优化部分cdn 调整卡片的透明度，计划值：80% 其他，略","text":"为了确保博客网站的连接，经历6h的打造，现新增Gitee版，目前两个可用博客如下： Hexo+Github 版 https://melodyhub.ltd/ Hexo+Gitee 版 https://melodyjerry.gitee.io/（新增） 值得注意的是，除去连接速度的差异外，两个网站的区别： 后增的Gitee版暂无HomePage（动画主页），后续会计划加入 计划加入一些新的动画、特效等 优化部分cdn 调整卡片的透明度，计划值：80% 其他，略 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"[转]Hexo 博客主题个性化","slug":"[转]Hexo 博客主题个性化","date":"2020-02-02T06:25:47.000Z","updated":"2020-02-07T15:20:51.231Z","comments":true,"path":"2020/02/02/[转]Hexo 博客主题个性化/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/02/[%E8%BD%AC]Hexo%20%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96/","excerpt":"permalink: https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/ 以下为原文的摘要： 本文将讲述一些博客主题的美化、实用功能的添加，本文以作者 luuman 的 spfk 主题和作者 xaoxuu 的 Material X 主题为例，文章会不定时进行更新。文章涉及有关参考资料、教程、链接如有侵权请联系我删除！ 本文在CSDN的链接：《Hexo 博客优化之博客美化》、《Hexo 博客优化之实用功能添加》，Hexo 博客专栏，从前期搭建到后期美化，帮您解决常见问题：《Github/Coding Pages + Hexo》，对您有帮助就点个赞吧❤️ 请注意：不同主题可能方法有些不同，相同主题不同版本，配置方法也有所差异！ 博客美化前提条件：有一定的前端基础，了解 HTML、CSS、JS，了解 CSS 预处理语言 Sass、Less、Stylus，搞懂 hexo 的目录结构。 博客美化通用步骤：选定主题，认真阅读主题文档，分析主题目录结构，了解每个文件是对应网页哪个部分的，认真阅读美化教程，美化教程本质上只为你提供核心代码和思路，具体代码要添加到哪个地方，需要你自己搞懂主题结构，添加到需要的、合适的位置！ 博客美化终极奥秘：创作第一，体验第二，避免繁杂，简洁为上！","text":"permalink: https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/ 以下为原文的摘要： 本文将讲述一些博客主题的美化、实用功能的添加，本文以作者 luuman 的 spfk 主题和作者 xaoxuu 的 Material X 主题为例，文章会不定时进行更新。文章涉及有关参考资料、教程、链接如有侵权请联系我删除！ 本文在CSDN的链接：《Hexo 博客优化之博客美化》、《Hexo 博客优化之实用功能添加》，Hexo 博客专栏，从前期搭建到后期美化，帮您解决常见问题：《Github/Coding Pages + Hexo》，对您有帮助就点个赞吧❤️ 请注意：不同主题可能方法有些不同，相同主题不同版本，配置方法也有所差异！ 博客美化前提条件：有一定的前端基础，了解 HTML、CSS、JS，了解 CSS 预处理语言 Sass、Less、Stylus，搞懂 hexo 的目录结构。 博客美化通用步骤：选定主题，认真阅读主题文档，分析主题目录结构，了解每个文件是对应网页哪个部分的，认真阅读美化教程，美化教程本质上只为你提供核心代码和思路，具体代码要添加到哪个地方，需要你自己搞懂主题结构，添加到需要的、合适的位置！ 博客美化终极奥秘：创作第一，体验第二，避免繁杂，简洁为上！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}],"author":{"name":"TRHX","avatar":"https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.9/images/trhx.png","url":"https://www.itrhx.com/"}},{"title":"[转]如何搭建基于Hexo的独立博客","slug":"[转]如何搭建基于Hexo的独立博客","date":"2020-02-01T06:25:47.000Z","updated":"2020-02-07T15:20:51.230Z","comments":true,"path":"2020/02/01/[转]如何搭建基于Hexo的独立博客/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/01/[%E8%BD%AC]%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/","excerpt":"permalink: https://xaoxuu.com/blog/2017-07-05-hexo-blog/","text":"permalink: https://xaoxuu.com/blog/2017-07-05-hexo-blog/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}],"author":{"name":"xaoxuu","avatar":"https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png","url":"https://xaoxuu.com"}},{"title":"第一个除夕","slug":"第一个除夕","date":"2020-01-24T10:15:53.000Z","updated":"2020-02-08T09:30:11.038Z","comments":true,"path":"2020/01/24/第一个除夕/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/01/24/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%99%A4%E5%A4%95/","excerpt":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！”","text":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"再见2019，你好2020","slug":"再见，2019；你好，2020","date":"2019-12-31T16:00:00.000Z","updated":"2019-12-31T14:49:27.649Z","comments":true,"path":"2020/01/01/再见，2019；你好，2020/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/01/01/%E5%86%8D%E8%A7%81%EF%BC%8C2019%EF%BC%9B%E4%BD%A0%E5%A5%BD%EF%BC%8C2020/","excerpt":"前言这是作为我2019年最后一年博客，同时是2020的第一篇博客。 起手写这篇博客时候是2019年12月晚上8点57分，距离2019的结束约3个小时👇","text":"前言这是作为我2019年最后一年博客，同时是2020的第一篇博客。 起手写这篇博客时候是2019年12月晚上8点57分，距离2019的结束约3个小时👇 概括用一个词来概括我的2019年，我想到的是“酸甜苦辣咸”。 没错，我整一年的经历就和这五种味道一样，多而杂…… 我在成长的路上，一步一步地，独自前进…… 没错，独自，我甚至是常常自己对自己聊天。 我的微信置顶是自己，把想说的就发给自己，这样舒服些了👇 基本每天都有，随笔、想说的话、计划、临时的想法……👇 这一年来到现在，因为经历、看清一些事情后，我性格有所改变，为人处事有了较大的变化。 最为突出的就是暑假和国庆这两段时间，我对我自己“重新洗牌”了。 思考是我最常做的事情之一，思考什么呢？ 我现在到底在做什么？ 我为什么做？ 我想做什么？ 我要做什么？ 我还有多少时间做？ 未来我会往哪里去，往哪里回？ 现在的我我是不是我要的那个“我”？ …… …… 还有很多，为什么呢？ “好好做人”“好好做人“ 是我从小听到大，被唠叨最多次的话之一就是它。 除了经常被爸妈唠叨，我最近一次看见听见是在一部网剧《一起同过窗》（背景是大一大二），里面的叶老师是班主任，他的口头禅就是“好好做人”，学生惹没惹事，他都挂嘴上。 可是，真的明白“好好做人”吗？ “好好”在这是副词，用来修饰动词“做人”。 今年经历了太多太多难以忘记的事情，我似乎开始懂得为什么爸妈在我七岁时候就开始教导我要“好好做人”。 想必他们可能花费了几十年的阅历才懂得为什么吧…… 感动、感谢、感恩初略地把涉及到”感动“、”感恩“、”感谢“的人列在这里~ “因为感动，所以感谢，更要感恩！”这是爸妈教育我的。 我凭我的记忆最大限度地检索了这些人，但一定还是会有漏的…… 家人：爸和妈、弟弟（妮）、外公外婆、奶奶、大姨一家人、二姨一家人、小姨、小姨丈、大舅一家人、小舅、奕剑叔、文燕姑姑姑、还有很多不记得称呼的亲戚…… 朋友：廖鑫圣、陈波、赖洁莹、何庆钊、冼俊贤、张桂源、刘千瑜、朱茜妍、吴嘉隆、蔡泽佳、钟叶茂、杨迎、杨天瑞、谢佳豪、冯皓明、梁大浩、袁舒恩、欧芝妍、陈晓霞、吴森、陈子平…… 师兄姐（归属于朋友）：邱海燕、纪秋荣、卢情波、海英姐（李海英）、海雯师姐、王梁兴、张康、林逸豪、何庄芸、键林、林金翼、王景华、钟榴炜、吴丹婷（广外）、周卓颖、陈庆鸿…… 老师：倪宇班主任、老罗（罗智杰老师）、陈鑫老师、廖老师（勤工网络中心）、郭世仁老师、史婷婷老师、曾宪贵老师、古笑珍老师（小学班数学兼两年班主任）、陈彩玉老师（初中三年数学老师）…… 愿望我在日记本、便签等等上写了很多愿望，其中有些是想在2020年实现的。 我直接copy了，会有重复的，以下是我对自己微信聊天中的部分愿望👇 2020我想当个好儿子、好哥哥、好朋友、好学生、好人。 希望能有人能了解、能理解并接受我的人。 秉承信念，好好做人。 常回家看看，多陪陪家人 我想做自己，我想做“吴锐杰” 不想做那些不符合我风格的事 想拿到国家励志奖学金 希望找到一个人来填补我内心的空白 2020年我要来考驾照了 改变自己，让自己多一些坚硬、刚正、远谋、顾己 好好赚钱、好好学习、好好生活 希望每个人都平安、健康、幸福、好运、快乐 珍惜当下、好好做人、万事生意 找到能陪伴、鼓励、支持我的人 我想拿奖助学金，很想要 还掉所有欠别人的钱 给老弟预留一万的存款，供9月份上大学 好好勤工、挣多点钱，多吃些肉，长胖些 学更多的知识、技能，听更多的歌 想要一副好的身体，能不能搞好我的皮肤病呢 …… …… END文字没法完全表述我想表达的，其他的就存在我的心、记忆里吧 我可以忘记很多东西，也可以记得很多东西 2019年发生的一些事我不会忘🧡…… 2020年，Jerry加油，给我冲冲冲💪…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"2019冬至","slug":"2019冬至","date":"2019-12-22T09:57:04.000Z","updated":"2020-02-03T08:31:36.470Z","comments":true,"path":"2019/12/22/2019冬至/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/22/2019%E5%86%AC%E8%87%B3/","excerpt":"😄2019.12.20-22，三天，在小姨家度过了一个冬至小长假。 🧡周五下午从学校出发，骑着小蓝到地铁站乘地铁，经过3条（2、3、9线）地铁线、18（13+3+2）个站、2次（嘉禾望岗、 高增）换乘，来到花都的小姨家。 以下为20号下午抵达花都时发的随笔 #生活 #记录三个月来，第一次出学校出趟远门. ᶘ ͡°ᴥ͡°ᶅ 今天的天气真不错，音乐、风、云……都陪伴着我，特别轻松 (୨୧•͈ᴗ•͈) 因为想家了，但回深圳有些麻烦，先来趟花都吧 ( ´◔ ‸◔`) 海珠来花都，还是有丶远。到了花都就变得有丶冷了 💛","text":"😄2019.12.20-22，三天，在小姨家度过了一个冬至小长假。 🧡周五下午从学校出发，骑着小蓝到地铁站乘地铁，经过3条（2、3、9线）地铁线、18（13+3+2）个站、2次（嘉禾望岗、 高增）换乘，来到花都的小姨家。 以下为20号下午抵达花都时发的随笔 #生活 #记录三个月来，第一次出学校出趟远门. ᶘ ͡°ᴥ͡°ᶅ 今天的天气真不错，音乐、风、云……都陪伴着我，特别轻松 (୨୧•͈ᴗ•͈) 因为想家了，但回深圳有些麻烦，先来趟花都吧 ( ´◔ ‸◔`) 海珠来花都，还是有丶远。到了花都就变得有丶冷了 💛 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Java—替换字符串右侧出现的第一个子串","slug":"Java—替换字符串右侧出现的第一个子串","date":"2019-12-08T04:46:08.000Z","updated":"2019-12-08T09:18:36.934Z","comments":true,"path":"2019/12/08/Java—替换字符串右侧出现的第一个子串/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/08/Java%E2%80%94%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%B3%E4%BE%A7%E5%87%BA%E7%8E%B0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%90%E4%B8%B2/","excerpt":"🔺需求 👇 编程实现一个方法，能把一个字符串src的右侧出现的第一个olds子串替换为news，并把替换后的结果返回。","text":"🔺需求 👇 编程实现一个方法，能把一个字符串src的右侧出现的第一个olds子串替换为news，并把替换后的结果返回。 🔺代码 👇 123456789101112131415161718192021public class StringReplaceLast { public static String replaceLast(String src, String olds, String news){ /* 实现一个尾部替换方法 */ System.out.println(src); StringBuffer sbsrc = new StringBuffer(src); int lenolds = olds.length(); int tail = src.lastIndexOf(olds); sbsrc = sbsrc.replace(tail,tail+lenolds, news); src = sbsrc.toString(); return src; } public static void main(String[] args) { System.out.println(replaceLast(\"goodJava,I love it, very good,Truly.\", \"good\", \"yes\" )); }} 🔺截图 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java—转置数组","slug":"Java—转置数组","date":"2019-12-07T13:43:33.000Z","updated":"2019-12-08T14:07:45.921Z","comments":true,"path":"2019/12/07/Java—转置数组/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/07/Java%E2%80%94%E8%BD%AC%E7%BD%AE%E6%95%B0%E7%BB%84/","excerpt":"🔺需求 👇 编写一个程序，其功能是能随机生成一个数组、同时完成对该数组的转置并打印输出转置后的数组。","text":"🔺需求 👇 编写一个程序，其功能是能随机生成一个数组、同时完成对该数组的转置并打印输出转置后的数组。 🔺代码 👇 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import static java.lang.System.out;import java.util.Random;public class Reverse2dArray { static int[][] a; // 存放两位随机整数的int二维数组a /** * 构造方法，初始化数组a，r和c分别是行数和列数row column */ public Reverse2dArray(int r, int c){ a = new int[r][c]; buildRandArray(); } /** * 构造随机数组 */ public void buildRandArray(){ Random random = new Random(); for(int i = 0; i &lt; a.length; i++) for(int j = 0; j &lt; a[i].length; j++) a[i][j] = random.nextInt(100); } /** * 转置本类成员的二维数组a，并返回一个新的二维数组 * @return */ public int[][] reverse2dArray(){ int [][] b = new int [a[0].length] [a.length] ; for (int i = 0; i &lt; a.length; i++) { for (int j = 0; j &lt; a[0].length; j++) { b[j][i] = a[i][j] ; } } return b ; } /* 显示二维数组 */ public void showArray(int[][] c){ out.printf(\"=========%2d×%-2d=========%n\", c.length, c[0].length); for(int[] cr : c){ for(int cc : cr){ out.printf(\"%5d \", cc); } out.println(); } out.println(\"=======================\"); } public static void main(String[] args) { int row = 3, col = 4; Reverse2dArray me = new Reverse2dArray(row, col); me.showArray(a); // 显示原数组 int[][] r = me.reverse2dArray(); me.showArray(r); // 显示转置的数组 }} 🔺截图 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"【纪念】我的博客上线一个月","slug":"【纪念】我的博客上线一个月","date":"2019-12-06T16:41:29.000Z","updated":"2019-12-06T17:20:33.920Z","comments":true,"path":"2019/12/07/【纪念】我的博客上线一个月/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/07/%E3%80%90%E7%BA%AA%E5%BF%B5%E3%80%91%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E6%9C%88/","excerpt":"大致写完这文章时，已是2019年12月7日的夜晚00时41分。 从最简单的纯粹的文字，到文字加粗，到用图床（SM.MS）来插入图片，到利用HTML来丰富博客，等等……本小白的博客之旅早已开始，学习、生活，图文、视频、音乐，想写想分享的都不会少。 今天这篇文章，一是回顾这一个多月来写博客的点滴，二是对未来的一些期望、想法，三是纪念一个人！！！","text":"大致写完这文章时，已是2019年12月7日的夜晚00时41分。 从最简单的纯粹的文字，到文字加粗，到用图床（SM.MS）来插入图片，到利用HTML来丰富博客，等等……本小白的博客之旅早已开始，学习、生活，图文、视频、音乐，想写想分享的都不会少。 今天这篇文章，一是回顾这一个多月来写博客的点滴，二是对未来的一些期望、想法，三是纪念一个人！！！ 尝试 &amp; 第一篇博客2019十月的最后一天，那是我写博客的第一天。 第一篇博客，同时用来纪念我的开始。 https://blog.csdn.net/weixin_43438052/article/details/102841961 那篇博客的标签我给的是#尝试#。 没错，这是我第一次尝试写博客，一次伟大的尝试和开始。 博客的内容也很简单。 当然，这也是我人生以来 第一次全面地接触 MarkDown 语言。 又迈出一步 &amp; 小小的收获之后，先后在CSDN和简书上，又发表共5篇文章（含重复）。 我的CDSN主页：https://blog.csdn.net/weixin_43438052 我的简书主页： https://www.jianshu.com/u/a75808cbb13e 经过写这几篇博客，对于MD（Markdown）的使用越来越熟练。 这也让我收获一些东西，比如点击量、评论量、点赞数、收藏数等等。 虽然和那些大佬比起来微不足道，不过我还是很开心。 尤其是我合计了（双平台）全部文章的浏览量是1726。 截止到写这篇博客，有1726‬人看过我的文章。1726啊啊啊，大数字了hhhh 于是，我傻乎乎地打开计算器，用1726除了30，得到这个数‭57.53。 忍不住说了句 卧槽 ，平均每天有57人看我的文章。 57人啊，我也算是个小网红 (不算，那我自个变红) 了吧？！！ 此刻的我👉一时自恋+持续傻笑ing 大胆地想法 &amp; 勇敢地再尝试2019.11.1 我突然有个 大想法 ，和这三个字那么大的想法——我要搭建自己Blog（博客）。 那又是为什么呢？ 很简单，还是 尝试 。 然而，想法是好，实践起来，不容易啊。 起初是使用 Gridea 来撰写、发布博客。 不过，没多久被我舍弃了这个方案。并不是说Gridea不好，而是缺少了自定义。 我说的自定义是，可以给自己的博客加入一些其他的东西，比如页面动画之类的。 于是，在朋友的推荐下，我接触了 Hexo 。这是一个专门用来搭建博客的框架。 没错，就是框架。因为是框架，所以能直接、便利地搭建、撰写、发布博客文章。 更重要的是，Hexo提供现成的主题模板，你可以直接利用，甚至对其二次加工。 就这样，前前后后，在没课的时候、还有半夜，大概花了四天左右来研究Hexo，从命令行开始。 终于在2019.11.6初步搭建完成，隔天7号发布了第一篇文章。 同时也是记录我搭建博客的大致过程。 人生第一个域名 &amp; 一写小坎坷2019.11.6 也是我获取人生第一个专属域名【melodyhub.ltd】的日子。 43买了五年，真的很值很划算。 不过，在接下的两三天也遇到点麻烦。 第一个是DNS解析，这个还好办，查ip、到阿里云控制台改一下就好。 第二个是，每次``hexo d` 后，用域名总是404。每次都要到GitHub仓库里修改CNAME，太麻烦了。于是，我干脆就直接在Hexo的框架中写入CNAME文件，这样每次更新到远端（仓库）时，都会有正确的CNAME。机智的我 ( ͡° ͜ʖ ͡°)✧ 第三个，也是最麻烦的一个，浏览器打开我的网站，总是提示“证书失效 / 危险链接”等字段。这个懊恼了我两天，反复查了一堆东西，最后发现原来是主题模板中重定向到一个外国授权认证的网站去了。 真的是，整的我发愁，好在最后能够解决了。 进一步尝试优化到目前为止，我的网站一共经历两次大变化，一次是在11.8，另一次是11.24。 主要就是优化了主题模板中存在的一些问题，然后加入了一点自己想要的东西，还有一些待以后再实现。 具体的，主要的，大致在【博客v1.4上线】这篇博客中提到了。 其实，这个过程很难，一个是我对Hexo内部的设计的了解不是很深，另一个是对HTML语言不是精通。主要是前者，后者可以通过百度、书籍来学习。 反反复复，查阅各个文档、修改一堆文件、增删改n次代码。 总算是，得到了一个较为满意的博客。 期间，还丢失过几次代码和文件，折腾死我了。😂 奋笔疾书（敲键盘）写写写截至到写这篇博客，一共在自己的网站上发布了26篇正式博客。 但是由于目前还没不会使用“不蒜子” 的接口来显示浏览量，所以我页没法知道有多少人看过我的文章。 我就假装每天就一共吧，那就是我哈哈哈。 26篇博客文章，不仅提升为了我的打字速度，还让我更加地想搞IT。** 当然，我一向对IT感兴趣。** 写 ，这个过程让我在不断地遇到困难，然后解决它。 不懂的，就琢磨它。再不懂，找大佬、问大佬。 也就一步步地，收获了知识、也认识了几位大佬。 期望 &amp; 未来我的目标是成为以为IT技术大佬，目前的想法是能熟练Java+一种数据库+HTML+其他语言/技术。 这几个月来，因为一件事、一些人，重新洗牌了我的生活，同时也让我有了全新的目标、计划。 现如今，我有新的顾虑，我有家、有朋友的期望，我必须自强自立。放眼到以前，熟悉我的人也知道我一向比较执着于想做的事，虽然现在我也也是，不过更多了一些热情、勇气、认识。 这一个多月来，得到很多人的帮助、指导、建议。朋友啊、老师啊、师兄师姐啊…… 人总要向前看向前走，无论是失去某样东西，或者某个人，都得向前。 我在博客中用到一句话当【归档页】的副标题“生命不过三天：昨天、今天、明天”。 反思昨天，珍惜今天，把握明天。所以，但看到别人在向前走时，我就要跑、向前跑。 就这样，我也才给我的网站的主页设置了 “你用走 可是我用跑” . 我希望这句话能够在关键时候提醒我，你不能停还得跑。 同时我也希望，能够看到这里的你，也要向前向前再向前。 晚安计划分享截止到现在的所有【晚安计划】 👇 END😊 最后，希望 健康、平安、简单、快乐、好运。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"用JDBC连接数据库","slug":"用JDBC连接数据库","date":"2019-12-03T04:12:50.000Z","updated":"2020-02-09T16:02:16.381Z","comments":true,"path":"2019/12/03/用JDBC连接数据库/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/03/%E7%94%A8JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"简单理解JDBC（Java DataBase Connectivity）是 Java 和 数据库 之前的一座桥。 实则，JDBC 是用于Java编程语言和数据库之间的标准Java API。 三者之间的关系就如下图 👇","text":"简单理解JDBC（Java DataBase Connectivity）是 Java 和 数据库 之前的一座桥。 实则，JDBC 是用于Java编程语言和数据库之间的标准Java API。 三者之间的关系就如下图 👇 JDBC介绍官方文档：https://www.oracle.com/technetwork/java/javase/jdbc/index.htmlJava 原文👇 译文（可能有偏差）👇 数据库连接 （JDBC） Java 数据库连接 （JDBC） API 是 Java 编程语言与各种数据库 SQL 数据库和其他表格数据源（如电子表格或平面文件）之间的独立于数据库的连接的行业标准。JDBC API 为基于 SQL 的数据库访问提供了调用级 API。 JDBC 技术允许您使用 Java 编程语言来利用需要访问企业数据的应用程序的”一次写入，随处运行”功能。借助支持 JDBC 技术的驱动程序，即使在异构环境中，您也可以连接所有企业数据。 教程本文环境 OS IDE 数据库 Windows 10 专业版 Eclipse(v4.11.0)—jdk8 SQL server 2017 SQL Server 2017 设置【SQL 身份验证登录】 设置【登录名 sa】 的状态为【授予】和【启用】 关闭程序 SQL Server 配置管理器==因为SQL Server 2012装好后，默认协议是没有开启的，所以要打开SQL Server配置管理器中开启。== 打开【SQL server2017配置管理器】 启用【Named Pipes】 修改 【TCP/IP 属性】： 将【IP1 、IP10】中的【IP地址】改成【 127.0.0.1】，并将所有的【IPx】的【已启用】设置为【是】，将 【IPAII】中的【TCP端口】设成 【1433】，其余不变。 重启【SQL Server服务】 【win+r】打开【运行】，键入【cmd】，打开命令行，键入以下命令👇 1telnet 127.0.0.1 1433 提示【talent不是内部命令】，则【打开控制面版】-&gt;【程序】-&gt;【启用或关闭Windows功能】-&gt;【勾选talent】-&gt;【确定】。 重新【步骤4】，进入【telnet】。 JDBC驱动 下载驱动包：http://www.microsoft.com/zh-cn/download/details.aspx?id=11774 选择、下载【 sqljdbc_6.0.8112.200_chs.tar.gz】 解压上述压缩包，得到目录文件夹 复制【”sqljdbc_6.0\\chs\\jre8”】中的包【sqljdbc42.jar】，粘贴到IDE【Eclipse目录】下的【jdk1.8\\jre\\lib\\ext】中。 右键【我的电脑】-&gt;【高级系统设置】-&gt;【系统属性】-&gt;【高级】-&gt;【环境变量】，编辑【系统变量】中的【CLASSPATH】的【变量值】，加入【;路径】（该路径为步骤4中包的完整路径，注意路径前一定要加 ;）-&gt;【确定】。 Eclipse 【右键】工程项目-&gt;【Build Path】-&gt;【Configure Build Path】 选择【Libraries】页-&gt;【Add External JARs…】-&gt;【添加】前面粘贴jar包的路径-&gt;【Apply and Close】 实践新建一个class，复制粘贴一下代码👇 12345678910111213141516171819202122232425262728293031323334import java.sql.*;public class JDBC_Demo { // MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL //static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; //static final String DB_URL = \"jdbc:mysql://localhost:3306/数据库名\"; // MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL //static final String JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\"; //static final String DB_URL = \"jdbc:mysql://localhost:3306/数据库名?useSSL=false&amp;serverTimezone=UTC\"; // SQL Server数据库引擎 static final String JDBC_DRIVER = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\"; // 数据源！！！注意若出现加载或者连接数据库失败一般是这里出现问题 static final String DB_URL = \"dbc:sqlserver://localhost:1433;DatabaseName=数据库名\"; //【1】修改 数据库名 // 数据库的用户名与密码，需要根据自己的设置 static final String Name=\"登录名\";//【2】修改 登录名 static final String Pwd=\"密码\";//【3】修改 密码 public static void main(String[] args) { try { Class.forName(JDBC_DRIVER); Connection conn=DriverManager.getConnection(DB_URL,Name,Pwd); System.out.println(\"连接数据库成功\"); }catch(Exception e){ e.printStackTrace(); System.out.println(\"连接失败\"); } } } 运行截图👇 心得体会前前后后，总计花了差不多三天的时间来研究怎么用JDBC连接数据库。 期间，遇到好多问题。问过指导老师，老师说可能是SQL Server版本的问题。 实验要求是2014，而我的是2017。但我觉得这不是问题。 反反复复地，其他都配置好了，但是总是连接不上数据库。 后来关注点放在了Eclipse的Path上，注意到我用的是jdk12，于是我想换成jdk8。 一换、一 run ……咦，可以了哈哈哈哈。 期间参考了很多人的博客，但是那些都没有强调 IDE中的环境要设置为【jdk8】。 写博客不易，如果本文对你有帮助，可以考虑给我 打赏 哦 *( ͡° ͜ʖ ͡°)✧ * 2020.2.10 补充：关于JDBC连接MySQL的具体实例，可以前往 这里 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"https://melodyjerry.github.io/blog/tags/SQL-Server/"}]},{"title":"Java——API中文手册","slug":"Java-API中文手册","date":"2019-12-01T12:00:15.000Z","updated":"2019-12-02T12:56:16.300Z","comments":true,"path":"2019/12/01/Java-API中文手册/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/01/Java-API%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/","excerpt":"【Java 8中文版开发文档，Java 8中文版 API手册中文版】( http://www.matools.com/api/java8 )","text":"【Java 8中文版开发文档，Java 8中文版 API手册中文版】( http://www.matools.com/api/java8 ) L2Dwidget.init({\"model\":{\"jsonPath\":\"/blog/live2dw/assets/assets/haruto.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"tagMode\":false,\"debug\":false,\"mobile\":{\"show\":true},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\"}); 为了避免版权问题，再次声明：移植该文档，仅供学习交流，别无其它目的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"2019的最后一个月","slug":"2019年的最后一个月","date":"2019-12-01T05:32:39.000Z","updated":"2019-12-31T14:16:35.253Z","comments":true,"path":"2019/12/01/2019年的最后一个月/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/01/2019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88/","excerpt":"","text":"💛今天，2019年12月01日，是 今年最后一个月的第一天。 🔺回想去年的12月，经历了很多，一切都是从 【晚安计划】的短信 开始。时至今天，我仍保存着去年的“晚安计划”短信。 💙今晚开始，又是新的一轮【晚安计划】。不知道你有没有呢？ 🧡从国庆回到学校后，课多了、要处理的事情多了，总之这两个月来搞的东西太多了。 💚不过呢，也是有收哦的哦！像比如，现在这个博客(2019.11.07)就是之一。还有自己写的小玩意，以后会放出来。 💜忙完这最后的12月，也该是时候让自己出去走走了。总是待在宿舍、教学楼，会傻的hh。 💛最近很想家，很想回家。不过也要等到2020元旦之后啦，也快了快了。 最后，祝我自己和大家12月健康、平安、快乐、好运…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Java—(递归+非递归)阶层","slug":"Java—（递归-非递归）阶层","date":"2019-11-30T08:08:51.000Z","updated":"2019-12-01T01:01:56.156Z","comments":true,"path":"2019/11/30/Java—（递归-非递归）阶层/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94%EF%BC%88%E9%80%92%E5%BD%92-%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89%E9%98%B6%E5%B1%82/","excerpt":"递归阶层算法、非递归阶层算法 扩展①：求阶层的和 扩展②：寻找最高阶、打印阶层的计算过程","text":"递归阶层算法、非递归阶层算法 扩展①：求阶层的和 扩展②：寻找最高阶、打印阶层的计算过程 非递归阶层算法12345678910111213141516171819import java.util.Scanner;public class UnRecurrenceFactorial { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"input:\"); int n = sc.nextInt(); int a = 1; while(n != 1){ a = a*n; n--; } System.out.println(a); sc.close(); }} 递归阶层算法12345678910111213141516public class RecurrenceFactorial { public static void main(String[] args) { long fac = fac(k);//修改k的值即可 System.out.println(\"n的阶乘为:\" + fac); } public static long fac(int n){ if(n == 1){ return 1; }else{ return fac(n-1) * n; } }} 扩展①：求阶层的和🔺计算 1!+2!+3!+···+k! 的值： 123456789101112public static void main(String[] args) { int i,j; long sum = 0; for(i = 1; i &lt;= k; i++){ //修改k的值即可 int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } sum += t; } System.out.println(sum);} 扩展②：寻找最高阶、打印阶层的计算过程🔺题目： 指定一个整型数MAX，试编写一个程序求满足1!+2!+3!…+n!&lt;=MAX 的最大整数n。并把满足条件的求和式子和找到的最大整数n打印输出。 示例1：MAX=111时，输出 1!+2!+3!+4!=33 满足条件的最大整数:4 示例2：MAX=9876 1!+2!+3!+4!+5!+6!+7!=5,913 满足条件的最大整数:7 🔺代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;public class Du { public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.println(\"the value of MAX:\"); int MAX; MAX=input.nextInt(); System.out.println(\"满足条件的最大整数：\"+SUM(MAX)); input.close(); } public static int SUM(int MAX) { int i = 0,j; long sum = 0; for(i = 1; i &lt;= 10; i++){ int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } sum += t; if(sum&gt;MAX) break; } Print(i-1); return i-1; } /*打印阶层的计算过程*/ public static void Print(int k) { int i,j; long sum = 0; for(i = 1; i &lt;= k; i++){ //修改k的值即可 int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } System.out.printf(\"%d! + \",i); sum += t; } System.out.print(\"\\b\\b= \"+ sum);//退两个，删去最后一个+ System.out.println(); }} 🔺截图： 我的文章、代码简单，这里有更详细文章，见大佬👉Java实现n阶阶乘的计算 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java—向下/上取整","slug":"Java—-向下-上取整","date":"2019-11-30T05:44:08.000Z","updated":"2019-12-01T00:58:39.448Z","comments":true,"path":"2019/11/30/Java—-向下-上取整/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94-%E5%90%91%E4%B8%8B-%E4%B8%8A%E5%8F%96%E6%95%B4/","excerpt":"Java中对数的舍入也分有 向上舍入（向上取整） 向下舍入（向下取整） Java的Math类中包含数舍入的方法： ceil() floor() ceil()和floor() ceil() floor() 向上取整 向下取整 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 返回小于等于（&lt;=）给定参数的最大整数 。","text":"Java中对数的舍入也分有 向上舍入（向上取整） 向下舍入（向下取整） Java的Math类中包含数舍入的方法： ceil() floor() ceil()和floor() ceil() floor() 向上取整 向下取整 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 返回小于等于（&lt;=）给定参数的最大整数 。 看个栗子👇 关于Math类的说明，参考 Number &amp; Math 类方法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java—打印字母表","slug":"Java—打印字母表","date":"2019-11-30T03:46:31.000Z","updated":"2019-12-02T15:24:50.647Z","comments":true,"path":"2019/11/30/Java—打印字母表/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94%E6%89%93%E5%8D%B0%E5%AD%97%E6%AF%8D%E8%A1%A8/","excerpt":"A到Z的ASCII码值是65到90 a到z的ASCII码值是97到122","text":"A到Z的ASCII码值是65到90 a到z的ASCII码值是97到122 Demo123456789101112131415161718public class AlphabetDemo { public static void main(String[] args) { /*char和int类型能够相互转换，相信大家都明白 */ //A到Z的ASCII码是65到90，a到z的ASCII码值是97到122 for (char c = 0; c &lt; 128; c++) { //java里包装类的一个静态方法，确定c是字母还是小写！！！） if (Character.isLowerCase(c)) { System.out.printf(\"value: %3d char: %c\\n\", (int)c, c); //同上，判断c是大写 } else if (Character.isUpperCase(c)) { System.out.printf(\"value: %3d char: %c\\n\", (int)c, c); } } } } 注：关于isLowerCase和isUpperCase在文末有进一步的说明。 扩展 ①🔺题目： 🔺参考代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Scanner;public class Alphabet { public static void main(String[] args) { Scanner input=new Scanner(System.in); int n,level; System.out.println(\"the value of n:\"); n=input.nextInt(); level=(int)Math.ceil(26/n);//向上取整 System.out.println(\"======Upper========\"); char CH=65; for(int i=0;i&lt;=level;i++) { for(int j=0;j&lt;n;j++) { System.out.printf(\"%c \",CH); ++CH; if(CH&gt;=90) break; } System.out.println(); } System.out.println(); /* 另一个版本，这就看个人理解了！ System.out.println(\"======Upper========\"); char CH=65; for(int i=1;i&lt;=26;i++) { System.out.print(CH+\" \"); CH++; if(i%n==0) { System.out.println(); } } System.out.println(); */ System.out.println(\"======Lower========\"); char ch=97; for(int i=0;i&lt;=level;i++) { for(int j=0;j&lt;n;j++) { System.out.printf(\"%c \",ch); ++ch; if(ch&gt;=123) break; } System.out.println(); } System.out.println(); input.close(); }} 注意：Math.ceil();//向上取整 参考：我的另一篇博客：Java—向下/上取整 🔺执行截图： 扩展 ②上面常规思考题中的第6题是自左往右从上往下的水平顺序输出大写堆和小写堆字母表。假如想要按照自上而下从左往右的垂直顺序输出大写堆，该如何实现程序？ 即假如每列输出N=5个，则程序的输出情况如下： = = = Upper = = = A F K P U Z B G L Q V C H M R W D I N S X E J O T Y 试用一重循环编写程序，指定一个整型数N(1&lt;=N&lt;=26)，按示例规格输出列优先排序的大写字母表。 🔺代码： 123456789101112131415161718192021222324252627import java.util.Scanner;public class Aphabet { public static void main(String[] args) { System.out.println(\"======Upper========\"); Scanner input = new Scanner(System.in); int n,level; System.out.println(\"the value of n:\"); n = input.nextInt(); level = (int)Math.ceil(26/n);//向上取整 int j = 0; char ch = 65; p(1, n, ch); } public static void p(int x,int n,char ch) { if(x &gt; n) return; for(int i = x;i &lt;= 26;i += n){ ch = (char)(i + 64); System.out.print(ch + \" \"); } System.out.println(); ++x; p(x, n, ch); }} 下午做了半个多小时都没做出来，晚上玩了会游戏突然想到用递归，下午怎么就没想到呢？然后游戏就挂机被举报了，但一气呵成搞定了这题。说明思想不够灵活hhh 🔺截图： 补充：Java Character 类isLowerCase() 方法🔺作用：用于判断指定字符是否为小写字母。 🔺语法 1boolean isLowerCase(char ch) 🔺参数 ch – 要测试的字符。 🔺返回值 如果字符为小写，则返回 true；否则返回 false。 🔺实例 1234567public class Test { public static void main(String args[]) { System.out.println( Character.isLowerCase('a')); System.out.println( Character.isLowerCase('A')); }} 🔺以上程序执行结果为： 12truefalse isUpperCase() 方法 🔺作用：用于判断指定字符是否为大写字母。 🔺语法 1boolean isUpperCase(char ch) 🔺参数 ch – 要测试的字符。 🔺返回值 如果字符为大写，则返回 true；否则返回 false。 🔺实例 1234567public class Test { public static void main(String args[]) { System.out.println( Character.isUpperCase('b')); System.out.println( Character.isUpperCase('B')); }} 🔺以上程序执行结果为： 12falsetrue document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java—5种生成随机数的方法","slug":"Java—5种生成随机数的方法","date":"2019-11-30T02:33:25.000Z","updated":"2019-12-01T01:53:18.885Z","comments":true,"path":"2019/11/30/Java—5种生成随机数的方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%945%E7%A7%8D%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"5种生成随机数的简单方法 和一篇大佬的文章👇","text":"5种生成随机数的简单方法 和一篇大佬的文章👇 方法①🔺 通过java.Math包的random方法得到1-10的int随机数 🔺 公式： 最小值—最大值（整数）的随机数 (类型) 最小值+Math.random()*最大值 12345678910111213import java.util.Random;public class RandomDemo { public static void main(String[] args) { for (int i=0;i&lt;5;i++) { System.out.println((int)(1+Math.random()*10)); int k; k=(int)(1+Math.random()*10); } }} 方法②🔺借助java.util.Random类来产生一个随机数发生器，也是最常用的一种，构造函数有两个，Random()和Random(long seed)。第一个就是以当前时间为默认种子，第二个是以指定的种子值进行。产生之后，借助不同的语句产生不同类型的数。 🔺种子就是产生随机数的第一次使用值,机制是通过一个函数,将这个种子的值转化为随机数空间中的某一个点上,并且产生的随机数均匀的散布在空间中。以后产生的随机数都与前一个随机数有关 123456789101112131415import java.util.Random;public class RandomDemo { public static void main(String[] args) { Random r = new Random(); for(int i=0 ; i&lt;5 ; i++) { int ran1 = r.nextInt(100);//种子：100 System.out.println(ran1); } }} 注：类似的方法可参考 利用Random类来产生5个20~50之间的随机整数 方法③ 生成随机数需要使用到Java工具类中的Random类。 要求是随机x到y之间的整数，即指定范围，则使用Random类中的nextInt(int n)方法。 该方法生成从0（包括）到n（不包括）之间的随机整数，是一个伪随机数，并不是真正的随机数。 若x不为0，则需要在随机结果后加上x。参数n的值也需要加上1后减去x。最后结果才符合要求的范围。 1234567891011121314151617import java.util.Random;public class RandomDemo { public static final int START = 50; //定义范围开始数字 public static final int END = 99; //定义范围结束数字 public static void main(String[] args) { //创建Random类对象 Random random = new Random(); //产生随机数 int number = random.nextInt(END - START + 1) + START; //打印随机数 System.out.println(\"产生一个\"+START+\"到\"+END+\"之间的随机整数：\"+number); }} 注：更多方法可参考【Java工具类】—-产生随机数 方法④🔺 返回的数值是 [ 0.0 , 1.0 ) 的double型数值，由于double类数的精度很高，可以在一定程度下看做随机数，借助（int）来进行类型转换就可以得到整数随机数了 12345678public static void main(String[] args){ for (int i = 1; i &lt;= 10; i++) { int max=99,min=10;//生成两位随机正整数 int ran2 = (int) (Math.random()*(max-min)+min); System.out.println(ran2); }} 方法⑤🔺 返回从1970年1月1日0时0分0秒（这与OS有关）到现在的一个long型的毫秒数，取模之后即可得到所需范围内的随机数 12345678public static void main(String[] args) { int max=100,min=1; long randomNum = System.currentTimeMillis(); int ran3 = (int) (randomNum%(max-min)+min); System.out.println(ran3); } 大佬的文章这个大佬【peabits】的文章贼详细，可以好好琢磨琢磨 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java中的<<、>>和>>>","slug":"Java中的、-和","date":"2019-11-29T16:33:38.000Z","updated":"2019-11-29T17:14:55.054Z","comments":true,"path":"2019/11/30/Java中的、-和/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E4%B8%AD%E7%9A%84%E3%80%81-%E5%92%8C/","excerpt":"左移 左移运算符 &lt;&lt; 👉使指定值的所有位都左移规定的次数 左移m&lt;&lt;n，代表把数字m在无溢出的前提下乘以2的n次方 右移 右移运算符 &gt;&gt; 👉 使指定值的所有位都右移规定的次数 右移m&gt;&gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数 注意，如果是单数，也就是二进制末位为1，则结果是将m除以2的n次方的整数商 无符号右移 无符号右移运算符 &gt;&gt;&gt; 👉同右移，但是结果全变正数","text":"左移 左移运算符 &lt;&lt; 👉使指定值的所有位都左移规定的次数 左移m&lt;&lt;n，代表把数字m在无溢出的前提下乘以2的n次方 右移 右移运算符 &gt;&gt; 👉 使指定值的所有位都右移规定的次数 右移m&gt;&gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数 注意，如果是单数，也就是二进制末位为1，则结果是将m除以2的n次方的整数商 无符号右移 无符号右移运算符 &gt;&gt;&gt; 👉同右移，但是结果全变正数 Demo 以下内容转载于 Java中的&lt;&lt; 和 &gt;&gt; 和 &gt;&gt;&gt; 详细分析 详细分析&lt;&lt;表示左移，不分正负数，低位补0； 注：以下数据类型默认为byte-8位 左移时不管正负，低位补0 正数：r = 20 &lt;&lt; 2 20的二进制补码：0001 0100 向左移动两位后：0101 0000 结果：r = 80 负数：r = -20 &lt;&lt; 2 -20 的二进制原码 ：1001 0100 -20 的二进制反码 ：1110 1011 -20 的二进制补码 ：1110 1100 左移两位后的补码：1011 0000 反码：1010 1111 原码：1101 0000 结果：r = -80 &gt;&gt;表示右移，如果该数为正，则高位补0，若为负数，则高位补1； 注：以下数据类型默认为byte-8位 正数：r = 20 &gt;&gt; 2 20的二进制补码：0001 0100 向右移动两位后：0000 0101 结果：r = 5 负数：r = -20 &gt;&gt; 2 -20 的二进制原码 ：1001 0100 -20 的二进制反码 ：1110 1011 -20 的二进制补码 ：1110 1100 右移两位后的补码：1111 1011 反码：1111 1010 原码：1000 0101 结果：r = -5 &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0 正数： r = 20 &gt;&gt;&gt; 2 的结果与 r = 20 &gt;&gt; 2 相同； 负数： r = -20 &gt;&gt;&gt; 2 注：以下数据类型默认为int 32位 -20:源码：10000000 00000000 00000000 00010100 反码：11111111 11111111 11111111 11101011 补码：11111111 11111111 11111111 11101100 右移：00111111 11111111 11111111 11111011 结果：r = 1073741819 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java用最有效率的方法计算2乘以8","slug":"Java—用最有效率的方法计算2乘以8","date":"2019-11-29T16:24:00.000Z","updated":"2019-12-01T01:58:23.398Z","comments":true,"path":"2019/11/30/Java—用最有效率的方法计算2乘以8/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%972%E4%B9%98%E4%BB%A58/","excerpt":"","text":"最有效率的方法 👉 2 &lt;&lt; 3 其中，左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方 再比如，31 * num 等价于( num &lt;&lt; 5 ) – num 左移5位相当于乘以2的5次方（32），再减去自身（-1），这一过程就相当于乘以31 注：关于移位运算符，可参考我的下一篇博客 Java中的&lt;&lt;、&gt;&gt;和&gt;&gt;&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—static关键字","slug":"Java笔记—static关键字","date":"2019-11-28T09:24:41.000Z","updated":"2019-11-29T17:43:43.410Z","comments":true,"path":"2019/11/28/Java笔记—static关键字/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/28/Java%E7%AC%94%E8%AE%B0%E2%80%94static%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"static 关键字修饰目标 (成员数据/方法/成员内部类/代码块)属于类的 静态类 静态块 静态方法 静态变量 static 成员内部类 static 代码块 static 成员方法 static 成员变量 直接通过类就可以访问。所有对象共享该类 只能出现在类中不能出现方法体中，类加载后初始化时被执行一次。注意:区分构造代码块，每次构造都被执行 直接通过类就可以调用。不用等创建了实例后 类加载时在Java方法区分配空间，所有对象共享 区别：无static关键字成员属于具体的对象实例： 实例变量、实例方法(只能通过对象调用)、实例成员内部类(只能通过对象引用) static 成员的访问格式一般要通过 *“ 类名 ” *来访问 静态变量 静态方法 静态成员内部类 类名 . 静态变量 类名 . 静态方法 类名 . 静态成员内部类 注意两点： 🔺 static成员方法/代码块：方法体 只能 使用静态成员变量(或内部类)或调用静态方法。（老师称： 静者恒静） 🔺 static成员方法/代码块：方法体中不能出现this(当前对象)或super(基类对象)","text":"static 关键字修饰目标 (成员数据/方法/成员内部类/代码块)属于类的 静态类 静态块 静态方法 静态变量 static 成员内部类 static 代码块 static 成员方法 static 成员变量 直接通过类就可以访问。所有对象共享该类 只能出现在类中不能出现方法体中，类加载后初始化时被执行一次。注意:区分构造代码块，每次构造都被执行 直接通过类就可以调用。不用等创建了实例后 类加载时在Java方法区分配空间，所有对象共享 区别：无static关键字成员属于具体的对象实例： 实例变量、实例方法(只能通过对象调用)、实例成员内部类(只能通过对象引用) static 成员的访问格式一般要通过 *“ 类名 ” *来访问 静态变量 静态方法 静态成员内部类 类名 . 静态变量 类名 . 静态方法 类名 . 静态成员内部类 注意两点： 🔺 static成员方法/代码块：方法体 只能 使用静态成员变量(或内部类)或调用静态方法。（老师称： 静者恒静） 🔺 static成员方法/代码块：方法体中不能出现this(当前对象)或super(基类对象) Demo：类内使用1234567891011121314151617181920212223import static java.lang.System.*; //静态导入静态方法或对象 public class StaticDemo1 { static int a = 3, b, i = 0; // 静态变量 char ch = 'Y'; // 实例变量 static void meth(int x) { // 静态方法 out.println(\"x = \" + x); //out.println(\"ch = \" + ch);//【1】Error! } static { // 静态代码块-类加载时只执行1次 out.println(\"静态块初始化：仅1次\"); b = a * 4; //out.println(\"ch = \" + ch);//【1】Error! } public static void main(String[] args) { meth(42); //静态方法调用静态方法 new StaticDemo1(); //创建匿名对象1 new StaticDemo1(); //创建匿名对象2 } { out.println(\"ch = \" + ch);//【2】OK! out.printf(\"构造代码块：第%d次构造第%1$d次执行\\n\", (++i)); } }} 注意： 🔺特别注意：类的静态代码块仅在类在加载后初始化时被执行1次 🔺第一次new一个类时才加载该类 🔺静态方法、静态块不能访问非静态的成员（即，静者恒静）。如上述代码中的注释【1】 🔺静态块初始化：仅1次 Demo：类外使用和静态块执行时机1234567891011121314151617181920212223import static java.lang.System.out;class MyD{ private static int m; public static int n; static{ // 静态代码块【2】 m = n = 0; out.println(\"仅1次\"); } public static void callMe(){ out.printf(\"m=%d,n=%d\", m, n); }}public class StaticDemo2 { public static void main(String[] args) { MyD d; //【0】MyD被加载，但未主动使用 d = new MyD(); //【1】这里才【主动使用】MyD，于是执行其静态代码块【2】 MyD.n++; //最佳：类名.静态变量 MyD.callMe(); //最佳：类名.静态方法 }} 特别留意： 🔺用一个类声明一个类对象变量，至多会加载该类，但还未主动使用🔺老师说：【主动使用】，是一个比较高级的专题，暂不深入 注：前面的几篇Java笔记中也有提到static，后来上课老师再小结static关键词，结合前面的笔记食用效果更佳。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—this关键字","slug":"Java笔记—this关键字","date":"2019-11-28T09:11:18.000Z","updated":"2019-11-29T17:36:57.692Z","comments":true,"path":"2019/11/28/Java笔记—this关键字/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/28/Java%E7%AC%94%E8%AE%B0%E2%80%94this%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"this 关键字三个形式上的用途，但本质上就两个： 调用重载的其他构造方法：放置在构造方法体首行的this()或this(实参列表) 作为当前对象，引用成员（数据、方法等）：区分同名变量等 作为当前对象，方法返回当前对象的引用，形成链式调用","text":"this 关键字三个形式上的用途，但本质上就两个： 调用重载的其他构造方法：放置在构造方法体首行的this()或this(实参列表) 作为当前对象，引用成员（数据、方法等）：区分同名变量等 作为当前对象，方法返回当前对象的引用，形成链式调用 案 例 ： 123456789101112131415161718192021222324252627282930313233public class ThisDemo { private int a = 1; private String name = \"good\"; private int i = 0; public ThisDemo(){ System.out.println(\"无参构造子\" + this); } public ThisDemo(int a, String name){ this(); // 【1】调用无参构造子 this.a = a; // 【2】当前对象，引用成员 this.name = name; } public ThisDemo setA(int a){ this.a = a; return this; // 【3】返回当前对象 } public ThisDemo setName(String name){ this.name = name; return this; } public ThisDemo inc(){ i++; return this; } public static void main(String[] args) { ThisDemo t1 = new ThisDemo(); t1.setA(100).setName(\"guo\").inc().inc(); System.out.println(t1.i); ThisDemo t2 = new ThisDemo(2, \"Tom\"); t2.inc().setA(8).inc().inc(); //【4】链式调用 System.out.println(t2.i); }} 特别注意，案例中的【3】和【4】。 注：前面的几篇Java笔记中也有提到this，后来上课老师再小结this关键词，结合前面的笔记食用效果更佳。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"对SQL的触发器的浅理解","slug":"浅谈SQLServer触发器","date":"2019-11-26T05:08:18.000Z","updated":"2019-11-28T11:22:43.203Z","comments":true,"path":"2019/11/26/浅谈SQLServer触发器/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/26/%E6%B5%85%E8%B0%88SQLServer%E8%A7%A6%E5%8F%91%E5%99%A8/","excerpt":"","text":"个人理解如果需要做一些特定的增删改操作，就可以使用触发器。 触发 ，当做了某种预设的操作时才会执行触发器的命令。 栗子：假设现在有个员工基础信息表，里面有员工的身份证号码，手机等基本信息。那么，当你换了身份证或手机，需要修改号码的时候，肯定是去修改员工的基础资料表。假设你现在有别的地方，比如人事档案啊之类的，同样使用了员工的手机等信息，难道还要再去修改一次档案表么？那么如果还有其他地方使用了呢？而在这种时候有触发器就好解决了。如果设置一个触发器来判断，如果修改了基础表的信息，那么就同步把其他使用了基础表的关联信息也更改成最新的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"SQL Server","slug":"SQL-Server","permalink":"https://melodyjerry.github.io/blog/tags/SQL-Server/"}]},{"title":"G.E.M.邓紫棋《句号》MV首播！","slug":"G.E.M.邓紫棋《句号》MV首播！","date":"2019-11-25T14:21:12.000Z","updated":"2019-11-29T04:53:27.657Z","comments":true,"path":"2019/11/25/G.E.M.邓紫棋《句号》MV首播！/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/25/G.E.M.%E9%82%93%E7%B4%AB%E6%A3%8B%E3%80%8A%E5%8F%A5%E5%8F%B7%E3%80%8BMV%E9%A6%96%E6%92%AD%EF%BC%81/","excerpt":"G.E.M.邓紫棋《句号》MV首播！ 🧡点击破亿『全创作天后』G.E.M.邓紫棋和过去告别，向未来大步迈开，开启音乐版图新起点的一个“句号”。 这是华语乐坛前所未见的真实披露之作，她用&lt;句号&gt;这首歌，预告了全新的音乐篇章，翻页之后，就要开始。 榜单Top 1 💗邓紫棋新歌《句号》上线颇有波折，国内几大音乐平台推迟上线，但在唯一上线的Apple Music平台，已经超过霉霉新歌《lover》，一举拿下 榜单 Top1！ 官方MV视频第一发布于微博： GEM鄧紫棋 2019.11.28更换 1 网页视频源： B站官方合作发布","text":"G.E.M.邓紫棋《句号》MV首播！ 🧡点击破亿『全创作天后』G.E.M.邓紫棋和过去告别，向未来大步迈开，开启音乐版图新起点的一个“句号”。 这是华语乐坛前所未见的真实披露之作，她用&lt;句号&gt;这首歌，预告了全新的音乐篇章，翻页之后，就要开始。 榜单Top 1 💗邓紫棋新歌《句号》上线颇有波折，国内几大音乐平台推迟上线，但在唯一上线的Apple Music平台，已经超过霉霉新歌《lover》，一举拿下 榜单 Top1！ 官方MV视频第一发布于微博： GEM鄧紫棋 2019.11.28更换 1 网页视频源： B站官方合作发布 ( ͡° ͜ʖ ͡°)✧我已经 循环 MV几天了，等待网易云上架。 听说 “连Siri都被圈粉？有网友发现现在向Siri提出“播放世界第一的歌曲”，结果直接是《句号》” 有iPhone的，赶紧试试看吧 ( ͡° ͜ʖ ͡°)✧ 1.第一次发这篇文章的第二天发现视频链接失效，研究了一下，发现微博视频用的是临时链接，就是生命周期只有1天的临时链接，于是我改由B站的视频 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"音乐","slug":"音乐","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"[电影]《Ladybird》演绎完整18岁的青春","slug":"电影-《Ladybird》演绎完整18岁的青春","date":"2019-11-23T13:33:12.000Z","updated":"2020-02-11T06:44:37.415Z","comments":true,"path":"2019/11/23/电影-《Ladybird》演绎完整18岁的青春/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/23/%E7%94%B5%E5%BD%B1-%E3%80%8ALadybird%E3%80%8B%E6%BC%94%E7%BB%8E%E5%AE%8C%E6%95%B418%E5%B2%81%E7%9A%84%E9%9D%92%E6%98%A5/","excerpt":"《LadyBird》，2017年的青春轻喜剧，烂番茄指数高达99%！","text":"《LadyBird》，2017年的青春轻喜剧，烂番茄指数高达99%！ ​ 该电影讲的是一个入不敷出的家庭，强势严厉的Mom，慈祥宽容却患有抑郁症的Dad，自称LadyBird的叛逆少女Christian克里斯汀，从高中步入大学时期所经历的亲情、友情、爱情，酸甜苦辣。 ​ 虽然欧美家庭的相处方式离我们很远，但影片展现的青春经历却与我们都有可对照之处。 ​ Christian不喜欢父母取的名字，自己取名为LadyBird，盼望自己化身为鸟，渴望获得自由。她横冲直撞，怼哥哥，怼老师，怼修女，公然挑衅和搞恶作剧。18岁的第一天，就去买了骆驼香烟，一张彩票，一本成人杂志，站在家乡萨克拉门托的阳光下，体会成长放纵的快感。她想逃离家乡，去纽约，去外面的世界闯荡，瞒着妈妈偷偷申请纽约的学校。 ​ 她不去考虑别人地感受，想要的太多，对得到的总是不够满足。当然，她也有自卑虚荣的一面。会纠结自己不够出众的长相，“为什么我看起来不像是杂志里的女孩？”，不喜欢贫寒的出身，把男朋友外婆家的dreamhouse说成是自己家；为了接近乐队的凯尔，成为同样酷酷的类型，她和珍娜套近乎而疏远了自己最好的朋友。 ​ 两次恋爱纷纷落空。第一次是个贴心男友，交往顺利，却被发现是个同性恋。第二次是个俊俏阴郁乐队选手（是有点帅），但性生活不够严肃，上完床两人就分了一半了吧。直到在去舞会的路上，男友和他的朋友们想中途逃出来，LadyBird却对舞会充满期待。其实就是三观不合啊！她开始同意，却也意识到，坚持自己内心的感受，不适合跟这些人做朋友。生活就是这样啊，我们期待、努力、相信又落空。谁的青春没遇上过渣男，只是帅不帅而已。 ​ LadyBird和老妈的冲突贯穿影片。强势得老妈常常扮演成长中的“黑脸角色”，总是试图把自己的意念强加给孩子：上一秒还被广播感动的母女二人，下一秒迅速争执起来，LadyBird用跳车的方式宣扬自己的逃离和叛逆；衣服不叠会被老妈骂，走路的姿势会被嫌弃，穿什么衣服都得不到赞扬，浴室不能反锁门，进屋从来不敲门……青春期的孩子都渴望自由，太想脱离大人的管教——“告诉我你抚养花了多少钱！等我长大了努力赚钱都还给你！这样我就再也不用和你讲话！” ​ 这份冲突的亲情在最后得到了和解。平安夜不在家过看得出妈妈最难过；会在半夜为女儿修剪裙边；暗自用没有语法韵律的信件记录下对女儿的冲突和爱意；当LadyBird真的去上大学，表面保持冷漠严肃，车都不下，实际内心有满满地不舍。一切地情感在试衣间前得到合理地解释： “I want you to be the best version of yourself you can be.” “What if this is the best version?” ​ 这也是每个家长对我们地期待吧。然而，对于家长地对我们地改变，我们总是无意识就反驳，就对抗。你有你的唠叨，我有我的骄傲！ ​ 失业、并长期患有抑郁症的老爸是影片温情的存在，是家里的“好人角色”担当。记得在女儿十八岁生日时送上生日蛋糕；瞒着妈妈帮女儿申请纽约的学校，是女儿地‘同党’；问是否要和门外那个按喇叭的男孩走，虽然爸爸内心是不喜欢的，但依然会尊重女儿；影片最后，悄悄把妈妈写的信放进Ladybird书包，告诉她，妈妈其实是多么爱她——这也是促进母女关系和解的重要一环。 ​ 这是一个与自己、与家人和解的故事，像极了青春期的我们。影片的最后，她真的到达纽约。在家乡，这个女孩给自己取名为LadyBird，向所有人宣称自己的叛逆，想像鸟一样自由挣脱；而到了纽约，她要像鸟一样开始漂泊时，又叫回Christian。因未来而出走，因出走而怀乡。 影片的最后，她在电话里说“妈妈，我发现我从来没有意识到，萨克拉门托是那么美的地方。似乎每一处细节，每一个弯道，都是那么的美丽。” ​ 我们总想为逃离自己的家庭出身而奋斗，终有一天会觉得，走得再远，都想再回到最初的地方。蜷局于母体时的安全是最安全。 大二上学期《英语影视鉴赏》课结作业。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"电影","slug":"电影","permalink":"https://melodyjerry.github.io/blog/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"Java笔记—包","slug":"Java笔记—包","date":"2019-11-23T05:54:59.000Z","updated":"2019-11-29T17:36:24.562Z","comments":true,"path":"2019/11/23/Java笔记—包/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/23/Java%E7%AC%94%E8%AE%B0%E2%80%94%E5%8C%85/","excerpt":"Java笔记——包创建时间：2019.11.23 说明：持续更新ing 概念 包(package) 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 ✔ 用来组织和管理类、接口、枚举和注解✔ 有三方面作用：1)便于组织,比如按功能、按团队等；2)解决命名冲突；3)进行访问权限控制(同包可用，包外不可见等) 如同类似OS的文件夹(或目录或路径)一样，包也采用了树形目录的存储方式。","text":"Java笔记——包创建时间：2019.11.23 说明：持续更新ing 概念 包(package) 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 ✔ 用来组织和管理类、接口、枚举和注解✔ 有三方面作用：1)便于组织,比如按功能、按团队等；2)解决命名冲突；3)进行访问权限控制(同包可用，包外不可见等) 如同类似OS的文件夹(或目录或路径)一样，包也采用了树形目录的存储方式。 作用 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 🔺 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 同一个包中类名字是不同的，不同包中类的名字可以相同，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 语法格式 123package 包名或package 父包名[.子包名][.孙包名][.层次下去] 🔸包名符合标识符命名规范，一般由小写字母组成🔹必须出现在源文件的第一行(忽略注释语句)🔸每个源文件至多只能出现一个package语句🔹如果没有package语句，那就使用无名包(或称默认包:所在的当前目录)🔸包的背后对应着操作系统的路径名称 示例： 12345678910111213package ch08.web.sample; public class Person { String name; int age; //省略部分代码 } class Dog { String name; int age; //省略部分代码} 🔺package ch08.web.sample; 这个层级的文件夹必须先存在：即ch08/web/sample 包的使用 🔺import 关键字 为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。 为了使用另外一个包中的成员(主要是类)，可以明确import该成员。 避免重复使用完整路径的类名。 语法格式： 1import package1[.package2…].(classname|*); 注意： 必须紧跟在package语句之后(若有的话，若无package，则import出现在源文件头部)。 可以使用 * 来表示导入当前一层包中的所有类。但是* 不可以连续使用。 1import java.*.*; // Error! 不表示可以继续导入当前包的子包。如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。 类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。 Java常用包 🔵JavaAPI的类库也是按照包的方式组织的 包名 描述 备注 Java.lang Java语言进行程序设计的基础类(核心类库)，它是默认导入的包 Runnable接口和Object、Math、String、StringBuffer、System、Thread、Throwable类 Java.util 实用工具类包 定义系统特性、随机数、日期时间、日历、集合类等 Java.io IO类包 包含能提供多种输入输出的文件读写类 Java.net 网络编程API Java.sql 数据库操作包 Java.text 文本处理相关类 包含了一些用来处理文本、数字和消息的类和接口 Java.awt 提供创建界面和绘制图形图像的所有类 Javax.asing awt上封装的GUI包 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"推荐3款文本编辑器","slug":"文本编辑器","date":"2019-11-22T02:34:04.000Z","updated":"2019-11-29T17:38:00.468Z","comments":true,"path":"2019/11/22/文本编辑器/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/22/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/","excerpt":"前言今天作者推荐两款文本编辑器。 我先后使用的Notepad 3、Sublime、Atom、VS Code、Vim。 这里作者就只推荐Notepad 3、Sublime和Atom。 关于VS Code和Vim，文末有两篇教程供大家入手。","text":"前言今天作者推荐两款文本编辑器。 我先后使用的Notepad 3、Sublime、Atom、VS Code、Vim。 这里作者就只推荐Notepad 3、Sublime和Atom。 关于VS Code和Vim，文末有两篇教程供大家入手。 //截断文章 Notepad 3 虽然 Windows 操作系统在过去几年中有了显著变化，但是，默认的 Windows 记事本却鲜有更新。如果您需要一个简单且适于编程的文本编辑器，Notepad3 将是一个不错的选择！ Notepad3是一款轻便快捷的基于 Scintilla 的文本编辑器，具有语法高亮、代码折叠、括号匹配、自动缩进、编码转换、换行格式转换、多次撤销或重做、书签、基于正则表达式的查找和替换等实用功能。它占用的内存很小，但功能强大，足以处理大多数编程工作。 Notepad 3 的界面 可能 是我见过所有主流文本编辑器里最最最简单清爽的吧？ 蓝奏云：下载链接（作者提供了已经汉化过的便携版本） （注意：Notepad 3和Notepad++没有关系 ） Sublime官方的介绍简单又粗暴 一款用于代码、标记和散文的精致文本编辑器 Sublime支持 Windows 、Mac 平台。插件是程序员的灵魂，Sublime不失这点。类似于 Eclipse，IDEA，它有着丰富的插件系统，完全可以满足各种开发编辑需求。1）安装 官网关于Sublime的介绍语下就是win版的下载入口或者点击这里快速下载最新版==Sublime Text 3 (Build 3207)== 下载得到的是exe，双击开始安装。 安装导向界面，点击【Next】继续安装。选择Sublime Text 3安装位置，您可以点击【Next】，软件会自动安装。或者您可以单击【Browse】，在弹出的安装位置窗口中，您可以自己选择Sublime Text安装位置，选择完成后点击【Next】。这里可选择 添加到资源管理器上下文菜单 。 安装完后可以在桌面或者开始菜单中找到Sublime。 2）使用Sublime的界面特别简洁，让人看着很舒服。这里，作者已经汉化过了。初始语言是English。 3）汉化 sublime 的插件的强大之处，sublime 通过 package control来统一管理安装的插件。现版本sublime 3自带package control功能。 将English变成Chinese，也可以通过Sublime的插件实现。 作者已经汉化过。为了教程，故在win7虚拟机上教大家如何实现汉化。 官网下载，并安装好, 刚安装好的是没有 Package Control 选项 找到 Tools-&gt;Install Package Control 选项，即可调出 Package Contro 不能直接找到 Install Package Control，去找“Tools-&gt;Command Palette…”选项 输入 ipc ,点击 Install Package Control，即可调出 Package Control 等待完成 找到 Preferences-&gt;Package Control 选项弹出命令行输入框，输入ip，点击“install Package 弹出命令行输入框，输入clz，点击“ChineseLocalizations” 搞定，设置成中文了 开开心心地食用汉化地Sublime吧 o(￣▽￣)o Atom Atom 是 Github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持CSS，HTML，JavaScript等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。 官网在这里👈友情链接：w3school之Atom教程Atom 中文社区 1）安装官网地Downloa或者点击这里快速下载最新版==Atom (1.41.0)== 下载得到exe，双击开始安装。安装过程很简单，直接省略。 2）使用Atom 的界面也比较简洁。Atom提供了侧栏、标签栏，可提高效率。Atom还能链接到GitHub，这真是GitHub用户的福利。(当然，Atom本来就是Github推出的hhhh)3）汉化Atom的汉化有两种方法： 方法一 打开软件后，点击 File&gt; Settings&gt; install 搜索 chinese，安装两个插件 重启软件因为插件托管在国外，可能因为网速原因，会非常慢，因此推荐下载中文插件包，请看方法二👇 方法二 打开https://atom.io/packages/去官网下载中文包，搜索【Chinese】，找到【atom-simplified-chinese-menu】点击进入主页（如上图），然后再点【Verions】，之后，找到最新版本，点【zip】包下载即可。。作者在这已经准备好中文包了，点击这里下载 将下载好了的压缩包解压到 C:/user/&lt;用户名&gt;/.atom/packages/目录下面 打开Atom，发现已经Chinese了。 综上主流的文本编辑器有很多。每个人的需求不一样，找到合适自己的才是好的。Notepad 3、Sublime、Atom、VS Code、Vim、Notepad++（前段时间闹事，作者不方便再提） VS Code：传送门 Vim：传送门 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Java笔记—继承","slug":"Java笔记—继承","date":"2019-11-21T09:54:59.000Z","updated":"2019-11-29T17:36:14.410Z","comments":true,"path":"2019/11/21/Java笔记—继承/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/21/Java%E7%AC%94%E8%AE%B0%E2%80%94%E7%BB%A7%E6%89%BF/","excerpt":"Java笔记——继承 创建时间：2019.11.21 说明：持续更新ing 继承源于自然 就比如：兔子和羊属于食草动物类，狮子和豹属于食肉动物类。食草动物和食肉动物又是属于动物类。虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以 子类会具有父类的一般特性也会具有自身的特性。","text":"Java笔记——继承 创建时间：2019.11.21 说明：持续更新ing 继承源于自然 就比如：兔子和羊属于食草动物类，狮子和豹属于食肉动物类。食草动物和食肉动物又是属于动物类。虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以 子类会具有父类的一般特性也会具有自身的特性。 //截断文章 概念、目的、本质、特性 概念 它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 其主要作用在于，在已有基础上继续进行功能的扩充。（即，以存在的类为基础定义新的类，新类即拥有基类的数据成员和成员方法） 目的 继承的目的是代码重用 本质 描述了自然界中广泛存在的一种关系——类属关系（is-a），对应还有一种has-a关系即组合（聚合）关系。 特性 Java 继承的特性 子类拥有父类非private的属性，方法 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展 子类可以用自己的方式实现父类的方法 Java的继承是单继承，【但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性】 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系） 继承的关键字 继承可以使用 extends(单继承) 和 implements（变相的多继承）， 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 （1）extends关键字 Java只支持单继承，即：一个子类只能有一个父类.但可以有多个间接祖先类。 语法格式： 123456权限修饰符 class 父类名 { //父类体}权限修饰符 class 子类名 extends 父类名 { //子类体} 实例： 123456789101112public class Animal { private String name; private int id; public Animal(String myName, String myid) { //初始化属性值 } public void eat() { //吃东西方法的具体实现 } public void sleep() { //睡觉方法的具体实现 } } public class Penguin extends Animal{ } —————————————————————— 我 是 分 割 线 ——————————————————————— （2）implements关键字 变相地使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 public interface A { public void eat(); public void sleep(); } public interface B { public void show(); } public class C implements A,B { } &lt;!--￼2--&gt; 执行结果： &lt;!--￼3--&gt; —————————————————————— 我 是 分 割 线 ——————————————————————— （4）this关键字 指向”自己的引用“。 实例： 123456789101112131415161718192021222324class Animal { void eat() { System.out.println(\"animal : eat\"); }} class Dog extends Animal { void eat() { System.out.println(\"dog : eat\"); } void eatTest() { this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 }} public class Test { public static void main(String[] args) { Animal a = new Animal(); a.eat(); Dog d = new Dog(); d.eatTest(); }} 输出结果： 123animal : eatdog : eatanimal : eat ——————————————————————————— 我 是 分 割 线 ———————————————————————————— （5）final关键字 声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。 继承类型 Java 不支持多继承，但支持多重继承 （ 一般不会超过三层 ）。 继承的限制 🔺 Java只允许单继承、不允许多继承（一个子类继承一个父类）。 🔺 子类对象在进行实例化前首先调用父类构造方法，再调用子类构造方法实例化子类对象。 🔺 在继承时，子类会继承父类的所有结构。 在进行继承的时候，子类会继承父类的所有结构（包括私有属性、构造方法、普通方法）显示继承：所有非私有操作属于显示继承（可以直接调用）。隐式继承：所有私有操作属于隐式继承（不可以直接调用，需要通过其它形式调用（get或者set））。 子类能够使用的是所有非private操作，而所有的private操作无法被直接使用，所以称为隐式继承。 继承中“域的隐藏” 在子类中重新定义( 同 名 )继承自父类的域. 🔺子类继承父类非私域。 🔺子类定义与从父类继承下来的同名域，在子类中用该名直接访问就只能访问到子类定义的域，即隐藏了同名的继承下来的父类域。 🔺如果要访问同名父类域：通过父类方法，或者使用“*super . *” 实例： 123456789101112131415161718192021222324import static java.lang.System.*;class Super{ private int v1 = 1; int v2 = 2; public int getV1() { return v1; }}class Sub extends Super{ int v1 = 11; int v2 = 22; public void show() { out.println(v1); //out.println(super.v1); out.println(getV1()); out.println(v2); out.println(super.v2); }}public class FHTest{ public static void main(String[] args) { new Sub().show(); }} 继承情况的构造 首先🔺类初始化时,继承链上(包括当前类)的全部静态代码块最先执行一次。之后不再执行，除非程序又重启。(按链序和声明序且仅1次) 其次🔺创建子类实例时,会先进行父类的构造(要么显式进行，要么隐式用super()进行) 最后🔺类的构造顺序：构造代码块(按声明序) ➡ 构造方法 总体🔺父类静态块 ➡ 子类静态块 ➡ 父类构造块 ➡ 父类构造子 ➡ 子类构造块 ➡ 子类构造子（下划线”__”部分， 仅执行一次） 总结 1、为什么使用继承 从已有的类派生出新的类，称为继承。 在不同的类中也可能会有共同的特征和动作，可以把这些共同的特征和动作放在一个类中，让其它类共享。 因此可以定义一个通用类，然后将其扩展为其它多个特定类，这些特定类继承通用类中的特征和动作。 继承是 Java 中实现软件重用的重要手段，避免重复，易于维护，易于理解。 2、父类和子类 如果类 B 从类 A 派生，或者说类 B 扩展自类 A，或者说类 B 继承类 A， 则称类 A 为”父类”，也称为超类、基类； 称类 B 为”子类”，也称为次类、扩展类、派生类。 子类从它的父类中继承可访问的数据域和方法，也可以添加新的数据域和新的方法。 定义继承的语法： 1修饰符 class 子类名 extends 父类名 例如：Shape 类是父类，其子类可以有 Circle 类、Rectangle 类、Triangle 类，等等。 继承的注意点： 子类不是父类的子集，子类一般比父类包含更多的数据域和方法。 父类中的 private 数据域在子类中是不可见的，因此在子类中不能直接使用它们。 继承是为”是一个”的关系建模的，父类和其子类间必须存在”是一个”的关系，否则不能用继承。 但也并不是所有”是一个”的关系都应该用继承。例如，正方形是一个矩形，但不能让 Square 类来继承 Rectangle 类，因为正方形不能从矩形扩展得到任何东西。正确的继承关系是 Square 类继承 Shape 类 Java 只允许单一继承（即一个子类只能有一个直接父类），C++ 可以多重继承（即一个子类有多个直接父类）。 3、super 关键字 super 表示使用它的类的父类。super 可用于： 调用父类的构造方法； 调用父类的方法（子类覆盖了父类的方法时）； 访问父类的数据域（可以这样用但没有必要这样用）。 调用父类的构造方法语法： 12345super(); 或 super(参数列表); 注意：super 语句必须是子类构造方法的第一条语句。不能在子类中使用父类构造方法名来调用父类构造方法。 父类的构造方法不被子类继承。调用父类的构造方法的唯一途径是使用 super 关键字，如果子类中没显式调用，则编译器自动将 super(); 作为子类构造方法的第一条语句。这会形成一个构造方法链。 静态方法中不能使用 super 关键字。 调用父类的方法语法： 1super.方法名(参数列表); 如果是继承的方法，是没有必要使用 super 来调用，直接即可调用。但如果子类覆盖或重写了父类的方法，则只有使用 super 才能在子类中调用父类中的被重写的方法。 4、this 关键字 this 关键字表示当前对象。可用于： 调用当前类的构造方法，并且必须是方法的第一条语句。如：this(); 调用默认构造方法。this(参数); 调用带参构造方法。 限定当前对象的数据域变量。一般用于方法内的局部变量与对象的数据域变量同名的情况。如 this.num = num。this.num 表示当前对象的数据域变量 num，而 num 表示方法中的局部变量。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—数组","slug":"Java笔记—数组","date":"2019-11-20T04:54:46.000Z","updated":"2019-11-29T17:36:21.566Z","comments":true,"path":"2019/11/20/Java笔记—数组/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/20/Java%E7%AC%94%E8%AE%B0%E2%80%94%E6%95%B0%E7%BB%84/","excerpt":"Java笔记——数组创建时间：2019.11.20 说明：持续更新ing ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 数组 数组是一组相同类型的变量（元素）的集合。可以用来存放一组相同类型的数据。数组的学习涉及数组的定义、赋值和使用。再扩展一点就是二维数组的应用。数组既是一种重要的数据类型，也是一种重要的数据结构。 数组（array）————一组相同类型的变量(元素)集合 相同的任意类型 (包括基本类型、类类型等) 这组变量被连续地存放在Java堆区的内存空间 数组是一种引用类型，数组名是一个地址的别名 数组需要创建（new），否则不会被分配堆空间 数组名对应的地址单元中存放上述连续堆区空间的首地址 🔺 对程序员而言, 数组总体有三样东西：数组名+数组长度+数组元素","text":"Java笔记——数组创建时间：2019.11.20 说明：持续更新ing ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 数组 数组是一组相同类型的变量（元素）的集合。可以用来存放一组相同类型的数据。数组的学习涉及数组的定义、赋值和使用。再扩展一点就是二维数组的应用。数组既是一种重要的数据类型，也是一种重要的数据结构。 数组（array）————一组相同类型的变量(元素)集合 相同的任意类型 (包括基本类型、类类型等) 这组变量被连续地存放在Java堆区的内存空间 数组是一种引用类型，数组名是一个地址的别名 数组需要创建（new），否则不会被分配堆空间 数组名对应的地址单元中存放上述连续堆区空间的首地址 🔺 对程序员而言, 数组总体有三样东西：数组名+数组长度+数组元素 “声明、创建、初始化、访问”数组 声明数组： 🔺只给数组变量(由数组名描述)分配空间，而不会给数组按要存放的元素的多少来分配空间。 有两种形式——&gt;推荐第一种： 数据类型[] 数组名 12345//数据类型[] 数组名int[] a;//数据类型 数组名[]int a[]; ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 创建数组：用new运算符，同对象的创建。 有两种形式——&gt; 123456//先声明，后创建int[] a; //声明存放int型数据的数组aa = new int[10]; //在Java堆区中创建10个int型元素空间(共40个字节)//声明和创建合一int[] test = new int[12]; 注意： 🔺声明数组，仅仅创建数组变量🔺创建数组，才在堆区中分配空间 [ ]中必须是非负整数，否则执行时异常。可以是字面常量、也可以是变量，只要保证其值是非负整数。 创建数组之后，各元素的默认初始值是：数值型为0(0.0)；字符型’\\0’；引用类型null；布尔型false ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 初始化数组：在创建好的数组元素空间中存放初始值.否则按默认值初始化。 🔺数组创建时（即new时使用）初始化器语法：{元素值列表}。 12//声明存放int型数据的数组aMonth并初始化int[] aMonth = new int[]{1,2,3,4,5,6,7,8,9,10,11,12}; 注意： 使用了初始化器之后不能显式指定长度 即 new int[12]{…} ，不对 12345int[] a; //先声明数组aa = new int[2]{1,2}; // Error,不能显式指明长度[2]a = {1,2}; // Errora = new int[]{1,2}; // OK!int[] b = {1, 2}; // OK!此方式用得最多 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 访问数组： 🔺数组元素：数组中的每一个变量，也被称为下标变量，索引变量 🔺下标从0开始：用[ ]运算符访问元素，即 数组名 [ 数组下标 ] 🔺既然是变量，所以数组元素可以作为左值也可以作为右值，比如a[i]++、b[0]=5;、a=b[0]+2;等等。 数组长度属性 🔺数组唯一的一个 只读 属性：length 存有数组元素个数值。 🔺*数组名.length * 遍历数组 🔺增强版for语句：foreach语句（JDK5开始提供） 🔺适用于遍历数组、集合元素等形式 123for(元素的数据类型 遍历变量x : 遍历对象obj){ //x是自定义遍历变量名 引用了x的Java语句; //循环体 } 注意： foreach语句是for的简化,任何foreach语句都可以改用for语句，反之不行。 foreach语句不关注下标。 用foreach的遍历变量不能修改元素值。 123456789public class Demo { public static void main(String[] args) { int[] a = {1, 3, 4, 5, 6, 8, 10}; /* 循环输出a */ for(int n : a){ // 利用变量n遍历数组a System.out.printf(\"%4d \", n); // n表示数组a的每一个元素值 } } } 二维数组、多维数组 Arrays 类 主要功能： 🔺java.util.Arrays类： 数组操作实用类,它提供了一系列静态方法 equals()方法:比较两个数组长度是否相同和对应索引上的元素值是否相同. fill()方法:向数组中填充数据. copyOf()方法:复制一个数组的部分元素并生成一个新的数组返回 sort()方法:若是基本类型则把数组元素按自然顺序升序排列.若是引用类型,其该实现了Comparable接口才能调用sort方法,否则报异常. binarySearch()方法:对已排序数组使用二分查找算法查找指定元素. asList()方法:返回数组的List对象形式. toString()方法:返回包含所有元素信息的字符串 parallelSort()方法:开启多线程的排序. deepEquals()方法:深度比较两个数组是否相同.适于任何深度的多维(嵌套)数组. 问：数组可以作为方法的参数或返回值吗？ 当然是可以的 。答案来源 m博客 数组作为方法参数 🔺数组作为方法参数传递，传递的参数是数组内存的地址。 123456789101112public static void main(String[] args) { int[] arr = {11, 22, 33, 44, 55}; System.out.println(\"1位置: \" + arr); printArray(arr); // 数组作为方法参数传递，传递的参数是数组内存的地址}public static void printArray(int[] arr) { System.out.println(\"2位置: \" + arr); for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); }}1234567891011 数组作为方法返回值 🔺数组作为方法的返回值，返回的是数组的内存地址。 123456789101112131415161718public static void main(String[] args) { //调用方法，接收数组的返回值 //接收到的是数组的内存地址 int[] arr = getArray(); for (int i = 0; i &lt; arr.length; i++) {System.out.println(arr[i]); }}/* 创建方法，返回值是数组类型 return返回数组的地址*/public static int[] getArray() { int[] arr = { 1, 3, 5, 7, 9 }; //返回数组的地址，返回到调用者 return arr;}1234567891011121314151617 该博主的延伸阅读： Java–数组的定义和访问、Java–数组原理内存图、Java–数组的常见操作 判断： Java中数组可以动态改变长度？ 错误。 Java中的数组的定义就是相同类型，固定长度的一组数据，一旦被初始化，长度不可更改。 10. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"教会你怎么安装和使用 Visio 哦 ~ ~","slug":"Visio教程","date":"2019-11-19T01:34:04.000Z","updated":"2019-11-29T17:38:35.080Z","comments":true,"path":"2019/11/19/Visio教程/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/19/Visio%E6%95%99%E7%A8%8B/","excerpt":"前言 很多学生会在编程、设计或其他时候可能使用到【制图工具】。最好用的莫不过【微软的Visio】了。但是很多学生不会使用Visio，甚至不会安装Visio。 &gt; Visio 这么好的工具，一定要会用。 今天，作者写一份教程，教会大家了解如何安装和使用 ==Visio==。 在正式教程之前，我们先介绍 Visio。 Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。 &gt; Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。","text":"前言 很多学生会在编程、设计或其他时候可能使用到【制图工具】。最好用的莫不过【微软的Visio】了。但是很多学生不会使用Visio，甚至不会安装Visio。 &gt; Visio 这么好的工具，一定要会用。 今天，作者写一份教程，教会大家了解如何安装和使用 ==Visio==。 在正式教程之前，我们先介绍 Visio。 Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。 &gt; Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。 //截断文章 安装1. 【下载资源】 网上也有很多资源，但是包是不完整的。版本也很多，要激活也不容易。 作者在这里已经打包好“Visio 2019”和“激活工具”了，点击这里(提取码: rwtr)开始下载。 由于现在的笔记本都是预装win10的，所以不用担心Visio 2019合不合适。毕竟Visio 2019在win7上是安装不了的。2. 【解压】 下载得到压缩包，解压，打开文件夹。 3. 【打开Setup】 打开“Visio 2019”，右键“Setup”选中“以管理员身份运行”。（似乎不用管理员也行？？？） 4. 【正在安装】 等待就好，很快的。 5. 【安装完成】 安装结束，点击“关闭”。 6. 【激活】 Visio 2019是==必须激活==才可以使用的。 否则，会一直弹窗提示激活的。 激活工具在另一个文件夹里。 补充一些关于KMS： KMS（全称:Key Management Service），这个是微软的一种新型产品激活机制，目的是为了Microsoft更好的遏制非法软件授权行为(盗版)。 当然作者不提倡破解、或盗版。 对于有能力的人，还是支持正版。但是学生嘛，能用就好了。 使用激活工具前，作者建议： ==最好关闭杀毒软件，如果有的话。== 作者没安装360那些，很流畅地激活成功。 ==激活工具无毒的。不关闭的话，可能被误报。== 1).【打开】 界面如下： 这个激活工具还可以xxxxxx。（你懂的） 我啥都没说哦hh 2).【激活】 简单一按，等待激活成功就好。 补充：可能有的电脑打开软件时会提示这个。解决很简单，安装框架就好。 （1）打开“控制面板”。（2）找到并点击“程序和功能”项，在打开的页面中，点击“启用或关闭Windows功能”。（3）在打开的“Windows功能”对话框中，找到并勾选“Microsoft.Net Framework”服务，单击“确定”即可。 使用激活后，就可以安安心心、大大方方地使用 Visio 了。o(￣▽￣)o 【打开】 【新建】新建页面，有一些初始模板可以使用。一般选择“基本框图”就好，然后“新建”。 【制图】 左侧可以选择很多官方自带的形状，当然还可以自己建立自己的模型。 右侧可以对图形自定义，包括颜色、线条、端点等等。 结尾使用 Visio 来制图真的很爽。但是，如果只是临时制图使用 Visio ，还得安装确实不太方便。因此 作者还收藏了几个线上制图的网站，在这提供给大家临时使用。 1. https://www.draw.io/ 2. https://zh.numberempire.com/graphingcalculator.php 3. https://www.processon.com 4. 当然用电脑自带的【画图】也是可以的，你看。 emmm只是好难看啊hhhh。 这就是结尾：如果教程上有什么不足的或者有问题的，可以私信我。谢谢你的阅读！ 本博客第一次发表于【简书】： https://www.jianshu.com/p/32648bcc6f1c 。现转载到作者的网站上。谢谢阅读！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"百合","slug":"百日","date":"2019-11-16T12:54:59.000Z","updated":"2019-11-25T12:23:15.221Z","comments":true,"path":"2019/11/16/百日/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/16/%E7%99%BE%E6%97%A5/","excerpt":"2019.11.16 星期六 晴天","text":"2019.11.16 星期六 晴天 💙汪曾祺老人的散文《活着多好呀》中“活着多好呀”为汪老一句名言。这位老人不管遇到什么环境，永远不消沉沮丧，守护心中的热情与生机，兴致盎然地生活。💛时光机，这个世界不存在的理想物品。可是我多希望有这东西，真是可惜无法回到两三年前，“时间就是让人猝不及防的东西”……💜有段时间，喜欢黑暗安静的环境。肚子一个人发呆，内室里一个窗户也不开，杜绝所有来往。但已经走出来那段抑郁期，今后不知道，但是现在我挺好的。恍惚发现，最好掩盖哭的方式，除了偷偷一个人，就是洗澡的时候。💚或记日记或写随笔或向月亮倾诉或对空气说说，~生活不易，但也没那么糟糕。柏拉图说：没有什么比健康更快乐的了，虽然在他们生病之前并不曾觉得那是最大的快乐。💗“谢谢你的不告而别”。下辈子，我们再会 ! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"解除课程中心看视频时的“ 窗口获取焦点事件 ”","slug":"解除课程中心看视频时的“ 窗口获取焦点事件 ”","date":"2019-11-16T09:54:59.000Z","updated":"2019-11-23T02:16:39.416Z","comments":true,"path":"2019/11/16/解除课程中心看视频时的“ 窗口获取焦点事件 ”/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/16/%E8%A7%A3%E9%99%A4%E8%AF%BE%E7%A8%8B%E4%B8%AD%E5%BF%83%E7%9C%8B%E8%A7%86%E9%A2%91%E6%97%B6%E7%9A%84%E2%80%9C%20%E7%AA%97%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6%20%E2%80%9D/","excerpt":"前言前段时间，在观看课程中心的马克思视频，因为要至少看到80%以上。 发现那我挂着刷不就得了？偏偏。。。。。 发现这个课程中心存在某个机制——一定要使视频一直处于“置顶”的状态，否者会自动暂停视频。","text":"前言前段时间，在观看课程中心的马克思视频，因为要至少看到80%以上。 发现那我挂着刷不就得了？偏偏。。。。。 发现这个课程中心存在某个机制——一定要使视频一直处于“置顶”的状态，否者会自动暂停视频。 //截断文章 就像下图这样： 操作鼠标前——&gt; 操作鼠标后——&gt; 你会注意到，视频的播放状态跟鼠标的行为有关，准确来说是==和鼠标点击的位置（焦点）有关==。 第一时间想到“这不就是windows的“窗口获取焦点”吗？ 补充先补充补充什么是窗口获取焦点？ 在你浏览其他窗口页面、或是浏览器最小化、又或是点击了程序窗口时，等等都算是浏览器窗口失去焦点，这时候 window.onblur 事件就会触发。 当然，当你的页面获得焦点的时候一样也会触发window.onfocus。 应该有人会注意到过，当你点击不同窗口时，窗口栏会有不同的颜色反馈，就比如win 10的资源管理器，前置窗口和后置窗口的窗口颜色是不是不一样？ 寻找直接按下F12，打开控制台，查看Elements…… emmmmmm结果，没找到对应的代码（或许我没仔细去挖hh） 再试那我直接Console。不就是当前窗口获取了焦点吗？？？？直接暴力敲下代码，并Enter，嘿嘿…… 1javascript:window.onblur=null;void 0 //有无`void 0`，都可以 当我Enter时，诶，成功了hhh效果就是这样。 后续测试了一段时间后，成功率基本达97%左右。后来就分享到班群，让更多人试试效果。两天刷完所有马克思的视频哈哈有木有？ 建议 一次最多同时两个视频在看，因为后台有个计时器再加上我不会写自动播放、自动静音的脚本hhhhh（有时间再去琢磨哈） 一旦刷新页面，就得重新Enter脚本 极小几率会失败，原因我也不清楚，失败重新Enter即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://melodyjerry.github.io/blog/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"Java笔记—对象、类","slug":"Java笔记—对象、类","date":"2019-11-15T04:54:59.000Z","updated":"2019-11-30T10:18:12.578Z","comments":true,"path":"2019/11/15/Java笔记—对象、类/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/15/Java%E7%AC%94%E8%AE%B0%E2%80%94%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB/","excerpt":"Java笔记——对象、类创建时间：2019.11.11 说明：持续更新ing 对象和类的概念。 对象：对象是类的一个实例（实实在在存在的个体），有属性（状态）和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 属性(property)： 静态特征行为(behavior)： 动态特征 类：类是对现实生活中事物的描述。类是一个模板，它描述一类对象的行为和状态。同种类型对象共性的抽象","text":"Java笔记——对象、类创建时间：2019.11.11 说明：持续更新ing 对象和类的概念。 对象：对象是类的一个实例（实实在在存在的个体），有属性（状态）和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 属性(property)： 静态特征行为(behavior)： 动态特征 类：类是对现实生活中事物的描述。类是一个模板，它描述一类对象的行为和状态。同种类型对象共性的抽象 用老师的话来说，就是下面这样——&gt; 下图中男孩（boy）、女孩（girl）为类（class），而具体的每个人为该类的对象（object）： 【定义类】 Java中的类 类可以看成是创建Java对象的模板。 通过下面一个简单的类来理解下Java中类的定义： 123456789101112public class Student { int id; String name; double score1, score2, score3; public Student(int id, String name) { this.id = id; this.name = name; } public double getAverageScore() { return (score1 ＋ score2 + score3) / 3; } } 一个类可以包含以下类型变量： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。一个类可以拥有多个方法。 Java中的对象现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。对比现实对象和软件对象，它们之间十分相似。 软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 创建对象——&gt; 1234567891011/*有两种基本形式*//*1.对象声明和创建*/类名 对象名 = new 类名();Student xiaoming = new Student ();/*2.先声明,后创建*/类名 对象名; // 类(对象)变量对象名 = new 类名(); //实例化Student xiaobai ;xiaobai = new Student(); 类和对象的关系：类是具有相同==属性和方法==的集合，是对对象的抽象描述。 现实生活中的对象：张三、李四。 【想要描述】提取对象中的共性内容。对具体的抽象。 【描述时】这些对象的共性有：姓名、学号、年龄、性别、学习Java等等。（即定义类：描述事物的属性和行为，就是在定义属性和行为。属性和行为共同成为类中的成员（成员变量和成员方法）。） 映射到Java中，描述就是class定义的类，具体对象就是new建立的实体。 这些描述在Java当中是用类的形式来体现的。而对象是通过Java的new操作符所产生的一个实体，这个的实体存在于==堆内存==当中。 12345678910111213141516171819202122232425//定义类，就是描述事物，就是在定义属性和行为。属性和行为共同成为类中的成员（成员变量和成员方法）。//需求：描述车汽车（颜色，轮胎数）。class Car { //描述颜色 String color = \"red\"; //描述轮胎数 int num = 4; //运行行为。 void run() { System.out.println(color+\"..\"+num); }}class CarDemo { public static void main(String[] args){ //生产汽车：在Java中通过new操作符来完成。 //其实就是在堆内存中产生一个实体。 Car c = new Car(); //c就是一个【类类型】变量。记住：类类型变量只想对象。 //需求：将已有车的颜色的颜色改成蓝色。指定该对象做使用。 //在Java指挥方式是：【对象.对象成员】 c.color = \"blue\"; //需求：想要车运行起来。 c.run(); }} Car c = new Car();在内存中的示意图——&gt; c.run();——&gt;输出这个车的颜色“蓝色”和轮胎数“4”。 (1)倘若在c.run();后加入Car c1=new Car();c1.run();——&gt; (2)若main的代码块改为： 123456789class CarDemo { public static void main(String[] args){ Car c = new Car(); c.num = 5; Car c1 = c; c1.color = \"green\"; c.run(); }} 在内存中的示意图——&gt; 对对象调用的基本概念：用new建立对象，在堆内存中产生对象。那么对象的特点在于封装数据，数据包含属性和行为。想要操作对象中的内容就指挥对象做事，指挥哪个对象要明确，操作什么也要明确，用对象.xyz的形式就能完成。 【注意】：如下图， 以前定义在函数里面，现在定义在函数外面 【方法】 方法的定义： 方法是类或对象的行为特征的抽象。 Java中的方法不能独立存在，所有的方法必须定义在类中。 使用 “类名.方法” 或 “对象.方法” 的形式调用。 语法格式： 1234权限修饰符 返回值类型 方法名（参数类型 参数名1,参数类型 参数名2,...） { // 方法体 方法语句序列//当返回类型非void时,最后一条被执行语句必须是return语句,返回对应类型的值} 访问权限/权限修饰符（4P权限）： 访问权限 类内 包层内 子类 包层外 public √ √ √ √ protected √ √ √ × package （缺省） √ √ × × private √ × × × return语句： 结束方法调用，并返回值。 return 表达式; return; 🔺方法被调用时,执行到方法内的return语句,则不论方法里是否还有语句未执行,立即结束方法的调用,并将return 后的表达式的值返回方法调用者🔺利用return 语句返回值，仅能返回一个值🔺return语句仅结束方法的执行 🔺void型方法 方法分类： 无参数无返回值 有参数无返回值 无参数有返回值 有参数有返回值 123456789101112131415161718192021222324252627282930public class Method { public void aMethod() { System.out.println(\"无参数无返回值的方法\"); } public void bMethod(int b) { System.out.println(\"有参数无返回值的方法\"); } public int cMethod() { System.out.println(\"无参数有返回值的方法\"); return 10; } public int dMethod(int d) { System.out.println(\"有参数有返回值的方法\"); return d; } public static void main(String[] args) { int ret; // 创建Method类的对象 Method md = new Method(); // 通过对象.方法调用 md.aMethod(); md.bMethod(10); ret = md.cMethod(); ret = md.dMethod(10); System.out.println(ret); }} 方法的参数： 方法可以没有参数，或者有多个参数，参数类型可以是任意类型 方法参数也是局部变量 参数为引用数据类型4时： 当对象实例作为参数传递给方法时，传递的是对象的引用，为地址传递，接受参数的方法可以改变参数的值。 参数为简单数据类型时： 传递的是参数的副本，为值传递，接受参数的方法中不会改变参数的值。 123456789101112131415161718192021222324252627282930313233343536373839public class MethodParam { /** * 方法的参数为基本数据类型时，传递的是值的副本（值拷贝） * 方法中不会改变元参数的值 */ public void swap(int a, int b) {//a, b为形参 int tmp; tmp = a; a = b; b = tmp; } int x = 100, y = 200; /** * 方法的参数为引用数据类型时，传递的对象的引用（传地址） * 方法中可以改变参数的值 */ public void swap2(MethodParam mp) { int tmp = mp.x; mp.x = mp.y; mp.y = tmp; } public static void main(String[] args) { MethodParam mp = new MethodParam(); int m = 10, n = 20; System.out.println(\"交换前：a = \"+m+\",b = \"+n); mp.swap(m, n);// m,n为实参 System.out.println(\"交换后：a = \"+m+\",b = \"+n); System.out.println(\"交换前：x = \"+mp.x+\",y = \"+mp.y); mp.swap2(mp); System.out.println(\"交换后：x = \"+mp.x+\",y = \"+mp.y); }} 普通方法调用——&gt; 成员方法和成员变量的关系——&gt; 【成员方法】和【构造方法】 【成员方法】 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【构造方法】 构造方法需满足以下三个条件 ： 1、方法名与类名同名 2、在方法中不能使用 return 语句，即无返回值 3、在方法名的前面*没有返回值的类型声明 * （有看到“ 构造方法无返回值也不可以加void，但其实返回的是首地址 ”这话还得去证实，先放在这里） ==老师推荐==：显式无参构造子,作为一种良好实践,定义了其他构造子，那就准备一个无参构造子 12345678910111213package me;public class Me { private String name; //成员变量 public Me(String name){ //构造方法 this.name = name; } public String getName() { //成员方法 return name; } public void setName(String name) {//成员方法 this.name = name; }} 我如果我在添加一age 如下 添加方法依然是成员方法 , 1234567891011121314151617181920package me;public class Me { private String name; //成员变量 private String age; //成员变量 public Me(String name){ //构造方法 this.name = name; } public String getName() { //成员方法 return name; } public void setName(String name) {//成员方法 this.name = name; } public String getAge() {//成员方法 return age; } public void setAge(String age) {//成员方法 this.age = age; }} 个人理解：无论多少方法，==除了构造方法外，其余都是成员方法==，当然这样理解可能有点偏见.. 它们的区别： 构造方法一般是给对象的数据进行初始化,没有返回值 成员方法一般实现对类中成员变量的操作，提供某些功能,有返回类型，可以为void类型 成员方法与构造方法调用的区别 123456789package me;public class Book { public static void main(String[] args) { Me me = new Me(\"张三\");//构造方法调用 System.out.println(me); me.setName(\"李四\");//成员方法调用 System.out.println(me.getName()); }} 从上面的demo中可以看出，==构造方法通过new运算符调用==，==成员方法通过对象调用==。 注意：类中除了构造方法以外的方法都是成员方法。原因是在类中，除了变量外的基本都是成员方法。 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【this 关键字】 https://i.loli.net/2019/11/16/49d7AMODXhKbsuy.png ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【重载构造方法之间的调用】 【含对象成员的构造方法调用】 【无继承情况下的对象初始化顺序】 【创建对象】 对象是根据类创建的。在Java中，使用关键字new 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 下面是一个创建对象的例子： 12345678910public class Puppy{ public Puppy(String name){ //这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public static void main(String[] args){ // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( \"tommy\" ); } } 编译并运行上面的程序，会打印出下面的结果： 1小狗的名字是 : tommy ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【访问实例变量和方法】 通过已创建的对象来访问成员变量和成员方法，如下所示： 123456/* 实例化对象 */ Object referenceVariable = new Constructor(); /* 访问类中的变量 */ referenceVariable.variableName; /* 访问类中的方法 */ referenceVariable.methodName(); ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【访问实例变量】和【调用成员方法】： 1234567891011121314151617181920212223public class Puppy{ int puppyAge; public Puppy(String name){ // 这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public void setAge( int age ){ puppyAge = age; } public int getAge( ){ System.out.println(\"小狗的年龄为 : \" + puppyAge ); return puppyAge; } public static void main(String[] args){ /* 创建对象 */ Puppy myPuppy = new Puppy( \"tommy\" ); /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println(\"变量值 : \" + myPuppy.puppyAge ); } } 编译并运行上面的程序，产生如下结果： 123小狗的名字是 : tommy小狗的年龄为 : 2变量值 : 2 【方法重载，重构，覆盖，重写的区别】 方法重载还是比较好理解的，就是在类的内部，定义多个方法，这些方法的方法名字相同，参数类型、参数顺序、参数个数不同，注意，返回值类型并不能区分重载 。 123456789public void show(int a,double b){}public void show(double c){} public int show(double d){ return 1;} //报错，方法已经定义了 方法重写（override)方法重写和方法覆盖都是一个道理，发生在子类继承父类或者实现接口的类，要求的是： 1.方法名字相同，2.参数个数不同，3.返回值类型不同 ， 代码： 方法重构 定义：在不改变外界外界访问的情况下对代码进行修改，但是不改变原方法的效果，提高其性能，使程序更加易读，可维护。重构是在不改变软件可观察行为的前提下改善其内部结构重构通常不是一次性的，它贯穿软件的整个生命周期，只要觉得不合理都是重构的时机。 题目：下面说法中，错误的有（ ） ​ A. Java面向对象语言容许单独的过程与函数存在； ​ B. Java面向对象语言容许单独的方法存在； ​ C. Java语言中的方法属于类中的成员（member）； ​ D. Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同。 答案：ABC 解释： 方法与函数：这两个概念不严格区分，就是一个东西，通过对象调用的，就是方法，直接调用，就是函数； 在java中，everything is object 所以，方法，函数，必须隶属于某一个类或对象， java中没有过程。（类中的代码块不知道算不算，就算代码块是过程，也是必须在类中才有的） 对于C选项，方法分为静态方法和非静态方法，静态方法属于类成员，非静态方法属于实例成员。 类其实一种类型，它封装了数据和操作。 对象是类的实例 一个对象比属于某个类 一个类可以声明多个对象 问：构造方法可以调用本类的其他方法吗？ 1,构造方法可以调用本类的其他方法。既然可以调用本类的属性,那么也就可以调用属于本类的其他方法。 2,需要注意的是,如果要在构造方法里调用一个非静态方法时,应该将该方法声明为private。因为如果这个类被其他类继承成为父类时,这个方法不是private的又被子类所重载，这样在实际创建子类的过程中递归调用到了父类的构造器时，父类构造器对这个方法的调用就会由于多态而实际上调用了子类的方法，当这个子类方法需要用到子类中实例变量1的时候，就会由于变量没有初始化而出现异常（子类中的实例变量没有初始化这种情况还是会遇见的），这是Java不想看到的情况。 一个类的构造方法有多个，在其他类中是否可以被调用？ 只要不是私有的构造函数，在其他类中就可以调用。 传对应的参数就行了 。 12345678910class` `A{ ``public` `A(String s){} ``public` `A(``int` `n){} ``public` `A(String s, ``int` `n){}}class` `B{ ``A a1 = ``new` `A(``\"abc\"``); ``A a2 = ``new` `A(``1``); ``A a3 = ``new` `A(``\"aaa\"``,``2``);} 类是一种引用类型。 Java的引用类型只有三种，分别是 类(class) 接口(interface) 数组 参考资料 问：方法一定是在类内部被定义的？ 所有方法必须写在类体里，也包括构造方法2的。 static方法同样属于类，叫类方法或静态方法，它与类一同被加载时，处于内存的公共代码区中，无需创建实例来调用，只需用类名引用即可。 static方法既可以通过类名来调用，也可以通过类的实例调用。 Java一切都是以类的形式存在，方法是类的一部分，需要通过类才能进行方法的调用。 从内存存储角度来说，java中找对应方法时，都是先找对应类实例，类实例是根据类来初始化内存的。如果方法在类外部，则无法找到该方法。 所以方法必须在类体里。 注意： 可以在其他类里使用这个类的方法（在不同的包下就要引ltem这个类），继承就是一个类从另一个类继承通过关键字extends 来实现 问：构造方法中可不可以有return语句呢? （这个解释有问题？）可以。而是我们写成这个样子就OK了：return; 其实，在任何的void类型的方法的最后你都可以写上：return; 问：非构造方法的一般成员方法必须有return语句？ 错。 （待补充……） 问：类中的数据成员可以按需选择任意类型，包括类本身？ 可以。可以参考下图，图源于陈三千的博客 问：Java中构造函数的权限可以是private吗？ 可以，这个类就不能再外部被new了，如果需要这个类的实例化对象，就只能在类内部提供静态方法生产这个类的对象了。 问：构造方法能不能被重载，构造方法能不能被重写？ 在回答这两个问题之前，首先先回顾：什么是构造方法？构造方法的特点是什么？ 概述：构造方法存在于类中，给对象数据（属性）初始化； 特点：方法名与类名一样；无返回值无void; 默认构造方法：我们不创建一个构造方法时，系统默认提供一个无参构造；当我们创建一个构造方法时，系统不再提供无参构造，所以在实际项目中，全部手动给出无参构造 其次\\什么是重载？什么是重写？** 重载：存在于在一个类中，方法名相同，方法参数的类型或个数不同 重写：存在于子父类中，方法名、方法参数、返回值全部相同 所以：构造方法可以重载，不能重写 在一个类中，可以有多个构造方法（方法参数不同） ，即重载，来实现对象属性不同的初始化； 但是子类中不能定义一个方法无void无返回值的方法，编译错误，即子类无法继承构造方法，但是子类的构造器中可以调用父类的构造方法（默认自动调用无参构造） 注意：回答来源于 CSDN博客 Java中可以定义一个空类（即没有数据成员和成员方法） 。 问： 下面这个类有几个构造方法？ 1class A{} 1个。（待补充……） 问：Java 类可以作为（ C ） A．类型定义机制 B．数据封装机制 C．类型定义机制和数据封装机制 D．上述都不对 用于定义类头的修饰符可以是public、abstract、final或者是默认(friendly) 题目：下列说法错误的有（ CD ） A． 在类方法中可用this来调用本类的类方法B． 在类方法中调用本类的类方法时可直接调用 C． 在类方法中只能调用本类中的类方法 D． 在类方法中绝对不能调用实例方法 C：类方法可以调用外部其他类的方法。D：只要实力化对象，也是可以调用实例方法的。 判断： 只有基本类型的参数传递使用值传递。 错误。 引用类型参数的传递，依然是值传递。但因为是地址值，所以会指向同一个对象实例。 Java中方法的参数传递是值传递（pass by value），并且为单向传递。 《Java 变量参数传入方法，修改后是否影响外面的值》。参考 博客 《某个变量当作函数的参数传递后，函数内部修改了。到底这个变量是否受影响》。参考 博客 问：类设计get方法和set方法的作用是什么？ 答1：一般类的成员变量被设置为private（私有的），这样设置安全性比较高，但是设置为私有的后其他的类和对象则无法调用该对象了，所以会有get和set方法，这两个方法一般设置为public，在其他的类中通过对象调用set或get方法即可操作私有的变量，增强程序的安全性，set为给对象赋值的方法，而get则是取得变量值的方法！ 答2：get set常用在自定义类，类创建了一个实例对象后，用set设置对象的某一个属性，get得到对象某一属性。如果不使用get set，你就得用点，点出来还得是个方法。其实就是给get set换个名而已。而且get set作为内部方法，可以访问私有数据 答3：别说的那么专业化了，理解都要半天。就这么理解吧，面向对象中，想对类的成员变量设置访问一些权限，于是，就将该字段设置为private的，这样别的类就不能访问了，然后在该内定义两个方法，一个专门用于获取，一个用于修改，这样，在你不想让别人乱动该字段的时候，就在该方法内写一些限制条件。而为了规范起见（团队开发需要嘛），就根据人家老外的习惯，将方法名设置为set+字段名，get+字段名（名字乱改没问题），既然规范了，那就是别人都叫这名了，于是，有些框架给对象赋值就有方法了，方法名称由get或set开始的又有private变量名的，就找出来调用。hibernate1框架就这样弄得，至于后面的版本是不是这样就不大清楚了。JavaBean就是一个JAVA类，既然是JAVA类就不需要什么组件了，这玩意直接深入到虚拟机了的 Java的包装类： 【包装类的概念】 【Integer类的用法】 【自动装箱机制和自动拆箱机制】 匿名对象： 使用方法： 当对对象的方法只调用一次，可以使用匿名对象来完成，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。 可以将匿名对象作为实际参数进行传递。 注脚：1.实例变量（全局变量）、成员变量、实例变量、属性 ↩2.java的构造方法、java的构造方法、Java入门：构造方法 ↩3.来创建一个新的对象。创建对象需要以下三步： ↩3.java之new的用处 ↩4.JAVA中基本数据类型和引用数据类型区别 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—面向对象","slug":"Java笔记—面向对象","date":"2019-11-13T04:54:46.000Z","updated":"2019-11-29T17:35:40.535Z","comments":true,"path":"2019/11/13/Java笔记—面向对象/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/13/Java%E7%AC%94%E8%AE%B0%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"Java笔记——面向对象创建时间：2019.11.11 说明：持续更新ing Java作为一种面向对象语言。支持以下基本概念： 多态 | 继承 | 封装 | 抽象 类 | 对象 | 实例 | 方法 | 重载 “面向对象”和“面向过程”的区别： 面向过程：如 C/C++ 例子：冰箱装大象。1、打开冰箱门；2、放进大象；3、关上冰箱门。强调过程，“打开”、“存储”、“关闭”三个动作。注重过程，注重的是过程涉及的行为（即功能）。 面向对象：如 Java 将功能封装进对象，强调具备了功能的对象。 面向对象是基于面向过程的。","text":"Java笔记——面向对象创建时间：2019.11.11 说明：持续更新ing Java作为一种面向对象语言。支持以下基本概念： 多态 | 继承 | 封装 | 抽象 类 | 对象 | 实例 | 方法 | 重载 “面向对象”和“面向过程”的区别： 面向过程：如 C/C++ 例子：冰箱装大象。1、打开冰箱门；2、放进大象；3、关上冰箱门。强调过程，“打开”、“存储”、“关闭”三个动作。注重过程，注重的是过程涉及的行为（即功能）。 面向对象：如 Java 将功能封装进对象，强调具备了功能的对象。 面向对象是基于面向过程的。 使用不同思想，对“冰箱装大象”的理解——&gt; 问：“人开冰箱”事件，其中人、冰箱都是实物（对象），开是动作。若使用面向对象思维，“开”的这个动作是属于“人”还是属于“冰箱”？ 答：属于“冰箱”，“人”只是调用了“冰箱”的“开”的方法（或功能），用力作用了门一下并将门打开了。 1234567891011121314人开门：名词提炼法。/*人{ 开门（门）{ 门.开（）; }}门{ 开（）{ 操作门轴; ……等等; }}*/ 面向对象的三个特征：封装、继承、多态。 以后开发：其实就是找对象使用，没有对象就创建一个对象。 找对象，建立对象，使用对象，维护对象的关系。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—语法","slug":"Java笔记—语法","date":"2019-11-13T04:54:20.000Z","updated":"2019-11-29T17:36:18.031Z","comments":true,"path":"2019/11/13/Java笔记—语法/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/13/Java%E7%AC%94%E8%AE%B0%E2%80%94%E8%AF%AD%E6%B3%95/","excerpt":"Java笔记——语法创建时间：2019.11.11说明：持续更新ing 单引号’’中存放一个字符，不能存放字符串。双引号””中存放字符串。 Java是强类型语言。对于每一种数据都定义了明确的具体数据类型，在内存中总分配了不同的内存空间。 布尔型常量只有2个值：true、false 标识符由字母：26个，大小写；数字：0- 8；符号：$ _ 组成。 标识符不能数字开头、不能使用关键字 main不是关键字，但是是被JVM识别的名字，是程序的入口 Java中的名称规范： 包名：多单词组成，全为小写 xxxyyyy 类名接口： 多单词组成，所有单词的首字母大写 XxxYyyZzz 变量名和函数名：多单词组成时，第一个单词的首字母小写，其余首字母大写 xxxYyyZzz 常量名：所有字母都大写。每个单词用_隔开 XXX_YYY_ZZZ","text":"Java笔记——语法创建时间：2019.11.11说明：持续更新ing 单引号’’中存放一个字符，不能存放字符串。双引号””中存放字符串。 Java是强类型语言。对于每一种数据都定义了明确的具体数据类型，在内存中总分配了不同的内存空间。 布尔型常量只有2个值：true、false 标识符由字母：26个，大小写；数字：0- 8；符号：$ _ 组成。 标识符不能数字开头、不能使用关键字 main不是关键字，但是是被JVM识别的名字，是程序的入口 Java中的名称规范： 包名：多单词组成，全为小写 xxxyyyy 类名接口： 多单词组成，所有单词的首字母大写 XxxYyyZzz 变量名和函数名：多单词组成时，第一个单词的首字母小写，其余首字母大写 xxxYyyZzz 常量名：所有字母都大写。每个单词用_隔开 XXX_YYY_ZZZ //截断文章 注释，写在代码前面 对于整数：Java有三种表现形式。· 十进制：0-9，满10进1· 八进制：0-7，满8进1，用0开头表示· 十六进制：0-9，A-F或a-f（A\\a是10，B\\b是11…F\\f是15），满16进1，用0x开头表示 null常量：只有一个值null。在对象、引用数据类型时会用上。 二进制。一个字节8位0、1组合。 八进制：3位二进制位代表1位八进制位；十六进制：4位二进制位代表1位十六进制位。进制转换：进制越大，表示越短，更方便地表示数据。 二进制计算：5 + 4 = 9 负数地二进制表现形式：对应的整数二进制取反加1。负数的最高位都是1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"博客v1.4上线","slug":"博客v1.4","date":"2019-11-08T14:30:21.000Z","updated":"2019-11-29T17:39:13.419Z","comments":true,"path":"2019/11/08/博客v1.4/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/08/%E5%8D%9A%E5%AE%A2v1.4/","excerpt":"搞了半天时间，优化一些模板上的问题后，新博客1.4版本上线了","text":"搞了半天时间，优化一些模板上的问题后，新博客1.4版本上线了 //截断文章 新增 主页动画，点击体验效果（这里） 文字跳动（menu、head中的文字均可跳动）,比如顶部的“你用走，可是我用跑”…… 新增Valine评论（可以使用表情；发送前浏览）。想用别的，但是暂时先着Valine。可以试着来骚扰我（滑稽~~ 有评论，邮件提示(还未测试)。接入Leancloud（文档）。 底部开启鼠标滑动渲染 开启“一言”api。menu中作者名（Melody Jerry）下面随机显示一句话。同时，使用文字扭曲动画。 修复 1.重写三个按钮（menu、搜索、回到顶部）的代码，现在可以正常使用了。 更新menu的Github的url 修复移动端提示证书错误的问题（移动端重定向太多次了，难怪hhh） 主页和首页分仓（也不算是修复，不知道写哪而已） 已知问题（加粗的为重要问题） menu中的“分类”、“标签”、“关于”，仍然无法正常使用（原因未知） menu的Email仍旧无法mailto 文章增加标签或类名，无法被tags或categories绑定 浏览人数、浏览次数，无法使用（接口有问题？） 文字截断，异常。（原因位置） 等待发现 未来加入 音乐控件（自动？手动？浮窗？嵌入？音源线上还是本地？） 实时颜色 加载网页时、侧栏、搜索、进度条等动画 留言板？ 友情链接？快速导航？ 嵌入播放（这个很想要，链接一些学习视频） 天气控件 等待脑洞大开 最后从早上9点搞到下午4点，午饭还没吃hh，就一直坐在电脑前。找模板中的问题代码、修改代码，还是很麻烦的。最后分享一首今天网易日推的英文歌（版权原因，没法生成外联播放器）I’ll Be There-Jess Glynne对于我的博客有问题或建议，欢迎在评论或邮件中告诉我。谢谢每一位读者。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"多图片滚动测试","slug":"多图片滚动测试","date":"2019-11-07T23:10:13.000Z","updated":"2019-12-01T06:31:24.901Z","comments":true,"path":"2019/11/08/多图片滚动测试/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/08/%E5%A4%9A%E5%9B%BE%E7%89%87%E6%BB%9A%E5%8A%A8%E6%B5%8B%E8%AF%95/","excerpt":"","text":"无缝滚动 *{margin: 0;padding: 0;} #div1{position: relative;border:1px solid #0ff;width:800px; height: 180px;margin:50px auto 0;overflow: hidden;} /* 修改容器规模 */ #div1 ul{position: absolute;left: 0;} #div1 ul li{list-style: none;width:200px;float: left;padding: 10px;height: 160px;} #div1 ul li img{width:100%;} window.onload=function(){ var oDiv=document.getElementById('div1'); var oUl=oDiv.getElementsByTagName('ul')[0]; var aLi=oUl.getElementsByTagName('li'); var aA=document.getElementsByTagName('a');//获取向右向左的箭头 var timer=null; var iSpeed=10; oUl.innerHTML+=oUl.innerHTML;//定义图片可以循环播放 oUl.style.width=aLi.length*aLi[0].offsetWidth+'px';//定义外层ul的宽度，根据图片的个数和每个图片的宽度计算，保证总宽度是可调整的 function fnMove(){ if(oUl.offsetLeft0){ oUl.style.left=-oUl.offsetWidth/2+'px'; }//定义到边界的时候，实现无缝衔接 oUl.style.left=oUl.offsetLeft+iSpeed+'px'; //定义图片的右边距随着速度不断不断增加，或减小，实现运动的效果 } timer=setInterval(fnMove,30); aA[0].onclick=function(){ iSpeed=-10; //按下左箭头，定义向左运动 } aA[1].onclick=function(){ iSpeed=10; //按下右箭头，定义向右运动 } oDiv.onmouseover=function(){ clearInterval(timer); //鼠标移动到图片上，清除定时器，停止运动 } oDiv.onmouseout=function(){ timer=setInterval(fnMove,30); //鼠标移出，重新开启定时器，重新运动 } }; ←→！！！方向选择按钮异常！！！L2Dwidget.init({\"model\":{\"jsonPath\":\"/blog/live2dw/assets/assets/haruto.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"tagMode\":false,\"debug\":false,\"mobile\":{\"show\":true},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\"}); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"网页视频测试","slug":"网页视频测试","date":"2019-11-07T16:00:00.000Z","updated":"2019-11-25T14:12:49.754Z","comments":true,"path":"2019/11/08/网页视频测试/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/08/%E7%BD%91%E9%A1%B5%E8%A7%86%E9%A2%91%E6%B5%8B%E8%AF%95/","excerpt":"浏览测试效果👇","text":"浏览测试效果👇 video大窗口 video小窗口 embed窗口 iframe窗口 测试完毕 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"使用Hexo+GitHub建站","slug":"Hexo+GitHub","date":"2019-11-07T11:24:01.000Z","updated":"2019-12-06T15:32:21.356Z","comments":true,"path":"2019/11/07/Hexo+GitHub/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/07/Hexo+GitHub/","excerpt":"前言： 使用CSDN平台撰写博客似乎是一件美事，只不过个人觉得太过于依赖他人平台，不如就自己搭建一个属于自己的博客。","text":"前言： 使用CSDN平台撰写博客似乎是一件美事，只不过个人觉得太过于依赖他人平台，不如就自己搭建一个属于自己的博客。 安装篇 一、安装 【hexo】 前的准备安装hexo前的必要工作1).安装以下两个程序： 程序 下载地址 说明 Git Git - Downloads 网速的同学，可以自行百度移步到国内镜像 Node.js Node.js - Downloads 有LTS和Current两个版本，安装 LTS 版即可 注意：关于Git和Node.js的安装可能会有问题，尤其是Git的安装。这里贴上几张安装界面的截图（来源见水印，作者GroovRain）。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 2).配置（可以在未来部署，并非一定现在） 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 $ git config --global user.name \"your name\"` $ git config --global user.email \"your Email\"二、正式安装【hexo】 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。——官方 准备工作完成后，来安装hexo框架吧！ == 主要根据hexo官方的文档来安装hexo == ==使用 npm 安装 Hexo== $ npm install -g hexo-cli 这样,【hexo】就安装完成了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"}]},{"title":"博客文章太长？截断！","slug":"文章截断","date":"2019-11-06T08:49:56.000Z","updated":"2020-01-04T01:51:09.574Z","comments":true,"path":"2019/11/06/文章截断/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/06/%E6%96%87%E7%AB%A0%E6%88%AA%E6%96%AD/","excerpt":"写的md文章太长，担心放到首页上浏览效果不好，怎么办？ 那就直接截断文章。 截断按钮文字不是通过配置文件_config.yml实现的，而是在文章内容里实现。 只要在需要被截断的文章位置加上： 1&lt;!-- more --&gt; 就可以了！ 效果就像下面的这个按钮 可以点点看哦👇","text":"写的md文章太长，担心放到首页上浏览效果不好，怎么办？ 那就直接截断文章。 截断按钮文字不是通过配置文件_config.yml实现的，而是在文章内容里实现。 只要在需要被截断的文章位置加上： 1&lt;!-- more --&gt; 就可以了！ 效果就像下面的这个按钮 可以点点看哦👇 插入测试代码 （无任何作用、意义，仅提供该页面测试用） 12345678910111213141516171819202122232425262728293031javascript:window.onblur=null;void 0;//allvar open_all_chapter = document.getElementsByClassName(\"fold_chapter\");for (var i = 1; i &lt; open_all_chapter.length; i++) {open_all_chapter[i].click()}//eachvar chapters = document.getElementsByClassName(\"rate_box\");var count = 0;chapters[++count].click();setInterval(() =&gt; {// var playButton = document.getElementById(\"div_play_wrapper\");// if (playButton) {// playButton.click();// }var TC = document.getElementsByClassName(\"layui-layer-close1\");if (TC.length &gt; 0) {console.log(\"检测到弹窗\");TC[0].click();}console.log(\"正在\" + count + \"个\");var isFinish = chapters[count].getElementsByClassName(\"round_complete\");if (isFinish.length &gt; 0) {chapters[++count].click()console.log(\"进入下\");if(chapters[count].className===\"rate_box\"){chapters[++count].click()}}}, 5000); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]}]}