{"meta":{"title":"MelodyHub","subtitle":"你用走 可是我用跑","description":"","author":"Melody Jerry","url":"https://melodyjerry.github.io/blog","root":"/blog/"},"pages":[{"title":"404 Not Found","date":"2020-02-13T05:06:58.070Z","updated":"2020-02-13T05:06:58.070Z","comments":true,"path":"404.html","permalink":"https://melodyjerry.github.io/blog/404.html","excerpt":"","text":"404 Not Found 您访问的页面，呃，鬼知道跑哪去了(´･ω･`) 可能是因为： 你的节操掉光啦~~~ 手残⑨级输错了地址~~~ 或该地址已被删除~~~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"关于","date":"2020-07-10T15:46:17.990Z","updated":"2020-07-10T15:46:17.990Z","comments":true,"path":"about/index.html","permalink":"https://melodyjerry.github.io/blog/about/index.html","excerpt":"","text":"关……于……？ 关于啥呢？ 关于我这个小渣渣？ 目前， MelodyJerry还只是个某搬砖过来的码农， 现正在一块叫Java的田里种草。 然后，然后……没了，就这样。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"友人帐","date":"2020-06-23T10:12:05.023Z","updated":"2020-06-23T10:12:05.023Z","comments":true,"path":"friends/index.html","permalink":"https://melodyjerry.github.io/blog/friends/index.html","excerpt":"","text":"欢迎小伙伴的到来。 如果有什么推荐/想法/问题，欢迎到底下留言。 给我留言，我们互相交换友链。 友链格式 名称：XXX 【博客名/昵称均可】头像链接：https://your/avatar/picture/ 【请使用https加密协议开头】博客地址：https://your/personal/blog/ 【请使用https加密协议开头】标签：#标签 #标签2 【这里可以写希望我贴上的标签喔~ 如：Web/Java/C++】 我的博客信息在这里喔~ 名称： MelodyHub头像链接： https://i.loli.net/2020/02/10/6yndjPI2rHL94vJ.png博客地址： https://melodyjerry.gitee.io/标签： # 后端 #音乐 最后，感谢小可爱们多多支持我喔٩(๑&gt;◡&lt;๑)۶有你们的鼓励，我会一定加油滴&gt;&lt;/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"分类","date":"2020-02-01T09:53:46.111Z","updated":"2020-02-01T09:53:46.111Z","comments":true,"path":"categories/index.html","permalink":"https://melodyjerry.github.io/blog/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-02-09T06:07:15.686Z","updated":"2020-02-09T06:07:15.686Z","comments":true,"path":"mylist/index.html","permalink":"https://melodyjerry.github.io/blog/mylist/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"藏宝阁","date":"2020-02-14T10:26:07.922Z","updated":"2020-02-14T10:26:07.922Z","comments":true,"path":"treasures/index.html","permalink":"https://melodyjerry.github.io/blog/treasures/index.html","excerpt":"","text":"欢迎来到 MelodyJerry的藏宝阁 能找到藏宝阁的入口，说明你与我有缘 以下所有资源可供你学习使用 有补充，可以留言告诉我 我不定时更新此内容 工具集 MCTool.cn在线工具 http://tool.liumingye.cn/ 兔二工具 http://www.tool2.cn/ 精准云工具 https://jingzhunyun.com/ 脚本之家 http://tools.jb51.net/ patorjk.com的线上工具集 http://patorjk.com/blog/software/ 图床 SM.MS（知名且免费） https://sm.ms/ 路过图床（免费） https://imgchr.com/ img.vim-cn.com（免费且访问速度快。） https://img.vim-cn.com/ 图片压缩 压缩图 https://www.yasuotu.com/ 建站 站长素材 http://sc.chinaz.com/ 网页游戏 2048-Game（作者：Tomotoes） https://tomotoes.com/2048/ 小霸王游戏免费玩 https://www.yikm.net/ 简历 xaoxuu制作 … Simon Ma制作 Windows 10 镜像（ISO） 微软官方 https://www.microsoft.com/zh-cn/software-download/windows10 MSDN我告诉你 https://msdn.itellyou.cn/ 网络亦是美 http://www.yishimei.cn/ UUP专制ISO https://uup.rg-adguard.net/index.php 动漫（我基本不看动漫，帮老弟存的hh）AGE动漫：https://www.agefans.tv/ Zzz Fun：http://d.mqaq.fun/ 康点动漫：http://www.zzzfun.com/ 樱花动漫：https://www.6111.tv/ Anime1：https://anime1.me/ 度盘搜索引擎 大力盘搜索（无需登录，有下载弹窗），网址：https://www.dalipan.com/ 大圣盘（无需登录，无下载弹窗），网址：https://www.dashengpan.com/ 小白盘（无需登录，有下载弹窗），网址：https://www.xiaobaipan.com/ SooHub 搜哈普（无需登录，无下载弹窗），网址：https://www.soohub.com/ bdy搜（无需登录，有下载链接跳转页面），网址：http://www.bdyso.com/ 度盘搜（Pandownload 内置），官网：http://pandownload.com/ 电子书搜索 一站式电子书搜索工具 网站非常简洁，打开官网，直接列出了包含的 70+ 电子书搜索网站。 以及网站特点，如是否需要注册、是否免费等，一目了然。 官网：http://www.soshuvip.com/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"标签","date":"2020-02-01T09:54:04.836Z","updated":"2020-02-01T09:54:04.836Z","comments":true,"path":"tags/index.html","permalink":"https://melodyjerry.github.io/blog/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"成果展","date":"2020-02-09T06:42:13.805Z","updated":"2020-02-09T06:42:13.805Z","comments":true,"path":"projects/index.html","permalink":"https://melodyjerry.github.io/blog/projects/index.html","excerpt":"","text":"一枚 小渣渣 ，目前啥都没有~~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"IDEA新建SpringBoot项目提示connect timed out错误","slug":"IDEA搭建SpringBoot项目提示connect timed out错误","date":"2020-10-04T06:12:11.000Z","updated":"2020-10-04T07:53:13.007Z","comments":true,"path":"2020/10/04/IDEA搭建SpringBoot项目提示connect timed out错误/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/10/04/IDEA%E6%90%AD%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE%E6%8F%90%E7%A4%BAconnect%20timed%20out%E9%94%99%E8%AF%AF/","excerpt":"IDEA新建的SpringBoot项目时： 无法连接到http://start.spring.io。 解决对应不同情况，可能存在不止一种解决方法。 网络问题不管是网站上的，还是IDEA里集成的，都有时会提示网络异常。 多试试几次，或者更换网络环境，我用手机开热点，就解决了。 使用自动代理IDEA ==&gt; Settings ==&gt; HTTP Proxy ==&gt; Auto-detect proxy settings： 等待check connection结果，若弹出connection successful即表示连接成功，问题解决。 更换源IDEA ==&gt; New Project ==&gt; Spring Initializr ==&gt; Custom: 使用阿里云提供的镜像服务： https://start.aliyun.com 更换了阿里云之后，还可以使用阿里云的组件呢！！！","text":"IDEA新建的SpringBoot项目时： 无法连接到http://start.spring.io。 解决对应不同情况，可能存在不止一种解决方法。 网络问题不管是网站上的，还是IDEA里集成的，都有时会提示网络异常。 多试试几次，或者更换网络环境，我用手机开热点，就解决了。 使用自动代理IDEA ==&gt; Settings ==&gt; HTTP Proxy ==&gt; Auto-detect proxy settings： 等待check connection结果，若弹出connection successful即表示连接成功，问题解决。 更换源IDEA ==&gt; New Project ==&gt; Spring Initializr ==&gt; Custom: 使用阿里云提供的镜像服务： https://start.aliyun.com 更换了阿里云之后，还可以使用阿里云的组件呢！！！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"SPringBoot","slug":"SPringBoot","permalink":"https://melodyjerry.github.io/blog/tags/SPringBoot/"}]},{"title":"IDEA新建SpringBoot项目无法引入SpringApplication","slug":"IDEA新建SpringBoot项目无法引入SpringApplication","date":"2020-10-04T04:12:11.000Z","updated":"2020-10-04T07:45:25.151Z","comments":true,"path":"2020/10/04/IDEA新建SpringBoot项目无法引入SpringApplication/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/10/04/IDEA%E6%96%B0%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E5%BC%95%E5%85%A5SpringApplication/","excerpt":"IDEA新建的SpringBoot项目，run时居然会报错： 无法引入SpringApplication。。。 解决对应不同情况，可能存在不止一种解决方法。 版本问题Maven存在多个版本的springBoot，可能会造成版本冲突。 在路径C:\\Users\\name\\.m2\\repository\\org\\springframework\\boot\\spring-boot中，删除旧版本即可。 然后Maven执行clean、compile、install命令。 来源：http://m.mamicode.com/info-detail-2209550.html","text":"IDEA新建的SpringBoot项目，run时居然会报错： 无法引入SpringApplication。。。 解决对应不同情况，可能存在不止一种解决方法。 版本问题Maven存在多个版本的springBoot，可能会造成版本冲突。 在路径C:\\Users\\name\\.m2\\repository\\org\\springframework\\boot\\spring-boot中，删除旧版本即可。 然后Maven执行clean、compile、install命令。 来源：http://m.mamicode.com/info-detail-2209550.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"SPringBoot","slug":"SPringBoot","permalink":"https://melodyjerry.github.io/blog/tags/SPringBoot/"}]},{"title":"uTools,你的生产力工具集","slug":"uTools你的生产力工具集","date":"2020-10-03T09:39:00.000Z","updated":"2020-10-03T10:11:16.646Z","comments":true,"path":"2020/10/03/uTools你的生产力工具集/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/10/03/uTools%E4%BD%A0%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E9%9B%86/","excerpt":"uTools是什么？uTools，你的生产力工具集 极简 插件化 跨平台 官网：https://www.u.tools/ 自由集成丰富插件，快速匹配「场景功能」，用完即走 。 通过自由选配丰富的插件，打造你得心应手的工具集合。 该软件支持Windows、Mac以及Linux使用，并且拥有丰富的插件库。 简单来讲，uTools可以作为一个程序快速启动器，使用中英文搜索并快速打开你的本地程序、文件、系统设置等。你可以使用快捷键（默认为alt+space）快速呼出这个搜索框，小巧却不简单。 当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。 uTools能做什么？uTools作者将此软件设计为“一切皆插件”的插件化工具，所有的功能均可通过插件实现。 插件中心有很多实用高效地插件，例如：在线翻译、压缩图片、颜色小助手、开发文档、图床、OCR图片识别等等小工具，你可以选择适合自己使用场景的插件安装使用。","text":"uTools是什么？uTools，你的生产力工具集 极简 插件化 跨平台 官网：https://www.u.tools/ 自由集成丰富插件，快速匹配「场景功能」，用完即走 。 通过自由选配丰富的插件，打造你得心应手的工具集合。 该软件支持Windows、Mac以及Linux使用，并且拥有丰富的插件库。 简单来讲，uTools可以作为一个程序快速启动器，使用中英文搜索并快速打开你的本地程序、文件、系统设置等。你可以使用快捷键（默认为alt+space）快速呼出这个搜索框，小巧却不简单。 当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。 uTools能做什么？uTools作者将此软件设计为“一切皆插件”的插件化工具，所有的功能均可通过插件实现。 插件中心有很多实用高效地插件，例如：在线翻译、压缩图片、颜色小助手、开发文档、图床、OCR图片识别等等小工具，你可以选择适合自己使用场景的插件安装使用。 接下来给大家看看MelodyJerry经常使用的一些插件👇 MelodyJerry的uTools在线翻译搜索框中搜索“翻译”就可以呼出在线翻译界面。简洁易用、随用随走。 图床写博客必备，搭配Typora使用，效果最佳！！！ 使用非常简单： 拖动图片到搜索框 复制图片，到插件页Ctrl+V 插件页的上传按钮 图床支持三种返回格式： URL MarkDown Html 当然，还可以选择不同的图床源。更快速的，✔自动复制，并选择MarkDown。 这样粘贴好图片，自动复制md格式的图片链接到剪切板，提升办公写作效率呢！ 自动复制 MarkDown 图片识别 剪切板最常用的插件之一，可以保存所有复制过的内容。 文本 文件 图片 不用担心uTools会泄露你的信息，所有插件的生命周期就是 开机到关机。 cmd 快速打开cmd 颜色 前端开发者的福利工具 uTools提供了多个插件，有的是官方的，还有的是开发者们维护的。 MelodyJerry最常用的是“色彩助手”。 看，羡慕了吗？ 本地快速搜索 集成Everything的内核 干净简洁的用户界面 快速文件索引 快速搜索 最小资源使用 便于文件分享 实时更新 …… 内网穿透 能够快速的将你的内网服务暴露到公网 启动你本地服务器，如下配置你本地的ip，和随便起个外网域名。 这样你就可以外网访问你的服务了，超简单，这可比有些网站搞个内网穿透还得收钱强多了。 开发小工具 只展示其中一部分插件 独立文档 只展示其中一部分文档手册 像MelodyJerry经常用到的是： Linux Java 程序员手册不同于上面的独立文档，“程序员手册”直接集成了各种文档，list： php手册 linux手册 python手册 PyQt5文档 C函数 go vim命令 git命令 sql手册 uTools API java javascript vue payload devdocs 关于此插件的详细信息：https://yuanliao.info/d/356 网页快开 移动端网页聚合 B站 GitHub 图片压缩 进阶使用uTools全局快捷键顾名思义，上图MelodyJerry的： 超级面板 这是1.3版本后新增的 自己开发uTools插件uTools已经向开发者们提供开发者文档，可以参考文档，捣鼓自己的插件哦。 像MelodyJerry的，暂时就不开源，也就暂不演示了。 插件开发文档：https://u.tools/docs/developer/welcome.html 心得体会 用户体验极佳 麻雀虽小，五脏俱全：简洁、方便、轻量、快速 文档齐全 支持开发个人插件 UI 很舒服 就写这么多，更多的要自己去挖掘啦~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"开发","slug":"开发","permalink":"https://melodyjerry.github.io/blog/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"【狂神说Java】SpringBoot笔记存档","slug":"【狂神说Java】SpringBoot笔记存档","date":"2020-10-02T14:51:02.771Z","updated":"2020-10-03T07:54:16.372Z","comments":true,"path":"2020/10/02/【狂神说Java】SpringBoot笔记存档/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/10/02/%E3%80%90%E7%8B%82%E7%A5%9E%E8%AF%B4Java%E3%80%91SpringBoot%E7%AC%94%E8%AE%B0%E5%AD%98%E6%A1%A3/","excerpt":"转自狂神老师，非常感谢老师，仅作为个人笔记使用 部分来自CSDN","text":"转自狂神老师，非常感谢老师，仅作为个人笔记使用 部分来自CSDN 1、SpringBoot简介：Hello,World！1.1、回顾什么是SpringSpring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。 Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。 1.2、Spring是如何简化Java开发的为了降低Java开发的复杂性，Spring采用了以下4种关键策略： 1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean； 2、通过IOC，依赖注入（DI）和面向接口实现松耦合； 3、基于切面（AOP）和惯例进行声明式编程； 4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate； 1.3、什么是SpringBoot学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍； 言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。 所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。 是的这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。 随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件； Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。 简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。 Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。 Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 真的很爽，我们快速去体验开发个接口的感觉吧！ Hello，World 1.4、准备工作我们将学习如何快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。 我的环境准备： java version “1.8.0_181” Maven-3.6.1 SpringBoot 2.x 最新版 开发工具： IDEA 1.5、创建基础项目说明Spring官方提供了非常方便的工具让我们快速构建应用 Spring Initializr：https://start.spring.io/ 项目创建方式一：使用Spring Initializr 的 Web页面创建项目 1、打开 https://start.spring.io/ 2、填写项目信息 3、点击”Generate Project“按钮生成项目；下载此项目 4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。 5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。 项目创建方式二：使用 IDEA 直接创建项目 1、创建一个新项目 2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现 3、填写项目信息 4、选择初始化的组件（初学勾选 Web 即可） 5、填写项目路径 6、等待项目构建成功 项目结构分析： 通过上面步骤完成了基础项目的创建。就会自动生成以下文件。 1、程序的主启动类 2、一个 application.properties 配置文件 3、一个 测试类 4、一个 pom.xml 1.6、pom.xml 分析打开pom.xml，看看Spring Boot项目的依赖： &lt;!-- 父依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- web场景启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 剔除依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 打包插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 1.7、编写一个http接口1、在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到 2、在包中新建一个HelloController类 @RestController public class HelloController { @RequestMapping(\"/hello\") public String hello() { return \"Hello World\"; } } 3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！ 简单几步，就完成了一个web接口的开发，SpringBoot就是这么简单。所以我们常用它来建立我们的微服务项目！ 1.8、将项目打成jar包，点击 maven的 package 如果遇到以上错误，可以配置打包时 跳过项目运行测试用例 &lt;!-- 在工作中,很多情况下我们打包是不想执行测试用例的 可能是测试用例不完事,或是测试用例会影响数据库数据 跳过测试用例执 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--跳过项目运行测试用例--&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; 如果打包成功，则会在target目录下生成一个 jar 包 打成了jar包后，就可以在任何地方运行了！OK 彩蛋 如何更改启动时显示的字符拼成的字母，SpringBoot呢？也就是 banner 图案； 只需一步：到项目下的 resources 目录下新建一个banner.txt 即可。 图案可以到：https://www.bootschool.net/ascii 这个网站生成，然后拷贝到文件中即可！ **SpringBoot这么简单的东西背后一定有故事，我们之后 2、SpringBoot：运行原理初探我们之前写的HelloSpringBoot，到底是怎么运行的呢，Maven项目，我们一般从pom.xml文件探究起； pom.xml 2.1、父依赖其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！ &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 点进去，发现还有一个父依赖 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt; &lt;/parent&gt; 这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心； 以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了； 2.2、启动器 spring-boot-starter&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; springboot-boot-starter-xxx：就是spring-boot的场景启动器 spring-boot-starter-web：帮我们导入了web模块正常运行所依赖的组件； SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter； 主启动类 分析完了 pom.xml 来看看这个启动类 2.3、默认的主启动类//@SpringBootApplication 来标注一个主程序类 //说明这是一个Spring Boot应用 @SpringBootApplication public class SpringbootApplication { public static void main(String[] args) { //以为是启动了一个方法，没想到启动了一个服务 SpringApplication.run(SpringbootApplication.class, args); } } 但是一个简单的启动类并不简单！我们来分析一下这些注解都干了什么 2.4、@SpringBootApplication作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 进入这个注解：可以看到上面还有很多其他注解！ @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication { // ...... } 2.5、@ComponentScan这个注解在Spring中很重要 ,它对应XML配置中的元素。 作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中 2.6、@SpringBootConfiguration作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类； 我们继续进去这个注解查看 // 点进去得到下面的 @Component @Configuration public @interface SpringBootConfiguration {} @Component public @interface Configuration {} 这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件； 里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！ 我们回到 SpringBootApplication 注解中继续看。 2.7、@EnableAutoConfiguration@EnableAutoConfiguration ：开启自动配置功能 以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效； 点进注解接续查看： @AutoConfigurationPackage ：自动配置包 @Import({Registrar.class}) public @interface AutoConfigurationPackage { } @import ：Spring底层注解@import ， 给容器中导入一个组件 Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ； 这个分析完了，退到上一步，继续看 @Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ； AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码： 1、这个类中有一个这样的方法 // 获得候选的配置 protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { //这里的getSpringFactoriesLoaderFactoryClass（）方法 //返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\"); return configurations; } 2、这个方法又调用了 SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法 public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) { String factoryClassName = factoryClass.getName(); //这里它又调用了 loadSpringFactories 方法 return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList()); } 3、我们继续点击查看 loadSpringFactories 方法 private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) { //获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身 MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader); if (result != null) { return result; } else { try { //去获取一个资源 \"META-INF/spring.factories\" Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(\"META-INF/spring.factories\") : ClassLoader.getSystemResources(\"META-INF/spring.factories\"); LinkedMultiValueMap result = new LinkedMultiValueMap(); //将读取到的资源遍历，封装成为一个Properties while(urls.hasMoreElements()) { URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) { Entry&lt;?, ?&gt; entry = (Entry)var6.next(); String factoryClassName = ((String)entry.getKey()).trim(); String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); int var10 = var9.length; for(int var11 = 0; var11 &lt; var10; ++var11) { String factoryName = var9[var11]; result.add(factoryClassName, factoryName.trim()); } } } cache.put(classLoader, result); return result; } catch (IOException var13) { throw new IllegalArgumentException(\"Unable to load factories from location [META-INF/spring.factories]\", var13); } } } 4、发现一个多次出现的文件：spring.factories，全局搜索它 2.8、spring.factories我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！ WebMvcAutoConfiguration 我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration 可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！ 所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。 结论： SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作； 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中； 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ； 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作； 现在大家应该大概的了解了下，SpringBoot的运行原理，后面我们还会深化一次！ SpringApplication 2.9、不简单的方法我最初以为就是运行了一个main方法，没想到却开启了一个服务； @SpringBootApplication public class SpringbootApplication { public static void main(String[] args) { SpringApplication.run(SpringbootApplication.class, args); } } SpringApplication.run分析 分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行； 2.10、SpringApplication这个类主要做了以下四件事情： 1、推断应用的类型是普通的项目还是Web项目 2、查找并加载所有可用初始化器 ， 设置到initializers属性中 3、找出所有的应用程序监听器，设置到listeners属性中 4、推断并设置main方法的定义类，找到运行的主类 查看构造器： public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) { // ...... this.webApplicationType = WebApplicationType.deduceFromClasspath(); this.setInitializers(this.getSpringFactoriesInstances(); this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = this.deduceMainApplicationClass(); } 2.11、run方法流程分析跟着源码和这幅图就可以一探究竟了！ 3、SpringBoot：yaml配置注入yaml语法学习 3.1、配置文件SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的 application.properties 语法结构 ：key=value application.yml 语法结构 ：key：空格 value 配置文件的作用 ：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了； 比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！ server.port=8081 3.2、yaml概述YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言） 这种语言以数据\\**作**\\为中心，而不是以标记语言为重点！** 以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml 传统xml配置： &lt;server&gt; &lt;port&gt;8081&lt;port&gt; &lt;/server&gt; yaml配置： server： prot: 8080 3.3、yaml基础语法说明：语法要求严格！ 1、空格不能省略 2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。 3、属性和值的大小写都是十分敏感的。 字面量：普通的值 [ 数字，布尔值，字符串 ] 字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号； k: v 注意： “ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思； 比如 ：name: “kuang \\n shen” 输出 ：kuang 换行 shen ‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出 比如 ：name: ‘kuang \\n shen’ 输出 ：kuang \\n shen 对象、Map（键值对） #对象、Map格式 k: v1: v2: 在下一行来写对象的属性和值得关系，注意缩进；比如： student: name: qinjiang age: 3 行内写法 student: {name: qinjiang,age: 3} 数组（ List、set ） 用 - 值表示数组中的一个元素,比如： pets: - cat - dog - pig 行内写法 pets: [cat,dog,pig] 修改SpringBoot的默认端口号 配置文件中添加，端口号的参数，就可以切换端口； server: port: 8082 注入配置文件 yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！ 3.4、yaml注入配置文件1、在springboot项目中的resources目录下新建一个文件 application.yml 2、编写一个实体类 Dog； package com.kuang.springboot.pojo; @Component //注册bean到容器中 public class Dog { private String name; private Integer age; //有参无参构造、get、set方法、toString()方法 } 3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下： @Component //注册bean public class Dog { @Value(\"阿黄\") private String name; @Value(\"18\") private Integer age; } 4、在SpringBoot的测试类下注入狗狗输出一下； @SpringBootTest class DemoApplicationTests { @Autowired //将狗狗自动注入进来 Dog dog; @Test public void contextLoads() { System.out.println(dog); //打印看下狗狗对象 } } 结果成功输出，@Value注入成功，这是我们原来的办法对吧。 5、我们在编写一个复杂一点的实体类：Person 类 @Component //注册bean到容器中 public class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; //有参无参构造、get、set方法、toString()方法 } 6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！ person: name: qinjiang age: 3 happy: false birth: 2000/01/01 maps: {k1: v1,k2: v2} lists: - code - girl - music dog: name: 旺财 age: 1 7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！ /* @ConfigurationProperties作用： 将配置文件中配置的每一个属性的值，映射到这个组件中； 告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定 参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应 */ @Component //注册bean @ConfigurationProperties(prefix = \"person\") public class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; } 8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！ &lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 9、确认以上配置都OK之后，我们去测试类中测试一下： @SpringBootTest class DemoApplicationTests { @Autowired Person person; //将person自动注入进来 @Test public void contextLoads() { System.out.println(person); //打印person信息 } } 结果：所有值全部注入成功！ yaml配置注入到实体类完全OK！ 课堂测试： 1、将配置文件的key 值 和 属性的值设置为不一样，则结果输出为null，注入失败 2、在配置一个person2，然后将 @ConfigurationProperties(prefix = “person2”) 指向我们的person2； 3.5、加载指定的配置文件@PropertySource ：加载指定的配置文件； @configurationProperties：默认从全局配置文件中获取值； 1、我们去在resources目录下新建一个person.properties文件 name=kuangshen 2、然后在我们的代码中指定加载person.properties文件 @PropertySource(value = \"classpath:person.properties\") @Component //注册bean public class Person { @Value(\"${name}\") private String name; ...... } 3、再次输出测试一下：指定配置文件绑定成功！ 3.6、配置文件占位符配置文件还可以编写占位符生成随机数 person: name: qinjiang${random.uuid} # 随机uuid age: ${random.int} # 随机int happy: false birth: 2000/01/01 maps: {k1: v1,k2: v2} lists: - code - girl - music dog: name: ${person.hello:other}_旺财 age: 1 3.7、回顾properties配置我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！ 【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8； settings–&gt;FileEncodings 中配置； 测试步骤： 1、新建一个实体类User @Component //注册bean public class User { private String name; private int age; private String sex; } 2、编辑配置文件 user.properties user1.name=kuangshen user1.age=18user1.sex=男 3、我们在User类上使用@Value来进行注入！ @Component //注册bean @PropertySource(value = \"classpath:user.properties\") public class User { //直接使用@value @Value(\"${user.name}\") //从配置文件中取值 private String name; @Value(\"#{9*2}\") // #{SPEL} Spring表达式 private int age; @Value(\"男\") // 字面量 private String sex; } 4、Springboot测试 user1.name=kuangshen user1.age=18 user1.sex=男 结果正常输出： 3.8、对比小结@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图 1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加 2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下 3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性 4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持 结论： 配置yml和配置properties都可以获取到值 ， 强烈推荐 yml； 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value； 如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！ 4、SpringBoot：JSR303数据校验及多环境切换JSR303数据校验 4.1、先看看如何使用Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式； @Component //注册bean @ConfigurationProperties(prefix = \"person\") @Validated //数据校验 public class Person { @Email(message=\"邮箱格式错误\") //name必须是邮箱格式 private String name; } 运行结果 ：default message [不是一个合法的电子邮件地址]; 使用数据校验，可以保证数据的正确性； 4.2、常见参数@NotNull(message=\"名字不能为空\") private String userName; @Max(value=120,message=\"年龄最大不能查过120\") private int age; @Email(message=\"邮箱格式错误\") private String email; 空检查 @Null 验证对象是否为null @NotNull 验证对象是否不为null, 无法查检长度为0的字符串 @NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. @NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查 @AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false 长度检查 @Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) string is between min and max included. 日期检查 @Past 验证 Date 和 Calendar 对象是否在当前时间之前 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 @Pattern 验证 String 对象是否符合正则表达式的规则 .......等等 除此以外，我们还可以自定义一些数据校验规则 多环境切换 profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境； 4.3、多配置文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本； 例如： application-test.properties 代表测试环境配置 application-dev.properties 代表开发环境配置 但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件； 我们需要通过一个配置来选择需要激活的环境： #比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试； #我们启动SpringBoot，就可以看到已经切换到dev下的配置了； spring.profiles.active=dev 4.4、yaml的多文档块和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 ! server: port: 8081 #选择要激活那个环境块 spring: profiles: active: prod --- server: port: 8083 spring: profiles: dev #配置环境的名称 --- server: port: 8084 spring: profiles: prod #配置环境的名称 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！ 4.5、配置文件加载位置外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！ 官方外部配置文件说明参考文档 springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件： 优先级1：项目路径下的config文件夹配置文件 优先级2：项目路径下配置文件 优先级3：资源路径下的config文件夹配置文件 优先级4：资源路径下配置文件 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； 我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题； #配置项目的访问路径 server.servlet.context-path=/kuang 4.6、拓展，运维小技巧指定位置加载配置文件 我们还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高 5、SpringBoot：自动配置原理自动配置原理 配置文件到底能写什么？怎么写？ SpringBoot官方文档中有大量的配置，我们无法全部记住 5.1、分析自动配置原理我们以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； //表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件； @Configuration //启动指定类的ConfigurationProperties功能； //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来； //并把HttpProperties加入到ioc容器中 @EnableConfigurationProperties({HttpProperties.class}) //Spring底层@Conditional注解 //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效； //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效 @ConditionalOnWebApplication( type = Type.SERVLET ) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器； @ConditionalOnClass({CharacterEncodingFilter.class}) //判断配置文件中是否存在某个配置：spring.http.encoding.enabled； //如果不存在，判断也是成立的 //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的； @ConditionalOnProperty( prefix = \"spring.http.encoding\", value = {\"enabled\"}, matchIfMissing = true ) public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) { this.properties = properties.getEncoding(); } //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @Bean @ConditionalOnMissingBean //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; } //。。。。。。。 } 一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！ 一但这个配置类生效；这个配置类就会给容器中添加各种组件； 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着； 配置文件能配置什么就可以参照某个功能对应的这个属性类 //从配置文件中获取指定的值和bean的属性进行绑定 @ConfigurationProperties(prefix = \"spring.http\") public class HttpProperties { // ..... } 我们去配置文件里面试试前缀，看提示！ 这就是自动装配的原理！ 5.2、精髓1、SpringBoot启动会加载大量的自动配置类 2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中； 3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了） 4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可； xxxxAutoConfigurartion：自动配置类；给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 5.3、了解：@Conditional了解完自动装配的原理后，我们来关注一个细节问题，自动配置类必须在一定的条件下才能生效； @Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； 那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。 我们怎么知道哪些自动配置类生效？ 我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； #开启springboot的调试类 debug=true Positive matches:（自动配置类启用的：正匹配） Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配） Unconditional classes: （没有条件的类） 【演示：查看输出的日志】 掌握吸收理解原理，即可以不变应万变！ 6、SpringBoot：自定义starter我们分析完毕了源码以及自动装配的过程，我们可以尝试自定义一个启动器来玩玩！ 6.1、说明启动器模块是一个 空 jar 文件，仅提供辅助性依赖管理，这些依赖可能用于自动装配或者其他类库； 命名归约： 官方命名： 前缀：spring-boot-starter-xxx 比如：spring-boot-starter-web…. 自定义命名： xxx-spring-boot-starter 比如：mybatis-spring-boot-starter 6.2、编写启动器1、在IDEA中新建一个空项目 spring-boot-starter-diy 2、新建一个普通Maven模块：kuang-spring-boot-starter 3、新建一个Springboot模块：kuang-spring-boot-starter-autoconfigure 4、点击apply即可，基本结构 5、在我们的 starter 中 导入 autoconfigure 的依赖！ &lt;!-- 启动器 --&gt; &lt;dependencies&gt; &lt;!-- 引入自动配置模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.kuang&lt;/groupId&gt; &lt;artifactId&gt;kuang-spring-boot-starter-autoconfigure&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 6、将 autoconfigure 项目下多余的文件都删掉，Pom中只留下一个 starter，这是所有的启动器基本配置！ 7、我们编写一个自己的服务 package com.kuang; public class HelloService { HelloProperties helloProperties; public HelloProperties getHelloProperties() { return helloProperties; } public void setHelloProperties(HelloProperties helloProperties) { this.helloProperties = helloProperties; } public String sayHello(String name){ return helloProperties.getPrefix() + name + helloProperties.getSuffix(); } } 8、编写HelloProperties 配置类 package com.kuang; import org.springframework.boot.context.properties.ConfigurationProperties; // 前缀 kuang.hello @ConfigurationProperties(prefix = \"kuang.hello\") public class HelloProperties { private String prefix; private String suffix; public String getPrefix() { return prefix; } public void setPrefix(String prefix) { this.prefix = prefix; } public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; } } 9、编写我们的自动配置类并注入bean，测试！ package com.kuang; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @ConditionalOnWebApplication //web应用生效 @EnableConfigurationProperties(HelloProperties.class) public class HelloServiceAutoConfiguration { @Autowired HelloProperties helloProperties; @Bean public HelloService helloService(){ HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; } } 10、在resources编写一个自己的 META-INF\\spring.factories # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.kuang.HelloServiceAutoConfiguration 11、编写完成后，可以安装到maven仓库中！ 6.3、新建项目测试我们自己写的启动器1、新建一个SpringBoot 项目 2、导入我们自己写的启动器 &lt;dependency&gt; &lt;groupId&gt;com.kuang&lt;/groupId&gt; &lt;artifactId&gt;kuang-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 3、编写一个 HelloController 进行测试我们自己的写的接口！ package com.kuang.controller; @RestController public class HelloController { @Autowired HelloService helloService; @RequestMapping(\"/hello\") public String hello(){ return helloService.sayHello(\"zxc\"); } } 4、编写配置文件 application.properties kuang.hello.prefix=\"ppp\" kuang.hello.suffix=\"sss\" 5、启动项目进行测试，结果成功 ! 7、SpringBoot整合JDBC7.1、SpringData简介对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。 Spring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。 Sping Data 官网：https://spring.io/projects/spring-data 数据库相关的启动器 ：可以参考官方文档： https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter 整合JDBC 7.2、创建测试项目测试数据源1、我去新建一个项目测试：springboot-data-jdbc ; 引入相应的模块！基础模块 2、项目建好之后，发现自动帮我们导入了如下的启动器 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 3、编写yaml配置文件连接数据库； spring: datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver 4、配置完这一些东西后，我们就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去测试类测试一下 @SpringBootTest class SpringbootDataJdbcApplicationTests { //DI注入数据源 @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException { //看一下默认数据源 System.out.println(dataSource.getClass()); //获得连接 Connection connection = dataSource.getConnection(); System.out.println(connection); //关闭连接 connection.close(); } } 结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置 我们来全局搜索一下，找到数据源的所有自动配置都在 ：DataSourceAutoConfiguration文件： @Import( {Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSourceJmxConfiguration.class} ) protected static class PooledDataSourceConfiguration { protected PooledDataSourceConfiguration() { } } 这里导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源； HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀； 可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。 关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate 7.3、JDBCTemplate1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库； 2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。 3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。 4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用 5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类 JdbcTemplate主要提供以下几类方法： execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句； update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句； query方法及queryForXXX方法：用于执行查询相关语句； call方法：用于执行存储过程、函数相关语句。 7.4、测试编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试； package com.kuang.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.Date; import java.util.List; import java.util.Map; @RestController @RequestMapping(\"/jdbc\") public class JdbcController { /** * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作 * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接 */ @Autowired JdbcTemplate jdbcTemplate; //查询employee表中所有数据 //List 中的1个 Map 对应数据库的 1行数据 //Map 中的 key 对应数据库的字段名，value 对应数据库的字段值 @GetMapping(\"/list\") public List&lt;Map&lt;String, Object&gt;&gt; userList(){ String sql = \"select * from employee\"; List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql); return maps; } //新增一个用户 @GetMapping(\"/add\") public String addUser(){ //插入语句，注意时间问题 String sql = \"insert into employee(last_name, email,gender,department,birth)\" + \" values ('狂神说','24736743@qq.com',1,101,'\"+ new Date().toLocaleString() +\"')\"; jdbcTemplate.update(sql); //查询 return \"addOk\"; } //修改用户信息 @GetMapping(\"/update/{id}\") public String updateUser(@PathVariable(\"id\") int id){ //插入语句 String sql = \"update employee set last_name=?,email=? where id=\"+id; //数据 Object[] objects = new Object[2]; objects[0] = \"秦疆\"; objects[1] = \"24736743@sina.com\"; jdbcTemplate.update(sql,objects); //查询 return \"updateOk\"; } //删除用户 @GetMapping(\"/delete/{id}\") public String delUser(@PathVariable(\"id\") int id){ //插入语句 String sql = \"delete from employee where id=?\"; jdbcTemplate.update(sql,id); //查询 return \"deleteOk\"; } } 测试请求，结果正常； 到此，CURD的基本操作，使用 JDBC 就搞定了。https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#using-boot-starter) 7.5、原理探究 ：org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration 数据源配置类作用 ：根据逻辑判断之后，添加数据源； SpringBoot默认支持以下数据源： com.zaxxer.hikari.HikariDataSource （Spring Boot 2.0 以上，默认使用此数据源） org.apache.tomcat.jdbc.pool.DataSource org.apache.commons.dbcp2.BasicDataSource 可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。默认情况下，它是从类路径自动检测的。 @Configuration @ConditionalOnMissingBean({DataSource.class}) @ConditionalOnProperty( name = {\"spring.datasource.type\"} ) static class Generic { Generic() { } @Bean public DataSource dataSource(DataSourceProperties properties) { return properties.initializeDataSourceBuilder().build(); } } 8、SpringBoot整合Druid8.1、Druid简介Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。 Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。 Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。 Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。 Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。 Github地址：https://github.com/alibaba/druid/ com.alibaba.druid.pool.DruidDataSource 基本配置参数如下： 配置 缺省值 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-“ + System.identityHashCode(this). 另外配置此属性至少在1.0.5版本中是不起作用的，强行设置name会出错 详情-点此处。 url 连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/使用ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 validationQueryTimeout 单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 1分钟（1.0.14） 有两个含义： 1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis 30分钟（1.0.14） 连接保持空闲而不被驱逐的最长时间 connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat 日志用的filter:log4j 防御sql注入的filter:wall proxyFilters 类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 8.2、配置数据源1、添加上 Druid 数据源依赖。 &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt; &lt;/dependency&gt; 2、切换数据源；之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以 通过 spring.datasource.type 指定数据源。 spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源 3、数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换； 4、切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码 spring: datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 5、导入Log4j 的依赖 &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 6、现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性； package com.kuang.config; import com.alibaba.druid.pool.DruidDataSource; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; @Configuration public class DruidConfig { /* 将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建 绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效 @ConfigurationProperties(prefix = \"spring.datasource\")：作用就是将 全局配置文件中 前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中 */ @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druidDataSource() { return new DruidDataSource(); } } 7、去测试类中测试一下；看是否成功！ @SpringBootTest class SpringbootDataJdbcApplicationTests { //DI注入数据源 @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException { //看一下默认数据源 System.out.println(dataSource.getClass()); //获得连接 Connection connection = dataSource.getConnection(); System.out.println(connection); DruidDataSource druidDataSource = (DruidDataSource) dataSource; System.out.println(\"druidDataSource 数据源最大连接数：\" + druidDataSource.getMaxActive()); System.out.println(\"druidDataSource 数据源初始化连接数：\" + druidDataSource.getInitialSize()); //关闭连接 connection.close(); } } 输出结果 ：可见配置参数已经生效！ 8.3、配置Druid数据源监控Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。 所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理； //配置 Druid 监控管理后台的Servlet； //内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式 @Bean public ServletRegistrationBean statViewServlet() { ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); // 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet // 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到 Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"loginUsername\", \"admin\"); //后台管理界面的登录账号 initParams.put(\"loginPassword\", \"123456\"); //后台管理界面的登录密码 //后台允许谁可以访问 //initParams.put(\"allow\", \"localhost\")：表示只有本机可以访问 //initParams.put(\"allow\", \"\")：为空或者为null时，表示允许所有访问 initParams.put(\"allow\", \"\"); //deny：Druid 后台拒绝谁访问 //initParams.put(\"kuangshen\", \"192.168.1.20\");表示禁止此ip访问 //设置初始化参数 bean.setInitParameters(initParams); return bean; } 配置完毕后，我们可以选择访问 ：http://localhost:8080/druid/login.html 进入之后 配置 Druid web 监控 filter 过滤器 //配置 Druid 监控 之 web 监控的 filter //WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计 @Bean public FilterRegistrationBean webStatFilter() { FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计 Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\", \"*.js,*.css,/druid/*,/jdbc/*\"); bean.setInitParameters(initParams); //\"/*\" 表示过滤所有请求 bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; } 平时在工作中，按需求进行配置即可，主要用作监 9、SpringBoot 整合mybatis9.1、导入mybatis所需要的依赖&lt;!-- 引入 myBatis，这是 MyBatis官方提供的适配 Spring Boot 的，而不是Spring Boot自己的--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; 9.2、配置数据库连接信息spring.datasource.username=root spring.datasource.password=123456 spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.driver-class-name=com.mysql.jdbc.Driver 9.3、我们这里就是用默认的数据源了；先去测试一下连接是否成功！@RunWith(SpringRunner.class) @SpringBootTest public class SpringbootDemoMybatisApplicationTests { @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException { System.out.println(\"数据源&gt;&gt;&gt;&gt;&gt;&gt;\" + dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(\"连接&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" + connection); System.out.println(\"连接地址&gt;&gt;&gt;&gt;&gt;\" + connection.getMetaData().getURL()); connection.close(); } } 查看输出结果，数据库配置OK！ 9.4、创建实体类package com.kuang.mybatis.pojo; public class User { private int id; private String name; private String pwd; public User() { } public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '}'; } } 9.5、配置Mapper接口类package com.kuang.mybatis.pojo.mapper; import com.kuang.mybatis.pojo.User; import org.apache.ibatis.annotations.Mapper; import org.springframework.stereotype.Repository; import java.util.List; //@Mapper : 表示本类是一个 MyBatis 的 Mapper，等价于以前 Spring 整合 MyBatis 时的 Mapper 接口 @Mapper @Repository public interface UserMapper { //选择全部用户 List&lt;User&gt; selectUser(); //根据id选择用户 User selectUserById(int id); //添加一个用户 int addUser(User user); //修改一个用户 int updateUser(User user); //根据id删除用户 int deleteUser(int id); } 9.6、对应Mapper映射文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.kuang.mybatis.pojo.mapper.UserMapper\"&gt; &lt;select id=\"selectUser\" resultType=\"User\"&gt; select * from user &lt;/select&gt; &lt;select id=\"selectUserById\" resultType=\"User\"&gt; select * from user where id = #{id} &lt;/select&gt; &lt;insert id=\"addUser\" parameterType=\"User\"&gt; insert into user (id,name,pwd) values (#{id},#{name},#{pwd}) &lt;/insert&gt; &lt;update id=\"updateUser\" parameterType=\"User\"&gt; update user set name=#{name},pwd=#{pwd} where id = #{id} &lt;/update&gt; &lt;delete id=\"deleteUser\" parameterType=\"int\"&gt; delete from user where id = #{id} &lt;/delete&gt; &lt;/mapper&gt; 9.7、maven配置资源过滤问题&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; 9.8、SpringBoot 整合！以前 MyBatis 未与 spring 整合时，配置数据源、事务、连接数据库的账号、密码等都是在 myBatis 核心配置文件中进行的myBatis 与 spring 整合后，配置数据源、事务、连接数据库的账号、密码等就交由 spring 管理。因此，在这里我们即使不使用mybatis配置文件也完全ok！既然已经提供了 myBatis 的映射配置文件，自然要告诉 spring boot 这些文件的位置 spring.datasource.username=root spring.datasource.password=123456 spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.driver-class-name=com.mysql.jdbc.Driver #指定myBatis的核心配置文件与Mapper映射文件 mybatis.mapper-locations=classpath:mybatis/mapper/*.xml # 注意：对应实体类的路径 mybatis.type-aliases-package=com.kuang.mybatis.pojo 已经说过 spring boot 官方并没有提供 myBaits 的启动器，是 myBatis 官方提供的开发包来适配的 spring boot，从 pom.xml 文件中的依赖包名也能看出来，并非是以 spring-boot 开头的； 同理上面全局配置文件中的这两行配置也是以 mybatis 开头 而非 spring 开头也充分说明这些都是 myBatis 官方提供的 可以从 org.mybatis.spring.boot.autoconfigure.MybatisProperties 中查看所有配置项 @ConfigurationProperties( prefix = \"mybatis\" ) public class MybatisProperties { public static final String MYBATIS_PREFIX = \"mybatis\"; private static final ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver(); private String configLocation; private String[] mapperLocations; private String typeAliasesPackage; private Class&lt;?&gt; typeAliasesSuperType; private String typeHandlersPackage; private boolean checkConfigLocation = false; private ExecutorType executorType; private Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageDriver; private Properties configurationProperties; @NestedConfigurationProperty private Configuration configuration; 也可以直接去查看 官方文档 9.9、编写controllerpackage com.kuang.mybatis.controller; import com.kuang.mybatis.pojo.User; import com.kuang.mybatis.pojo.mapper.UserMapper; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import java.util.List; @RestController public class UserController { @Autowired private UserMapper userMapper; //选择全部用户 @GetMapping(\"/selectUser\") public String selectUser(){ List&lt;User&gt; users = userMapper.selectUser(); for (User user : users) { System.out.println(user); } return \"ok\"; } //根据id选择用户 @GetMapping(\"/selectUserById\") public String selectUserById(){ User user = userMapper.selectUserById(1); System.out.println(user); return \"ok\"; } //添加一个用户 @GetMapping(\"/addUser\") public String addUser(){ userMapper.addUser(new User(5,\"阿毛\",\"456789\")); return \"ok\"; } //修改一个用户 @GetMapping(\"/updateUser\") public String updateUser(){ userMapper.updateUser(new User(5,\"阿毛\",\"421319\")); return \"ok\"; } //根据id删除用户 @GetMapping(\"/deleteUser\") public String deleteUser(){ userMapper.deleteUser(5); return \"ok\"; } } 9.10、启动项目访问进行测试！步骤： Mybatis整合包 mybatis-spring-boot-starter 1.导入包 2.配置文件 3.mybatis配置 4.编写sql 5.service层调用dao层 6.controller调用service层 注：配置数据库连接信息（不变）spring: datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址： https://mvnrepository.com/artifact/log4j/log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 10、SpringBoot：Web开发静态资源处理Web开发探究 10.1、简介好的，同学们，那么接下来呢，我们开始学习SpringBoot与Web开发，从这一章往后，就属于我们实战部分的内容了； 其实SpringBoot的东西用起来非常简单，因为SpringBoot最大的特点就是自动装配。 使用SpringBoot的步骤： 1、创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好 2、手动在配置文件中配置部分配置项目就可以运行起来了 3、专注编写业务代码，不需要考虑以前那样一大堆的配置了。 要熟悉掌握开发，之前学习的自动配置的原理一定要搞明白！ 比如SpringBoot到底帮我们配置了什么？我们能不能修改？我们能修改哪些配置？我们能不能扩展？ 向容器中自动配置组件 ：*** Autoconfiguration 自动配置类，封装配置文件的内容：***Properties 没事就找找类，看看自动装配原理！ 我们之后来进行一个单体项目的小项目测试，让大家能够快速上手开发！ 静态资源处理 10.2、静态资源映射规则首先，我们搭建一个普通的SpringBoot项目，回顾一下HelloWorld程序！ 写请求非常简单，那我们要引入我们前端资源，我们项目中有许多的静态资源，比如css，js等文件，这个SpringBoot怎么处理呢？ 如果我们是一个web应用，我们的main下会有一个webapp，我们以前都是将所有的页面导在这里面的，对吧！但是我们现在的pom呢，打包方式是为jar的方式，那么这种方式SpringBoot能不能来给我们写页面呢？当然是可以的，但是SpringBoot对于静态资源放置的位置，是有规定的！ 我们先来聊聊这个静态资源映射规则： SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面； 我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法； 有一个方法：addResourceHandlers 添加资源处理 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { // 已禁用默认资源处理 logger.debug(\"Default resource handling disabled\"); return; } // 缓存控制 Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); // webjars 配置 if (!registry.hasMappingForPattern(\"/webjars/**\")) { customizeResourceHandlerRegistration(registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\") .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); } // 静态资源配置 String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) { customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); } } 读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源； 10.3、什么是webjars 呢？Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。 使用SpringBoot需要使用Webjars，我们可以去搜索一下： 网站：https://www.webjars.org 要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！ &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; 导入完毕，查看webjars目录结构，并访问Jquery.js文件！ 访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：http://localhost:8080/webjars/jquery/3.4.1/jquery.js 10.4、第二种静态资源映射规则那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码； 我们去找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析： // 进入方法 public String[] getStaticLocations() { return this.staticLocations; } // 找到对应的值 private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS; // 找到路径 private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" }; ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。 所以得出结论，以下四个目录存放的静态资源可以被我们识别： \"classpath:/META-INF/resources/\" \"classpath:/resources/\" \"classpath:/static/\" \"classpath:/public/\" 我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件； 比如我们访问 http://localhost:8080/1.js , 他就会去这些文件夹中寻找对应的静态资源文件； 10.5、自定义静态资源路径我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置； spring.resources.static-locations=classpath:/coding/,classpath:/kuang/ 一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！ 首页处理 静态资源文件夹说完后，我们继续向下看源码！可以看到一个欢迎页的映射，就是我们的首页！ @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService,ResourceUrlProvider mvcResourceUrlProvider) { WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), // getWelcomePage 获得欢迎页 this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider)); return welcomePageHandlerMapping; } 点进去继续看 private Optional&lt;Resource&gt; getWelcomePage() { String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations()); // ::是java8 中新引入的运算符 // Class::function的时候function是属于Class的，应该是静态方法。 // this::function的funtion是属于这个对象的。 // 简而言之，就是一种语法糖而已，是一种简写 return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst(); } // 欢迎页就是一个location下的的 index.html 而已 private Resource getIndexHtml(String location) { return this.resourceLoader.getResource(location + \"index.html\"); } 欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。 比如我访问 http://localhost:8080/ ，就会找静态资源文件夹下的 index.html 新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试 http://localhost:8080/ 看结果！ 关于网站图标说明： 与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。 1、关闭SpringBoot默认图标 #关闭默认图标spring.mvc.favicon.enabled=false 2、自己放一个图标在静态资源目录下，我放在 public 目录下 3、清除浏览器缓存！刷新网页，发现图标已经变成自己的了！ 11、SpringBoot：Thymeleaf模板引擎11.1、模板引擎前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。 jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，他现在默认是不支持jsp的。 那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？ SpringBoot推荐你可以来使用模板引擎： 模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图： 模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。 我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。 11.2、引入Thymeleaf怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址： Thymeleaf 官网：https://www.thymeleaf.org/ Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf Spring官方文档：找到我们对应的版本 https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter 找到对应的pom依赖：可以适当点进源码看下本来的包！ &lt;!--thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; Maven会自动下载jar包，我们可以去看下下载的东西； 11.3、Thymeleaf分析前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？ 我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。 我们去找一下Thymeleaf的自动配置类：ThymeleafPropert @ConfigurationProperties( prefix = \"spring.thymeleaf\" ) public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; private String mode = \"HTML\"; private Charset encoding; } 我们可以在其中看到默认的前缀和后缀！ 我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。 使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！ 测试 1、编写一个TestController @Controller public class TestController { @RequestMapping(\"/t1\") public String test1(){ //classpath:/templates/test.html return \"test\"; } } 2、编写一个测试页面 test.html 放在 templates 目录下 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;测试页面&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 3、启动项目请求测试 11.4、Thymeleaf 语法学习要学习语法，还是参考官网文档最为准确，我们找到对应的版本看一下； Thymeleaf 官网：https://www.thymeleaf.org/ ， 简单看一下官网！我们去下载Thymeleaf的官方文档！ 我们做个最简单的练习 ：我们需要查出一些数据，在页面中展示 1、修改测试请求，增加数据传输； @RequestMapping(\"/t1\") public String test1(Model model){ //存入数据 model.addAttribute(\"msg\",\"Hello,Thymeleaf\"); //classpath:/templates/test.html return \"test\"; } 2、我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。 我们可以去官方文档的#3中看一下命名空间拿来过来： xmlns:th=\"http://www.thymeleaf.org\" 3、我们去编写下前端页面 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;狂神说&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;测试页面&lt;/h1&gt; &lt;!--th:text就是将div中的内容设置为它指定的值，和之前学习的Vue一样--&gt; &lt;div th:text=\"${msg}\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 4、启动测试！ OK，入门搞定，我们来认真研习一下Thymeleaf的使用语法！ 1、我们可以使用任意的 th:attr 来替换Html中原生属性的值！ 2、我们能写哪些表达式呢？ Simple expressions:（表达式语法） Variable Expressions: ${...}：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象：#18 #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. 3）、内置的一些工具对象： #execInfo : information about the template being processed. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. ================================================================================== Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样； Message Expressions: #{...}：获取国际化内容 Link URL Expressions: @{...}：定义URL； Fragment Expressions: ~{...}：片段引用表达式 Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,… Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is ${name}| Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): - Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , not Comparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne ) Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) Special tokens: No-Operation: _ 练习测试： 1、 我们编写一个Controller，放一些数据 @RequestMapping(\"/t2\") public String test2(Map&lt;String,Object&gt; map){ //存入数据 map.put(\"msg\",\"&lt;h1&gt;Hello&lt;/h1&gt;\"); map.put(\"users\", Arrays.asList(\"qinjiang\",\"kuangshen\")); //classpath:/templates/test.html return \"test\"; } 2、测试页面取出数据 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;狂神说&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;测试页面&lt;/h1&gt; &lt;div th:text=\"${msg}\"&gt;&lt;/div&gt; &lt;!--不转义--&gt; &lt;div th:utext=\"${msg}\"&gt;&lt;/div&gt; &lt;!--遍历数据--&gt; &lt;!--th:each每次遍历都会生成当前这个标签：官网#9--&gt; &lt;h4 th:each=\"user :${users}\" th:text=\"${user}\"&gt;&lt;/h4&gt; &lt;h4&gt; &lt;!--行内写法：官网#12--&gt; &lt;span th:each=\"user:${users}\"&gt;[[${user}]]&lt;/span&gt; &lt;/h4&gt; &lt;/body&gt; &lt;/html&gt; 3、启动项目测试！ 我们看完语法，很多样式，我们即使现在学习了，也会忘记，所以我们在学习过程中，需要使用什么，根据官方文档来查询，才是最重要的，要熟练使用官方文档！ 12、SpringBoot：MVC自动配置原理12.1、官网阅读在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。 只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！ 地址 ：https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration Spring MVC Auto-configuration // Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。 Spring Boot provides auto-configuration for Spring MVC that works well with most applications. // 自动配置在Spring默认设置的基础上添加了以下功能： The auto-configuration adds the following features on top of Spring’s defaults: // 包含视图解析器 Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. // 支持静态资源文件夹的路径，以及webjars Support for serving static resources, including support for WebJars // 自动注册了Converter： // 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把\"1\"字符串自动转换为int类型 // Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】 Automatic registration of Converter, GenericConverter, and Formatter beans. // HttpMessageConverters // SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释； Support for HttpMessageConverters (covered later in this document). // 定义错误代码生成规则的 Automatic registration of MessageCodesResolver (covered later in this document). // 首页定制 Static index.html support. // 图标定制 Custom Favicon support (covered later in this document). // 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！ Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). /* 如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己 的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供 RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义 实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。 */ If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. // 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 我们来仔细对照，看一下它怎么实现的，它告诉我们SpringBoot已经帮我们自动配置好了SpringMVC，然后自动配置了哪些东西呢？ 12.2、ContentNegotiatingViewResolver 内容协商视图解析器自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器； 即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。 我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！ @Bean @ConditionalOnBean(ViewResolver.class) @ConditionalOnMissingBean(name = \"viewResolver\", value = ContentNegotiatingViewResolver.class) public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) { ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class)); // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级 resolver.setOrder(Ordered.HIGHEST_PRECEDENCE); return resolver; } 我们可以点进这类看看！找到对应的解析视图的代码； @Nullable // 注解说明：@Nullable 即参数可为null public View resolveViewName(String viewName, Locale locale) throws Exception { RequestAttributes attrs = RequestContextHolder.getRequestAttributes(); Assert.state(attrs instanceof ServletRequestAttributes, \"No current ServletRequestAttributes\"); List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest()); if (requestedMediaTypes != null) { // 获取候选的视图对象 List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes); // 选择一个最适合的视图对象，然后把这个对象返回 View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs); if (bestView != null) { return bestView; } } // ..... } 我们继续点进去看，他是怎么获得候选的视图的呢？ getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！ Iterator var5 = this.viewResolvers.iterator(); 所以得出结论：ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的 我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！ protected void initServletContext(ServletContext servletContext) { // 这里它是从beanFactory工具中获取容器中的所有视图解析器 // ViewRescolver.class 把所有的视图解析器来组合的 Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values(); ViewResolver viewResolver; if (this.viewResolvers == null) { this.viewResolvers = new ArrayList(matchingBeans.size()); } // ............... } 既然它是在容器中去找视图解析器，我们是否可以猜想，我们就可以去实现一个视图解析器了呢？ 我们可以自己给容器中去添加一个视图解析器；这个类就会帮我们自动的将它组合进来；我们去实现一下 1、我们在我们的主程序中去写一个视图解析器来试试； @Bean //放到bean中 public ViewResolver myViewResolver(){ return new MyViewResolver(); } //我们写一个静态内部类，视图解析器就需要实现ViewResolver接口 private static class MyViewResolver implements ViewResolver{ @Override public View resolveViewName(String s, Locale locale) throws Exception { return null; } } 2、怎么看我们自己写的视图解析器有没有起作用呢？ 我们给 DispatcherServlet 中的 doDispatch方法 加个断点进行调试一下，因为所有的请求都会走到这个方法中 3、我们启动我们的项目，然后随便访问一个页面，看一下Debug信息； 找到this 找到视图解析器，我们看到我们自己定义的就在这里了； 所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情SpringBoot就会帮我们做了！ 12.3、转换器和格式化器找到格式化转换器： @Bean @Override public FormattingConversionService mvcConversionService() { // 拿到配置文件中的格式化规则 WebConversionService conversionService = new WebConversionService(this.mvcProperties.getDateFormat()); addFormatters(conversionService); return conversionService; } 点击去： public String getDateFormat() { return this.dateFormat; } /** * Date format to use. For instance, `dd/MM/yyyy`. 默认的 */ private String dateFormat; 可以看到在我们的Properties文件中，我们可以进行自动配置它！ 如果配置了自己的格式化方式，就会注册到Bean中生效，我们可以在配置文件中配置日期格式化的规则： 其余的就不一一举例了，大家可以下去多研究探讨即可！ 12.4、修改SpringBoot的默认配置这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。 SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论； SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的； 如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！ 扩展使用SpringMVC 官方文档如下： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. 我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig； //应为类型要求为WebMvcConfigurer，所以我们实现其接口 //可以使用自定义类扩展MVC的功能 @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { // 浏览器发送/test ， 就会跳转到test页面； registry.addViewController(\"/test\").setViewName(\"test\"); } } 我们去浏览器访问一下： 确实也跳转过来了！所以说，我们要扩展SpringMVC，官方就推荐我们这么去使用，既保SpringBoot留所有的自动配置，也能用我们扩展的配置！ 我们可以去分析一下原理： 1、WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter 2、这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class) 3、我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration 这个父类中有这样一段代码： public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); // 从容器中获取所有的webmvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); } } } 4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个 protected void addViewControllers(ViewControllerRegistry registry) { this.configurers.addViewControllers(registry); } 5、我们点进去看一下 public void addViewControllers(ViewControllerRegistry registry) { Iterator var2 = this.delegates.iterator(); while(var2.hasNext()) { // 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的 WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); delegate.addViewControllers(registry); } } 所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用； 12.5、全面接管SpringMVC官方文档： If you want to take complete control of Spring MVC you can add your own @Configuration annotated with @EnableWebMvc. 全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！ 只需在我们的配置类中要加一个@EnableWebMvc。 我们看下如果我们全面接管了SpringMVC了，我们之前SpringBoot给我们配置的静态资源映射一定会无效，我们可以去测试一下； 不加注解之前，访问首页： 给配置类加上注解：@EnableWebMvc 我们发现所有的SpringMVC自动配置都失效了！回归到了最初的样子； 当然，我们开发中，不推荐使用全面接管SpringMVC 思考问题？为什么加了一个注解，自动配置就失效了！我们看下源码： 1、这里发现它是导入了一个类，我们可以继续进去看 @Import({DelegatingWebMvcConfiguration.class})public @interface EnableWebMvc {} 2、它继承了一个父类 WebMvcConfigurationSupport public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { // ......} 3、我们来回顾一下Webmvc自动配置类 @Configuration(proxyBeanMethods = false) @ConditionalOnWebApplication(type = Type.SERVLET) @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) // 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效 @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10) @AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class }) public class WebMvcAutoConfiguration { } 总结一句话：@EnableWebMvc将WebMvcConfigurationSupport组件导入进来了； 而导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能！ 在SpringBoot中会有非常多的扩展配置，只要看见了这个，我们就应该多留心注意~ 13、SpringBoot：页面国际化有的时候，我们的网站会去涉及中英文甚至多语言的切换，这时候我们就需要学习国际化了！ 13.1、准备工作先在IDEA中统一设置properties的编码问题！ 编写国际化配置文件，抽取页面需要显示的国际化页面消息。我们可以去登录页面查看一下，哪些内容我们需要编写国际化的配置！ 13.2、配置文件编写1、我们在resources资源文件下新建一个i18n目录，存放国际化配置文件 2、建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹变了！ 3、我们可以在这上面去新建一个文件； 弹出如下页面：我们再添加一个英文的； 这样就快捷多了！ 4、接下来，我们就来编写配置，我们可以看到idea下面有另外一个视图； 这个视图我们点击 + 号就可以直接添加属性了；我们新建一个login.tip，可以看到边上有三个文件框可以输入 我们添加一下首页的内容！ 然后依次添加其他页面内容即可！ 然后去查看我们的配置文件； login.properties ：默认 login.btn=登录 login.password=密码 login.remember=记住我 login.tip=请登录 login.username=用户名 英文： login.btn=Sign in login.password=Password login.remember=Remember me login.tip=Please sign in login.username=Username 中文： login.btn=登录 login.password=密码 login.remember=记住我 login.tip=请登录 login.username=用户名 OK，配置文件步骤搞定！ 13.3、配置文件生效探究我们去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：MessageSourceAutoConfiguration 里面有一个方法，这里发现SpringBoot已经自动配置好了管理我们国际化资源文件的组件 ResourceBundleMessageSource； // 获取 properties 传递过来的值进行判断 @Bean public MessageSource messageSource(MessageSourceProperties properties) { ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(properties.getBasename())) { // 设置国际化文件的基础名（去掉语言国家代码的） messageSource.setBasenames( StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(properties.getBasename()))); } if (properties.getEncoding() != null) { messageSource.setDefaultEncoding(properties.getEncoding().name()); } messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale()); Duration cacheDuration = properties.getCacheDuration(); if (cacheDuration != null) { messageSource.setCacheMillis(cacheDuration.toMillis()); } messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat()); messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage()); return messageSource; } 我们真实 的情况是放在了i18n目录下，所以我们要去配置这个messages的路径； spring.messages.basename=i18n.login 13.4、配置页面国际化值去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{…}。我们去页面测试下： IDEA还有提示，非常智能的！ 我们可以去启动项目，访问一下，发现已经自动识别为中文的了！ 但是我们想要更好！可以根据按钮自动切换中文英文！ 13.5、配置国际化解析在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！ 我们去我们webmvc自动配置文件，寻找一下！看到SpringBoot默认配置： @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\") public LocaleResolver localeResolver() { // 容器中没有就自己配，有的话就用用户配置的 if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) { return new FixedLocaleResolver(this.mvcProperties.getLocale()); } // 接收头国际化分解 AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; } AcceptHeaderLocaleResolver 这个类中有一个方法 public Locale resolveLocale(HttpServletRequest request) { Locale defaultLocale = this.getDefaultLocale(); // 默认的就是根据请求头带来的区域信息获取Locale进行国际化 if (defaultLocale != null &amp;&amp; request.getHeader(\"Accept-Language\") == null) { return defaultLocale; } else { Locale requestLocale = request.getLocale(); List&lt;Locale&gt; supportedLocales = this.getSupportedLocales(); if (!supportedLocales.isEmpty() &amp;&amp; !supportedLocales.contains(requestLocale)) { Locale supportedLocale = this.findSupportedLocale(request, supportedLocales); if (supportedLocale != null) { return supportedLocale; } else { return defaultLocale != null ? defaultLocale : requestLocale; } } else { return requestLocale; } } } 那假如我们现在想点击链接让我们的国际化资源生效，就需要让我们自己的Locale生效！ 我们去自己写一个自己的LocaleResolver，可以在链接上携带区域信息！ 修改一下前端页面的跳转连接： &lt;!-- 这里传入参数不需要使用 ？使用 （key=value）--&gt; &lt;a class=\"btn btn-sm\" th:href=\"@{/index.html(l='zh_CN')}\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\" th:href=\"@{/index.html(l='en_US')}\"&gt;English&lt;/a&gt; 我们去写一个处理的组件类！ package com.kuang.component; import org.springframework.util.StringUtils; import org.springframework.web.servlet.LocaleResolver; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Locale; //可以在链接上携带区域信息 public class MyLocaleResolver implements LocaleResolver { //解析请求 @Override public Locale resolveLocale(HttpServletRequest request) { String language = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); // 如果没有获取到就使用系统默认的 //如果请求链接不为空 if (!StringUtils.isEmpty(language)){ //分割请求参数 String[] split = language.split(\"_\"); //国家，地区 locale = new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) { } } 为了让我们的区域化信息能够生效，我们需要再配置一下这个组件！在我们自己的MvcConofig下添加bean； @Beanpublic LocaleResolver localeResolver(){ return new MyLocaleResolver();} 我们重启项目，来访问一下，发现点击按钮可以实现成功切换！搞定收工！ 14、SpringBoot：集成Swagger终极版 学习目标： 了解Swagger的概念及作用 掌握在项目中集成Swagger自动生成API文档 14.1、Swagger简介前后端分离 前端 -&gt; 前端控制层、视图层 后端 -&gt; 后端控制层、服务层、数据访问层 前后端通过API进行交互 前后端相对独立且松耦合 产生的问题 前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发 解决方案 首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险 Swagger 号称世界上最流行的API框架 Restful Api 文档在线自动生成器 =&gt; API 文档 与API 定义同步更新 直接运行，在线测试API 支持多种语言 （如：Java，PHP等） 官网：https://swagger.io/ 14.2、SpringBoot集成SwaggerSpringBoot集成Swagger =&gt; springfox，两个jar包 Springfox-swagger2 swagger-springmvc 使用Swagger 要求：jdk 1.8 + 否则swagger2无法运行 步骤： 1、新建一个SpringBoot-web项目 2、添加Maven依赖 &lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 3、编写HelloController，测试确保运行成功！ 4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger @Configuration //配置类 @EnableSwagger2// 开启Swagger2的自动配置 public class SwaggerConfig { }j 5、访问测试 ：http://localhost:8080/swagger-ui.html ，可以看到swagger的界面； 14.3、配置Swagger1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。 @Bean //配置docket以配置Swagger具体参数 public Docket docket() { return new Docket(DocumentationType.SWAGGER_2); } 2、可以通过apiInfo()属性配置文档信息 //配置文档信息 private ApiInfo apiInfo() { Contact contact = new Contact(\"联系人名字\", \"http://xxx.xxx.com/联系人访问链接\", \"联系人邮箱\"); return new ApiInfo( \"Swagger学习\", // 标题 \"学习演示如何配置Swagger\", // 描述 \"v1.0\", // 版本 \"http://terms.service.url/组织链接\", // 组织链接 contact, // 联系人信息 \"Apach 2.0 许可\", // 许可 \"许可链接\", // 许可连接 new ArrayList&lt;&gt;()// 扩展 ); } 3、Docket 实例关联上 apiInfo() @Bean public Docket docket() { return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()); } 4、重启项目，访问测试 http://localhost:8080/swagger-ui.html 看下效果； 14.4、配置扫描接口1、构建Docket时通过select()方法配置怎么扫描接口。 any() // 扫描所有，项目中的所有接口都会被扫描到 none() // 不扫描接口 // 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求 withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation) // 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口 withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation) basePackage(final String basePackage) // 根据包路径扫描接口 2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类 3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式： any() // 扫描所有，项目中的所有接口都会被扫描到 none() // 不扫描接口 // 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求 withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation) // 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口 withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation) basePackage(final String basePackage) // 根据包路径扫描接口 4、除此之外，我们还可以配置接口扫描过滤： @Bean public Docket docket() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(\"com.kuang.swagger.controller\")) // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口 .paths(PathSelectors.ant(\"/kuang/**\")) .build(); } 5、这里的可选值还有 any() // 任何请求都扫描 none() // 任何请求都不扫描 regex(final String pathRegex) // 通过正则表达式控制 ant(final String antPattern) // 通过ant()控制 14.5、配置Swagger开关1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了 @Bean public Docket docket() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问 .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(\"com.kuang.swagger.controller\")) // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口 .paths(PathSelectors.ant(\"/kuang/**\")) .build(); } 2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？ @Bean public Docket docket(Environment environment) { // 设置要显示swagger的环境 Profiles of = Profiles.of(\"dev\", \"test\"); // 判断当前是否处于该环境 // 通过 enable() 接收此参数判断是否要显示 boolean b = environment.acceptsProfiles(of); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(b) //配置是否启用Swagger，如果是false，在浏览器将无法访问 .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(\"com.kuang.swagger.controller\")) // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口 .paths(PathSelectors.ant(\"/kuang/**\")) .build(); } 3、可以在项目中增加一个dev的配置文件查看效果！ 14.6、配置API分组 1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组： @Bean public Docket docket(Environment environment) { return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()) .groupName(\"hello\") // 配置分组 // 省略配置.... } 2、重启项目查看分组 3、如何配置多个分组？配置多个分组只需要配置多个docket即可： @Bean public Docket docket1(){ return new Docket(DocumentationType.SWAGGER_2).groupName(\"group1\"); } @Bean public Docket docket2(){ return new Docket(DocumentationType.SWAGGER_2).groupName(\"group2\"); } @Bean public Docket docket3(){ return new Docket(DocumentationType.SWAGGER_2).groupName(\"group3\"); } 4、重启项目查看即可 14.7、实体配置1、新建一个实体类 @ApiModel(\"用户实体\") public class User { @ApiModelProperty(\"用户名\") public String username; @ApiModelProperty(\"密码\") public String password; } 2、只要这个实体在请求接口的返回值上（即使是泛型），都能映射到实体项中： @RequestMapping(\"/getUser\") public User getUser(){ return new User(); } 3、重启查看测试 注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。 @ApiModel为类添加注释 @ApiModelProperty为类属性添加注释 14.8、常用注解Swagger的所有注解定义在io.swagger.annotations包下 下面列一些经常用到的，未列举出来的可以另行查阅说明： Swagger注解 简单说明 @Api(tags = “xxx模块说明”) 作用在模块类上 @ApiOperation(“xxx接口说明”) 作用在接口方法上 @ApiModel(“xxxPOJO说明”) 作用在模型类上：如VO、BO @ApiModelProperty(value = “xxx属性说明”,hidden = true) 作用在类方法和属性上，hidden设置为true可以隐藏该属性 @ApiParam(“xxx参数说明”) 作用在参数、方法和字段上，类似@ApiModelProperty 我们也可以给请求的接口配置一些注释 @ApiOperation(\"狂神的接口\") @PostMapping(\"/kuang\") @ResponseBody public String kuang(@ApiParam(\"这个名字会被返回\")String username){ return username; } 这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！ 相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。 Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。 14.9、拓展：其他皮肤我们可以导入不同的包实现不同的皮肤定义： 1、默认的 访问 http://localhost:8080/swagger-ui.html &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 2、bootstrap-ui 访问 http://localhost:8080/doc.html &lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt; &lt;/dependency&gt; 3、Layui-ui 访问 http://localhost:8080/docs.html &lt;!-- 引入swagger-ui-layer包 /docs.html--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.caspar-chen&lt;/groupId&gt; &lt;artifactId&gt;swagger-ui-layer&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;/dependency&gt; 4、mg-ui 访问 http://localhost:8080/document.html &lt;!-- 引入swagger-ui-layer包 /document.html--&gt; &lt;dependency&gt; &lt;groupId&gt;com.zyplayer&lt;/groupId&gt; &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt; &lt;version&gt;1.0.6&lt;/version&gt; &lt;/dependency&gt; 15、SpringBoot：异步、定时、邮件任务前言 在我们的工作中，常常会用到异步处理任务，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。还有一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息。还有就是邮件的发送，微信的前身也是邮件服务呢？这些东西都是怎么实现的呢？其实SpringBoot都给我们提供了对应的支持，我们上手使用十分的简单，只需要开启一些注解支持，配置一些配置文件即可！那我们来看看吧~ 最后编辑于2020.3.26 作者：狂神说 15.1、异步任务1、创建一个service包 2、创建一个类AsyncService 异步处理还是非常常用的，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。 编写方法，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况； @Service public class AsyncService { public void hello(){ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"业务进行中....\"); } } 3、编写controller包 4、编写AsyncController类 我们去写一个Controller测试一下 @RestController public class AsyncController { @Autowired AsyncService asyncService; @GetMapping(\"/hello\") public String hello(){ asyncService.hello(); return \"success\"; } } 5、访问http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。 问题：我们如果想让用户直接得到消息，就在后台使用多线程的方式进行处理即可，但是每次都需要自己手动去编写多线程的实现的话，太麻烦了，我们只需要用一个简单的办法，在我们的方法上加一个简单的注解即可，如下： 6、给hello方法添加@Async注解； //告诉Spring这是一个异步方法 @Async public void hello(){ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"业务进行中....\"); } SpringBoot就会自己开一个线程池，进行调用！但是要让这个注解生效，我们还需要在主程序上添加一个注解@EnableAsync ，开启异步注解功能； @EnableAsync //开启异步注解功能 @SpringBootApplication public class SpringbootTaskApplication { public static void main(String[] args) { SpringApplication.run(SpringbootTaskApplication.class, args); } } 7、重启测试，网页瞬间响应，后台代码依旧执行！ 15.2、定时任务项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。 TaskExecutor接口 TaskScheduler接口 两个注解： @EnableScheduling @Scheduled cron表达式： 测试步骤： 1、创建一个ScheduledService 我们里面存在一个hello方法，他需要定时执行，怎么处理呢？ @Service public class ScheduledService { //秒 分 时 日 月 周几 //0 * * * * MON-FRI //注意cron表达式的用法； @Scheduled(cron = \"0 * * * * 0-7\") public void hello(){ System.out.println(\"hello.....\"); } } 2、这里写完定时任务之后，我们需要在主程序上增加@EnableScheduling 开启定时任务功能 @EnableAsync //开启异步注解功能 @EnableScheduling //开启基于注解的定时任务 @SpringBootApplication public class SpringbootTaskApplication { public static void main(String[] args) { SpringApplication.run(SpringbootTaskApplication.class, args); } } 3、我们来详细了解下cron表达式； http://www.bejson.com/othertools/cron/ 4、常用的表达式 (1）0/2 * * * * ? 表示每2秒 执行任务 （1）0 0/2 * * * ? 表示每2分钟 执行任务 （1）0 0 2 1 * ? 表示在每月的1日的凌晨2点调整任务 （2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业 （3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作 （4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 （5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 （6）0 0 12 ? * WED 表示每个星期三中午12点 （7）0 0 12 * * ? 每天中午12点触发 （8）0 15 10 ? * * 每天上午10:15触发 （9）0 15 10 * * ? 每天上午10:15触发 （10）0 15 10 * * ? 每天上午10:15触发 （11）0 15 10 * * ? 2005 2005年的每天上午10:15触发 （12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 （13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 （14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 （15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 （16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 （17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 （18）0 15 10 15 * ? 每月15日上午10:15触发 （19）0 15 10 L * ? 每月最后一日的上午10:15触发 （20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 （21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 （22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发 15.3、邮件任务邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持 邮件发送需要引入spring-boot-start-mail SpringBoot 自动配置MailSenderAutoConfiguration 定义MailProperties内容，配置在application.yml中 自动装配JavaMailSender 测试邮件发送 测试： 1、引入pom依赖 &lt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 看它引入的依赖，可以看到 jakarta.mail &lt;dependency&gt; &lt;groupId&gt;com.sun.mail&lt;/groupId&gt; &lt;artifactId&gt;jakarta.mail&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 2、查看自动配置类：MailSenderAutoConfiguration 这个类中存在bean，JavaMailSenderImpl 然后我们去看下配置文件 @ConfigurationProperties( prefix = \"spring.mail\" ) public class MailProperties { private static final Charset DEFAULT_CHARSET; private String host; private Integer port; private String username; private String password; private String protocol = \"smtp\"; private Charset defaultEncoding; private Map&lt;String, String&gt; properties; private String jndiName; } 3、配置文件： spring.mail.username=24736743@qq.comspring.mail.password=你的qq授权码spring.mail.host=smtp.qq.com# qq需要配置sslspring.mail.properties.mail.smtp.ssl.enable=true 获取授权码：在QQ邮箱中的设置-&gt;账户-&gt;开启pop3和smtp服务 4、Spring单元测试 @Autowired JavaMailSenderImpl mailSender; @Test public void contextLoads() { //邮件设置1：一个简单的邮件 SimpleMailMessage message = new SimpleMailMessage(); message.setSubject(\"通知-明天来狂神这听课\"); message.setText(\"今晚7:30开会\"); message.setTo(\"24736743@qq.com\"); message.setFrom(\"24736743@qq.com\"); mailSender.send(message); } @Test public void contextLoads2() throws MessagingException { //邮件设置2：一个复杂的邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); helper.setSubject(\"通知-明天来狂神这听课\"); helper.setText(\"&lt;b style='color:red'&gt;今天 7:30来开会&lt;/b&gt;\",true); //发送附件 helper.addAttachment(\"1.jpg\",new File(\"\")); helper.addAttachment(\"2.jpg\",new File(\"\")); helper.setTo(\"24736743@qq.com\"); helper.setFrom(\"24736743@qq.com\"); mailSender.send(mimeMessage); } 查看邮箱，邮件接收成功！ 我们只需要使用Thymeleaf进行前后端结合即可开发自己网站邮件收发功能了！ 16、SpringBoot：富文本编辑器16.1、简介思考：我们平时在博客园，或者CSDN等平台进行写作的时候，有同学思考过他们的编辑器是怎么实现的吗？ 在博客园后台的选项设置中，可以看到一个文本编辑器的选项： 其实这个就是富文本编辑器，市面上有许多非常成熟的富文本编辑器，比如： Editor.md——功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费 官网：https://pandao.github.io/editor.md/ wangEditor——基于javascript和css开发的 Web富文本编辑器， 轻量、简洁、界面美观、易用、开源免费。 官网：http://www.wangeditor.com/ TinyMCE——TinyMCE是一个轻量级的基于浏览器的所见即所得编辑器，由JavaScript写成。它对IE6+和Firefox1.5+都有着非常良好的支持。功能齐全，界面美观，就是文档是英文的，对开发人员英文水平有一定要求。 官网：https://www.tiny.cloud/docs/demo/full-featured/ 博客园 百度ueditor——UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，功能齐全，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码，缺点是已经没有更新了 官网：https://ueditor.baidu.com/website/onlinedemo.html kindeditor——界面经典。 官网：http://kindeditor.net/demo.php Textbox——Textbox是一款极简但功能强大的在线文本编辑器，支持桌面设备和移动设备。主要功能包含内置的图像处理和存储、文件拖放、拼写检查和自动更正。此外，该工具还实现了屏幕阅读器等辅助技术，并符合WAI-ARIA可访问性标准。 官网：https://textbox.io/ CKEditor——国外的，界面美观。 官网：https://ckeditor.com/ckeditor-5/demo/ quill——功能强大，还可以编辑公式等 官网：https://quilljs.com/ simditor——界面美观，功能较全。 官网：https://simditor.tower.im/ summernote——UI好看，精美 官网：https://summernote.org/ jodit——功能齐全 官网：https://xdsoft.net/jodit/ froala Editor——界面非常好看，功能非常强大，非常好用（非免费） 官网：https://www.froala.com/wysiwyg-editor 总之，目前可用的富文本编辑器有很多……这只是其中的一部分 16.2、Editor.md我这里使用的就是Editor.md，作为一个资深码农，Mardown必然是我们程序猿最喜欢的格式，看下面，就爱上了！ 我们可以在官网下载它：https://pandao.github.io/editor.md/ ， 得到它的压缩包！ 解压以后，在examples目录下面，可以看到他的很多案例使用！学习，其实就是看人家怎么写的，然后进行模仿就好了！ 我们可以将整个解压的文件倒入我们的项目，将一些无用的测试和案例删掉即可！ 16.3、基础工程搭建 数据库设计 article：文章表 字段 备注 id int 文章的唯一ID author varchar 作者 title varchar 标题 content longtext 文章的内容 建表SQL： CREATE TABLE `article` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'int文章的唯一ID', `author` varchar(50) NOT NULL COMMENT '作者', `title` varchar(100) NOT NULL COMMENT '标题', `content` longtext NOT NULL COMMENT '文章的内容', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 基础项目搭建 1、建一个SpringBoot项目配置 spring: datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; 2、实体类： //文章类 @Data @NoArgsConstructor @AllArgsConstructor public class Article implements Serializable { private int id; //文章的唯一ID private String author; //作者名 private String title; //标题 private String content; //文章的内容 } 3、mapper接口： @Mapper @Repository public interface ArticleMapper { //查询所有的文章 List&lt;Article&gt; queryArticles(); //新增一个文章 int addArticle(Article article); //根据文章id查询文章 Article getArticleById(int id); //根据文章id删除文章 int deleteArticleById(int id); } 既然已经提供了 myBatis 的映射配置文件，自然要告诉 spring boot 这些文件的位置 mybatis: mapper-locations: classpath:com/kuang/mapper/*.xml type-aliases-package: com.kuang.pojo 编写一个Controller测试下，是否ok； 16.4、文章编辑整合（重点）1、导入 editor.md 资源 ，删除多余文件 2、编辑文章页面 editor.html、需要引入 jQuery； &lt;!DOCTYPE html&gt; &lt;html class=\"x-admin-sm\" lang=\"zh\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;秦疆'Blog&lt;/title&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,user-scalable=yes, minimum-scale=0.4, initial-scale=0.8,target-densitydpi=low-dpi\" /&gt; &lt;!--Editor.md--&gt; &lt;link rel=\"stylesheet\" th:href=\"@{/editormd/css/editormd.css}\"/&gt; &lt;link rel=\"shortcut icon\" href=\"https://pandao.github.io/editor.md/favicon.ico\" type=\"image/x-icon\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"layui-fluid\"&gt; &lt;div class=\"layui-row layui-col-space15\"&gt; &lt;div class=\"layui-col-md12\"&gt; &lt;!--博客表单--&gt; &lt;form name=\"mdEditorForm\"&gt; &lt;div&gt; 标题：&lt;input type=\"text\" name=\"title\"&gt; &lt;/div&gt; &lt;div&gt; 作者：&lt;input type=\"text\" name=\"author\"&gt; &lt;/div&gt; &lt;div id=\"article-content\"&gt; &lt;textarea name=\"content\" id=\"content\" style=\"display:none;\"&gt; &lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;!--editormd--&gt; &lt;script th:src=\"@{/editormd/lib/jquery.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/editormd.js}\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var testEditor; //window.onload = function(){ } $(function() { testEditor = editormd(\"article-content\", { width : \"95%\", height : 400, syncScrolling : \"single\", path : \"../editormd/lib/\", saveHTMLToTextarea : true, // 保存 HTML 到 Textarea emoji: true, theme: \"dark\",//工具栏主题 previewTheme: \"dark\",//预览主题 editorTheme: \"pastel-on-dark\",//编辑主题 tex : true, // 开启科学公式TeX语言支持，默认关闭 flowChart : true, // 开启流程图支持，默认关闭 sequenceDiagram : true, // 开启时序/序列图支持，默认关闭, //图片上传 imageUpload : true, imageFormats : [\"jpg\", \"jpeg\", \"gif\", \"png\", \"bmp\", \"webp\"], imageUploadURL : \"/article/file/upload\", onload : function() { console.log('onload', this); }, /*指定需要显示的功能按钮*/ toolbarIcons : function() { return [\"undo\",\"redo\",\"|\", \"bold\",\"del\",\"italic\",\"quote\",\"ucwords\",\"uppercase\",\"lowercase\",\"|\", \"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"|\", \"list-ul\",\"list-ol\",\"hr\",\"|\", \"link\",\"reference-link\",\"image\",\"code\",\"preformatted-text\", \"code-block\",\"table\",\"datetime\",\"emoji\",\"html-entities\",\"pagebreak\",\"|\", \"goto-line\",\"watch\",\"preview\",\"fullscreen\",\"clear\",\"search\",\"|\", \"help\",\"info\",\"releaseIcon\", \"index\"] }, /*自定义功能按钮，下面我自定义了2个，一个是发布，一个是返回首页*/ toolbarIconTexts : { releaseIcon : \"&lt;span bgcolor=\\\"gray\\\"&gt;发布&lt;/span&gt;\", index : \"&lt;span bgcolor=\\\"red\\\"&gt;返回首页&lt;/span&gt;\", }, /*给自定义按钮指定回调函数*/ toolbarHandlers:{ releaseIcon : function(cm, icon, cursor, selection) { //表单提交 mdEditorForm.method = \"post\"; mdEditorForm.action = \"/article/addArticle\";//提交至服务器的路径 mdEditorForm.submit(); }, index : function(){ window.location.href = '/'; }, } }); }); &lt;/script&gt; &lt;/html&gt; 3、编写Controller，进行跳转，以及保存文章 @Controller @RequestMapping(\"/article\") public class ArticleController { @GetMapping(\"/toEditor\") public String toEditor(){ return \"editor\"; } @PostMapping(\"/addArticle\") public String addArticle(Article article){ articleMapper.addArticle(article); return \"editor\"; } } 图片上传问题 1、前端js中添加配置 //图片上传 imageUpload : true, imageFormats : [\"jpg\", \"jpeg\", \"gif\", \"png\", \"bmp\", \"webp\"], imageUploadURL : \"/article/file/upload\", // //这个是上传图片时的访问地址 2、后端请求，接收保存这个图片, 需要导入 FastJson 的依赖！ //博客图片上传问题 @RequestMapping(\"/file/upload\") @ResponseBody public JSONObject fileUpload(@RequestParam(value = \"editormd-image-file\", required = true) MultipartFile file, HttpServletRequest request) throws IOException { //上传路径保存设置 //获得SpringBoot当前项目的路径：System.getProperty(\"user.dir\") String path = System.getProperty(\"user.dir\")+\"/upload/\"; //按照月份进行分类： Calendar instance = Calendar.getInstance(); String month = (instance.get(Calendar.MONTH) + 1)+\"月\"; path = path+month; File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } //上传文件地址 System.out.println(\"上传文件保存地址：\"+realPath); //解决文件名字问题：我们使用uuid; String filename = \"ks-\"+UUID.randomUUID().toString().replaceAll(\"-\", \"\"); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +\"/\"+ filename)); //给editormd进行回调 JSONObject res = new JSONObject(); res.put(\"url\",\"/upload/\"+month+\"/\"+ filename); res.put(\"success\", 1); res.put(\"message\", \"upload success!\"); return res; } 3、解决文件回显显示的问题，设置虚拟目录映射！在我们自己拓展的MvcConfig中进行配置即可！ @Configuration public class MyMvcConfig implements WebMvcConfigurer { // 文件保存在真实目录/upload/下， // 访问的时候使用虚路径/upload，比如文件名为1.png，就直接/upload/1.png就ok了。 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/upload/**\") .addResourceLocations(\"file:\"+System.getProperty(\"user.dir\")+\"/upload/\"); } } 表情包问题 自己手动下载，emoji 表情包，放到图片路径下： 修改editormd.js文件 // Emoji graphics files url path editormd.emoji = { path : \"../editormd/plugins/emoji-dialog/emoji/\", ext : \".png\" }; 16.5、文章展示1、Controller 中增加方法 @GetMapping(\"/{id}\") public String show(@PathVariable(\"id\") int id,Model model){ Article article = articleMapper.getArticleById(id); model.addAttribute(\"article\",article); return \"article\"; } 2、编写页面 article.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;title th:text=\"${article.title}\"&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;!--文章头部信息：标题，作者，最后更新日期，导航--&gt; &lt;h2 style=\"margin: auto 0\" th:text=\"${article.title}\"&gt;&lt;/h2&gt; 作者：&lt;span style=\"float: left\" th:text=\"${article.author}\"&gt;&lt;/span&gt; &lt;!--文章主体内容--&gt; &lt;div id=\"doc-content\"&gt; &lt;textarea style=\"display:none;\" placeholder=\"markdown\" th:text=\"${article.content}\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;link rel=\"stylesheet\" th:href=\"@{/editormd/css/editormd.preview.css}\" /&gt; &lt;script th:src=\"@{/editormd/lib/jquery.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/lib/marked.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/lib/prettify.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/lib/raphael.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/lib/underscore.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/lib/sequence-diagram.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/lib/flowchart.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/lib/jquery.flowchart.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/editormd.js}\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var testEditor; $(function () { testEditor = editormd.markdownToHTML(\"doc-content\", {//注意：这里是上面DIV的id htmlDecode: \"style,script,iframe\", emoji: true, taskList: true, tocm: true, tex: true, // 默认不解析 flowChart: true, // 默认不解析 sequenceDiagram: true, // 默认不解析 codeFold: true });}); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 重启项目，访问进行测试！大功告成！ 小结： 有了富文本编辑器，我们网站的功能就会又多一项，大家到了这里完全可以有时间写一个属于自己的博客网站了，根据所学的知识是完全没有任何问题的！ 17、SpringBoot：Dubbo和Zookeeper集成分布式理论 17.1、什么是分布式系统？在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”； 分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。 分布式系统（distributed system）是建立在网络之上的软件系统。 首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。 17.2、Dubbo文档随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进。 在Dubbo的官网文档有这样一张图 **单一应用架构**当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。 缺点： 1、性能扩展比较难 2、协同开发问题 3、不利于升级维护 *\\*\\垂直应用架构******当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。 缺点：公用模块无法重复利用，开发性的浪费 **分布式服务架构**当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 *\\***\\流动计算架构********当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键。 什么是RPC RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。 也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数； 推荐阅读文章：https://www.jianshu.com/p/2accc2840a1b RPC基本原理 步骤解析： RPC两个核心模块：通讯，序列化。 测试环境搭建 *\\***\\Dubbo********Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 dubbo官网 http://dubbo.apache.org/zh-cn/index.html 1.了解Dubbo的特性 2.查看官方文档 dubbo基本概念 服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者 监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 调用关系说明 l 服务容器负责启动，加载，运行服务提供者。 l 服务提供者在启动时，向注册中心注册自己提供的服务。 l 服务消费者在启动时，向注册中心订阅自己所需的服务。 l 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 l 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 l 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 *\\***\\Dubbo环境搭建********点进dubbo官方文档，推荐我们使用Zookeeper 注册中心 什么是zookeeper呢？可以查看官方文档 *\\***\\Window下安装zookeeper********1、下载zookeeper ：地址， 我们下载3.4.14 ， 最新版！解压zookeeper 2、运行/bin/zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件； 可能遇到问题：闪退 ! 解决方案：编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。 3、修改zoo.cfg配置文件 将conf文件夹下面的zoo_sample.cfg复制一份改名为zoo.cfg即可。 注意几个重要位置： dataDir=./ 临时数据存储的目录（可写相对路径） clientPort=2181 zookeeper的端口号 修改完成后再次启动zookeeper 4、使用zkCli.cmd测试 ls /：列出zookeeper根下保存的所有节点 [zk: 127.0.0.1:2181(CONNECTED) 4] ls /[zookeeper] create –e /kuangshen 123：创建一个kuangshen节点，值为123 get /kuangshen：获取/kuangshen节点的值 我们再来查看一下节点 *\\***\\window下安装dubbo-admin********dubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。 但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。 我们这里来安装一下： 1、下载dubbo-admin 地址 ：https://github.com/apache/dubbo-admin/tree/master 2、解压进入目录 修改 dubbo-admin\\src\\main\\resources \\application.properties 指定zookeeper地址 server.port=7001spring.velocity.cache=falsespring.velocity.charset=UTF-8spring.velocity.layout-url=/templates/default.vmspring.messages.fallback-to-system-locale=falsespring.messages.basename=i18n/messagespring.root.password=rootspring.guest.password=guestdubbo.registry.address=zookeeper://127.0.0.1:2181 3、在项目目录下打包dubbo-admin mvn clean package -Dmaven.test.skip=true 第一次打包的过程有点慢，需要耐心等待！直到成功！ 4、执行 dubbo-admin\\target 下的dubbo-admin-0.0.1-SNAPSHOT.jar java -jar dubbo-admin-0.0.1-SNAPSHOT.jar 【注意：zookeeper的服务一定要打开！】 执行完毕，我们去访问一下 http://localhost:7001/ ， 这时候我们需要输入登录账户和密码，我们都是默认的root-root； 登录成功后，查看界面 安装完成！ 17.3、SpringBoot + Dubbo + zookeeper*\\***\\框架搭建********1. 启动zookeeper ！ 2. IDEA创建一个空项目； 3.创建一个模块，实现服务提供者：provider-server ， 选择web依赖即可 4.项目创建完毕，我们写一个服务，比如卖票的服务； 编写接口 package com.kuang.provider.service; public interface TicketService { public String getTicket(); } 编写实现类 package com.kuang.provider.service; public class TicketServiceImpl implements TicketService { @Override public String getTicket() { return \"《狂神说Java》\"; } } 5.创建一个模块，实现服务消费者：consumer-server ， 选择web依赖即可 6.项目创建完毕，我们写一个服务，比如用户的服务； 编写service package com.kuang.consumer.service; public class UserService { //我们需要去拿去注册中心的服务 } 需求：现在我们的用户想使用买票的服务，这要怎么弄呢 ？ *\\***\\服务提供者********1、将服务提供者注册到注册中心，我们需要整合Dubbo和zookeeper，所以需要导包 我们从dubbo官网进入github，看下方的帮助文档，找到dubbo-springboot，找到依赖包 &lt;!-- Dubbo Spring Boot Starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; zookeeper的包我们去maven仓库下载，zkclient； &lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; 【新版的坑】zookeeper及其依赖包，解决日志冲突，还需要剔除日志依赖； &lt;!-- 引入zookeeper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;!--排除这个slf4j-log4j12--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 2、在springboot配置文件中配置dubbo相关属性！ #当前应用名字 dubbo.application.name=provider-server #注册中心地址 dubbo.registry.address=zookeeper://127.0.0.1:2181 #扫描指定包下服务 dubbo.scan.base-packages=com.kuang.provider.service 3、在service的实现类中配置服务注解，发布服务！注意导包问题 import org.apache.dubbo.config.annotation.Service; import org.springframework.stereotype.Component; @Service //将服务发布出去 @Component //放在容器中 public class TicketServiceImpl implements TicketService { @Override public String getTicket() { return \"《狂神说Java》\"; } } 逻辑理解 ：应用启动起来，dubbo就会扫描指定的包下带有@component注解的服务，将它发布在指定的注册中心中！ *\\***\\服务消费者********1、导入依赖，和之前的依赖一样； &lt;!--dubbo--&gt; &lt;!-- Dubbo Spring Boot Starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--zookeeper--&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入zookeeper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;!--排除这个slf4j-log4j12--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 2、配置参数 #当前应用名字 dubbo.application.name=consumer-server #注册中心地址 dubbo.registry.address=zookeeper://127.0.0.1:2181 3. 本来正常步骤是需要将服务提供者的接口打包，然后用pom文件导入，我们这里使用简单的方式，直接将服务的接口拿过来，路径必须保证正确，即和服务提供者相同； 4. 完善消费者的服务类 package com.kuang.consumer.service; import com.kuang.provider.service.TicketService; import org.apache.dubbo.config.annotation.Reference; import org.springframework.stereotype.Service; @Service //注入到容器中 public class UserService { @Reference //远程引用指定的服务，他会按照全类名进行匹配，看谁给注册中心注册了这个全类名 TicketService ticketService; public void bugTicket(){ String ticket = ticketService.getTicket(); System.out.println(\"在注册中心买到\"+ticket); } } 5. 测试类编写； @RunWith(SpringRunner.class) @SpringBootTest public class ConsumerServerApplicationTests { @Autowired UserService userService; @Test public void contextLoads() { userService.bugTicket(); } } *\\***\\启动测试********1. 开启zookeeper 2. 打开dubbo-admin实现监控【可以不用做】 3. 开启服务者 4. 消费者消费测试，结果： 监控中心 ： ok , 这就是SpingBoot + dubbo + zookeeper实现分布式开发的应用，其实就是一个服务拆分的思想； 18、SpringBoot：集成SpringSecurity18.1、安全简介在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。 市面上存在比较有名的：Shiro，Spring Security ！ 这里需要阐述一下的是，每一个框架的出现都是为了解决某一问题而产生了，那么Spring Security框架的出现是为了解决什么问题呢？ 首先我们看下它的官网介绍：Spring Security官网地址 Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications. Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。 Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求 从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。 怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。 Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。 对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。 18.2、实战测试18.2.1、实验环境搭建1、新建一个初始的springboot项目web模块，thymeleaf模块 2、导入静态资源 welcome.html |views |level1 1.html 2.html 3.html |level2 1.html 2.html 3.html |level3 1.html 2.html 3.html Login.html 3、controller跳转！ package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class RouterController { @RequestMapping({\"/\",\"/index\"}) public String index(){ return \"index\"; } @RequestMapping(\"/toLogin\") public String toLogin(){ return \"views/login\"; } @RequestMapping(\"/level1/{id}\") public String level1(@PathVariable(\"id\") int id){ return \"views/level1/\"+id; } @RequestMapping(\"/level2/{id}\") public String level2(@PathVariable(\"id\") int id){ return \"views/level2/\"+id; } @RequestMapping(\"/level3/{id}\") public String level3(@PathVariable(\"id\") int id){ return \"views/level3/\"+id; } } 4、测试实验环境是否OK！ 18.2.2、认识SpringSecuritySpring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！ 记住几个类： WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式 Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。 “认证”（Authentication） 身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。 身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。 “授权” （Authorization） 授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。 这个概念是通用的，而不是只在Spring Security 中存在。 18.2.3、认证和授权目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能 1、引入 Spring Security 模块 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 2、编写 Spring Security 配置类 参考官网：https://spring.io/projects/spring-security 查看我们自己项目中的版本，找到对应的帮助文档： https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5 #servlet-applications 8.16.4 3、编写基础配置类 package com.kuang.config; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; @EnableWebSecurity // 开启WebSecurity模式 public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { } } 4、定制请求的授权规则 @Override protected void configure(HttpSecurity http) throws Exception { // 定制请求的授权规则 // 首页所有人可以访问 http.authorizeRequests().antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasRole(\"vip1\") .antMatchers(\"/level2/**\").hasRole(\"vip2\") .antMatchers(\"/level3/**\").hasRole(\"vip3\"); } 5、测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！ 6、在configure()方法中加入以下配置，开启自动配置的登录功能！ // 开启自动配置的登录功能 // /login 请求来到登录页 // /login?error 重定向到这里表示登录失败 http.formLogin(); 7、测试一下：发现，没有权限的时候，会跳转到登录的页面！ 8、查看刚才登录页的注释信息； 我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法 //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //在内存中定义，也可以在jdbc中去拿.... auth.inMemoryAuthentication() .withUser(\"kuangshen\").password(\"123456\").roles(\"vip2\",\"vip3\") .and() .withUser(\"root\").password(\"123456\").roles(\"vip1\",\"vip2\",\"vip3\") .and() .withUser(\"guest\").password(\"123456\").roles(\"vip1\",\"vip2\"); } 9、测试，我们可以使用这些账号登录进行测试！发现会报错！ There is no PasswordEncoder mapped for the id “null” 10、原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码 //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //在内存中定义，也可以在jdbc中去拿.... //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。 //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密 //spring security 官方推荐的是使用bcrypt加密方式。 auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(\"kuangshen\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip2\",\"vip3\") .and() .withUser(\"root\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\",\"vip3\") .and() .withUser(\"guest\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\"); } 11、测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定 18.2.4、权限控制和注销1、开启自动配置的注销的功能 //定制请求的授权规则 @Override protected void configure(HttpSecurity http) throws Exception { //.... //开启自动配置的注销的功能 // /logout 注销请求 http.logout(); } 2、我们在前端，增加一个注销的按钮，index.html 导航栏中 &lt;a class=\"item\" th:href=\"@{/logout}\"&gt; &lt;i class=\"address card icon\"&gt;&lt;/i&gt; 注销 &lt;/a&gt; 3、我们可以去测试一下，登录成功后点击注销，发现注销完毕会跳转到登录页面！ 4、但是，我们想让他注销成功后，依旧可以跳转到首页，该怎么处理呢？ // .logoutSuccessUrl(\"/\"); 注销成功来到首页 http.logout().logoutSuccessUrl(\"/\"); 5、测试，注销完毕后，发现跳转到首页OK 6、我们现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？ 我们需要结合thymeleaf中的一些功能 sec：authorize=”isAuthenticated()”:是否认证登录！来显示不同的页面 Maven依赖： &lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; 7、修改我们的 前端页面 导入命名空间 xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\" 3. 修改导航栏，增加认证判断 4. ```html &lt;!--登录注销--&gt; &lt;div class=\"right menu\"&gt; &lt;!--如果未登录--&gt; &lt;div sec:authorize=\"!isAuthenticated()\"&gt; &lt;a class=\"item\" th:href=\"@{/login}\"&gt; &lt;i class=\"address card icon\"&gt;&lt;/i&gt; 登录 &lt;/a&gt; &lt;/div&gt; &lt;!--如果已登录--&gt; &lt;div sec:authorize=\"isAuthenticated()\"&gt; &lt;a class=\"item\"&gt; &lt;i class=\"address card icon\"&gt;&lt;/i&gt; 用户名：&lt;span sec:authentication=\"principal.username\"&gt;&lt;/span&gt; 角色：&lt;span sec:authentication=\"principal.authorities\"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div sec:authorize=\"isAuthenticated()\"&gt; &lt;a class=\"item\" th:href=\"@{/logout}\"&gt; &lt;i class=\"address card icon\"&gt;&lt;/i&gt; 注销 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; 8、重启测试，我们可以登录试试看，登录成功后确实，显示了我们想要的页面； 9、如果注销404了，就是因为它默认防止csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 http.csrf().disable(); http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求 http.logout().logoutSuccessUrl(\"/\"); 10、我们继续将下面的角色功能块认证完成！ &lt;!-- sec:authorize=\"hasRole('vip1')\" --&gt; &lt;div class=\"column\" sec:authorize=\"hasRole('vip1')\"&gt; &lt;div class=\"ui raised segment\"&gt; &lt;div class=\"ui\"&gt; &lt;div class=\"content\"&gt; &lt;h5 class=\"content\"&gt;Level 1&lt;/h5&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=\"@{/level1/1}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-1-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@{/level1/2}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-1-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@{/level1/3}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-1-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"column\" sec:authorize=\"hasRole('vip2')\"&gt; &lt;div class=\"ui raised segment\"&gt; &lt;div class=\"ui\"&gt; &lt;div class=\"content\"&gt; &lt;h5 class=\"content\"&gt;Level 2&lt;/h5&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=\"@{/level2/1}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-2-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@{/level2/2}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-2-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@{/level2/3}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-2-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"column\" sec:authorize=\"hasRole('vip3')\"&gt; &lt;div class=\"ui raised segment\"&gt; &lt;div class=\"ui\"&gt; &lt;div class=\"content\"&gt; &lt;h5 class=\"content\"&gt;Level 3&lt;/h5&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=\"@{/level3/1}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-3-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@{/level3/2}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-3-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@{/level3/3}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-3-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 11、测试一下！ 12、权限控制和注销搞定！ 18.2.5、记住我现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单 1、开启记住我功能 //定制请求的授权规则 @Override protected void configure(HttpSecurity http) throws Exception { //。。。。。。。。。。。 //记住我 http.rememberMe(); } 2、我们再次启动项目测试一下，发现登录页多了一个记住我功能，我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！ 思考：如何实现的呢？其实非常简单 我们可以查看浏览器的cookie 3、我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie 4、结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie，具体的原理我们在JavaWeb阶段都讲过了，这里就不在多说了！ 18.2.6、定制登录页现在这个登录页面都是spring security 默认的，怎么样可以使用我们自己写的Login界面呢？ 1、在刚才的登录页配置后面指定 loginpage http.formLogin().loginPage(\"/toLogin\"); 2、然后前端也需要指向我们自己定义的 login请求 &lt;a class=\"item\" th:href=\"@{/toLogin}\"&gt; &lt;i class=\"address card icon\"&gt;&lt;/i&gt; 登录 &lt;/a&gt; 3、我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为post: 在 loginPage()源码中的注释上有写明： &lt;form th:action=\"@{/login}\" method=\"post\"&gt; &lt;div class=\"field\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;div class=\"ui left icon input\"&gt; &lt;input type=\"text\" placeholder=\"Username\" name=\"username\"&gt; &lt;i class=\"user icon\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"field\"&gt; &lt;label&gt;Password&lt;/label&gt; &lt;div class=\"ui left icon input\"&gt; &lt;input type=\"password\" name=\"password\"&gt; &lt;i class=\"lock icon\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;input type=\"submit\" class=\"ui blue submit button\"/&gt; &lt;/form&gt; 4、这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看formLogin()方法的源码！我们配置接收登录的用户名和密码的参数！ http.formLogin() .usernameParameter(\"username\") .passwordParameter(\"password\") .loginPage(\"/toLogin\") .loginProcessingUrl(\"/login\"); // 登陆表单提交请求 5、在登录页增加记住我的多选框 &lt;input type=\"checkbox\" name=\"remember\"&gt; 记住我 6、后端验证处理！ //定制记住我的参数！ http.rememberMe().rememberMeParameter(\"remember\"); 7、测试，OK 18.3、完整配置代码package com.kuang.config; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { //定制请求的授权规则 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasRole(\"vip1\") .antMatchers(\"/level2/**\").hasRole(\"vip2\") .antMatchers(\"/level3/**\").hasRole(\"vip3\"); //开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！ // /login 请求来到登录页 // /login?error 重定向到这里表示登录失败 http.formLogin() .usernameParameter(\"username\") .passwordParameter(\"password\") .loginPage(\"/toLogin\") .loginProcessingUrl(\"/login\"); // 登陆表单提交请求 //开启自动配置的注销的功能 // /logout 注销请求 // .logoutSuccessUrl(\"/\"); 注销成功来到首页 http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求 http.logout().logoutSuccessUrl(\"/\"); //记住我 http.rememberMe().rememberMeParameter(\"remember\"); } //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //在内存中定义，也可以在jdbc中去拿.... //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。 //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密 //spring security 官方推荐的是使用bcrypt加密方式。 auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(\"kuangshen\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip2\",\"vip3\") .and() .withUser(\"root\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\",\"vip3\") .and() .withUser(\"guest\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\"); } } 去进行一波源码分析！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://melodyjerry.github.io/blog/tags/SpringBoot/"}]},{"title":"Linux下安装node v12.16.3","slug":"Linux下安装node-v12.16.3","date":"2020-09-23T09:21:21.000Z","updated":"2020-09-24T08:55:08.023Z","comments":true,"path":"2020/09/23/Linux下安装node-v12.16.3/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/23/Linux%E4%B8%8B%E5%AE%89%E8%A3%85node-v12.16.3/","excerpt":"下载nodejs cd ~ wget http://nodejs.org/dist/v12.16.3/node-v12.16.3-linux-x64.tar.gz 解压并修改解压后文件名 tar -zxvf node-v12.16.3-linux-x64.tar.gz mv node-v12.16.3-linux-x64 nodejs 切换路径到解压后文件 cd nodejs/bin // 切换路径 ./node -v //查看node是否安装成功 若成功返回 v12.16.3 pwm //查看node路径 (我安装在根目录下)返回 /root/nodejs/bin 配置环境变量 cd ~ //切换到根目录 vim ~/.bash_profile //查看环境变量文件 //在配置文件里面，设置PATH环境变量 //我查看时，PATH环境变量为PATH=$PATH:$HOME/bin。在其后面添加：，在：后面添加之前执行pwm返回的路径 PATH=$PATH:$HOME/bin:/root/nodejs/bin //键盘输入i 切换为输入状态。编辑完之后 点击esc键 退出编辑状态 输入：wq 保存离开 source ~/.bash_profile //保存配置文件 可不执行 查看node版本 node -v","text":"下载nodejs cd ~ wget http://nodejs.org/dist/v12.16.3/node-v12.16.3-linux-x64.tar.gz 解压并修改解压后文件名 tar -zxvf node-v12.16.3-linux-x64.tar.gz mv node-v12.16.3-linux-x64 nodejs 切换路径到解压后文件 cd nodejs/bin // 切换路径 ./node -v //查看node是否安装成功 若成功返回 v12.16.3 pwm //查看node路径 (我安装在根目录下)返回 /root/nodejs/bin 配置环境变量 cd ~ //切换到根目录 vim ~/.bash_profile //查看环境变量文件 //在配置文件里面，设置PATH环境变量 //我查看时，PATH环境变量为PATH=$PATH:$HOME/bin。在其后面添加：，在：后面添加之前执行pwm返回的路径 PATH=$PATH:$HOME/bin:/root/nodejs/bin //键盘输入i 切换为输入状态。编辑完之后 点击esc键 退出编辑状态 输入：wq 保存离开 source ~/.bash_profile //保存配置文件 可不执行 查看node版本 node -v document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"yum常见命令-安装与卸载软件","slug":"yum常见命令-安装与卸载软件","date":"2020-09-23T04:21:21.000Z","updated":"2020-09-24T08:55:08.043Z","comments":true,"path":"2020/09/23/yum常见命令-安装与卸载软件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/23/yum%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"1.使用yum安装和卸载软件 有个前提是yum安装的软件包都是rpm格式的 安装的命令是，yum install ~，yum会查询数据库，有无这一软件包，如果有，则检查其依赖冲突关系，如果没有依赖冲突，那么最好，下载安装;如果有，则会给出提示，询问是否要同时安装依赖，或删除冲突的包，你可以自己作出判断； 删除的命令是，yum remove ~，同安装一样，yum也会查询数据库，给出解决依赖关系的提示。 其中~代表软件名 1) 用YUM安装软件包命令：yum install ~ 2) 用YUM删除软件包命令：yum remove ~ 2.用yum查询想安装的软件​ 我们常会碰到这样的情况，想安装一个软件，只知道它和某方面有关，但又不能确切知道它的名字。这时yum的查询功能就起作用了。我们可以用yum search keyword这样的命令来进行搜索，比如我们要则安装一个InstantMessenger，但又不知到底有哪些，这时不妨用yum search messenger这样的指令进行搜索，yum会搜索所有可用rpm的描述，列出所有描述中和messeger有关的rpm包，于是我们可能得到 gaim，kopete等等，并从中选择。 有时我们还会碰到安装了一个包，但又不知道其用途，我们可以用yuminfo packagename这个指令来获取信息。 使用YUM查找软件包 命令：yum search ~ 2.列出所有可安装的软件包 命令：yum list 3.列出所有可更新的软件包 命令：yum list updates 4.列出所有已安装的软件包 命令：yum list installed 5.列出所有已安装但不在Yum Repository內的软件包 命令：yum list extras 6.列出所指定软件包 命令：yum list ~ 7.使用YUM获取软件包信息 命令：yum info ~ 8.列出所有软件包的信息 命令：yum info 9.列出所有可更新的软件包信息 命令：yum info updates 10.列出所有已安裝的软件包信息 命令：yum info installed 11.列出所有已安裝但不在Yum Repository內的软件包信息 命令：yum info extras 12.列出软件包提供哪些文件 命令：yum provides ~ 3.清除yum缓存yum会把下载的软件包和header存储在cache中，而不会自动删除。如果我们觉得它们占用了磁盘空间，可以使用yum clean指令进行清除，更精确的用法是yumclean headers清除header，yum clean packages清除下载的rpm包，yum clean all 清除所有。 1.清除缓存目录(/var/cache/yum)下的软件包 命令：yum clean packages 2.清除缓存目录(/var/cache/yum)下的 headers 命令：yum clean headers 3.清除缓存目录(/var/cache/yum)下旧的 headers 命令：yum clean oldheaders 4.清除缓存目录(/var/cache/yum)下的软件包及旧的headers 命令：yum clean, yum clean all (= yum clean packages; yum clean oldheaders) 4.yum命令工具使用举例yum update 升级系统 yum install ~ 安装指定软件包 yum update ~ 升级指定软件包 yum remove ~ 卸载指定软件 yum grouplist 查看系统中已经安装的和可用的软件组，可用的可以安装 yum groupinstall ~ 安装上一个命令显示的可用的软件组中的一个 yum groupupdate ~ 更新指定软件组的软件包 yum groupremove ~ 卸载指定软件组中的软件包 yum deplist ~ 查询指定软件包的依赖关系 yum list yum\\* 列出所有以yum开头的软件包 yum localinstall ~ 从硬盘安装rpm包并使用yum解决依赖 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"Linux下更新Node到最新版本","slug":"Linux下更新Node到最新版本","date":"2020-09-22T14:21:21.000Z","updated":"2020-09-24T08:55:08.024Z","comments":true,"path":"2020/09/22/Linux下更新Node到最新版本/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/22/Linux%E4%B8%8B%E6%9B%B4%E6%96%B0Node%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC/","excerpt":"1. 查看当前node的版本号node --version 2. 清理npm的cachenpm cache clean -f 3. 版本管理工具 名称： nnpm install -g n 4. 更新到最新版n latest n 常用的命令有： n 会列出所有安装的版本供你切换 n latest 安装最新版本 n stable 安装最新稳定版 n lts 安装最新长期支持版本 n rm [版本号] 删除某一版本 n -h 帮助命令 n [版本号] 安装指定版本node 5. 验证是否成功node -v","text":"1. 查看当前node的版本号node --version 2. 清理npm的cachenpm cache clean -f 3. 版本管理工具 名称： nnpm install -g n 4. 更新到最新版n latest n 常用的命令有： n 会列出所有安装的版本供你切换 n latest 安装最新版本 n stable 安装最新稳定版 n lts 安装最新长期支持版本 n rm [版本号] 删除某一版本 n -h 帮助命令 n [版本号] 安装指定版本node 5. 验证是否成功node -v document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"Ubuntu下mongodb安装","slug":"Ubuntu下mongodb安装","date":"2020-09-22T13:21:21.000Z","updated":"2020-09-24T08:55:08.025Z","comments":true,"path":"2020/09/22/Ubuntu下mongodb安装/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/22/Ubuntu%E4%B8%8Bmongodb%E5%AE%89%E8%A3%85/","excerpt":"下载mongodb源码，并解压： wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-4.0.11.tgz tar -zxvf mongodb-linux-x86_64-ubuntu1604-4.0.11.tgz 创建mongo专属目录，拷贝bin下文件到mongodb目录下bin中： mkdir /usr/local/mongodb cd /usr/local/mongodb mkdir bin cp .../mongodb-linux-x86_64-ubuntu1604-4.0.11/bin/* ./bin/ 创建数据库文件目录、日志目录、配置文件： mkdir data touch mongodb.log touch mongodb.conf 配置文件内容： dbpath=/usr/local/mongodb/data logpath=/usr/local/mongodb/mongodb.log logappend=true journal=true fork=true bind_ip = 127.0.0.1 port = 27017 noauth = true #auth = true 将mongo添加path： #打开profile vi /etc/profile #输入下面内容： MONGO_DB=\"/usr/local/mongodb\" PATH=$MONGO_DB/bin:$PATH: export PATH #加载配置 source /etc/profile 启动mongodb： /usr/local/mongodb/bin/mongod --config /usr/local/mongodb/mongodb.conf #启动后会看到： about to fork child process, waiting until server is ready for connections. forked process: 1361 child process started successfully, parent exiting","text":"下载mongodb源码，并解压： wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-4.0.11.tgz tar -zxvf mongodb-linux-x86_64-ubuntu1604-4.0.11.tgz 创建mongo专属目录，拷贝bin下文件到mongodb目录下bin中： mkdir /usr/local/mongodb cd /usr/local/mongodb mkdir bin cp .../mongodb-linux-x86_64-ubuntu1604-4.0.11/bin/* ./bin/ 创建数据库文件目录、日志目录、配置文件： mkdir data touch mongodb.log touch mongodb.conf 配置文件内容： dbpath=/usr/local/mongodb/data logpath=/usr/local/mongodb/mongodb.log logappend=true journal=true fork=true bind_ip = 127.0.0.1 port = 27017 noauth = true #auth = true 将mongo添加path： #打开profile vi /etc/profile #输入下面内容： MONGO_DB=\"/usr/local/mongodb\" PATH=$MONGO_DB/bin:$PATH: export PATH #加载配置 source /etc/profile 启动mongodb： /usr/local/mongodb/bin/mongod --config /usr/local/mongodb/mongodb.conf #启动后会看到： about to fork child process, waiting until server is ready for connections. forked process: 1361 child process started successfully, parent exiting document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"[转]JavaScript 初学者教程（指南）","slug":"JavaScript-初学者教程（指南）","date":"2020-09-22T13:21:13.000Z","updated":"2020-09-24T08:55:08.020Z","comments":true,"path":"2020/09/22/JavaScript-初学者教程（指南）/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/22/JavaScript-%E5%88%9D%E5%AD%A6%E8%80%85%E6%95%99%E7%A8%8B%EF%BC%88%E6%8C%87%E5%8D%97%EF%BC%89/","excerpt":"JavaScript 初学者教程（指南） 原文链接：https://segmentfault.com/a/1190000016337325 作者：joyqi JavaScript 是前端开发者使用的主要编程语言，随着前端技术的发展，这门语言的边界也得以不断扩展。我们在这里选择了与 JavaScript 相关的经典文章，可以让大家对如何学习这门语言有一些全面的认识。特别的，我们还着重于 JavaScript 这门语言与其它编程语言的不同之处，方便大家深入理解。 语言特性 JavaScript 循环 JavaScript 正则表达式 JavaScript 闭包 JavaScript async/await ES6 元编程 JavaScript 垃圾内存回收机制 JavaScript 装饰器 JavaScript AST 抽象语法树 JavaScript 单线程运行机制 面向对象 JavaScript 继承 原型链 prototype JavaScript proto 与 prototype JavaScript this JavaScript 拷贝对象 函数解析 JavaScript Fetch JavaScript Object.defineProperty JavaScript cookie/localStorage/sessionStorage JavaScript Array 数组 JavaScript Array.reduce JavaScript Promise JavaScript call/apply/bind JavaScript Date JavaScript Array.sort JavaScript setInterval/setTimeout 编程技巧 Chrome 调试技巧 JavaScript 获取参数 JavaScript 代码简写 JavaScript 跨域问题 script标签放在body里还是header里 编程思想 JavaScript 模块化 JavaScript 设计模式 JavaScript 全栈开发 其它 Ajax 基础知识 JavaScript 同步 异步 事件循环 JavaScript WebSocket JavaScript console对象 JavaScript 剪贴板","text":"JavaScript 初学者教程（指南） 原文链接：https://segmentfault.com/a/1190000016337325 作者：joyqi JavaScript 是前端开发者使用的主要编程语言，随着前端技术的发展，这门语言的边界也得以不断扩展。我们在这里选择了与 JavaScript 相关的经典文章，可以让大家对如何学习这门语言有一些全面的认识。特别的，我们还着重于 JavaScript 这门语言与其它编程语言的不同之处，方便大家深入理解。 语言特性 JavaScript 循环 JavaScript 正则表达式 JavaScript 闭包 JavaScript async/await ES6 元编程 JavaScript 垃圾内存回收机制 JavaScript 装饰器 JavaScript AST 抽象语法树 JavaScript 单线程运行机制 面向对象 JavaScript 继承 原型链 prototype JavaScript proto 与 prototype JavaScript this JavaScript 拷贝对象 函数解析 JavaScript Fetch JavaScript Object.defineProperty JavaScript cookie/localStorage/sessionStorage JavaScript Array 数组 JavaScript Array.reduce JavaScript Promise JavaScript call/apply/bind JavaScript Date JavaScript Array.sort JavaScript setInterval/setTimeout 编程技巧 Chrome 调试技巧 JavaScript 获取参数 JavaScript 代码简写 JavaScript 跨域问题 script标签放在body里还是header里 编程思想 JavaScript 模块化 JavaScript 设计模式 JavaScript 全栈开发 其它 Ajax 基础知识 JavaScript 同步 异步 事件循环 JavaScript WebSocket JavaScript console对象 JavaScript 剪贴板 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"}]},{"title":"[转]Yapi环境搭建(史上最详细步骤)","slug":"[转]Yapi环境搭建(史上最详细步骤)","date":"2020-09-22T09:21:21.000Z","updated":"2020-09-24T08:55:08.035Z","comments":true,"path":"2020/09/22/[转]Yapi环境搭建(史上最详细步骤)/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/22/[%E8%BD%AC]Yapi%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(%E5%8F%B2%E4%B8%8A%E6%9C%80%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4)/","excerpt":"参考文章：内网搭建yapi接口管理平台 环境准备 操作系统：centos 7 环境要求： nodejs 7.6+ mongodb 2.6+ git","text":"参考文章：内网搭建yapi接口管理平台 环境准备 操作系统：centos 7 环境要求： nodejs 7.6+ mongodb 2.6+ git 安装nodejs 获取资源（部署nodejs尽可能选择偶数版本，因为偶数版本官方有较长的维护时间，故这次选择8.x。） curl -sL https://rpm.nodesource.com/setup_8.x | bash - 安装 yum install -y nodejs 查看版本 node -v 查看npm版本 npm -v 安装mongodb 更新yum源，非必须但是更新一下无害 yum -y update 添加mongodb源文件，在/etc/yum.repos.d 创建一个 mongodb-org.repo 文件 touch /etc/yum.repos.d/mongodb-org.repo 编辑mongodb-org.repo文件 vim /etc/yum.repos.d/mongodb-org.repo 添加文件内容 [mongodb-org] name=MongoDB Repository baseurl=http://mirrors.aliyun.com/mongodb/yum/redhat/7Server/mongodb-org/3.2/x86_64/ gpgcheck=0 enabled=1 这里可能退不出Vim，参考https://www.cnblogs.com/melodyjerry/p/13714705.html 安装mongodb yum install -y mongodb-org 启动mongodb service mongod start 设置开机启动 chkconfig mongod on 打开moMongoDB(可忽略) /bin/mongo 配置远程访问 修改mongod.conf配置文件 vim /etc/mongod.conf 注释 bindIp: 127.0.0.1 #bindIp: 127.0.0.1 重启mongod service mongod restart 安装git 官方推荐，在内网部署的时候安装git，可以根据自己所需安装 yum -y install git 搭建YApi环境搭建YApi 准备环境搭建完成后，开始搭建YApi,安装命令 npm install -g yapi-cli --registry https://registry.npm.taobao.org yapi server $ yapi server /usr/lib/node_modules/yapi-cli/src/utils.js:68 getVersions: async function(){ ^^^^^^^^ SyntaxError: Unexpected token function at createScript (vm.js:56:10) at Object.runInThisContext (vm.js:97:10) at Module._compile (module.js:549:28) at Object.Module._extensions..js (module.js:586:10) at Module.load (module.js:494:32) at tryModuleLoad (module.js:453:12) at Function.Module._load (module.js:445:3) at Module.require (module.js:504:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/lib/node_modules/yapi-cli/src/index.js:4:15) 解决办法：将node升级到版本&gt;7.6 https://www.cnblogs.com/melodyjerry/p/13715111.html 实例截图： yapi server后提示： Accessing non-existent property 'cat' of module exports inside circular dependency 产生这个的原因是node的版本太高了解决的办法很简单，卸载最新版的node v14，重新安装稳定版的node v12，这个问题就解决了 有使用宝塔的话，还需要到宝塔防火墙里放行9090端口。 部署YApi 执行 yapi server 启动可视化部署程序，浏览器打开提示窗口上的地址，非本地服务器，将0.0.0.0替换指定的域名或IP，进入部署页面。 实例截图 根据项目实际需要可以修改部署信息，点击【开始部署】，完成部署任务 部署成功截图 MongoDB数据库连接失败，检查是不是配置文件的ip、port出错。或者，直接shutdown -r now重启一下服务器，反正我就是hh。 3.根据部署日志截图上的提示信息，启动服务启动服务：node vendors/server/app.js浏览器打开部署日志上的访问地址 http://127.0.0.1:3000 就可以访问搭建的YApi工具了（非本地服务器，将127.0.0.1替换指定的域名或IP），此时YApi本地环境搭建完成 如果是阿里云ecs服务器，端口需要在安全组里开放，不然访问不了 4.pm2方式管理进程 要保证后台保持进程，需要安装pm2。全局安装： npm install -g pm2` 启动： pm2 start /root/my-yapi/vendors/server/app.js --watch -i 1 这样以后就可以很方便的用pm2就行启动关闭啦~ 通过pm2 save保存当前进程状态。 查看： pm2 list 重启： pm2 restart service/app.js 停止： 可以先通过pm2 list获取应用的名字（–name指定的）或者进程id。 # pm2 stop app_name|app_id pm2 stop /root/my-yapi/vendors/server/app.js pm2使用参考文档：http://imweb.io/topic/57c8cbb27f226f687b365636 6.升级 升级项目版本是非常容易的，并且不会影响已有的项目数据，只会同步 vendors 目录下的源码文件。 cd {项目目录} yapi ls //查看版本号列表 yapi update //更新到最新版本 yapi update -v {Version} //更新到指定版本 9.nginx代理 如果您是将服务器代理到 nginx 服务器，请配置 nginx 支持 websocket。 在location /添加 proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; 10.禁止注册 在 config.json 添加 closeRegister:true 配置项,就可以禁止用户注册 yapi 平台，修改完成后，请重启 yapi 服务器。 { \"port\": \"*****\", \"closeRegister\":true } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"},{"name":"API","slug":"API","permalink":"https://melodyjerry.github.io/blog/tags/API/"}]},{"title":"Vim-类似于Vi的文本编辑器","slug":"Vim-类似于Vi的文本编辑器","date":"2020-09-21T13:54:00.000Z","updated":"2020-09-24T08:55:08.026Z","comments":true,"path":"2020/09/21/Vim-类似于Vi的文本编辑器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/21/Vim-%E7%B1%BB%E4%BC%BC%E4%BA%8EVi%E7%9A%84%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/","excerpt":"简介Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和Emacs并列成为类Unix系统用户最喜欢的编辑器。 键盘图 来源见水印","text":"简介Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和Emacs并列成为类Unix系统用户最喜欢的编辑器。 键盘图 来源见水印 主要功能 根据设定可以和原始vi完全兼容 多缓冲编辑 任意个数的分割窗口（横，竖） 具备列表和字典功能的脚本语言 可以在脚本中调用 Perl, Ruby, Python, Tcl, MzScheme 单词缩写功能 动态单词补完 多次撤销和重做 对应400种以上文本文件的语法高亮 C/C++, Perl, Java, Ruby, Python 等40种以上语言的自动缩排 利用ctags的标签中跳转 崩溃后文件恢复 光标位置和打开的缓冲状态的保存 复原（session功能） 可以对两个文件进行差分，同步功能的diff模式 远程文件编辑 Omni补完（上下文相关的补完） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"Linux下删除普通用户步骤","slug":"Linux下删除普通用户步骤","date":"2020-09-21T13:47:00.000Z","updated":"2020-09-24T08:55:08.021Z","comments":true,"path":"2020/09/21/Linux下删除普通用户步骤/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/21/Linux%E4%B8%8B%E5%88%A0%E9%99%A4%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%AD%A5%E9%AA%A4/","excerpt":"先用命令 cat /etc/passwd 查看一下所有的用户 可以看到片你需要删除的用户名 用命令 who 查询当前登录的用户 用命令 ps -u 用户名 查看该用户的pid 用命令 kill pid 杀掉他的sshd或者是shell进程 再用命令 userdel -r 用户名 删除用户","text":"先用命令 cat /etc/passwd 查看一下所有的用户 可以看到片你需要删除的用户名 用命令 who 查询当前登录的用户 用命令 ps -u 用户名 查看该用户的pid 用命令 kill pid 杀掉他的sshd或者是shell进程 再用命令 userdel -r 用户名 删除用户 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"Xshell-配色方案","slug":"Xshell-配色方案","date":"2020-09-21T13:21:21.000Z","updated":"2020-09-24T08:55:08.028Z","comments":true,"path":"2020/09/21/Xshell-配色方案/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/21/Xshell-%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/","excerpt":"设置命令行提示符在命令行提示符显示用户名，当前机器IP，当前时间，当前路径等信息。但有时候如果我们的目录很长，敲击命令很不方便，可以通过修改 PS1 环境变量，让命令提示符在第二行显示： 如下示例，后面的 \\n 就是起到了提示符 $ 在第二行显示效果。 export PS1=\"\\[\\033[01;31m\\]\\u\\[\\033[00m\\]@\\[\\033[01;32m\\]\\h\\[\\033[00m\\][\\[\\033[01;33m\\]\\t\\[\\033[00m\\]]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\n$ \" 效果如下： ​ 注： 设置为什么颜色，可以自己根据显示效果调，很灵活。","text":"设置命令行提示符在命令行提示符显示用户名，当前机器IP，当前时间，当前路径等信息。但有时候如果我们的目录很长，敲击命令很不方便，可以通过修改 PS1 环境变量，让命令提示符在第二行显示： 如下示例，后面的 \\n 就是起到了提示符 $ 在第二行显示效果。 export PS1=\"\\[\\033[01;31m\\]\\u\\[\\033[00m\\]@\\[\\033[01;32m\\]\\h\\[\\033[00m\\][\\[\\033[01;33m\\]\\t\\[\\033[00m\\]]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\n$ \" 效果如下： ​ 注： 设置为什么颜色，可以自己根据显示效果调，很灵活。 建议如果要写入shell配置文件，建议写到环境变量文件~/.bash_profile，而不要写入~/.bashrc，否则借助ssh类的工具都将因为trap DEBUG信号的特殊性而无限等待，比如scp/rsync等。 或者，直接判断是否是交互式登录，是的话就设置，否则不设置： if [ \"${-#*i}\" != \"$-\" ];then # interactively shell PS1=\"\\[\\033[01;31m\\]\\u\\[\\033[00m\\]@\\[\\033[01;32m\\]\\h\\[\\033[00m\\][\\[\\033[01;33m\\]\\t\\[\\033[00m\\]]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\n$ \" trap 'echo -ne \"\\e[0m\"' DEBUG fi # 写入 vim ~/.bash_profile # 立即生效 source ~/.bash_profile 参数说明 在终端上的显示的命令提示符：[root@root ~]# 配置文件中的设置：PS1=\"[\\u@\\h \\W]\\$\" 设置提示符格式：PS1 PS1的定义中个常用的参数的含义如下： \\d ：#代表日期，格式为weekday month date，例如：”Mon Aug 1” \\H ：#完整的主机名称 \\h ：#仅取主机的第一个名字 \\T ：#显示时间为24小时格式，如：HH：MM：SS \\t ：#显示时间为12小时格式 , 如：HH：MM：SS \\A ：#显示时间为12小时格式：HH：MM \\u ：#当前用户的账号名称 \\v ：#BASH的版本信息 \\w ：#完整的工作目录名称 \\W ：#利用basename取得工作目录名称，所以只会列出最后一个目录 `#` ：#下达的第几个命令 $ ：#提示字符，如果是root时，提示符为：# ，普通用户则为：$ 设置颜色 在PS1中设置字符颜色的格式为：[\\e[F;Bm]，其中F为字体颜色，编号为30-37，B为背景颜色，编号为40-47。 颜色表如下： [\\e[F;Bm]需要改变颜色的部分[\\e[0m] 开始颜色输入：[\\e[F;Bm] 结束颜色输入：[\\e[0m] F B 值分别对应的颜色30 40 黑色 31 41 红色 32 42 绿色 33 43 黄色 34 44 蓝色 35 45 紫红色 36 46 青蓝色 37 47 白色 设置特殊显示0 OFF，关闭颜色 1 高亮显示 4 显示下划线 5 闪烁显示 7 反白显示 8 颜色不可见 特殊显示可在结束颜色输入里面设置：[\\e[ 特殊颜色编号 m] 其他配色配置点击 Xshell 面板顶部的如下按钮。 ​ 点击 Browse 按钮，弹出如下面板，选择 ANSI Colors on Black，然后点击右侧save as 按钮，命名为 zkl。 这里其实就是复制一份 ANSI Colors on Black 的颜色方案，或者我们也可以 New 一个方案。 ANSI 颜色已经很好看，这里我们是沿用 ANSI 颜色，并加以修改，以得到自己想要的颜色方案。 ​ 然后，点击右侧的 edit 按钮，编辑前景色和背景色。 1. 设置背景色 点击 Backgroud 右侧的下拉列表， 在弹出的界面选择 other, 弹出一个界面，点击自定义颜色，然后会弹出如下界面： 按照如下 rgb 值填写颜色，（0，43, 53） 然后点击 Add to Custom Colors 按钮，添加自定义颜色到左侧面板中的 custom colors下，选择它。确定。 ​ 2. 设置字体颜色（前景色） 点击 Normal Text，进行设置。 rgb颜色：（131,148,150） ​ 3. 设置目录颜色 ​ 颜色 rgb 值如下：（128，128, 255） ​ 4. 设置压缩文件颜色 ANSI 颜色中，压缩文件颜色默认是红色，不干扰视线，如果感觉不好，可以调整为如下颜色： ​ 颜色 rgb 值如下：（128，128, 0） ​ 5. 设置VIM中注释的颜色 经过以上设置后，xshell的背景颜色，字体颜色，linux的目录，压缩文件颜色都比较好看了，效果如下。 ​ 但是我们打开 vim，编辑一个 c++, python 代码文件时会发现注释的颜色很不好看。需要再进行设置。 ​ 设置如下颜色即可： rgb颜色：（255,128,64） ​ 修改后的代码文件显示效果如下： ​ 6. 导出颜色方案 xshell 非常强大，各种功能。我们设置的颜色方案也可以导出保存，当我们在其他机器上使用时，可以导入颜色方案。 下面界面中的 import 和 export 即可完成导入和导出颜色方案，下面这个文件是上述配置对应的颜色方案文件： ​ ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"使用Hexo+GitHub建站","slug":"Hexo+GitHub","date":"2020-09-19T11:24:01.000Z","updated":"2020-09-24T08:55:08.019Z","comments":true,"path":"2020/09/19/Hexo+GitHub/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/19/Hexo+GitHub/","excerpt":"前言： 使用CSDN或简书撰写博客似乎是一件美事，只不过个人觉得太过于依赖他人平台，不如就自己搭建一个属于自己的博客。 最终，个人选择了Hexo+GitHub（Pages）的方式。 GitHub Pages 是开源协作社区 GitHub 的一个服务，将博客部署到它上面再合适不过了。 Q W 为什么要部署到 GitHub Pages 上？ 首先免费，其次省心，最后可以学习使用 GitHub。 GitHub Pages 有容量限制吗？ 有，由 What is GitHub Pages? 可知：大小限制为 1GB，一个月 100GB 流量。 超出限制的容量怎么办？ 讲真，如果图片音乐视频等大文件都放在七牛云 KODO、阿里云 OSS 或其它云存储上。图片我更多是存放在图床上，比如路过图床或SM.MS。 国内访问速度行不行，有必要同时部署在 Coding 上吗？ 个人感觉可有可无吧，自己不用梯子时，感觉访问速度可以，毕竟站点的大文件都是放在了云存储上，图片都是国内图床，加载较快。 我可以用自己的域名吗？ 可以，并且原生支持 https。","text":"前言： 使用CSDN或简书撰写博客似乎是一件美事，只不过个人觉得太过于依赖他人平台，不如就自己搭建一个属于自己的博客。 最终，个人选择了Hexo+GitHub（Pages）的方式。 GitHub Pages 是开源协作社区 GitHub 的一个服务，将博客部署到它上面再合适不过了。 Q W 为什么要部署到 GitHub Pages 上？ 首先免费，其次省心，最后可以学习使用 GitHub。 GitHub Pages 有容量限制吗？ 有，由 What is GitHub Pages? 可知：大小限制为 1GB，一个月 100GB 流量。 超出限制的容量怎么办？ 讲真，如果图片音乐视频等大文件都放在七牛云 KODO、阿里云 OSS 或其它云存储上。图片我更多是存放在图床上，比如路过图床或SM.MS。 国内访问速度行不行，有必要同时部署在 Coding 上吗？ 个人感觉可有可无吧，自己不用梯子时，感觉访问速度可以，毕竟站点的大文件都是放在了云存储上，图片都是国内图床，加载较快。 我可以用自己的域名吗？ 可以，并且原生支持 https。 安装篇 一、安装 Hexo前的准备1、安装Hexo前的必要工作安装以下两个程序： 程序 | 下载地址 | 说明|–|–|–|–Git|Git - Downloads| 网速的同学，可以自行百度移步到国内镜像 |Node.js|Node.js - Downloads| 有LTS和Current两个版本，安装 LTS 版即可。 |由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。 注意：关于Git和Node.js的安装可能会有问题，尤其是Git的安装。这里贴上几张安装界面的截图。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 2、新建GitHub仓库 按照下图来新建一个Repo： 最好勾选``Initialize this repository with a README`，图中忘记勾选了。 访问GitHub Pages 在建好的仓库右侧有个settings按钮，点击它 向下拉到GitHub Pages，提示的链接便是博客的首页了，可以点击浏览。（后期可以在这里绑定域名） 二、正式安装Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。——官方 准备工作完成后，来安装hexo框架吧！ 主要根据hexo官方的文档来安装Hexo。 在本地电脑上新建一个文件夹，用来存放整个Hexo博客项目。这里默认路径是D:\\blog。 使用 npm 安装 Hexo： $ npm install -g hexo-cli 这样，Hexo就安装完成了。 可使用输入hexo -v，检查Hexo是否安装成功 三、初始化Hexohexo init，就会自动构建一个 hexo 项目，看到后面的Start blogging with Hexo！就说明初始化好了。 # 初始化Hexo $ hexo init 四、安装npm必需组件$ npm install 五、生成并预览执行 hexo s，浏览器访问 localhost:4000 就可以看到效果啦！ # 本地预览 $ hexo s 初始化的默认博客页面： 配置篇一、配置git1、 全局变量name、email 可以在未来部署，并非一定现在 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 $ git config --global user.name \"your name\"` $ git config --global user.email \"your Email\"2、生成私钥和公钥$ ssh-keygen -t rsa 3、绑定SSH公钥登录Github，点击头像下的settings 左侧点击SSH and GPG keys，添加ssh，新建一个New SSH key，将id_rsa.pub文件里的内容复制上去 Title可以直接不填，Key粘贴id_rsa.pub文件里的内容 4、修改_config.yml中的Deployment配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾），repo值是github项目里的ssh 二、安装hexo-deployer-git插件 HexoBlog部署到git我们需要安装hexo-deployer-git插件，在blog目录下运行一下命令进行安装 $ npm install hexo-deployer-git --save 三、写作# 创建文章，默认layout布局为：post $ hexo new [layout] &lt;title&gt; # 例如 $ hexo new post HelloHexo 关于这块，最好看官方文档：https://hexo.io/zh-cn/docs/writing 之后会在source文件夹的_post文件夹中看到你新建的文件HelloHexo.md 四、生成并部署博客$ hexo d -g 生成以及部署了，在打开你的博客主页（melodyjerry.github.io）就可以看到你创建的文章了。 高阶篇一、主题1、选取喜欢的主题在Hexo官方，有许多现成的主题了。当然，你想自己原创设计或二次开发也可以的:angel: 大量主题：https://hexo.io/zh-cn/docs/themes.html 找到合适的就按要求下载即可。 以主题fluid为例，fluid的配置文档在这里。 # 下载到themes文件夹下 $ git clone https://github.com/fluid-dev/hexo-theme-fluid fluid 2、 配置主题找到_config.yml文件，修改theme值： theme: fluid 3、重新生成并预览$ hexo clean $ hexo g $ hexo s 部署优化每次都要执行 hexo clean 、hexo generate、 hexo deploy，不如写个新的脚本： // package.json \"dev\": \"hexo s\", \"build\": \"hexo clean &amp; hexo deploy\" 部署命令： $ npm run build 注意事项站点文件和主题文件的区别 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"}]},{"title":"Hexo博客加入聊天系统DaoVoice","slug":"加入聊天系统daovioce","date":"2020-09-18T12:23:11.000Z","updated":"2020-09-19T04:24:28.825Z","comments":true,"path":"2020/09/18/加入聊天系统daovioce/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/18/%E5%8A%A0%E5%85%A5%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9Fdaovioce/","excerpt":"关于 DaoVoiceDaoVoice 是一款革命性的应用运营平台，致力于帮助企业实现以用户为中心的「精益运营」体系。 融合「在线聊天」、「客服支持」、「用户画像」、「消息推送」、「行为引导」等功能为一体， 按需获取用户信息和行为，实现场景化消息推送，让通知更富有人情味。 接入只需 5 行代码，即可创建与用户实时沟通的窗口，无缝接入企业原有产品体系，拉近企业与用户的距离。 秉承「数据驱动，精益运营」的理念，让用户定义产品，让参与感驱动产品迭代。 用 DaoVoice 驱动用户运营，帮你最终实现用户转化。 “DaoVoice 帮我们更好地运营用户。实时在线沟通，可更快解决用户问题。后台管理可帮我们建立用户画像，针对不同的用户需求进行精准运营。此外，DaoVoice 团队会快速响应我们的反馈，给予高质量服务支持。” ——Travis创始人 &amp; CEO","text":"关于 DaoVoiceDaoVoice 是一款革命性的应用运营平台，致力于帮助企业实现以用户为中心的「精益运营」体系。 融合「在线聊天」、「客服支持」、「用户画像」、「消息推送」、「行为引导」等功能为一体， 按需获取用户信息和行为，实现场景化消息推送，让通知更富有人情味。 接入只需 5 行代码，即可创建与用户实时沟通的窗口，无缝接入企业原有产品体系，拉近企业与用户的距离。 秉承「数据驱动，精益运营」的理念，让用户定义产品，让参与感驱动产品迭代。 用 DaoVoice 驱动用户运营，帮你最终实现用户转化。 “DaoVoice 帮我们更好地运营用户。实时在线沟通，可更快解决用户问题。后台管理可帮我们建立用户画像，针对不同的用户需求进行精准运营。此外，DaoVoice 团队会快速响应我们的反馈，给予高质量服务支持。” ——Travis创始人 &amp; CEO 配置layout\\_third-party\\daovoice.ejs： &lt;% if(theme.daovoice.enable &amp;&amp; theme.daovoice.appid){ %&gt; &lt;script&gt;(function (i, s, o, g, r, a, m) { i['DaoVoiceObject'] = r; i[r] = i[r] || function () { (i[r].q = i[r].q || []).push(arguments); }; i[r].l = 1 * new Date(); a = s.createElement(o); m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; a.charset = 'utf-8'; m.parentNode.insertBefore(a, m); })(window, document, 'script', ('https:' === document.location.protocol ? 'https:' : 'http:') + \"//widget.daovoice.io/widget/&lt;%= theme.daovoice.appid %&gt;.js\", 'daovoice'); daovoice('init', { app_id: \"&lt;%= theme.daovoice.appid %&gt;\", }); daovoice('update'); &lt;/script&gt; &lt;% } %&gt; layout\\index.ejs： &lt;!--DaoVoice服务http://blog.daovoice.io/--&gt; &lt;%- partial('_third-party/daovoice') %&gt; _config.yml： daovoice: # 在线客服 Daovoice 参考：http://dashboard.daovoice.io enable: true # 是否开启在线客服聊天 appid: 'exxxxxxx' # 应用ID设置 效果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"AspectJ的切入点表达式---execution表达式","slug":"AspectJ的切入点表达式---execution表达式","date":"2020-09-18T09:24:41.000Z","updated":"2020-09-24T08:55:08.014Z","comments":true,"path":"2020/09/18/AspectJ的切入点表达式---execution表达式/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/18/AspectJ%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F---execution%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"execution(&lt;修饰符模式&gt;?&lt;返回类型模式&gt;&lt;方法名模式&gt;(&lt;参数模式&gt;)&lt;异常模式&gt;?)","text":"execution(&lt;修饰符模式&gt;?&lt;返回类型模式&gt;&lt;方法名模式&gt;(&lt;参数模式&gt;)&lt;异常模式&gt;?) 除了返回类型模式、方法名模式和参数模式外，其它项都是可选的。 一、通过方法签名定义切点 execution(public * *(..)) 匹配所有目标类的public方法，但不匹配SmartSeller和protected voidshowGoods()方法。第一个代表返回类型，第二个代表方法名，而..代表任意入参的方法； execution(* *To(..)) 匹配目标类所有以To为后缀的方法。它匹配NaiveWaiter和NaughtyWaiter的greetTo()和serveTo()方法。第一个代表返回类型，而To代表任意以To为后缀的方法； 二、通过类定义切点 execution(com.baobaotao.Waiter.(..)) 匹配Waiter接口的所有方法，它匹配NaiveWaiter和NaughtyWaiter类的greetTo()和serveTo()方法。第一个代表返回任意类型，com.baobaotao.Waiter.代表Waiter接口中的所有方法； execution(com.baobaotao.Waiter+.(..)) 匹配Waiter接口及其所有实现类的方法，它不但匹配NaiveWaiter和NaughtyWaiter类的greetTo()和serveTo()这两个Waiter接口定义的方法，同时还匹配NaiveWaiter#smile()和NaughtyWaiter#joke()这两个不在Waiter接口中定义的方法。 三、通过类包定义切点 在类名模式串中，”.*”表示包下的所有类，而”..*”表示包、子孙包下的所有类。 execution(* com.baobaotao.*(..))l 匹配com.baobaotao包下所有类的所有方法； execution(* com.baobaotao..*(..))l 匹配com.baobaotao包、子孙包下所有类的所有方法，如com.baobaotao.dao，com.baobaotao.servier以及com.baobaotao.dao.user包下的所有类的所有方法都匹配。”..”出现在类名中时，后面必须跟”*”，表示包、子孙包下的所有类； execution(* com...Dao.find*(..)) 匹配包名前缀为com的任何包下类名后缀为Dao的方法，方法名必须以find为前缀。如com.baobaotao.UserDao#findByUserId()、com.baobaotao.dao.ForumDao#findById()的方法都匹配切点。 四、通过方法入参定义切点 切点表达式中方法入参部分比较复杂，可以使用”*”和”..”通配符，其中”*”表示任意类型的参数，而”..”表示任意类型参数且参数个数不限。 execution(* joke(String,int))) 匹配joke(String,int)方法，且joke()方法的第一个入参是String，第二个入参是int。它匹配NaughtyWaiter#joke(String,int)方法。如果方法中的入参类型是Java.lang包下的类，可以直接使用类名，否则必须使用全限定类名，如joke(java.util.List,int)； execution(* joke(String,*))) 匹配目标类中的joke()方法，该方法第一个入参为String，第二个入参可以是任意类型，如joke(Strings1,String s2)和joke(String s1,double d2)都匹配，但joke(String s1,doubled2,String s3)则不匹配； execution(* joke(String,..))) 匹配目标类中的joke()方法，该方法第 一个入参为String，后面可以有任意个入参且入参类型不限，如joke(Strings1)、joke(String s1,String s2)和joke(String s1,double d2,Strings3)都匹配。 execution(* joke(Object+))) 匹配目标类中的joke()方法，方法拥有一个入参，且入参是Object类型或该类的子类。它匹配joke(Strings1)和joke(Client c)。如果我们定义的切点是execution(*joke(Object))，则只匹配joke(Object object)而不匹配joke(Stringcc)或joke(Client c)。 五、args()和@args() args()函数的入参是类名，@args()函数的入参必须是注解类的类名。虽然args()允许在类名后使用+通配符后缀，但该通配符在此处没有意义：添加和不添加效果都一样。 1、args() 该函数接受一个类名，表示目标类方法入参对象按类型匹配于指定类时，切点匹配，如下面的例子： args(com.baobaotao.Waiter) 表示运行时入参是Waiter类型的方法，它和execution(**(com.baobaotao.Waiter))区别在于后者是针对类方法的签名而言的，而前者则针对运行时的入参类型而言。如args(com.baobaotao.Waiter)既匹配于addWaiter(Waiterwaiter)，也匹配于addNaiveWaiter(NaiveWaiter naiveWaiter)，而execution(**(com.baobaotao.Waiter))只匹配addWaiter(Waiterwaiter)方法；实际上，args(com.baobaotao.Waiter)等价于execution(**(com.baobaotao.Waiter+))，当然也等价于args(com.baobaotao.Waiter+)。 2、@args() 该函数接受一个注解类的类名，当方法的运行时入参对象标注发指定的注解时，方法匹配切点。 注意事项：通过类包定义切点 在类名模式串中，“.*”表示包下的所有类，而“..*”表示包、子孙包下的所有类。 execution(* com.baobaotao.*(..)) 匹配com.baobaotao包下所有类的所有方法； execution(* com.baobaotao..*(..)) 匹 配com.baobaotao包、子孙包下所有类的所有方法，如com.baobaotao.dao，com.baobaotao.servier以及 com.baobaotao.dao.user包下的所有类的所有方法都匹配。“..”出现在类名中时，后面必须跟“*”，表示包、子孙包下的所有类 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"[转]Java面向对象的七大原则","slug":"[转]Java面向对象的七大原则","date":"2020-09-18T01:10:00.742Z","updated":"2020-09-24T08:55:08.031Z","comments":true,"path":"2020/09/18/[转]Java面向对象的七大原则/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/18/[%E8%BD%AC]Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/","excerpt":"","text":"前言其实没有设计模式我们也能完成开发工作。但是为什么需要设计模式呢？让你看起来很牛，没错这个算一个。让你的代码层次感分明，可读性强而且容易维护。让你像我一样有更多的摸鱼划水时间。可能有人说我一个类或者方法就干完的东西，你搞了七八个。当然使用设计模式也是要斟酌的。一些简单稳定的业务也不推荐使用设计模式。设计模式多用于复杂多变的业务或者要求适配性、扩展性更强的场景中。不要为了设计模式而设计模式。 接下来我们结合实际开探讨一下设计模式的一些原则。 1、开闭原则public class Seller { public BigDecimal sellCar(Car car) { return car.getPrice(); } } 上面模拟4S店一个销售在卖车。突然老板搞了一个促销：在双十一要开展打折活动。在sellCar方法内增加一个计算可行吗？这势必影响整个业务，导致所有车都打折。不行不行！那么在Car里面操作？然后你改啊改！结果各种逻辑流程判断。才实现了业务要求。如果后续打折活动结束了或者升级了，你还要再进行各种改动。你发现一个打折让你的代码面目全非、臃肿不堪。上面说了对于复杂而多变的业务使用设计模式就可以解决。那么设计模式最重要的一个原则就是开闭原则。也就是说一个软件模型实体如类、模块和函数应该对扩展开放，对修改关闭。也就是需要我们将业务行为抽象出来，使用抽象来构建。具体的业务通过抽象的实现来解决。那么我们就搞一个DiscountCar来extends Car.这样sellCar是什么具体的实现就执行什么具体的逻辑。不会影响以前的逻辑，而且不会因为改动原来的代码影响其他逻辑。保证接口可靠性和稳定性。如下： public class DiscountCar extends Car{ private BigDecimal price; private BigDecimal discount; @Override public BigDecimal getPrice() { return price.multiply(discount); } } 2、依赖倒置原则还拿上面的例子来说。经过一系列的打折活动4S店的生意蒸蒸日上。老板突然想扩展一下周边，同时压榨一下销售。让他们卖车的同时卖点玻璃水、防冻液之类的。这个需求当然又抛给了苦逼的程序员。sellCar太具体了不能满足需要了。很多情况下你会增加一个卖玻璃水、卖防冻液的方法。如果以后增加了卖大米，甚至买起了鸡蛋饼呢？总不能一直增加方法吧。我们需要考虑这种问题。我们可以抽象所有卖东西的场景。然后我们把卖的物品抽象成了一个抽象化的概念（java对应的是接口,把卖的行为抽象成了sell方法： public interface Any { String getName(); BigDecimal getPrice(); } public class Seller { public BigDecimal sell(Any any) { return any.getPrice(); } } 这样随便老板以后卖什么你都可以通过该方法进行处理了，只需要关注于Any的实现。 3、职责单一原则4S店销售卖了一段东西后，发现对客户的吸引力度不大。突然脑子比较灵活的老板又想起了电影中的一句台词：少林功夫加唱歌跳舞有没有搞头？对啊你们销售能不能搞搞什么唱、跳、Rap，当然打篮球就不要了别砸坏了车玻璃。但是人与人是不一样的，有的人只会唱，有的人只会跳，有的人可能唱跳Rap都会甚至篮球都很溜。所以为了适配这么多情况，我们必须把每种技能独立出来，根据不同的人来组合这些技能。 public class Seller implements Sing, Jump, Rap { public BigDecimal sell(Any any) { return any.doSell(); } @Override public void sing() { System.out.println(\"seller sing \"); } @Override public void jump() { System.out.println(\"seller jumping \"); } @Override public void rap() { System.out.println(\"seller raping \"); } } 但是注意一定要适度，根据业务来细分。否则会导致接口过多反而增大开发难度以及代码的复杂度。 4、迪米特法则新的销售方法搞了一段时间后，老板想看看检验一下他这个馊主意的效果。于是就叫了一个销售让他提供一份报表出来看看。那么程序员该如何实现老板查看报表功能呢，很可能有人会这么写： public class Boss { private Seller seller; private Report report; public void read() { seller.apply(report); } } 乍看功能实现了，细看会发现逻辑不对。哪里不对呢？老板已经持有了报表，如果老板已经知道了你的业绩还叫你干什么？这种逻辑肯定是不对的！也就是说Boss直接依赖了Report；而这个Report不应该直接由Boss处理，而应由Seller控制。 public class Boss { private Seller seller; public void read(){ seller.apply(); } } public class Seller { private Report report; public void apply(){ report.show(); ｝ } 这种最大化隔离了类与类之间的关系。降低了类之间的耦合。迪米特法则因此又得名最少知道原则。 5、接口隔离原则用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。一个类对一个类的依赖应该建立在最小的接口上。建立单一接口，不要建立庞大臃肿的接口尽量细化接口，接口中的方法尽量少，尽量细化接口。注意适度原则，一定要适度。不能滥用就像上面的唱跳 rap，分离是最好的。 6、里氏代换原则这里主要针对类的继承关系而言。比较正式的定义：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2 时，程序P的行为没有发生变化，那么类型 S 是类型 T 的子类型。在4S店老板眼里，只要新来的能在销售岗位上像销售老手一样卖出汽车，他就是一名合格的销售。感觉这种定义就像一句名言：不管你黑猫白猫，能抓老鼠的都是好猫。从某种含义上里氏代换有着以下的契约： 子类必须完全实现父类的方法。父类出现的地方子类都可以代替父类。 子类可以有自己的个性定义。里氏替换原则 可以正着用，但是不能反过来用。在子类出现的地方，父类未必就可以胜任。子类一般比父类有个性。 覆盖或实现父类的方法时输入参数可以被放大。如果4S店老板规定基础车谈价的折扣最多九折，销售打个九五折没有问题，打八折老板肯定要跟你说道说道了。 覆写或实现父类的方法时输出结果可以被缩小。同样是15W本来只能卖出给客户一个乞丐版，结果换了个销售结果给出了一辆旗舰版。怕不是过不了试用期哦。 7、合成/复用原则它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。欢迎大家关注我的公种浩【程序员追风】，文章都会在里面更新，整理的资料也会放在里面。 总结这七种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。在实际开发中我们可以根据业务来进行设计模式的使用，但是很重要的一点千万不要被这些条条框框束缚了你的手脚。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"关于Java的反射机制，4篇优选参考文章","slug":"关于Java的反射机制，4篇优选参考文章","date":"2020-09-18T01:10:00.738Z","updated":"2020-09-18T04:43:03.052Z","comments":true,"path":"2020/09/18/关于Java的反射机制，4篇优选参考文章/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/18/%E5%85%B3%E4%BA%8EJava%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%8C4%E7%AF%87%E4%BC%98%E9%80%89%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0/","excerpt":"Java高级特性——反射 Java基础之—反射（非常重要） Java高级篇（四）——反射 学习java应该如何理解反射？","text":"Java高级特性——反射 Java基础之—反射（非常重要） Java高级篇（四）——反射 学习java应该如何理解反射？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"[转]Java+Spring+MyBatis实现多数据源的动态切换","slug":"Java+Spring+MyBatis实现多数据源的动态切换","date":"2020-09-08T06:22:22.000Z","updated":"2020-09-18T04:43:02.959Z","comments":true,"path":"2020/09/08/Java+Spring+MyBatis实现多数据源的动态切换/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/08/Java+Spring+MyBatis%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/","excerpt":"原文链接：https://www.cnblogs.com/zt2710/p/11116637.html 群聊天记录截图👇","text":"原文链接：https://www.cnblogs.com/zt2710/p/11116637.html 群聊天记录截图👇 固定多数据源切换 固定多数据源的动态切换，通过自定义注解实现切换，这样在切换数据源时比较灵活，具体的实现方式如下： 1、配置多数据源 &lt;!--定义数据源1--&gt; &lt;bean id=\"oracledataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"oracle.jdbc.driver.OracleDriver\" /&gt; &lt;property name=\"url\" value=\"jdbc:oracle:thin:@127.0.0.1:1522:neworcl\" /&gt; &lt;property name=\"username\" value=\"emspdadev\" /&gt; &lt;property name=\"password\" value=\"emspdadev\" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=\"initialSize\" value=\"0\"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=\"maxActive\" value=\"20\"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=\"maxIdle\" value=\"20\"&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=\"minIdle\" value=\"1\"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=\"maxWait\" value=\"60000\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--定义数据源2--&gt; &lt;bean id=\"mysqldataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/jbpmdb\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123456\" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=\"initialSize\" value=\"0\"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=\"maxActive\" value=\"20\"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=\"maxIdle\" value=\"20\"&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=\"minIdle\" value=\"1\"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=\"maxWait\" value=\"60000\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--动态数据源配置--&gt; &lt;bean id=\"dataSource\" class=\"com.ssm.datasource.DynamicDataSource\"&gt; &lt;!--引入定义好的数据源--&gt; &lt;property name=\"targetDataSources\"&gt; &lt;map key-type=\"java.lang.String\"&gt; &lt;entry key=\"oracle\" value-ref=\"oracledataSource\" /&gt; &lt;entry key=\"mysql\" value-ref=\"mysqldataSource\" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--定义默认数据源--&gt; &lt;property name=\"defaultTargetDataSource\" ref=\"oracledataSource\" /&gt; &lt;/bean&gt; &lt;!--spring和mybatis整合--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapping/*.xml\" /&gt; &lt;/bean&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.ssm.dao\" /&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" /&gt; &lt;/bean&gt; 2、定义注解(注解名为DataSource)，用于切换数据源，注解的值只能为上述配置中定义的key(对应于上面配置中定义的oracle、mysql) @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) pub lic @interface DataSource { String value(); } 3、根据Sping切面编程，当调用指定的切面类时，解释注解，并根据注解的定义使用对应的数据库 public class DataSourceAspect { /** * 定义切面，当调用com.ssm.service下的所有类的所有方法前都会执行beforeInvoke方法 */ @Pointcut(\"execution(* com.ssm.service.*.*(..))\") public void pointCut(){}; @Before(value = \"pointCut()\") public void beforeInvoke(JoinPoint joinpoint) { try { String clazzName = joinpoint.getTarget().getClass().getName(); String methodName = joinpoint.getSignature().getName(); Class targetClazz = Class.forName(clazzName); Method[] methods = targetClazz.getMethods(); for(Method method : methods) { if(method.getName().equals(methodName)) { // 首先查看方法是否使用注解 // 如果使用注解，则获取注解定义的值，并根据注解的值设置访问数据库的key if(method.isAnnotationPresent(DataSource.class)) { DataSource dataSource = method.getAnnotation(DataSource.class); DatasourceHolder.setDataType(dataSource.value()); } break; } } } catch (Exception e) { e.printStackTrace(); } } } 4、定义动态切换数据源(继承Spring的AbstractRoutingDataSource) public class DynamicDataSource extends AbstractRoutingDataSource { /** * 根据DatasourceHolder中DataType的值获取具体的数据源 */ @Override protected Object determineCurrentLookupKey() { return DatasourceHolder.getDataType(); } } 5、数据源切换的使用 @Service public class IdxServiceImpl implements IIdxSevice { @Autowired private IdxMapper idxMapper; @Override public List&lt;Idx&gt; listIdxInfo() { return null; } /** * 根据注解的配置，会访问oracle对应的数据源 */ @Override @DataSource(\"oracle\") public Map&lt;String,Object&gt; getIdxById(int idxId) { return idxMapper.getIdxById(idxId); } /** * 根据注解的配置，会访问mysql对应的数据源 */ @Override @DataSource(\"mysql\") public Map&lt;String, Object&gt; getJobInfo(int dbId) { return idxMapper.getJobInfo(dbId); } } 通过以上的步骤即实现了数据源的动态切换 动态多数据源切换 对于动态的多数据源，数据源的配置一般不放在配置文件中，因为如果放在配置文件中，每次新增或删除数据源，都需要重启项目，这样的实现方式非常不友好；通常情况向数据源的配置放在数据库中。实现方式如下：**** 1、配置数据源，这里配置的数据源用于保存其他数据源的配置信息，今后数据的新增、删除、修改均在该数据库中操作，配置如下： &lt;!--定义数据源--&gt; &lt;bean id=\"oracledataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"oracle.jdbc.driver.OracleDriver\" /&gt; &lt;property name=\"url\" value=\"jdbc:oracle:thin:@127.0.0.1:1522:neworcl\" /&gt; &lt;property name=\"username\" value=\"cfgmanage\" /&gt; &lt;property name=\"password\" value=\"cfgmanage\" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=\"initialSize\" value=\"0\"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=\"maxActive\" value=\"20\"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=\"maxIdle\" value=\"20\"&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=\"minIdle\" value=\"1\"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=\"maxWait\" value=\"60000\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--查询动态配置的数据库连接信息--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"oracledataSource\" /&gt; &lt;/bean&gt; &lt;bean id=\"dbConfigService\" class=\"com.teamsun.datasource.DBConfigService\"&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" /&gt; &lt;/bean&gt; &lt;!--定义动态数据源--&gt; &lt;bean id=\"dataSource\" class=\"com.teamsun.datasource.DynamicDataSource\"&gt; &lt;property name=\"masterDataSource\" ref=\"oracledataSource\" /&gt; &lt;property name=\"dbConfigService\" ref=\"dbConfigService\" /&gt; &lt;/bean&gt; &lt;!--spring和mybatis整合--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\" /&gt; &lt;!--&lt;property name=\"mapperLocations\" value=\"classpath:mapping/*.xml\" /&gt;--&gt; &lt;/bean&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.teamsun.mapper\" /&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" /&gt; &lt;/bean&gt; 2、实现查询数据源配置信息的类 public class DBConfigService { private JdbcTemplate jdbcTemplate; /** * 查询数据库配置信息 * @param dbName 数据库名称 * @return 数据库配置信息 */ public DBCfg getDBCfg(String dbName) throws Exception { String querySql = \"select\\n\" + \" t.db_type as \\\"dbType\\\",\\n\" + \" t.db_name as \\\"dbName\\\",\\n\" + \" t.db_comment as \\\"dbCommment\\\",\\n\" + \" t.db_driver as \\\"driverClass\\\",\\n\" + \" t.db_username as \\\"userName\\\",\\n\" + \" t.db_password as \\\"passworld\\\",\\n\" + \" t.db_url as \\\"jdbcURL\\\"\" + \" from TB_RPT_DBCFG t\\n\" + \" where t.db_name = '\" + dbName + \"'\"; RowMapper&lt;DBCfg&gt; rowMapper = ParameterizedBeanPropertyRowMapper.newInstance(DBCfg.class); DBCfg dbCfg = (DBCfg) jdbcTemplate.queryForObject(querySql, rowMapper); return dbCfg; } public JdbcTemplate getJdbcTemplate() { return jdbcTemplate; } public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } } 3、实现动态切换数据源 /** * &lt;p&gt;动态创建及访问多数据源&lt;/p&gt; */ public class DynamicDataSource extends AbstractRoutingDataSource{ private DBConfigService dbConfigService; private DataSource masterDataSource; private Map&lt;Object, Object&gt; targetDataSource = new HashMap&lt;Object, Object&gt;(); private static final String DEFAULT_DB_NAME = \"dataSource\"; // 默认数据库名 private static final Logger LOGGER = Logger.getLogger(DynamicDataSource.class); /** * 创建并获取数据源 * @return */ @Override protected DataSource determineTargetDataSource() { // 获取数据源名称 String dbName = (String) determineCurrentLookupKey(); // 获取默认数据源 if(DEFAULT_DB_NAME.equals(dbName)) { return masterDataSource; } // 创建数据源 DataSource dataSource = (DataSource) targetDataSource.get(dbName); try { if (dataSource == null) { dataSource = getDataSourceByName(dbName); } } catch (Exception e) { e.printStackTrace(); } return dataSource; } /** * 获取数据库名称，可根据获取的数据库名称查询数据库配置信息， * 通过配置信息动态创建数据源 * @return */ @Override protected Object determineCurrentLookupKey() { String dbName = DatasourceHolder.getDBName(); if(StringUtils.isEmpty(dbName)) { dbName = DEFAULT_DB_NAME; } DatasourceHolder.remove(); return dbName; } @Override public void afterPropertiesSet() { } /** * 通过数据库的配置信息获取数据源 * @param dbName 数据库名称 * @return */ public synchronized DataSource getDataSourceByName(String dbName) throws Exception { // 创建数据源 BasicDataSource dataSource = createDataSource(dbName); // 如果创建数据源成功则缓存数据源，避免重复创建相同的数据源 if(dataSource != null) { targetDataSource.put(dbName, dataSource); } return dataSource; } /** * 通过数据库的配置创建数据源 * @param dbName 数据库名称 * @return */ public BasicDataSource createDataSource(String dbName) throws Exception { // 查询动态数据源配置信息 String oriDBName = DatasourceHolder.getDBName(); if(dbConfigService == null) { System.out.println(\"创建数据源失败[dbCfgService is null......]\"); LOGGER.debug(\"创建数据源失败[dbCfgService is null......]\"); } // 通过数据库名称查询相关的数据库配置信息 DatasourceHolder.setDBName(DEFAULT_DB_NAME); DBCfg dbCfg = dbConfigService.getDBCfg(dbName); DatasourceHolder.setDBName(oriDBName); String driver = dbCfg.getDriverClass(); // 数据库驱动 String url = dbCfg.getJdbcURL(); // 数据库连接地址 String username = dbCfg.getUserName(); // 数据库用户名 String password = dbCfg.getPassworld(); // 数据库密码 LOGGER.debug(\"动态连接的数据库为[\" + url + \"|\" + username + \"]\"); // 创建数据源 BasicDataSource basicDataSource = new BasicDataSource(); basicDataSource.setDriverClassName(driver); basicDataSource.setUrl(url); basicDataSource.setUsername(username); basicDataSource.setPassword(password); basicDataSource.setTestWhileIdle(true); return basicDataSource; } /** * 如果修改或删除数据源的配置，则需要同步删除缓存的数据源 * @param dbName */ public void removeDataSource(String dbName) { this.targetDataSource.remove(dbName); } public DataSource getMasterDataSource() { return masterDataSource; } public void setMasterDataSource(DataSource masterDataSource) { this.masterDataSource = masterDataSource; } public DBConfigService getDbConfigService() { return dbConfigService; } public void setDbConfigService(DBConfigService dbConfigService) { this.dbConfigService = dbConfigService; } } 4、使用动态切换数据源 public class ShowRptServiceImpl implements IShowRptService { private static final Logger LOGGER = Logger.getLogger(ShowRptServiceImpl.class); @Autowired private DBCfgMapper dbCfgMapper; @Autowired private ShowRptInfoMapper showRptInfoMapper; @Override public RptResult queryRptInfo(BaseRpt baseRpt, Map&lt;String, String&gt; params) { // 在调用Mybatis执行数据库之前先选择数据源 DatasourceHolder.setDBName(dbCfg.getDbName()); // 查询报表数据 List&lt;Map&lt;String,Object&gt;&gt; resultList = showRptInfoMapper.queryRptData(querySQL); // 选择数据源 DatasourceHolder.setDBName(dbCfg.getDbName()); // 查询数据数据量 int totalCount = showRptInfoMapper.queryTotalCount(countSQL); RptResult rptResult = new RptResult(); return rptResult; } } 通过以上步骤即可实现动态多数据源的动态切换 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"优化IDEA卡顿现象","slug":"优化IDEA卡顿现象","date":"2020-09-07T09:24:41.000Z","updated":"2020-09-18T04:43:03.056Z","comments":true,"path":"2020/09/07/优化IDEA卡顿现象/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/07/%E4%BC%98%E5%8C%96IDEA%E5%8D%A1%E9%A1%BF%E7%8E%B0%E8%B1%A1/","excerpt":"修改 vmoptions 文件首先是找到 IDEA 的安装目录，之后到安装目录的 bin 目录下，找到如下两个文件：idea.exe.vmoptions和idea64.exe.vmoptions看你是多少位系统的你就该对应的就可以了，编辑这个配置文件。修改前： -Xms128m -Xmx750m -XX:ReservedCodeCacheSize=240m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 -ea -XX:CICompilerCount=2 -Dsun.io.useCanonPrefixCache=false -Djdk.http.auth.tunneling.disabledSchemes=\"\" -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -Djdk.attach.allowAttachSelf=true -Dkotlinx.coroutines.debug=off -Djdk.module.illegalAccess.silent=true 修改后：分别把内存的参数 128m 和 750m 改成你想要改的就可以了，我是分别改成了 1024m 和 2048m，之后如果还卡，再往大了调，可以根据自己电脑的实际内存设置。 参考JVM调优常用参数","text":"修改 vmoptions 文件首先是找到 IDEA 的安装目录，之后到安装目录的 bin 目录下，找到如下两个文件：idea.exe.vmoptions和idea64.exe.vmoptions看你是多少位系统的你就该对应的就可以了，编辑这个配置文件。修改前： -Xms128m -Xmx750m -XX:ReservedCodeCacheSize=240m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 -ea -XX:CICompilerCount=2 -Dsun.io.useCanonPrefixCache=false -Djdk.http.auth.tunneling.disabledSchemes=\"\" -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -Djdk.attach.allowAttachSelf=true -Dkotlinx.coroutines.debug=off -Djdk.module.illegalAccess.silent=true 修改后：分别把内存的参数 128m 和 750m 改成你想要改的就可以了，我是分别改成了 1024m 和 2048m，之后如果还卡，再往大了调，可以根据自己电脑的实际内存设置。 参考JVM调优常用参数 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"宝塔同IP或同域名不同端口分别对应不同网站教程","slug":"宝塔同IP或同域名不同端口分别对应不同网站教程","date":"2020-09-05T09:24:41.000Z","updated":"2020-09-18T04:43:03.065Z","comments":true,"path":"2020/09/05/宝塔同IP或同域名不同端口分别对应不同网站教程/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/09/05/%E5%AE%9D%E5%A1%94%E5%90%8CIP%E6%88%96%E5%90%8C%E5%9F%9F%E5%90%8D%E4%B8%8D%E5%90%8C%E7%AB%AF%E5%8F%A3%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E4%B8%8D%E5%90%8C%E7%BD%91%E7%AB%99%E6%95%99%E7%A8%8B/","excerpt":"准备工作 IP 服务器端放行所需端口 安装好的宝塔面板。 实现效果192.168.1.666:80 站点一指向A项目 192.168.1.666:8081 站点二指向B项目 具体步骤1） 新建一个站点指向项目A 2）再次添加一个站点指向项目B 提交之后打开设置 修改配置文件如下图： 提交之后，切记一定要重启nginx，然后即打开站点就可以看到内容 照此可添加多个","text":"准备工作 IP 服务器端放行所需端口 安装好的宝塔面板。 实现效果192.168.1.666:80 站点一指向A项目 192.168.1.666:8081 站点二指向B项目 具体步骤1） 新建一个站点指向项目A 2）再次添加一个站点指向项目B 提交之后打开设置 修改配置文件如下图： 提交之后，切记一定要重启nginx，然后即打开站点就可以看到内容 照此可添加多个 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"Git笔记","slug":"Git笔记","date":"2020-08-29T13:00:00.000Z","updated":"2020-09-18T04:43:02.948Z","comments":true,"path":"2020/08/29/Git笔记/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/29/Git%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Git笔记在当前目录下初始化一个空的git仓库 git init 设置全局用户名和邮箱 git config --global user.name \"name\" git config --global user.email \"xxxxx@email.com\" git config user.name 查看git用户名 git config user.email 查看邮箱配置 查看git配置 git config --list 提交修改到暂存区 git add -A 提交全部修改。（git add -All） git add -u 只提交修改，不提交新文件。（git add -update) git add . 不提交删除文件 git add &lt;filename&gt; 提交指定文件 查看暂存区 git status 修改最新提交的 commit message git commit --amend 修改某个提交的 commit message git commit -i &lt;commit id&gt; commit id 为要修改的目标 commit 的父亲 commit id 合并连续的commit git rebase -i &lt;commit id&gt; commit id 为目标commit的父亲commit id 提交修改到本地仓库 git commit -m 'msg' 提交暂存区到本地仓库 git commit -a -m 'msg' 提交修改到本地仓库（不提交新增文件） 查看提交记录 git log 添加远程仓库 git remote add &lt;name&gt; &lt;url&gt; 查看远程仓库信息 git remote show &lt;name&gt; 远程仓库的删除和重命名 git remote rm &lt;remote_name&gt; git remote rename &lt;old_name&gt; &lt;new_name&gt; 拉取远程仓库数据到本地 git pull &lt;remote_name&gt; &lt;branch_name&gt; 提交本地仓库到远程仓库 git push &lt;remote_name&gt; &lt;branch_name&gt; 查看&amp;创建&amp;切换分支 git branch 查看已有分支 git branch -v 查看已有分支及各个分支最后一个提交对象的信息 git branch &lt;branch_name&gt; 创建新的空分支 git branch &lt;branch_name&gt; &lt;exist_branch_name&gt; 创建新分支 git checkout -b &lt;branch_name&gt; &lt;exist_branch_name&gt; 创建并切换到新分支 git checkout &lt;branch_name&gt; 切换分支 删除&amp;合并分支 git branch -D &lt;branch_name&gt; 删除分支 git merge &lt;branch_name&gt; 当前分支合并到指定分支 暂存区恢复到HEAD git reset HEAD git reset HEAD &lt;file_name&gt; 工作区恢复到暂存区 git checkout -- &lt;file_name&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Git","slug":"Git","permalink":"https://melodyjerry.github.io/blog/tags/Git/"}]},{"title":"[转]Maven中静态资源和字节码文件的过滤","slug":"[转]Maven中静态资源和字节码文件的过滤","date":"2020-08-29T13:00:00.000Z","updated":"2020-09-18T04:43:03.015Z","comments":true,"path":"2020/08/29/[转]Maven中静态资源和字节码文件的过滤/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/29/[%E8%BD%AC]Maven%E4%B8%AD%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E6%BB%A4/","excerpt":"本文的方法是针对Maven管理的Java Web工程","text":"本文的方法是针对Maven管理的Java Web工程 静态资源的过滤在maven中，静态资源的过滤使用基本上大家都知道，只需要在&lt;build&gt;&lt;/build&gt;中使用resources标签即可，示例如下： &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;1234567891011 在静态资源的过滤中，基本的元素有三种： directory：指定资源所在的目录，这个目录的路径是相对于pom.xml文件； includes：指定要包含哪些文件，其中包括inlcude子节点来指定匹配的模式； excludes：指定要排除哪些文件，其中包括exclude子节点来指定匹配的模式； filtering：指定哪些文件需要过滤，这个过滤的目的是为了替换其中的占位符${}，其中的占位符属性在pom.xml文件中的&lt;properties&gt;&lt;/properties&gt;中指定； 在其中可能遇到的问题如下： 当includes和excludes冲突的时候，优先采取excludes中的设定，这篇文章中详细的说明了，这篇文章从源码角度进行了分析； 字节码文件的过滤相对于静态资源的过滤，针对字节码文件的过滤则比较生僻，尤其是在配置文件基本上都是xml或者properties的时候，如果你的工程的配置是Java Config风格的，那么就会遇到在不同的环境下加载不同的配置类的问题。不同于静态的配置文件直接使用&lt;resources&gt;标签（其实背后还是通过resource插件完成的），字节码的过滤需要直接使用maven-war-plugin ，实例如下： &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;packagingExcludes&gt;WEB-INF/classes/test/dao/, WEB-INF/classes/test/service/, WEB-INF/classes/config/TestConfig.class, WEB-INF/lib/log4j-*.jar &lt;/packagingExcludes&gt; &lt;/configuration&gt; &lt;/plugin&gt;123456789101112 从上面可以看到，该插件是通过packagingExcludes元素完成过滤的，这个元素的作用是在工程package之前， 通过一些模式来排除掉一些文件或者文件夹，如果有多个可以通过逗号“,”来分割，上述使用的例子： 排除特定配置类：WEB-INF/classes/config/TestConfig.class 排除特定文件夹：WEB-INF/classes/test/service/ 排除引用的jar包：WEB-INF/lib/log4j-*.jar 上述使用的路径是相对于war包的根路径的。 另外在packagingExcludes中还可以使用Java的正则表达式，通过%regex[...]包裹即可，具体可以看官方文档 . 转载链接：https://blog.csdn.net/lmy86263/article/details/71189485?locationNum=3&amp;fps=1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Maven","slug":"Maven","permalink":"https://melodyjerry.github.io/blog/tags/Maven/"}]},{"title":"[转]curl教程","slug":"curl教程","date":"2020-08-28T04:11:11.000Z","updated":"2020-09-18T04:43:03.018Z","comments":true,"path":"2020/08/28/curl教程/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/28/curl%E6%95%99%E7%A8%8B/","excerpt":"","text":"curl 的用法指南作者： 阮一峰 简介curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。 它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具。 本文介绍它的主要命令行参数，作为日常的参考，方便查阅。内容主要翻译自《curl cookbook》。为了节约篇幅，下面的例子不包括运行时的输出，初学者可以先看我以前写的《curl 初学者教程》。 不带有任何参数时，curl 就是发出 GET 请求。 $ curl https://www.example.com 上面命令向www.example.com发出 GET 请求，服务器返回的内容会在命令行输出。 -A-A参数指定客户端的用户代理标头，即User-Agent。curl 的默认用户代理字符串是curl/[version]。 $ curl -A 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36' https://google.com 上面命令将User-Agent改成 Chrome 浏览器。 $ curl -A '' https://google.com 上面命令会移除User-Agent标头。 也可以通过-H参数直接指定标头，更改User-Agent。 $ curl -H 'User-Agent: php/1.0' https://google.com -b-b参数用来向服务器发送 Cookie。 $ curl -b 'foo=bar' https://google.com 上面命令会生成一个标头Cookie: foo=bar，向服务器发送一个名为foo、值为bar的 Cookie。 $ curl -b 'foo1=bar;foo2=bar2' https://google.com 上面命令发送两个 Cookie。 $ curl -b cookies.txt https://www.google.com 上面命令读取本地文件cookies.txt，里面是服务器设置的 Cookie（参见-c参数），将其发送到服务器。 -c-c参数将服务器设置的 Cookie 写入一个文件。 $ curl -c cookies.txt https://www.google.com 上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件cookies.txt。 -d-d参数用于发送 POST 请求的数据体。 $ curl -d'login=emma＆password=123'-X POST https://google.com/login # 或者 $ curl -d 'login=emma' -d 'password=123' -X POST https://google.com/login 使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。 -d参数可以读取本地文本文件的数据，向服务器发送。 $ curl -d '@data.txt' https://google.com/login 上面命令读取data.txt文件的内容，作为数据体向服务器发送。 –data-urlencode--data-urlencode参数等同于-d，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。 $ curl --data-urlencode 'comment=hello world' https://google.com/login 上面代码中，发送的数据hello world之间有一个空格，需要进行 URL 编码。 -e-e参数用来设置 HTTP 的标头Referer，表示请求的来源。 curl -e 'https://google.com?q=example' https://www.example.com 上面命令将Referer标头设为https://google.com?q=example。 -H参数可以通过直接添加标头Referer，达到同样效果。 curl -H 'Referer: https://google.com?q=example' https://www.example.com -F-F参数用来向服务器上传二进制文件。 $ curl -F 'file=@photo.png' https://google.com/profile 上面命令会给 HTTP 请求加上标头Content-Type: multipart/form-data，然后将文件photo.png作为file字段上传。 -F参数可以指定 MIME 类型。 $ curl -F 'file=@photo.png;type=image/png' https://google.com/profile 上面命令指定 MIME 类型为image/png，否则 curl 会把 MIME 类型设为application/octet-stream。 -F参数也可以指定文件名。 $ curl -F 'file=@photo.png;filename=me.png' https://google.com/profile 上面命令中，原始文件名为photo.png，但是服务器接收到的文件名为me.png。 -G-G参数用来构造 URL 的查询字符串。 $ curl -G -d 'q=kitties' -d 'count=20' https://google.com/search 上面命令会发出一个 GET 请求，实际请求的 URL 为https://google.com/search?q=kitties&amp;count=20。如果省略--G，会发出一个 POST 请求。 如果数据需要 URL 编码，可以结合--data--urlencode参数。 $ curl -G --data-urlencode 'comment=hello world' https://www.example.com -H-H参数添加 HTTP 请求的标头。 $ curl -H 'Accept-Language: en-US' https://google.com 上面命令添加 HTTP 标头Accept-Language: en-US。 $ curl -H 'Accept-Language: en-US' -H 'Secret-Message: xyzzy' https://google.com 上面命令添加两个 HTTP 标头。 $ curl -d '{\"login\": \"emma\", \"pass\": \"123\"}' -H 'Content-Type: application/json' https://google.com/login 上面命令添加 HTTP 请求的标头是Content-Type: application/json，然后用-d参数发送 JSON 数据。 -i-i参数打印出服务器回应的 HTTP 标头。 $ curl -i https://www.example.com 上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。 -I-I参数向服务器发出 HEAD 请求，然会将服务器返回的 HTTP 标头打印出来。 $ curl -I https://www.example.com 上面命令输出服务器对 HEAD 请求的回应。 --head参数等同于-I。 $ curl --head https://www.example.com -k-k参数指定跳过 SSL 检测。 $ curl -k https://www.example.com 上面命令不会检查服务器的 SSL 证书是否正确。 -L-L参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。 $ curl -L -d 'tweet=hi' https://api.twitter.com/tweet –limit-rate--limit-rate用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境。 $ curl --limit-rate 200k https://google.com 上面命令将带宽限制在每秒 200K 字节。 -o-o参数将服务器的回应保存成文件，等同于wget命令。 $ curl -o example.html https://www.example.com 上面命令将www.example.com保存成example.html。 -O-O参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。 $ curl -O https://www.example.com/foo/bar.html 上面命令将服务器回应保存成文件，文件名为bar.html。 -s-s参数将不输出错误和进度信息。 $ curl -s https://www.example.com 上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。 如果想让 curl 不产生任何输出，可以使用下面的命令。 $ curl -s -o /dev/null https://google.com -S-S参数指定只输出错误信息，通常与-s一起使用。 $ curl -s -o /dev/null https://google.com 上面命令没有任何输出，除非发生错误。 -u-u参数用来设置服务器认证的用户名和密码。 $ curl -u 'bob:12345' https://google.com/login 上面命令设置用户名为bob，密码为12345，然后将其转为 HTTP 标头Authorization: Basic Ym9iOjEyMzQ1。 curl 能够识别 URL 里面的用户名和密码。 $ curl https://bob:12345@google.com/login 上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。 $ curl -u 'bob' https://google.com/login 上面命令只设置了用户名，执行后，curl 会提示用户输入密码。 -v-v参数输出通信的整个过程，用于调试。 $ curl -v https://www.example.com --trace参数也可以用于调试，还会输出原始的二进制数据。 $ curl --trace - https://www.example.com -x-x参数指定 HTTP 请求的代理。 $ curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com 上面命令指定 HTTP 请求通过myproxy.com:8080的 socks5 代理发出。 如果没有指定代理协议，默认为 HTTP。 $ curl -x james:cats@myproxy.com:8080 https://www.example.com 上面命令中，请求的代理使用 HTTP 协议。 -X-X参数指定 HTTP 请求的方法。 $ curl -X POST https://www.example.com 上面命令对https://www.example.com发出 POST 请求。 参考链接 Curl Cookbook document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java中编译器自动进行的强制类型转换","slug":"Java中编译器自动进行的强制类型转换","date":"2020-08-27T09:24:41.000Z","updated":"2020-09-18T04:43:02.964Z","comments":true,"path":"2020/08/27/Java中编译器自动进行的强制类型转换/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/27/Java%E4%B8%AD%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E8%BF%9B%E8%A1%8C%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"关于类型转换一般规律：小类型向大类型可以自动类型转换，而大类型向小类型转换，需要手动的强制类型转换。 注意：1.类型的大小不是按字节大小区分的，而是按照它的范围来定的，比如 long long1 = 300F;//报错，编译无法通过 float float1 = 300L;//编译可以通过，并且可以正常运行 long占八个字节，float占四个字节，但实际上float表示的范围要比long更大，（这主要是底层采用存储方式不同造成的）所以long类型的常量可以赋值给float类型的变量，而反过来却不行。2.这个规则也可以用在引用数据类型上，如果是引用类型，类型的大小则由他们的继承或实现关系来决定。 关于自动java中编译器做的自动强制类型转换byte byte1 = 1; short short1 = 2; char char1 = 3; 类似上面的代码，相信大家都写过，实际上，也能编译通过，并且正常运行。但是，如果作为初学者，不应该有疑惑吗？java中的整型常量是int类型的，将一个int类型的常量，赋值给byte、short或char类型的变量，却不会报错？？不是小类型才可以进行自动类型转换转为大类型的吗？大类型的转小类型需要进行强制类型转换，并且可能会损失精度的。这里是为什么呢？ 其实是java中有一种机制：只要一个int类型的常量，在byte、short或char类型的范围之类的，就可以直接赋值给byte、short或char的变量，检查工作是java的编译器自动进行的。 注意：1.只能是常量，不能是变量或变量参与运算的表达式。 byte byte1 = 1; short short1 = 2; char char1 = 3; int int1 = 3； short short2 = byte1 + 1;//报错，编译无法通过 short short3 = int1;//报错，编译无法通过 short short4 = 3;//编译通过，并且可以正常运行 因为java编译器只会自动检测字面常量是否超出了类型的范围，而不会对变量的值或有变量参与的运算结果进行检测。“short short2 = byte1 + 1;”在做运算的时候，会自动上升为int类型，然后编译器就会检测到结果是一个int类型的值，而前面的变量是一个short类型的。不是小类型转大类型，所以直接编译报错。“short short3 = int1;” 直接通过变量的类型就有问题，而不会通过上下文来判断值是否超出了范围。 2.对于纯常量的表达式，也是可以的 short short4 = 1 + 2;//编译通过，并且可以正常运行 因为简单的常量表达式，java的编译器可以直接就运算出结果，然后再进一步检测是否超出了范围。 3.这个机制只是针对int转byte、short或char float float1 = 3.14;//报错，编译无法通过 对于其它的基本数据类型或引用数据类型，是没有这个机制的，只能使用文章开头说的一般规律。其它一些简单的测试，比如超出范围就会编译报错.","text":"关于类型转换一般规律：小类型向大类型可以自动类型转换，而大类型向小类型转换，需要手动的强制类型转换。 注意：1.类型的大小不是按字节大小区分的，而是按照它的范围来定的，比如 long long1 = 300F;//报错，编译无法通过 float float1 = 300L;//编译可以通过，并且可以正常运行 long占八个字节，float占四个字节，但实际上float表示的范围要比long更大，（这主要是底层采用存储方式不同造成的）所以long类型的常量可以赋值给float类型的变量，而反过来却不行。2.这个规则也可以用在引用数据类型上，如果是引用类型，类型的大小则由他们的继承或实现关系来决定。 关于自动java中编译器做的自动强制类型转换byte byte1 = 1; short short1 = 2; char char1 = 3; 类似上面的代码，相信大家都写过，实际上，也能编译通过，并且正常运行。但是，如果作为初学者，不应该有疑惑吗？java中的整型常量是int类型的，将一个int类型的常量，赋值给byte、short或char类型的变量，却不会报错？？不是小类型才可以进行自动类型转换转为大类型的吗？大类型的转小类型需要进行强制类型转换，并且可能会损失精度的。这里是为什么呢？ 其实是java中有一种机制：只要一个int类型的常量，在byte、short或char类型的范围之类的，就可以直接赋值给byte、short或char的变量，检查工作是java的编译器自动进行的。 注意：1.只能是常量，不能是变量或变量参与运算的表达式。 byte byte1 = 1; short short1 = 2; char char1 = 3; int int1 = 3； short short2 = byte1 + 1;//报错，编译无法通过 short short3 = int1;//报错，编译无法通过 short short4 = 3;//编译通过，并且可以正常运行 因为java编译器只会自动检测字面常量是否超出了类型的范围，而不会对变量的值或有变量参与的运算结果进行检测。“short short2 = byte1 + 1;”在做运算的时候，会自动上升为int类型，然后编译器就会检测到结果是一个int类型的值，而前面的变量是一个short类型的。不是小类型转大类型，所以直接编译报错。“short short3 = int1;” 直接通过变量的类型就有问题，而不会通过上下文来判断值是否超出了范围。 2.对于纯常量的表达式，也是可以的 short short4 = 1 + 2;//编译通过，并且可以正常运行 因为简单的常量表达式，java的编译器可以直接就运算出结果，然后再进一步检测是否超出了范围。 3.这个机制只是针对int转byte、short或char float float1 = 3.14;//报错，编译无法通过 对于其它的基本数据类型或引用数据类型，是没有这个机制的，只能使用文章开头说的一般规律。其它一些简单的测试，比如超出范围就会编译报错. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Linux运维常用的150条命令","slug":"Linux运维常用的150条命令","date":"2020-08-27T06:00:00.000Z","updated":"2020-09-18T04:43:02.970Z","comments":true,"path":"2020/08/27/Linux运维常用的150条命令/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/27/Linux%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E7%9A%84150%E6%9D%A1%E5%91%BD%E4%BB%A4/","excerpt":"","text":"命令 功能说明 线上查询及帮助命令(2个) man 查看命令帮助，命令的词典，更复杂的还有info，但不常用。 help 查看Linux内置命令的帮助，比如cd命令。 文件和目录操作命令(18个) ls 全拼list，功能是列出目录的内容及其内容属性信息。 cd 全拼change directory，功能是从当前工作目录切换到指定的工作目录。 cp 全拼copy，其功能为复制文件或目录。 find 查找的意思，用于查找目录及目录下的文件。 mkdir 全拼make directories，其功能是创建目录。 mv 全拼move，其功能是移动或重命名文件。 pwd 全拼print working directory，其功能是显示当前工作目录的绝对路径。 rename 用于重命名文件。 rm 全拼remove，其功能是删除一个或多个文件或目录。 rmdir 全拼remove empty directories，功能是删除空目录。 touch 创建新的空文件，改变已有文件的时间戳属性。 tree 功能是以树形结构显示目录下的内容。 basename 显示文件名或目录名。 dirname 显示文件或目录路径。 chattr 改变文件的扩展属性。 lsattr 查看文件扩展属性。 file 显示文件的类型。 md5sum 计算和校验文件的MD5值。 查看文件及内容处理命令（21个） cat 全拼concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。 tac tac是cat的反向拼写，因此命令的功能为反向显示文件内容。 more 分页显示文件内容。 less 分页显示文件内容，more命令的相反用法。 head 显示文件内容的头部。 tail 显示文件内容的尾部。 cut 将文件的每一行按指定分隔符分割并输出。 split 分割文件为不同的小片段。 paste 按行合并文件内容。 sort 对文件的文本内容排序。 uniq 去除重复行。oldboy wc 统计文件的行数、单词数或字节数。 iconv 转换文件的编码格式。 dos2unix 将DOS格式文件转换成UNIX格式。 diff 全拼difference，比较文件的差异，常用于文本文件。 vimdiff 命令行可视化文件比较工具，常用于文本文件。 rev 反向输出文件内容。 grep/egrep 过滤字符串，三剑客老三。 join 按两个文件的相同字段合并。 tr 替换或删除字符。 vi/vim 命令行文本编辑器。 文件压缩及解压缩命令（4个） tar 打包压缩。oldboy unzip 解压文件。 gzip gzip压缩工具。 zip 压缩工具。 信息显示命令（11个） uname 显示操作系统相关信息的命令。 hostname 显示或者设置当前系统的主机名。 dmesg 显示开机信息，用于诊断系统故障。 uptime 显示系统运行时间及负载。 stat 显示文件或文件系统的状态。 du 计算磁盘空间使用情况。 df 报告文件系统磁盘空间的使用情况。 top 实时显示系统资源使用情况。 free 查看系统内存。 date 显示与设置系统时间。 cal 查看日历等时间信息。 搜索文件命令（4个） which 查找二进制命令，按环境变量PATH路径查找。 find 从磁盘遍历查找文件或目录。 whereis 查找二进制命令，按环境变量PATH路径查找。 locate 从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用updatedb更新库。 用户管理命令（10个） useradd 添加用户。 usermod 修改系统已经存在的用户属性。 userdel 删除用户。 groupadd 添加用户组。 passwd 修改用户密码。 chage 修改用户密码有效期限。 id 查看用户的uid,gid及归属的用户组。 su 切换用户身份。 visudo 编辑/etc/sudoers文件的专属命令。 sudo 以另外一个用户身份（默认root用户）执行事先在sudoers文件允许的命令。 基础网络操作命令（11个） telnet 使用TELNET协议远程登录。 ssh 使用SSH加密协议远程登录。 scp 全拼secure copy，用于不同主机之间复制文件。 wget 命令行下载文件。 ping 测试主机之间网络的连通性。 route 显示和设置linux系统的路由表。 ifconfig 查看、配置、启用或禁用网络接口的命令。 ifup 启动网卡。 ifdown 关闭网卡。 netstat 查看网络状态。 ss 查看网络状态。 深入网络操作命令（9个） nmap 网络扫描命令。 lsof 全名list open files，也就是列举系统中已经被打开的文件。 mail 发送和接收邮件。 mutt 邮件管理命令。 nslookup 交互式查询互联网DNS服务器的命令。 dig 查找DNS解析过程。 host 查询DNS的命令。 traceroute 追踪数据传输路由状况。 tcpdump 命令行的抓包工具。 有关磁盘与文件系统的命令（16个） mount 挂载文件系统。 umount 卸载文件系统。 fsck 检查并修复Linux文件系统。 dd 转换或复制文件。 dumpe2fs 导出ext2/ext3/ext4文件系统信息。 dump ext2/3/4文件系统备份工具。 fdisk 磁盘分区命令，适用于2TB以下磁盘分区。 parted 磁盘分区命令，没有磁盘大小限制，常用于2TB以下磁盘分区。 mkfs 格式化创建Linux文件系统。 partprobe 更新内核的硬盘分区表信息。 e2fsck 检查ext2/ext3/ext4类型文件系统。 mkswap 创建Linux交换分区。 swapon 启用交换分区。 swapoff 关闭交换分区。 sync 将内存缓冲区内的数据写入磁盘。 resize2fs 调整ext2/ext3/ext4文件系统大小。 系统权限及用户授权相关命令（4个） chmod 改变文件或目录权限。 chown 改变文件或目录的属主和属组。 chgrp 更改文件用户组。 umask 显示或设置权限掩码。 查看系统用户登陆信息的命令（7个） whoami 显示当前有效的用户名称，相当于执行id -un命令。 who 显示目前登录系统的用户信息。 w 显示已经登陆系统的用户列表，并显示用户正在执行的指令。 last 显示登入系统的用户。 lastlog 显示系统中所有用户最近一次登录信息。 users 显示当前登录系统的所有用户的用户列表。 finger 查找并显示用户信息。 内置命令及其它（19个） echo 打印变量，或直接输出指定的字符串 printf 将结果格式化输出到标准输出。 rpm 管理rpm包的命令。 yum 自动化简单化地管理rpm包的命令。 watch 周期性的执行给定的命令，并将命令的输出以全屏方式显示。 alias 设置系统别名。 unalias 取消系统别名。 date 查看或设置系统时间。 clear 清除屏幕，简称清屏。 history 查看命令执行的历史纪录。 eject 弹出光驱。 time 计算命令执行时间。 nc 功能强大的网络工具。 xargs 将标准输入转换成命令行参数。 exec 调用并执行指令的命令。 export 设置或者显示环境变量。 unset 删除变量或函数。 type 用于判断另外一个命令是否是内置命令。 bc 命令行科学计算器 系统管理与性能监视命令(9个) chkconfig 管理Linux系统开机启动项。 vmstat 虚拟内存统计。 mpstat 显示各个可用CPU的状态统计。 iostat 统计系统IO。 sar 全面地获取系统的CPU、运行队列、磁盘 I/O、分页（交换区）、内存、 CPU中断和网络等性能数据。 ipcs 用于报告Linux中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。 ipcrm 用来删除一个或更多的消息队列、信号量集或者共享内存标识。 strace 用于诊断、调试Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。 ltrace 命令会跟踪进程的库函数调用,它会显现出哪个库函数被调用。 关机/重启/注销和查看系统信息的命令（6个） shutdown 关机。 halt 关机。 poweroff 关闭电源。 logout 退出当前登录的Shell。 exit 退出当前登录的Shell。 Ctrl+d 退出当前登录的Shell的快捷键。 进程管理相关命令（15个） bg 将一个在后台暂停的命令，变成继续执行 （在后台执行）。 fg 将后台中的命令调至前台继续运行。 jobs 查看当前有多少在后台运行的命令。 kill 终止进程。 killall 通过进程名终止进程。 pkill 通过进程名终止进程。 crontab 定时任务命令。 ps 显示进程的快照。 pstree 树形显示进程。 nice/renice 调整程序运行的优先级。 nohup 忽略挂起信号运行指定的命令。 pgrep 查找匹配条件的进程。 runlevel 查看系统当前运行级别。 init 切换运行级别。 service 启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"【狂神说Java】JavaWeb-文件上传","slug":"【狂神说Java】JavaWeb-文件上传","date":"2020-08-27T05:52:05.548Z","updated":"2020-09-18T04:43:03.045Z","comments":true,"path":"2020/08/27/【狂神说Java】JavaWeb-文件上传/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/27/%E3%80%90%E7%8B%82%E7%A5%9E%E8%AF%B4Java%E3%80%91JavaWeb-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"记录一下，以免以下几个包导错 import org.apache.commons.fileupload.FileItem; import org.apache.commons.fileupload.FileUploadException; import org.apache.commons.fileupload.ProgressListener; import org.apache.commons.fileupload.disk.DiskFileItemFactory; import org.apache.commons.fileupload.servlet.ServletFileUpload; 源码： FileSerlvet类 package com.chen; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.util.List; import java.util.UUID; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.apache.commons.fileupload.FileItem; import org.apache.commons.fileupload.FileUploadException; import org.apache.commons.fileupload.ProgressListener; import org.apache.commons.fileupload.disk.DiskFileItemFactory; import org.apache.commons.fileupload.servlet.ServletFileUpload; /** * Servlet implementation class FileSerlvet */ public class FileSerlvet extends HttpServlet { private static final long serialVersionUID = 1L; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse * response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub // response.getWriter().append(\"Served at: \").append(request.getContextPath()); // 判断上传的文件普通表单还是带文件的表单 if (!ServletFileUpload.isMultipartContent(request)) { return;//终止方法运行,说明这是一个普通的表单,直接返回 } //创建上传文件的保存路径,建议在WEB-INF路径下,安全,用户无法直接访间上传的文件; String uploadPath =this.getServletContext().getRealPath(\"/WEB-INF/upload\"); File uploadFile = new File(uploadPath); if (!uploadFile.exists()){ uploadFile.mkdir(); //创建这个月录 } // 创建上传文件的保存路径，建议在WEB-INF路径下，安全，用户无法直接访问上传的文件 String tmpPath = this.getServletContext().getRealPath(\"/WEB-INF/tmp\"); File file = new File(tmpPath); if (!file.exists()) { file.mkdir();//创建临时目录 } // 处理上传的文件,一般都需要通过流来获取,我们可以使用 request, getInputstream(),原生态的文件上传流获取,十分麻烦 // 但是我们都建议使用 Apache的文件上传组件来实现, common-fileupload,它需要旅 commons-io组件; try { // 创建DiskFileItemFactory对象，处理文件路径或者大小限制 DiskFileItemFactory factory = getDiskFileItemFactory(file); /* * //通过这个工厂设置一个缓冲区,当上传的文件大于这个缓冲区的时候,将他放到临时文件 factory.setSizeThreshold(1024 * * 1024); //缓存区大小为1M factory.setRepository (file);//临时目录的保存目录,需要一个File */ // 2、获取ServletFileUpload ServletFileUpload upload = getServletFileUpload(factory); // 3、处理上传文件 // 把前端请求解析，封装成FileItem对象，需要从ServletFileUpload对象中获取 String msg = uploadParseRequest(upload, request, uploadPath); // Servlet请求转发消息 System.out.println(msg); if(msg == \"文件上传成功!\") { // Servlet请求转发消息 request.setAttribute(\"msg\",msg); request.getRequestDispatcher(\"info.jsp\").forward(request, response); }else { msg =\"请上传文件\"; request.setAttribute(\"msg\",msg); request.getRequestDispatcher(\"info.jsp\").forward(request, response); } } catch (FileUploadException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } } public static DiskFileItemFactory getDiskFileItemFactory(File file) { DiskFileItemFactory factory = new DiskFileItemFactory(); // 通过这个工厂设置一个缓冲区,当上传的文件大于这个缓冲区的时候,将他放到临时文件中; factory.setSizeThreshold(1024 * 1024);// 缓冲区大小为1M factory.setRepository(file);// 临时目录的保存目录,需要一个file return factory; } public static ServletFileUpload getServletFileUpload(DiskFileItemFactory factory) { ServletFileUpload upload = new ServletFileUpload(factory); // 监听长传进度 upload.setProgressListener(new ProgressListener() { // pBYtesRead:已读取到的文件大小 // pContextLength:文件大小 public void update(long pBytesRead, long pContentLength, int pItems) { System.out.println(\"总大小：\" + pContentLength + \"已上传：\" + pBytesRead); } }); // 处理乱码问题 upload.setHeaderEncoding(\"UTF-8\"); // 设置单个文件的最大值 upload.setFileSizeMax(1024 * 1024 * 10); // 设置总共能够上传文件的大小 // 1024 = 1kb * 1024 = 1M * 10 = 10м return upload; } public static String uploadParseRequest(ServletFileUpload upload, HttpServletRequest request, String uploadPath) throws FileUploadException, IOException { String msg = \"\"; // 把前端请求解析，封装成FileItem对象 List&lt;FileItem&gt; fileItems = upload.parseRequest(request); for (FileItem fileItem : fileItems) { if (fileItem.isFormField()) {// 判断上传的文件是普通的表单还是带文件的表单 // getFieldName指的是前端表单控件的name; String name = fileItem.getFieldName(); String value = fileItem.getString(\"UTF-8\"); // 处理乱码 System.out.println(name + \": \" + value); } else {// 判断它是上传的文件 // ============处理文件============== // 拿到文件名 String uploadFileName = fileItem.getName(); System.out.println(\"上传的文件名: \" + uploadFileName); if (uploadFileName.trim().equals(\"\") || uploadFileName == null) { continue; } // 获得上传的文件名/images/girl/paojie.png String fileName = uploadFileName.substring(uploadFileName.lastIndexOf(\"/\") + 1); // 获得文件的后缀名 String fileExtName = uploadFileName.substring(uploadFileName.lastIndexOf(\".\") + 1); /* * 如果文件后缀名fileExtName不是我们所需要的 就直按return.不处理,告诉用户文件类型不对。 */ System.out.println(\"文件信息[件名: \" + fileName + \" ---文件类型\" + fileExtName + \"]\"); // 可以使用UID（唯一识别的通用码),保证文件名唯 // 0UID. randomUUID(),随机生一个唯一识别的通用码; String uuidPath = UUID.randomUUID().toString(); // ================处理文件完毕============== // 存到哪? uploadPath // 文件真实存在的路径realPath String realPath = uploadPath + \"/\" + uuidPath; // 给每个文件创建一个对应的文件夹 File realPathFile = new File(realPath); if (!realPathFile.exists()) { realPathFile.mkdir(); } // ==============存放地址完毕============== // 获得文件上传的流 InputStream inputStream = fileItem.getInputStream(); // 创建一个文件输出流 // realPath =真实的文件夹; // 差了一个文件;加上翰出文件的名产\"/\"+uuidFileName FileOutputStream fos = new FileOutputStream(realPath + \"/\" + fileName); // 创建一个缓冲区 byte[] buffer = new byte[1024 * 1024]; // 判断是否读取完毕 int len = 0; // 如果大于0说明还存在数据; while ((len = inputStream.read(buffer)) &gt; 0) { fos.write(buffer, 0, len); } // 关闭流 fos.close(); inputStream.close(); msg = \"文件上传成功!\"; fileItem.delete(); // 上传成功,清除临时文件 //=============文件传输完成============= } } return msg; } } 注册xml &lt;servlet&gt; &lt;servlet-name&gt;upload&lt;/servlet-name&gt; &lt;servlet-class&gt;com.chen.FileSerlvet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;upload&lt;/servlet-name&gt; &lt;url-pattern&gt;/upload.do&lt;/url-pattern&gt; 导入依赖的jar包 &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; index.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;body&gt; &lt;%-- GET：上传文件大小有限制 POST：上传文件大小没有限制 ${pageContext.request.contextPath} --%&gt; &lt;form action=\"upload.do\" enctype=\"multipart/form-data\" method=\"post\"&gt; 上传用户：&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; &lt;P&gt;&lt;input type=\"file\" name=\"file1\"&gt;&lt;/P&gt; &lt;P&gt;&lt;input type=\"file\" name=\"file1\"&gt;&lt;/P&gt; &lt;P&gt;&lt;input type=\"submit\" value=\"提交\"&gt; | &lt;input type=\"reset\"&gt;&lt;/P&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; info.jsp &lt;%@ page language=\"java\" contentType=\"text/html;charset=UTF-8\"%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%=request.getAttribute(\"msg\")%&gt; &lt;/body&gt; &lt;/html&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"【狂神说Java】Spring5笔记存档","slug":"【狂神说Java】Spring5笔记存档","date":"2020-08-27T05:52:05.530Z","updated":"2020-09-18T04:43:03.300Z","comments":true,"path":"2020/08/27/【狂神说Java】Spring5笔记存档/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/27/%E3%80%90%E7%8B%82%E7%A5%9E%E8%AF%B4Java%E3%80%91Spring5%E7%AC%94%E8%AE%B0%E5%AD%98%E6%A1%A3/","excerpt":"","text":"视频：https://www.bilibili.com/video/BV1WE411d7Dv 1、Spring1.1、简介spring官网： https://spring.io/projects/spring-framework#overview 官方下载： https://repo.spring.io/release/org/springframework/spring/ GitHub： https://github.com/spring-projects/spring-framework Spring Web MVC： spring-webmvc最新版 &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; 1.2、优点 Spring是一个开源的免费框架（容器）！ Spring是一个轻量级的非入侵式的框架 控制反转（IOC），面向切面编程（AOP）！ 支持事务的处理，对框架整合的支持 开源免费容器，轻量级非侵入式，控制反转，面向切面，支持事务，支持框架整合 Spring是一个轻量级的控制反转(IOC)和面向切面(AOP)编程的框架 1.3、组成 1.4、扩展现代化的java开发 -&gt; 基于Spring的开发 2、IOC理论推导传统的调用 UserDao package dao; public interface UserDao { void getUser(); } UserDaoImp package dao; public class UserDaoImpl implements UserDao{ public void getUser() { System.out.println(\"默认获取用户数据\"); } } UserSevice package Service; public interface UserService { void getUser(); } UserServiceImp package Service; import dao.UserDao; import dao.UserDaoImpl; public class UserServiceImpl implements UserService{ UserDao userDao = new UserDaoImpl(); public void getUser(){ userDao.getUser(); } } 测试 package holle0; import Service.UserService; import Service.UserServiceImpl; public class MyTest0 { public static void main(String[] args) { // 用户实际调用的是业务层，dao层他们不需要接触 UserService userService = new UserServiceImpl(); userService.getUser(); } } 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！ 改良：我们使用一个Set接口实现。已经发生了革命性的变化！ //在Service层的实现类(UserServiceImpl)增加一个Set()方法 //利用set动态实现值的注入！ private UserDao userDao; public void setUserDao(UserDao userDao){ this.userDao = userDao; } set() 方法实际上是动态改变了 UserDao userDao 的 初始化部分（new UserDaoImpl()） 测试中加上 ((UserServiceImpl)userService).setUserDao(new UserDaoImpl()); 之前，程序是主动创建对象！控制权在程序猿手上！ 使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象！（主动权在客户手上） 本质上解决了问题，程序员不用再去管理对象的创建 系统的耦合性大大降低，可以更专注在业务的实现上 这是IOC（控制反转）的原型，反转(理解)：主动权交给了用户 IOC本质 3、HolleSpring在父模块中导入jar包 &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; pojo的Hello.java package pojo; public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return \"Holle [str=\" + str + \"]\"; } } 在resource里面的xml配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--在Spring中创建对象，在Spring这些都称为bean 类型 变量名 = new 类型(); Holle holle = new Holle(); bean = 对象(holle) id = 变量名(holle) class = new的对象(new Holle();) property 相当于给对象中的属性设值,让str=\"Spring\" --&gt; &lt;bean id=\"hello\" class=\"pojo.Hello\"&gt; &lt;property name=\"str\" value=\"Spring\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 测试类MyTest package holle1; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import pojo.Hello; public class MyTest { public static void main(String[] args) { //获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //我们的对象下能在都在spring·中管理了，我们要使用，直接取出来就可以了 Hello holle = (Hello) context.getBean(\"hello\"); System.out.println(holle.toString()); } } 核心用set注入，所以必须要有下面的se()方法 //Hello类 public void setStr(String str) { this.str = str; } 思考： IOC：对象由Spring 来创建，管理，装配！ 弹幕评论里面的理解： 原来这套程序是：你写好菜单买好菜，客人来了自己把菜炒好招待，就相当于你请人吃饭现在这套程序是：你告诉楼下餐厅，你要哪些菜，客人来的时候，餐厅把做好的你需要的菜送上来IoC：炒菜这件事，不再由你自己来做，而是委托给了第三方__餐厅来做 此时的区别就是，如果我还需要做其他的菜，我不需要自己搞菜谱买材料再做好，而是告诉餐厅，我要什么菜，什么时候要，你做好送来 . 在前面第一个module试试引入Spring &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDaomSql\" class=\"dao.UserDaoMysqlImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"userServiceImpl\" class=\"service.UserServiceImp\"&gt; &lt;!--ref引用spring中已经创建很好的对象--&gt; &lt;!--value是一个具体的值,基本数据类型--&gt; &lt;property name=\"userDao\" ref=\"userDaomSql\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 第一个module改良后测试 package holle0; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import service.UserServiceImpl; public class MyTest0 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean(\"userServiceImpl\"); userServiceImpl.getUser(); } } 总结： 所有的类都要装配的beans.xml 里面； 所有的bean 都要通过容器去取； 容器里面取得的bean，拿出来就是一个对象，用对象调用方法即可； 4、IOC创建对象的方式 使用无参构造创建对象，默认。 使用有参构造（如下） 下标赋值 index指的是有参构造中参数的下标，下标从0开始; &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;constructor-arg index=\"0\" value=\"chen\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 类型赋值（不建议使用） &lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"kuang\"/&gt; &lt;/bean&gt; 直接通过参数名（掌握） &lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;constructor-arg name=\"name\" value=\"kuang\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 比如参数名是name，则有name=\"具体值\" --&gt; 注册bean之后就对象的初始化了（类似 new 类名()） 弹幕评论： name方式还需要无参构造和set方法,index和type只需要有参构造 就算是new 两个对象，也是只有一个实例（单例模式：全局唯一） User user = (User) context.getBean(\"user\"); User user2 = (User) context.getBean(\"user\"); system.out.println(user == user2)//结果为true 总结：在配置文件加载的时候，容器(&lt; bean&gt;)中管理的对象就已经初始化了 5、Spring配置5.1、别名&lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;constructor-arg name=\"name\" value=\"chen\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;alias name=\"user\" alias=\"userLove\"/&gt; &lt;!-- 使用时 User user2 = (User) context.getBean(\"userLove\"); --&gt; 5.2、Bean的配置&lt;!--id：bean的唯一标识符，也就是相当于我们学的对象名 class：bean对象所对应的会限定名：包名+类型 name：也是别名，而且name可以同时取多个别名 --&gt; &lt;bean id=\"user\" class=\"pojo.User\" name=\"u1 u2,u3;u4\"&gt; &lt;property name=\"name\" value=\"chen\"/&gt; &lt;/bean&gt; &lt;!-- 使用时 User user2 = (User) context.getBean(\"u1\"); --&gt; 5.3、importimport一般用于团队开发使用，它可以将多个配置文件，导入合并为一个 假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的！ 张三(beans.xm1) 李四(beans2.xm1) 王五(beans3.xm1) applicationContext.xml &lt;import resource=\"beans.xm1\"/&gt; &lt;import resource=\"beans2.xml\"/&gt; &lt;import resource=\"beans3.xm1\"/&gt; 使用的时候，直接使用总的配置就可以了 弹幕评论： 按照在总的xml中的导入顺序来进行创建，后导入的会重写先导入的，最终实例化的对象会是后导入xml中的那个 6、依赖注入（DI）6.1、构造器注入第4点有提到 6.2、set方式注入【重点】依赖注入：set注入！ 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器来注入 【环境搭建】 复杂类型 Address类 真实测试对象 Student类 beans.xml 测试 MyTest3 Student类 package pojo; import java.util.*; @Get @Set public class Student { //别忘了写get和set方法（用lombok注解也行） private String name; private Address address; private String[] books; private List&lt;String&gt; hobbies; private Map&lt;String, String&gt; card; private Set&lt;String&gt; game; private Properties infor; private String wife; @Override public String toString() { return \"Student{\" +\"\\n\"+ \"name='\" + name + '\\'' +\"\\n\"+ \", address=\" + address.toString() +\"\\n\"+ \", books=\" + Arrays.toString(books) +\"\\n\"+ \", hobbies=\" + hobbies +\"\\n\"+ \", card=\" + card +\"\\n\"+ \", game=\" + game +\"\\n\"+ \", infor=\" + infor +\"\\n\"+ \", wife='\" + wife + '\\'' +\"\\n\"+ '}'; } } Address类 package pojo; public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \"Address{\" + \"address='\" + address + '\\'' + '}'; } } beans.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"address\" class=\"pojo.Address\"&gt; &lt;property name=\"address\" value=\"address你好\" /&gt; &lt;/bean&gt; &lt;bean id=\"student\" class=\"pojo.Student\"&gt; &lt;!--第一种，普通值注入 --&gt; &lt;property name=\"name\" value=\"name你好\" /&gt; &lt;!--第二种，ref注入 --&gt; &lt;property name=\"address\" ref=\"address\" /&gt; &lt;!--数组注入 --&gt; &lt;property name=\"books\"&gt; &lt;array&gt; &lt;value&gt;三国&lt;/value&gt; &lt;value&gt;西游&lt;/value&gt; &lt;value&gt;水浒&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--list列表注入 --&gt; &lt;property name=\"hobbies\"&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;rap&lt;/value&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--map键值对注入 --&gt; &lt;property name=\"card\"&gt; &lt;map&gt; &lt;entry key=\"username\" value=\"root\" /&gt; &lt;entry key=\"password\" value=\"root\" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--set(可去重)注入 --&gt; &lt;property name=\"game\"&gt; &lt;set&gt; &lt;value&gt;wangzhe&lt;/value&gt; &lt;value&gt;lol&lt;/value&gt; &lt;value&gt;galname&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--空指针null注入 --&gt; &lt;property name=\"wife\"&gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt; &lt;!--properties常量注入 --&gt; &lt;property name=\"infor\"&gt; &lt;props&gt; &lt;prop key=\"id\"&gt;20200802&lt;/prop&gt; &lt;prop key=\"name\"&gt;cbh&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; MyTest3 import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import pojo.Student; public class MyTest3 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student stu = (Student) context.getBean(\"student\"); System.out.println(stu.toString()); } } 6.3、拓展注入官方文档位置 pojo增加User类 package pojo; public class User { private String name; private int id; public User() { } public User(String name, int id) { super(); this.name = name; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return \"User [name=\" + name + \", id=\" + id + \"]\"; } } 注意： beans 里面加上这下面两行 使用p和c命名空间需要导入xml约束 xmlns:p=“http://www.springframework.org/schema/p”xmlns:c=“http://www.springframework.org/schema/c” ?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--p命名空间注入/set注入，可以直接注入属性的值-》property--&gt; &lt;bean id=\"user\" class=\"pojo.User\" p:name=\"cxk\" p:id=\"20\" &gt; &lt;/bean&gt; &lt;!--c命名空间，通过构造器注入，需要写入有参和无参构造方法-》construct-args--&gt; &lt;bean id=\"user2\" class=\"pojo.User\" c:name=\"cbh\" c:id=\"22\"&gt;&lt;/bean&gt; &lt;/beans&gt; 测试 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = context.getBean(\"user\",User.class);//确定class对象，就不用再强转了 System.out.println(user.toString()); 6.4、Bean作用域 单例模式（默认） &lt;bean id=\"user2\" class=\"pojo.User\" c:name=\"cxk\" c:age=\"19\" scope=\"singleton\"&gt;&lt;/bean&gt; 弹幕评论：单例模式是把对象放在pool中，需要再取出来，使用的都是同一个对象实例 原型模式: 每次从容器中get的时候，都产生一个新对象！ &lt;bean id=\"user2\" class=\"pojo.User\" c:name=\"cxk\" c:age=\"19\" scope=\"prototype\"&gt;&lt;/bean&gt; 其余的request、session、application这些只能在web开放中使用！ 7、Bean的自动装配 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文自动寻找，并自动给bean装配属性 在Spring中有三种装配的方式 在xml中显示配置 在java中显示配置 隐式的自动装配bean 【重要】 环境搭建：一个人有两个宠物 byType自动装配：byType会自动查找，和自己对象set方法参数的类型相同的bean 保证所有的class唯一(类为全局唯一) byName自动装配：byName会自动查找，和自己对象set对应的值对应的id 保证所有id唯一，并且和set注入的值一致 &lt;!-- 找不到id和多个相同class --&gt; &lt;bean id=\"cat1\" class=\"pojo.Cat\"/&gt; &lt;bean id=\"cat2\" class=\"pojo.Cat\"/&gt; 找不到 id=cat，且有两个Cat 7.1测试：自动装配pojo的Cat类 public class Cat { public void shut(){ System.out.println(\"miao\"); } } pojo的Dog类 public class Dog { public void shut(){ System.out.println(\"wow\"); } } pojo的People类 package pojo; public class People { private Cat cat; private Dog dog; private String name; public Cat getCat() { return cat; } public void setCat(Cat cat) { this.cat = cat; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"People{\" + \"cat=\" + cat + \", dog=\" + dog + \", name='\" + name + '\\'' + '}'; } } xml配置 -&gt; byType 自动装配 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"cat\" class=\"pojo.Cat\"/&gt; &lt;bean id=\"dog\" class=\"pojo.Dog\"/&gt; &lt;!--byType会在容器自动查找，和自己对象属性相同的bean 例如，Dog dog; 那么就会查找pojo的Dog类，再进行自动装配 --&gt; &lt;bean id=\"people\" class=\"pojo.People\" autowire=\"byType\"&gt; &lt;property name=\"name\" value=\"cbh\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; xml配置 -&gt; byName 自动装配 &lt;bean id=\"cat\" class=\"pojo.Cat\"/&gt; &lt;bean id=\"dog\" class=\"pojo.Dog\"/&gt; &lt;!--byname会在容器自动查找，和自己对象set方法的set后面的值对应的id 例如:setDog()，取set后面的字符作为id，则要id = dog 才可以进行自动装配 --&gt; &lt;bean id=\"people\" class=\"pojo.People\" autowire=\"byName\"&gt; &lt;property name=\"name\" value=\"cbh\"&gt;&lt;/property&gt; &lt;/bean&gt; 弹幕评论：byName只能取到小写，大写取不到 7.2、使用注解实现自动装配jdk1.5支持的注解，spring2.5支持的注解 The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.（翻译：基于注释的配置的引入提出了一个问题，即这种方法是否比XML“更好”） 导入context约束 xmlns:context=”http://www.springframework.org/schema/context\" 配置注解的支持：&lt; context:annotation-config/&gt; &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;/beans&gt; 7.2.1、@Autowired默认是byType方式，如果匹配不上，就会byName 在属性上个使用，也可以在set上使用 我们可以不用编写set方法了，前提是自动装配的属性在Spring容器里，且要符合ByName 自动装配 public class People { @Autowired private Cat cat; @Autowired private Dog dog; private String name; } @Nullable 字段标记了这个注解，说明该字段可以为空 public name(@Nullable String name){ } //源码 public @interface Autowired { boolean required() default true; } 如果定义了Autowire的require属性为false，说明这个对象可以为null，否则不允许为空（false表示找不到装配，不抛出异常） 7.2.2、@Autowired+@Qualifier@Autowired不能唯一装配时，需要@Autowired+@Qualifier 如果@Autowired自动装配环境比较复杂。自动装配无法通过一个注解完成的时候，可以使用@Qualifier(value = “dog”)去配合使用，指定一个唯一的id对象 public class People { @Autowired private Cat cat; @Autowired @Qualifier(value = \"dog\") private Dog dog; private String name; } 弹幕评论： 如果xml文件中同一个对象被多个bean使用，Autowired无法按类型找到，可以用@Qualifier指定id查找 7.2.3、@Resource默认是byName方式，如果匹配不上，就会byType public class People { Resource(name=\"cat\") private Cat cat; Resource(name=\"dog\") private Dog dog; private String name; } 弹幕评论： Autowired是byType，@Autowired+@Qualifier = byType || byName Autowired是先byteType,如果唯一則注入，否则byName查找。resource是先byname,不符合再继续byType 区别：@Resource和@Autowired的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】 @Resource默认通过byname的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！【常用】 执行顺序不同：@Autowired通过byType的方式实现。@Resource默认通过byname的方式实现 8、使用注解开发在spring4之后，使用注解开发，必须要保证aop包的导入使用注解需要导入contex的约束 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;/beans&gt; 8.1、bean弹幕评论：有了&lt; context:component-scan&gt;，另一个&lt; context:annotation-config/&gt;标签可以移除掉，因为已经被包含进去了。 &lt;!--指定要扫描的包，这个包下面的注解才会生效 别只扫一个com.kuang.pojo包--&gt; &lt;context:component-scan base-package=\"com.kuang\"/&gt; &lt;context:annotation-config/&gt; 1234 //@Component 组件 //等价于&lt;bean id=\"user\" classs\"pojo.User\"/&gt; @Component public class User { public String name =\"秦疆\"; } 8.2、属性如何注入@value@Component public class User { //相当于&lt;property name=\"name\" value=\"kuangshen\"/&gt; @value(\"kuangshen\") public String name; //也可以放在set方法上面 //@value(\"kuangshen\") public void setName(String name) { this.name = name; } } 8.3、衍生的注解@Component有几个衍生注解，会按照web开发中，mvc架构中分层。 dao （@Repository） service（@Service） controller（@Controller） 这四个注解的功能是一样的，都是代表将某个类注册到容器中 8.4、自动装配置@Autowired：默认是byType方式，如果匹配不上，就会byName @Nullable：字段标记了这个注解，说明该字段可以为空 @Resource：默认是byName方式，如果匹配不上，就会byType 8.5、作用域@scope//原型模式prototype，单例模式singleton //scope(\"prototype\")相当于&lt;bean scope=\"prototype\"&gt;&lt;/bean&gt; @Component @scope(\"prototype\") public class User { //相当于&lt;property name=\"name\" value=\"kuangshen\"/&gt; @value(\"kuangshen\") public String name; //也可以放在set方法上面 @value(\"kuangshen\") public void setName(String name) { this.name = name; } } 8.6、小结xml与注解： xml更加万能，维护简单，适用于任何场合 注解，不是自己的类使用不了，维护复杂 最佳实践： xml用来管理bean 注解只用来完成属性的注入 要开启注解支持 9、使用Java的方式配置Spring不使用Spring的xml配置，完全交给java来做！ Spring的一个子项目，在spring4之后，，，它成为了核心功能 实体类：pojo的User.java //这里这个注解的意思,就是说明这个类被Spring接管了,注册到了容器中 @component public class User { private String name; public String getName() { return name; } //属性注入值 @value(\"QINJIANG') public void setName(String name) { this.name = name; } @Override public String toString() { return \"user{\" + \"name='\" + name + '\\''+ '}'; } } 弹幕评论：要么使用@Bean，要么使用@Component和ComponentScan，两种效果一样 配置文件：config中的kuang.java @Import(KuangConfig2.class)，用@import来包含KuangConfig2.java //这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于&lt;beans&gt;标签 @Configuration @componentScan(\"com.Kuang.pojo\") //开启扫描 //@Import(KuangConfig2.class) public class KuangConfig { //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -&gt;getUser //这个方法的返同值,就相当于bean 标签中的class 属性 -&gt;User //@Bean public User getUser(){ return new User(); //就是返回要注入到bean的对象! } } 弹幕评论：ComponentScan、@Component(“pojo”) 这两个注解配合使用 测试类 public class MyTest { public static void main(String[ ] args) { //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象 User getUser =(User)context.getBean( \"getUser\"); //方法名getUser System.out.Println(getUser.getName()); } } 会创建两个相同对象问题的说明： 弹幕总结 - -&gt; @Bean是相当于&lt; bean&gt;标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了 //这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于&lt;beans&gt;标签 @Configuration @componentScan(\"com.Kuang.pojo\") //开启扫描 //@Import(KuangConfig2.class) public class KuangConfig { //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -&gt;getUser //这个方法的返同值,就相当于bean 标签中的class 属性 -&gt;User //@Bean public User getUser(){ return new User(); //就是返回要注入到bean的对象! } } 弹幕评论：ComponentScan、@Component(“pojo”) 这两个注解配合使用 测试类 public class MyTest { public static void main(String[ ] args) { //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象 User getUser =(User)context.getBean( \"getUser\"); //方法名getUser System.out.Println(getUser.getName()); } } 会创建两个相同对象问题的说明： 弹幕总结 - -&gt; @Bean是相当于&lt; bean&gt;标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了 10、代理模式为什么要学代理模式？ 因为这个就是SpringAOP的底层！【SpringAOP 和 SpringMVC】 分类： 动态代理 静态代理 10.1、静态代理代码步骤： 1、接口 package pojo; public interface Host { public void rent(); } 2、真实角色 package pojo; public class HostMaster implements Host{ public void rent() { System.out.println(\"房东要出租房子\"); } } 3、代理角色 package pojo; public class Proxy { public Host host; public Proxy() { } public Proxy(Host host) { super(); this.host = host; } public void rent() { seeHouse(); host.rent(); fee(); sign(); } //看房 public void seeHouse() { System.out.println(\"看房子\"); } //收费 public void fee() { System.out.println(\"收中介费\"); } //合同 public void sign() { System.out.println(\"签合同\"); } } 4、客户端访问代理角色 package holle4_proxy; import pojo.Host; import pojo.HostMaster; import pojo.Proxy; public class My { public static void main(String[] args) { //房东要出租房子 Host host = new HostMaster(); //中介帮房东出租房子，但也收取一定费用（增加一些房东不做的操作） Proxy proxy = new Proxy(host); //看不到房东，但通过代理，还是租到了房子 proxy.rent(); } } 代码翻倍：几十个真实角色就得写几十个代理 AOP横向开发 10.2、动态代理动态代理和静态角色一样，动态代理底层是反射机制 动态代理类是动态生成的，不是我们直接写好的！ 动态代理(两大类)：基于接口，基于类 基于接口：JDK的动态代理【使用ing】 基于类：cglib java字节码实现：javasisit 了解两个类1、Proxy：代理2、InvocationHandler：调用处理程序 实例： 接口 Host.java //接口 package pojo2; public interface Host { public void rent(); } 接口Host实现类 HostMaster.java //接口实现类 package pojo2; public class HostMaster implements Host{ public void rent() { System.out.println(\"房东要租房子\"); } } 代理角色的处理程序类 ProxyInvocationHandler.java package pojo2; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; ///用这个类，自动生成代理 public class ProxyInvocationHandler implements InvocationHandler { // Foo f =(Foo) Proxy.NewProxyInstance(Foo. Class.GetClassLoader(), // new Class&lt;?&gt;[] { Foo.Class }, // handler); // 被代理的接口 public HostMaster hostMaster ; public void setHostMaster(HostMaster hostMaster) { this.hostMaster = hostMaster; } // 得到生成的代理类 public Object getProxy() { // newProxyInstance() -&gt; 生成代理对象，就不用再写具体的代理类了 // this.getClass().getClassLoader() -&gt; 找到加载类的位置 // hostMaster.getClass().getInterfaces() -&gt; 代理的具体接口 // this -&gt; 代表了接口InvocationHandler的实现类ProxyInvocationHandler return Proxy.newProxyInstance(this.getClass().getClassLoader(), hostMaster.getClass().getInterfaces(), this); // 处理代理实例并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { seeHouse(); // 动态代理的本质，就是使用反射机制实现的 // invoke()执行它真正要执行的方法 Object result = method.invoke(hostMaster, args); fee(); return result; } public void seeHouse() { System.out.println(\"看房子\"); } public void fee() { System.out.println(\"收中介费\"); } } 用户类 My2.java package holle4_proxy; import pojo2.Host; import pojo2.Host2; import pojo2.HostMaster; import pojo2.ProxyInvocationHandler; public class My2 { public static void main(String[] args) { //真实角色 HostMaster hostMaster = new HostMaster(); //代理角色，现在没有；用代理角色的处理程序来实现Host接口的调用 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //pih -&gt; HostMaster接口类 -&gt; Host接口 pih.setHostMaster(hostMaster); //获取newProxyInstance动态生成代理类 Host proxy = (Host) pih.getProxy(); proxy.rent(); } } 弹幕评论：什么时候调用invoke方法的?代理实例调用方法时invoke方法就会被调用，可以debug试试 改为万能代理类 ///用这个类，自动生代理 public class ProxyInvocationHandler implements InvocationHandler { // Foo f =(Foo) Proxy.NewProxyInstance(Foo. Class.GetClassLoader(), // new Class&lt;?&gt;[] { Foo.Class }, // handler); // 被代理的接口 public Object target; public void setTarget(Object target) { this.target = target; } // 得到生成的代理类 -&gt; 固定的代码 public Object getProxy() { // newProxyInstance() -&gt; 生成代理对象，就不用再写具体的代理类了 // this.getClass().getClassLoader() -&gt; 找到加载类的位置 // hostMaster.getClass().getInterfaces() -&gt; 代理的具体接口 // this -&gt; 代表了接口InvocationHandler的实现类ProxyInvocationHandler return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // 处理代理实例并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //前置通知 pre(); //打印日志,通过反射的方式 log(method.getName()); // 动态代理的本质，就是使用反射机制实现的 // invoke()执行它真正要执行的方法 Object result = method.invoke(target, args); //后置通知 post(); return result; } public void pre() { System.out.println(\"[前置通知]\"); } public void post() { System.out.println(\"[后置通知]\"); } //日志打印 public void log(String msg) { System.out.println(\"[Debug]执行了\" + msg + \"方法\"); } } 测试类： public class Client { public static void main(String[] args) { //真实角色 UserServiceImpl userService = new UserServiceImpl(); //代理角色,不存在 ProxyInvocationHandler proxyInvocationHandler = new ProxyInvocationHandler(); //设置要代理的对象 proxyInvocationHandler.setTarget(userService); //动态生产代理类 UserService proxy = (UserService) proxyInvocationHandler.getProxy(); //执行业务操作 proxy.add(); } } 11、AOP11.1、什么是AOP 11.2、AOP在Spring中的使用提供声明式事务，允许用户自定义切面 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等… 切面(Aspect)：横切关注点 被模块化的特殊对象。即，它是一个类。（Log类） 通知(Advice)：切面必须要完成的工作。即，它是类中的一个方法。（Log类中的方法） 目标(Target)：被通知对象。（生成的代理类) 代理(Proxy)：向目标对象应用通知之后创建的对象。（生成的代理类） 切入点(PointCut)：切面通知执行的”地点”的定义。（最后两点：在哪个地方执行，比如：method.invoke()） 连接点(JointPoint)：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即AOP在不改变原有代码的情况下，去增加新的功能。（代理） 11.3、使用Spring实现AOP【重点】 使用AOP织入，需要导入一个依赖包！ &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; 11.3.1、方法一：使用原生spring接口springAPI接口实现 需要先导入aop约束 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;/beans&gt; applicationContext.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--注册bean--&gt; &lt;bean id=\"userservice\" class=\"service.UserServiceImpl\"/&gt; &lt;bean id=\"log\" class=\"log.Log\"/&gt; &lt;bean id=\"afterLog\" class=\"log.AfterLog\"/&gt; &lt;!--方式一，使用原生Spring API接口--&gt; &lt;!--配置aop,还需要导入aop约束--&gt; &lt;aop:config&gt; &lt;!--切入点：expression:表达式，execution（要执行的位置）--&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* service.UserServiceImpl.*(..))\"/&gt; &lt;!--UserServiceImpl.*(..) -》 UserServiceImpl类下的所以方法(参数)--&gt; &lt;!--执行环绕增加--&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/&gt; &lt;!-- 环绕,在id=\"pointcut\"的前后切入 --&gt; &lt;/aop:config&gt; &lt;/beans&gt; execution(返回类型，类名，方法名(参数)) -&gt; execution(* com.service.*,*(…)) UserService.java package service; public interface UserService { public void add() ; public void delete() ; public void query() ; public void update(); } UserService 的实现类 UserServiceImp.java package service; public class UserServiceImpl implements UserService { public void add() { System.out.println(\"add增\"); } public void delete() { System.out.println(\"delete删\"); } public void update() { System.out.println(\"update改\"); } public void query() { System.out.println(\"query查\"); } } 前置Log.java package log; import org.springframework.aop.MethodBeforeAdvice; import java.lang.reflect.Method; public class Log implements MethodBeforeAdvice { //method：要执行的目标对象的方法 //args：参数 //target：目标对象 public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); } } 后置AfterLog.java package log; import java.lang.reflect.Method; import org.springframework.aop.AfterReturningAdvice; public class AfterLog implements AfterReturningAdvice { //returnVaule: 返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\"执行了\"+method.getName()+\"方法，返回值是\"+returnValue); } } 测试类MyTest5 import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import service.UserService; public class MyTest5 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //注意:动态代理代理的是接口 UserService userService = (UserService) context.getBean(\"userservice\"); userService.add(); } } 11.3.2、方法二：自定义类实现AOP&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--注册bean--&gt; &lt;bean id=\"userservice\" class=\"service.UserServiceImpl\"/&gt; &lt;bean id=\"log\" class=\"log.Log\"/&gt; &lt;bean id=\"afterLog\" class=\"log.AfterLog\"/&gt; &lt;!-- 方式二，自定义 --&gt; &lt;bean id=\"diy\" class=\"diy.DiyPointcut\"/&gt; &lt;aop:config&gt; &lt;!--自定义切面--&gt; &lt;aop:aspect ref=\"diy\"&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=\"point\" expression=\"execution(* service.UserServiceImpl.*(..))\"/&gt; &lt;aop:before method=\"before\" pointcut-ref=\"point\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"point\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;/beans&gt; package diy; public class DiyPointcut { public void before(){ System.out.println(\"插入到前面\"); } public void after(){ System.out.println(\"插入到后面\"); } } //测试 public class MyTest5 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //注意:动态代理代理的是接口 UserService userService = (UserService) context.getBean(\"userservice\"); userService.add(); } } 11.3.3、方法三：使用注解实现&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 注册 --&gt; &lt;bean id=\"userservice\" class=\"service.UserServiceImpl\"/&gt; &lt;!--方式三，使用注解实现--&gt; &lt;bean id=\"diyAnnotation\" class=\"diy.DiyAnnotation\"&gt;&lt;/bean&gt; &lt;!-- 开启自动代理 实现方式：默认JDK (proxy-targer-class=\"fasle\") cglib (proxy-targer-class=\"true\")--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;/beans&gt; DiyAnnotation.java package diy; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; @Aspect //标注这个类是一个切面 public class DiyAnnotation { @Before(\"execution(* service.UserServiceImpl.*(..))\") public void before(){ System.out.println(\"=====方法执行前=====\"); } @After(\"execution(* service.UserServiceImpl.*(..))\") public void after(){ System.out.println(\"=====方法执行后=====\"); } //在环绕增强中，我们可以给地暖管一个参数，代表我们要获取切入的点 @Around(\"execution(* service.UserServiceImpl.*(..))\") public void around(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\"环绕前\"); Object proceed = joinPoint.proceed(); System.out.println(\"环绕后\"); } } 测试 public class MyTest5 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //注意:动态代理代理的是接口 UserService userService = (UserService) context.getBean(\"userservice\"); userService.add(); } } 输出结果： 12、整合mybatis 【提醒】： 本节知识密度大，时间长，需要多看几遍视频，加深理解 视频链接：https://www.bilibili.com/video/BV1WE411d7Dv?p=23 步骤： 导入相关jar junit mybatis mysql数据库 spring相关的 aop织入 mybatis-spring【new】 编写配置文件 测试 mybatis-spring官网：https://mybatis.org/spring/zh/ 12.0、回忆Mybatismybatis的配置流程： 编写实体类 编写核心配置文件 编写接口 编写Mapper.xmi 测试 实例： 导入相关jar，pom.xml： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-study&lt;/artifactId&gt; &lt;groupId&gt;com.melodyhub&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;spring-10-mybatis&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;!--&lt;version&gt;5.1.47&lt;/version&gt;--&gt; &lt;version&gt;8.0.19&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring操作数据库的话，需要一个spring-jdbc--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--在build中配置resources，来防止资源导出失败的问题--&gt; &lt;!-- Maven解决静态资源过滤问题 --&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!--&lt;filtering&gt;false&lt;/filtering&gt;--&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!--&lt;filtering&gt;true&lt;/filtering&gt;--&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;/project&gt; 编写实体类，User.java： package com.melodyhub.pojo; import lombok.Data; @Data public class User { private int id; private String name; private String pwd; } 编写核心配置文件，resources/mybatis-config.xml： &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;!--configuration 核心配置文件--&gt; &lt;configuration&gt; &lt;!--开启日志--&gt; &lt;!--&lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;/settings&gt;--&gt; &lt;!--可以给实体类起别名 --&gt; &lt;typeAliases&gt; &lt;package name=\"com.melodyhub.pojo\"/&gt; &lt;/typeAliases&gt; &lt;!--environments 可配置多个环境--&gt; &lt;environments default=\"development\"&gt; &lt;!--多个环境，不同id--&gt; &lt;environment id=\"development\"&gt; &lt;!--事务管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--&lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt;--&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;autoReconnect=true\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册！！！--&gt; &lt;mappers&gt; &lt;mapper class=\"com.melodyhub.mapper.UserMapper\"/&gt; &lt;!--&lt;mapper resource=\"com/melodyhub/mapper/UserMapper.xml\"/&gt;--&gt; &lt;/mappers&gt; &lt;/configuration&gt; 编写接口，UserMapper.xml： package com.melodyhub.mapper; import com.melodyhub.pojo.User; import java.util.List; public interface UserMapper { public List&lt;User&gt; selectUser(); } 编写接口配置文件，UserMapper.xml： &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.melodyhub.mapper.UserMapper\"&gt; &lt;!-- 绑定接口 --&gt; &lt;select id=\"selectUser\" resultType=\"user\"&gt; select * from mybatis.user; &lt;/select&gt; &lt;/mapper&gt; 测试，test/java/MyTest.java： import com.melodyhub.mapper.UserMapper; import com.melodyhub.pojo.User; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Test; import org.apache.ibatis.io.Resources; import java.io.IOException; import java.io.InputStream; import java.util.List; public class MyTest { @Test public void test() throws IOException { String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.selectUser(); for (User user : userList) { System.out.println(user); } } } 结果： User(id=1, name=狂神, pwd=123456) User(id=2, name=张三, pwd=abcdef) User(id=3, name=李四, pwd=987654) Process finished with exit code 0 12.1、mybatis-spring-方式一 编写数据源配置 sqISessionFactory sqISessionTemplate（相当于sqISession） 需要给接口加实现类【new】 将自己写的实现类，注入到Spring中 测试！ 数据源： DataSource：使用Spring的数帮源替换Mybatis的配置 这使用Spring提供的JDBC：org.springframework.jdbc.datasource 其他数据源：c3p0、dbcp、druid 【核心对象】： sqISessionFactory 在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。 而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。 文档：http://mybatis.org/spring/zh/factorybean.html sqISessionTemplate SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。SqlSessionTemplate 是线程安全的，可以被多个 DAO 或映射器所共享使用。 当调用 SQL 方法时（包括由 getMapper() 方法返回的映射器中的方法），SqlSessionTemplate 将会保证使用的 SqlSession 与当前 Spring 的事务相关。此外，它管理 session 的生命周期，包含必要的关闭、提交或回滚操作。另外，它也负责将 MyBatis 的异常翻译成 Spring 中的 DataAccessExceptions。 由于模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。 可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。 文档：http://mybatis.org/spring/zh/sqlsession.html 先导入jar包， &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-study&lt;/artifactId&gt; &lt;groupId&gt;com.melodyhub&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;spring-10-mybatis&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;!--&lt;version&gt;5.1.47&lt;/version&gt;--&gt; &lt;version&gt;8.0.19&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring操作数据库的话，需要一个spring-jdbc--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--在build中配置resources，来防止资源导出失败的问题--&gt; &lt;!-- Maven解决静态资源过滤问题 --&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!--&lt;filtering&gt;false&lt;/filtering&gt;--&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!--&lt;filtering&gt;true&lt;/filtering&gt;--&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;/project&gt; 关于解决“Maven解决静态资源过滤问题”详见：Maven中静态资源和字节码文件的过滤 编写顺序： User -&gt; UserMapper -&gt; UserMapper.xml -&gt; spring-dao.xml -&gt; UserServiceImpl -&gt; applicationContext.xml -&gt; MyTest6 代码步骤： pojo实体类 User： package com.melodyhub.pojo; import lombok.Data; @Data public class User { private int id; private String name; private String pwd; } mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml 接口UserMapper： package com.melodyhub.mapper; import com.melodyhub.pojo.User; import java.util.List; public interface UserMapper { public List&lt;User&gt; selectUser(); } UserMapperImpl： package com.melodyhub.mapper; import com.melodyhub.pojo.User; import org.mybatis.spring.SqlSessionTemplate; import java.util.List; public class UserMapperImpl implements UserMapper { //我们的所有操作，在原来都使用sqlSession来执行，现在都使用SqlSessionTemplate； private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List&lt;User&gt; selectUser() { UserMapper userMapper = sqlSession.getMapper(UserMapper.class); return userMapper.selectUser(); } } UserMapper.xml： &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.melodyhub.mapper.UserMapper\"&gt; &lt;!-- 绑定接口 --&gt; &lt;select id=\"selectUser\" resultType=\"user\"&gt; select * from mybatis.user; &lt;/select&gt; &lt;/mapper&gt; resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml mybatis-config.xml： &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;!--configuration 核心配置文件--&gt; &lt;configuration&gt; &lt;!--开启日志--&gt; &lt;!--&lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;/settings&gt;--&gt; &lt;!--可以给实体类起别名 --&gt; &lt;typeAliases&gt; &lt;package name=\"com.melodyhub.pojo\"/&gt; &lt;/typeAliases&gt; &lt;!--environments 可配置多个环境--&gt; &lt;!--配置了Spring-Dao.xml后，这块可以直接注释掉了：dataSource &lt;environments default=\"development\"&gt; &amp;lt;!&amp;ndash;多个环境，不同id&amp;ndash;&amp;gt; &lt;environment id=\"development\"&gt; &amp;lt;!&amp;ndash;事务管理&amp;ndash;&amp;gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &amp;lt;!&amp;ndash;&lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt;&amp;ndash;&amp;gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=GMT%2B8&amp;amp;autoReconnect=true\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;--&gt; &lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册！！！--&gt; &lt;!-- 配置了Spring-Dao.xml后，这块可以直接注释掉了：绑定Mybatis配置文件 &lt;mappers&gt; &lt;mapper class=\"com.melodyhub.mapper.UserMapper\"/&gt; &amp;lt;!&amp;ndash;&lt;mapper resource=\"com/melodyhub/mapper/UserMapper.xml\"/&gt;&amp;ndash;&amp;gt; &lt;/mappers&gt;--&gt; &lt;/configuration&gt; spring-dao.xml： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--DataSource:使用Spring的数帮源替换Mybatis的配置 其他数据源：c3p0、dbcp、druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --&gt; &lt;!--dataSource --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=GMT%2B8&amp;amp;autoReconnect=true\"/&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;!--绑定 Mybatis 配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/melodyhub/mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!-- sqlSessionTemplate 就是之前使用的：sqlsession --&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;!-- 只能使用构造器注入sqlSessionFactory 原因：它没有set方法--&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; &lt;/beans&gt; applicationContext.xml： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--导入其他配置文件--&gt; &lt;import resource=\"spring-dao.xml\"/&gt; &lt;!--&lt;import resource=\"spring-mvc.xml\"/&gt;--&gt; &lt;!--mybatis-spring 方式1--&gt; &lt;bean id=\"userMapper\" class=\"com.melodyhub.mapper.UserMapperImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 测试类： import com.melodyhub.mapper.UserMapper; import com.melodyhub.pojo.User; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Test; import org.apache.ibatis.io.Resources; import org.springframework.context.support.ClassPathXmlApplicationContext; import java.io.IOException; import java.io.InputStream; import java.util.List; public class MyTest { @Test public void test1() { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class); for (User user : userMapper.selectUser()) { System.out.println(user); } } } 12.2、mybatis-spring-方式二 SqlSessionDaoSupport SqlSessionDaoSupport 是一个抽象的支持类，用来为你提供 SqlSession。调用 getSqlSession() 方法你会得到一个 SqlSessionTemplate，之后可以用于执行 SQL 方法，就像下面这样: public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao { public User getUser(String userId) { return getSqlSession().selectOne(\"org.mybatis.spring.sample.mapper.UserMapper.getUser\", userId); } } 在这个类里面，通常更倾向于使用 MapperFactoryBean，因为它不需要额外的代码。但是，如果你需要在 DAO 中做其它非 MyBatis 的工作或需要一个非抽象的实现类，那么这个类就很有用了。 SqlSessionDaoSupport 需要通过属性设置一个 sqlSessionFactory 或 SqlSessionTemplate。如果两个属性都被设置了，那么 SqlSessionFactory 将被忽略。 假设类 UserMapperImpl 是 SqlSessionDaoSupport 的子类，可以编写如下的 Spring 配置来执行设置： &lt;bean id=\"userDao\" class=\"org.mybatis.spring.sample.dao.UserDaoImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" /&gt; &lt;/bean&gt; 文档：http://mybatis.org/spring/zh/sqlsession.html UserServiceImpl2.java： package com.melodyhub.mapper; import com.melodyhub.pojo.User; import org.apache.ibatis.session.SqlSession; import org.mybatis.spring.support.SqlSessionDaoSupport; import java.util.List; public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper { @Override public List&lt;User&gt; selectUser() { /* SqlSession sqlSession = getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); return userMapper.selectUser(); */ return getSqlSession().getMapper(UserMapper.class).selectUser(); } } spring-dao.xml：SqlSessionTemplate可以不写了 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--DataSource:使用Spring的数帮源替换Mybatis的配置 其他数据源：c3p0、dbcp、druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --&gt; &lt;!--dataSource --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=GMT%2B8&amp;amp;autoReconnect=true\"/&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;!--绑定 Mybatis 配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/melodyhub/mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!-- 方法二：SqlSessionTemplate 可以不写了--&gt; &lt;/beans&gt; applicationContext.xml： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--导入其他配置文件--&gt; &lt;import resource=\"spring-dao.xml\"/&gt; &lt;!--&lt;import resource=\"spring-mvc.xml\"/&gt;--&gt; &lt;!--mybatis-spring 方式-2--&gt; &lt;bean id=\"userMapper2\" class=\"com.melodyhub.mapper.UserMapperImpl2\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 测试： public class MyTest6 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = (UserMapper) context.getBean(\"userMapper2\"); for (User user : userMapper.getUser()) { System.out.println(user); } } } 13. 声明式事务 把一组业务当成一个业务来做；要么都成功，要么都失败！ 事务在项目开发中，十分的重要，涉及到数据的一致性问题 确保完整性和一致性 事务的ACID原则：1、原子性2、隔离性3、一致性4、持久性 ACID参考文章：https://www.cnblogs.com/melodyjerry/p/13621129.html Spring中的事务管理 声明式事务：AOP 编程式事务：需要再代码中，进行事务管理 声明式事务 先导入jar包 &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--在build中配置resources，来防止资源导出失败的问题--&gt; &lt;!-- Maven解决静态资源过滤问题 --&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 代码步骤： pojo实体类 User package pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class User { private int id; private String name; private String pwd; } mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml 接口UserMapper package mapper; import java.util.List; import org.apache.ibatis.annotations.Param; import pojo.User; public interface UserMapper { public List&lt;User&gt; getUser(); public int insertUser(User user); public int delUser(@Param(\"id\") int id); } UserMapperImpl package mapper; import pojo.User; import org.apache.ibatis.session.SqlSession; import org.mybatis.spring.support.SqlSessionDaoSupport; import java.util.List; public class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper { public List&lt;User&gt; getUser() { User user = new User(5,\"你好\",\"ok\"); insertUser(user); delUser(5); SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); //或者return getSqlSession().getMapper(UserMapper.class).getUser(); } //插入 public int insertUser(User user) { return getSqlSession().getMapper(UserMapper.class).insertUser(user); } //删除 public int delUser(int id) { return getSqlSession().getMapper(UserMapper.class).delUser(id); } } UserMapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- 绑定接口 --&gt; &lt;mapper namespace=\"mapper.UserMapper\"&gt; &lt;select id=\"getUser\" resultType=\"pojo.User\"&gt; select * from mybatis.mybatis &lt;/select&gt; &lt;insert id=\"insertUser\" parameterType=\"pojo.User\" &gt; insert into mybatis.mybatis (id,name,pwd) values (#{id},#{name},#{pwd}) &lt;/insert&gt; &lt;delete id=\"delUser\" parameterType=\"_int\"&gt; deleteAAAAA from mybatis.mybatis where id = #{id} &lt;!-- deleteAAAAA是故意写错的 --&gt; &lt;/delete&gt; &lt;/mapper&gt; resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml mybatis-config.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;!-- configuration --&gt; &lt;configuration&gt; &lt;!--开启日志--&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;/settings&gt; &lt;!--可以给实体类起别名--&gt; &lt;typeAliases&gt; &lt;package name=\"pojo\" /&gt; &lt;/typeAliases&gt; &lt;/configuration&gt; spring-dao.xml（已导入约束） &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--data source --&gt; &lt;bean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai\"/&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"datasource\" /&gt; &lt;!--绑定 mybatis 配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!--声明式事务--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;constructor-arg ref=\"datasource\" /&gt; &lt;/bean&gt; &lt;!--结合aop实现事务织入--&gt; &lt;!--配置事务的通知类--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!--给哪些方法配置事务--&gt; &lt;!--新东西：配置事务的传播特性 propagation--&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"add\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"query\" read-only=\"true\"/&gt; &lt;!-- *号包含上面4个方法： &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt; --&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置事务切入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"txpointcut\" expression=\"execution(* mapper.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txpointcut\"/&gt; &lt;/aop:config&gt; &lt;/beans&gt; applicationContext.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;import resource=\"spring-dao.xml\" /&gt; &lt;bean id=\"userMapper\" class=\"mapper.UserMapperImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 测试类 import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import mapper.UserMapper;import pojo.User; public class MyTest7 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = (UserMapper) context.getBean(\"userMapper\"); for (User user : userMapper.getUser()) { System.out.println(user); } } } 思考：为什么需要事务？ 如果不配置事务，可能存在数据提交不一致的情况下； 如果不在spring中去配置声明式事务，我们就需要在代码中手动配置事务！ 事务在项目的开发中非常重要，涉及到数据的一致性和完整性问题！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"【狂神说Java】SpringMVC笔记存档","slug":"【狂神说Java】SpringMVC笔记存档","date":"2020-08-27T05:52:05.512Z","updated":"2020-09-18T04:43:03.304Z","comments":true,"path":"2020/08/27/【狂神说Java】SpringMVC笔记存档/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/27/%E3%80%90%E7%8B%82%E7%A5%9E%E8%AF%B4Java%E3%80%91SpringMVC%E7%AC%94%E8%AE%B0%E5%AD%98%E6%A1%A3/","excerpt":"视频：https://www.bilibili.com/video/BV1aE41167Tu","text":"视频：https://www.bilibili.com/video/BV1aE41167Tu SpringMVCssm: mybatis + Spring + SpringMVC MVC三层架构 JavaSE:认真学习, 老师带，入门快JavaWeb:认真学习,老师带,入门快SSM框架:研究官方文档，锻炼自学能力，锻炼笔记能力，锻炼项目能力 SpringMVC + Vue + SpringBoot + SpringCloud + Linux SSM = JavaWeb做项目; Spring: IOC和APO SpringMVC: SpringMVC的执行流程! SpringMVC : SSM框架整合! Spring MVC:模型(dao, service) 视图 (jsp)控制器 (Servlet)daoserviceservlet :转发，重定向jsp/html 前端数据传输实体类 实体类:用户名，密码，生日，爱好，… 20个 前端:用户名密码 pojo: Uservo: UserVodto: JSP:本质就是一个Servlet 假设:你的项目的架构，是设计好的，还是演进的? Alibaba PHP 随着用户大， Java 王坚去 IOE MySQL MySQL : MySQL–&gt; AliSQL. AliRedis Allinone –微服务 MVC : MWM: M V VM ViewModel :双向绑定 1、什么是MVC MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 1.1、Model1时代 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model1优点：架构简单，比较适合小型项目开发； Model1缺点：JSP职责不单一，职责过重，不便于维护； 1.2、Model2时代Model2把一个项目分成三部分，包括视图、控制、模型。 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析： Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。 1.3、回顾Servlet 新建一个Maven工程当做父工程！ pom依赖！ &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！ 导入servlet 和 jsp 的 jar 依赖 &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; 编写一个Servlet类，用来处理用户的请求 package com.kuang.servlet; //实现Servlet接口 public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //取得参数 String method = req.getParameter(\"method\"); if (method.equals(\"add\")){ req.getSession().setAttribute(\"msg\",\"执行了add方法\"); } if (method.equals(\"delete\")){ req.getSession().setAttribute(\"msg\",\"执行了delete方法\"); } //业务逻辑 //视图跳转 req.getRequestDispatcher(\"/WEB-INF/jsp/hello.jsp\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } 编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 在web.xml中注册Servlet &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/user&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 配置Tomcat，并启动测试 localhost:8080/user?method=add localhost:8080/user?method=delete 访问结果 MVC框架要做哪些事情 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求–调用相关的业务处理–封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明： 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等…. 2、什么是SpringMVC概述 Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web 我们为什么要学习SpringMVC呢? Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 . 最重要的一点还是用的人多 , 使用的公司多 . 中心控制器Spring的web框架围绕DispatcherServlet设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。 SpringMVC的原理如下图所示： 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 在这里先听一遍原理，不理解没有关系，我们马上来写一个对应的代码实现大家就明白了，如果不明白，那就写10遍，没有笨人，只有懒人！ 3、HelloSpringMVC(配置版) 新建一个Moudle ， 添加web的支持！ 确定导入了SpringMVC 的依赖！ 配置web.xml ， 注册DispatcherServlet &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml说明，这里的名称要求是按照官方来的 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;/beans&gt; 添加 处理映射器 &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; 添加 处理器适配器 &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; 添加 视图解析器 &lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; 编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； package com.kuang.controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; //注意：这里我们先导入Controller接口 public class HelloController implements Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { //ModelAndView 模型和视图 ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model mv.addObject(\"msg\",\"HelloSpringMVC1!，我是成博\"); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(\"hello\"); //: /WEB-INF/jsp/hello.jsp return mv; } } 将自己的类交给SpringIOC容器，注册bean &lt;!--Handler--&gt; &lt;bean id=\"/hello\" class=\"com.kuang.controller.HelloController\"/&gt; 写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 配置Tomcat 启动测试！ 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！（与classes同级目录） 重启Tomcat 即可解决！ 小结：看这个估计大部分同学都能理解其中的原理了，但是我们实际开发才不会这么写，不然就疯了，还学这个玩意干嘛！我们来看个注解版实现，这才是SpringMVC的精髓，到底有多么简单，看这个图就知道了。 4、使用注解开发SpringMVC（注解版）第一步:新建一个Moudle , 添加web支持！建立包结构 com.kuang.controller 第二步:由于Maven可能存在资源过滤的问题，我们将配置完善 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 第三步:在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 第四步:配置web.xml 注意点： 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为 / 【不要用/*，会404】 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; / 和 /* 的区别： &lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求； 即：.jsp 不会进入spring的 DispatcherServlet类 。 &lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp， 会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 第五步:添加Spring MVC配置文件 让IOC的注解生效 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 ….. MVC的注解驱动 配置视图解析器 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;!-- 让Spring MVC不处理静态资源 过滤掉一些静态资源，如.css .js .html .mp3--&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 第六步:创建Controller 编写一个Java控制类： com.kuang.controller.HelloController , 注意编码规范 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/HelloController\")//多添加一级访问 public class HelloController { //真实访问地址 : 项目名/HelloController/hello @RequestMapping(\"/hello\")//请求路径 public String sayHello(Model model) { //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(\"msg\", \"hello,SpringMVC，我是成博\"); //会被视图解析器处理，web-inf/jsp/hello.jsp return \"hello\"; } } @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 第七步:创建视图层 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息； 可以通过EL表示取出Model中存放的值，或者对象； &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;SpringMVC&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 第八步:配置Tomcat运行 配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！ OK，运行成功！ 小结实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置 5、Controller 及 RestFul风格控制器Controller 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 我们来看看有哪些方式可以实现： 实现Controller接口Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； //实现该接口的类获得控制器功能 public interface Controller { //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception; } 测试 新建一个Moudle，springmvc-04-controller 。 将刚才的03 拷贝一份, 我们进行操作！ 删掉HelloController mvc的配置文件只留下 视图解析器！ 编写一个Controller类，ControllerTest1 //定义控制器 //注意点：不要导错包，实现Controller接口，重写方法； public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"Test1Controller\"); mv.setViewName(\"test\"); return mv; } } 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 &lt;bean name=\"/t1\" class=\"com.kuang.controller.ControllerTest1\"/&gt; 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！ 说明： 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; 增加一个ControllerTest2类，使用注解实现； //@Controller注解的类会自动添加到Spring上下文中 //代表这个类会被Spring按管 //被这个注解的类，中的所有方法，如果返回值是String，并且有具体页面可以跳转，那么就会被视图解析器解析; @Controller public class ControllerTest2{ //映射访问路径 @RequestMapping(\"/t2\") public String index(Model model){ //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"ControllerTest2\"); //返回视图位置 return \"test\"; } } 运行tomcat测试 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 注解方式是平时使用的最多的方式！除了这两种之外还有其他的方式，大家想要自己研究的话，可以参考我的博客：https://www.cnblogs.com/hellokuangshen/p/11270742.html RequestMapping@RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名测试 myweb 只注解在方法上面 @Controller public class TestController { @RequestMapping(\"/h1\") public String test(){ return \"test\"; } } 访问路径：http://localhost:8080 / 项目名 / h1 同时注解类与方法 @Controller @RequestMapping(\"/admin\") public class TestController { @RequestMapping(\"/h1\") public String test(){ return \"test\"; } } 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； 6、RestFul 风格(简洁，高效，安全)概念 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get http://127.0.0.1/item/queryItem.action?id=1 查询,GET http://127.0.0.1/item/saveItem.action 新增,POST http://127.0.0.1/item/updateItem.action 更新,POST http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST 使用RESTful操作资源 ： 可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ http://127.0.0.1/item/1 查询,GET http://127.0.0.1/item 新增,POST http://127.0.0.1/item 更新,PUT http://127.0.0.1/item/1 删除,DELETE 学习测试 在新建一个类 RestFulController @Controller public class RestFulController { } 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 @Controller public class RestFulController { //原来的 : http://localhost: 8080/add?a=1&amp;b=2 //RestFul : http://localhost : 8080/add/1/2 //映射访问路径 @RequestMapping(\"/commit/{p1}/{p2}\") public String index(@PathVariable int p1, @PathVariable int p2, Model model){ int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; } } 我们来测试请求查看下 思考：使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 我们来修改下对应的参数类型，再次测试 //映射访问路径 @RequestMapping(\"/commit/{p1}/{p2}\") public String index(@PathVariable int p1, @PathVariable String p2, Model model){ String result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; } 使用method属性指定请求类型 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 我们来测试一下： 增加一个方法 //映射访问路径,必须是POST请求 @RequestMapping(value = \"/hello\",method = {RequestMethod.POST}) public String index2(Model model){ model.addAttribute(\"msg\", \"hello!\"); return \"test\"; } 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： 如果将POST修改为GET则正常了； //映射访问路径,必须是Get请求 @RequestMapping(value = \"/hello\",method = {RequestMethod.GET}) public String index2(Model model){ model.addAttribute(\"msg\", \"hello!\"); return \"test\"; } 小结： Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个： 组合注解 @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping @GetMapping 是一个组合注解 @Controller public class RestFulController { //原来的 : http://localhost: 8080/add?a=1&amp;b=2 //RestFul : http://localhost : 8080/add/1/2 //映射访问路径 //@RequestMapping(value = \"/commit/{p1}/{p2}\",method = RequestMethod.GET) //@GetMapping(\"/commit/{p1}/{p2}\") @GetMapping(path = \"/commit/{p1}/{p2}\") public String index(@PathVariable int p1, @PathVariable int p2, Model model){ int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; } } 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。 平时使用的会比较多！ 小黄鸭调试法场景一：我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。 场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。 其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。 此概念据说来自《程序员修炼之道》书中的一个故事，传说程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。 7、SpringMVC：结果跳转三种方式(转发、重定向)7.1、ModelAndView设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; 对应的controller类 public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; } } 7.2、ServletAPI通过设置ServletAPI , 不需要视图解析器 . 通过HttpServletResponse进行输出 通过HttpServletResponse实现重定向 通过HttpServletResponse实现转发 @Controller public class ResultGo { @RequestMapping(\"/result/t1\") public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.getWriter().println(\"Hello,Spring BY servlet API\"); } @RequestMapping(\"/result/t2\") public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.sendRedirect(\"/index.jsp\"); } @RequestMapping(\"/result/t3\") public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception { //转发 req.setAttribute(\"msg\",\"/result/t3\"); req.getRequestDispatcher(\"/WEB-INF/jsp/test.jsp\").forward(req,rsp); } } 7.3、SpringMVC通过SpringMVC来实现转发和重定向 - 无需视图解析器； 测试前，需要将视图解析器注释掉 @Controller public class ResultSpringMVC { @RequestMapping(\"/rsm/t1\") public String test1(){ //转发 return \"/index.jsp\"; } @RequestMapping(\"/rsm/t2\") public String test2(){ //转发二 return \"forward:/index.jsp\"; } @RequestMapping(\"/rsm/t3\") public String test3(){ //重定向 return \"redirect:/index.jsp\"; } } 通过SpringMVC来实现转发和重定向 - 有视图解析器； 重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题. 可以重定向到另外一个请求实现 . @Controller public class ResultSpringMVC2 { @RequestMapping(\"/rsm2/t1\") public String test1(){ //转发 return \"test\"; } @RequestMapping(\"/rsm2/t2\") public String test2(){ //重定向 return \"redirect:/index.jsp\"; //return \"redirect:hello.do\"; //hello.do为另一个请求/ } } 8、数据处理（接收请求参数及数据回显）处理提交数据1、提交的域名称和处理方法的参数名一致 提交数据 : http://localhost:8080/hello?name=kuangshen 处理方法 : @RequestMapping(\"/hello\") public String hello(String name){ System.out.println(name); return \"hello\"; } 后台输出 : kuangshen 2、提交的域名称和处理方法的参数名不一致 提交数据 : http://localhost:8080/hello?username=kuangshen 处理方法 : //@RequestParam(\"username\") : username提交的域的名称 . @RequestMapping(\"/hello\") public String hello(@RequestParam(\"username\") String name){ System.out.println(name); return \"hello\"; } 后台输出 : 3、提交的是一个对象 要求提交的表单域和对象的属性名一致 , 参数使用对象即可 实体类 public class User { private int id; private String name; private int age; //构造 //get/set //tostring() } 提交数据 : http://localhost:8080/user?name=kuangshen&amp;id=1&amp;age=15 处理方法 : @RequestMapping(\"/user\") public String user(User user){ System.out.println(user); return \"hello\"; } 后台输出 : User { id=1, name=’kuangshen’, age=15 } 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。 数据显示到前端第一种 : 通过ModelAndView 我们前面一直都是如此 . 就不过多解释 public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; } } 第二种 : 通过ModelMap ModelMap @RequestMapping(\"/hello\") public String hello(@RequestParam(\"username\") String name, ModelMap model){ //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"name\",name); System.out.println(name); return \"hello\"; } 第三种 : 通过Model Model @RequestMapping(\"/ct2/hello\") public String hello(@RequestParam(\"username\") String name, Model model){ //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"msg\",name); System.out.println(name); return \"test\"; } 对比就对于新手而言简单来说使用区别就是： Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。 9、数据处理（乱码问题）测试步骤： 我们可以在首页编写一个提交的表单 &lt;form action=\"/e/t\" method=\"post\"&gt; &lt;input type=\"text\" name=\"name\"&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; 后台编写对应的处理类 @Controller public class Encoding { @RequestMapping(\"/e/t\") public String test(Model model,String name){ model.addAttribute(\"msg\",name); //获取表单提交的值 return \"test\"; //跳转到test页面显示输入的值 } } 输入中文测试，发现乱码 不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！ 以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 . 修改了xml文件需要重启服务器！ &lt;!--2.配置SpringMVC的乱码过滤--&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 有些极端情况下.这个过滤器对get的支持不好 . 处理方法 : 修改tomcat配置文件 ： 设置编码！ &lt;Connector URIEncoding=\"utf-8\" port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 自定义过滤器 package com.kuang.filter; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.util.Map; /** * 解决get和post请求 全部乱码的过滤器 */ public class GenericEncodingFilter implements Filter { @Override public void destroy() { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(\"text/html;charset=UTF-8\"); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); } @Override public void init(FilterConfig filterConfig) throws ServletException { } } //自定义request对象，HttpServletRequest的包装类 class MyRequest extends HttpServletRequestWrapper { private HttpServletRequest request; //是否编码的标记 private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰 public MyRequest(HttpServletRequest request) { super(request);// super必须写 this.request = request; } // 对需要增强方法 进行覆盖 @Override public Map getParameterMap() { // 先获得请求方式 String method = request.getMethod(); if (method.equalsIgnoreCase(\"post\")) { // post请求 try { // 处理post乱码 request.setCharacterEncoding(\"utf-8\"); return request.getParameterMap(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } else if (method.equalsIgnoreCase(\"get\")) { // get请求 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); if (!hasEncode) { // 确保get手动编码逻辑只运行一次 for (String parameterName : parameterMap.keySet()) { String[] values = parameterMap.get(parameterName); if (values != null) { for (int i = 0; i &lt; values.length; i++) { try { // 处理get乱码 values[i] = new String(values[i] .getBytes(\"ISO-8859-1\"), \"utf-8\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } } hasEncode = true; } return parameterMap; } return super.getParameterMap(); } //取一个值 @Override public String getParameter(String name) { Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) { return null; } return values[0]; // 取回参数的第一个值 } //取所有值 @Override public String[] getParameterValues(String name) { Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; } } 这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！ 然后在web.xml中配置这个过滤器即可！ 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！ 10、JSON讲解什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： {\"name\": \"QinJiang\"} {\"age\": \"3\"} {\"sex\": \"男\"} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转 要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' 代码测试 新建一个module ，springmvc-05-json ， 添加web的支持 在web目录下新建一个 json-1.html ， 编写测试内容 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSON_秦疆&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; //编写一个js的对象 var user = { name:\"成博\", age:3, sex:\"男\" }; //将js对象转换成json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转换为js对象 var user2 = JSON.parse(str); console.log(user2.age,user2.name,user2.sex); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在IDEA中使用浏览器打开，查看控制台输出！ Controller返回JSON数据1.jackson Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; 配置SpringMVC需要的配置 web.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; springmvc-servlet.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller； package com.kuang.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; //需要导入lombok @Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法 编写一个Controller； @Controller public class UserController { @RequestMapping(\"/json1\") @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 配置Tomcat ， 启动测试一下！ http://localhost:8080/json1 发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型； 通过@RequestMaping的produces属性来实现，修改下代码 //produces:指定响应体返回类型和编码 @RequestMapping(value = \"/json1\",produces = \"application/json;charset=utf-8\") 再次测试， http://localhost:8080/json1 ， 乱码问题OK！ 【注意：使用json记得处理乱码问题】 代码优化乱码统一解决 上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ &lt;!--JSON乱码问题配置--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 返回json字符串统一解决 在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ @RestController public class UserController { //produces:指定响应体返回类型和编码 @RequestMapping(value = \"/json1\") public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 启动tomcat测试，结果都正常输出！ 测试集合输出增加一个新的方法 @RequestMapping(\"/json2\") @ResponseBody public String json2() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str; } 运行结果 : 十分完美，没有任何问题！ 输出时间对象增加一个新的方法 @RequestMapping(\"/json3\") public String json3() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str; } 运行结果 : 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 @RequestMapping(\"/json4\") public String json4() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str; } 运行结果 : 成功的输出了时间！ 时间戳格式化，老手艺不能丢 @RequestMapping(\"/json6\") @ResponseBody public String json6() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); Date date = new Date(); //自定义日期的格式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); // objectMapper,时间解析后的默认格式为: Timestamp, 时间裁 return mapper.writeValueAsString(sdf.format(date)); } 抽取为工具类如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 package com.kuang.utils; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import java.text.SimpleDateFormat; public class JsonUtils { public static String getJson(Object object) { return getJson(object,\"yyyy-MM-dd HH:mm:ss\"); } public static String getJson(Object object,String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } } 我们使用工具类，代码就更加简洁了！ @RequestMapping(\"/json5\") public String json5() throws JsonProcessingException { Date date = new Date(); String json = JsonUtils.getJson(date); return json; } 大工告成！完美！ 2.FastJsonfastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。 fastjson 的 pom依赖！ &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt; &lt;/dependency&gt; fastjson 三个主要的类： 【JSONObject 代表 json 对象 】 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 【JSONArray 代表 json 对象数组】 内部是有List接口中的方法来完成操作的。 【JSON 代表 JSONObject和JSONArray的转化】 JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 代码测试，我们新建一个FastJsonDemo 类 package com.kuang.controller; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.kuang.pojo.User; import java.util.ArrayList; import java.util.List; public class FastJsonDemo { public static void main(String[] args) { //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(\"*******Java对象 转 JSON字符串*******\"); String str1 = JSON.toJSONString(list); System.out.println(\"JSON.toJSONString(list)==&gt;\"+str1); String str2 = JSON.toJSONString(user1); System.out.println(\"JSON.toJSONString(user1)==&gt;\"+str2); System.out.println(\"\\n****** JSON字符串 转 Java对象*******\"); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(\"JSON.parseObject(str2,User.class)==&gt;\"+jp_user1); System.out.println(\"\\n****** Java对象 转 JSON对象 ******\"); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(\"(JSONObject) JSON.toJSON(user2)==&gt;\"+jsonObject1.getString(\"name\")); System.out.println(\"\\n****** JSON对象 转 Java对象 ******\"); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(\"JSON.toJavaObject(jsonObject1, User.class)==&gt;\"+to_java_user); } } 例题： @RequestMapping(\"/json8\") @ResponseBody public String json8() throws JsonProcessingException { //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str1 = JSON.toJSONString(list); return str1; } 测试： http://localhost:8080/json8 这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！ 11、Ajax技术11.1、AJAX初体验异步可理解为局部刷新，同步指需要按部就班地完成一整套流程 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 就和国内百度的搜索框一样： 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 伪造Ajax我们可以使用前端的一个标签来伪造一个ajax的样子。 iframe标签 新建一个module ： sspringmvc-06-ajax ， 导入web支持！ 编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function(){ var myDate = new Date(); document.getElementById('currentTime').innerText = myDate.getTime(); }; function LoadPage(){ var targetUrl = document.getElementById('url').value; console.log(targetUrl); document.getElementById(\"iframePosition\").src = targetUrl; } &lt;/script&gt; &lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=\"currentTime\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=\"url\" type=\"text\" value=\"https://www.baidu.com/\"/&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"LoadPage()\"&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=\"iframePosition\" style=\"width: 100%;height: 500px;\"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 使用IDEA开浏览器测试一下！ 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 ….等等 jQuery.ajax 纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！ Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\") async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端课接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 \"xml\": 将服务器端返回的内容转换成xml格式 \"text\": 将服务器端返回的内容转换成普通文本格式 \"html\": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 \"json\": 将服务器端返回的内容转换成相应的JavaScript对象 \"jsonp\": JSONP 格式使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;mvc:default-servlet-handler /&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 编写一个AjaxController @Controller public class AjaxController { @RequestMapping(\"/a1\") public void ajax1(String name , HttpServletResponse response) throws IOException { if (\"admin\".equals(name)){ response.getWriter().print(\"true\"); }else{ response.getWriter().print(\"false\"); } } } 导入jquery ， 可以使用在线的CDN ， 也可以下载导入 &lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; 编写index.jsp测试 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;%--&lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt;--%&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1(){ $.post({ url:\"${pageContext.request.contextPath}/a1\", data:{'name':$(\"#txtName\").val()}, success:function (data,status) { alert(data); alert(status); } }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;%--onblur：失去焦点触发事件--%&gt; 用户名:&lt;input type=\"text\" id=\"txtName\" onblur=\"a1()\"/&gt; &lt;/body&gt; &lt;/html&gt; 启动tomcat测试！ 打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ 11.2、AJAX异步加载数据Springmvc实现实体类user @Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 我们来获取一个集合对象，展示到前端页面 @RequestMapping(\"/a2\") public List&lt;User&gt; ajax2(){ List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(\"秦疆1号\",3,\"男\")); list.add(new User(\"秦疆2号\",3,\"男\")); list.add(new User(\"秦疆3号\",3,\"男\")); return list; //由于@RestController注解，将list转成json格式返回 } 前端页面 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"button\" id=\"btn\" value=\"获取数据\"/&gt; &lt;table width=\"80%\" align=\"center\"&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;tbody id=\"content\"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () { $(\"#btn\").click(function () { $.post(\"${pageContext.request.contextPath}/a2\",function (data) { console.log(data) var html=\"\"; for (var i = 0; i &lt;data.length ; i++) { html+= \"&lt;tr&gt;\" + \"&lt;td&gt;\" + data[i].name + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + data[i].age + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + data[i].sex + \"&lt;/td&gt;\" + \"&lt;/tr&gt;\" } $(\"#content\").html(html); }); }) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 成功实现了数据回显！可以体会一下Ajax的好处！ 11.3、AJAX验证用户名体验注册提示效果我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化 我们写一个Controller @RequestMapping(\"/a3\") public String ajax3(String name,String pwd){ String msg = \"\"; //模拟数据库中存在数据 if (name!=null){ if (\"admin\".equals(name)){ msg = \"OK\"; }else { msg = \"用户名输入错误\"; } } if (pwd!=null){ if (\"123456\".equals(pwd)){ msg = \"OK\"; }else { msg = \"密码输入有误\"; } } return msg; //由于@RestController注解，将msg转成json格式返回 } 前端页面 login.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1(){ $.post({ url:\"${pageContext.request.contextPath}/a3\", data:{'name':$(\"#name\").val()}, success:function (data) { if (data.toString()=='OK'){ $(\"#userInfo\").css(\"color\",\"green\"); }else { $(\"#userInfo\").css(\"color\",\"red\"); } $(\"#userInfo\").html(data); } }); } function a2(){ $.post({ url:\"${pageContext.request.contextPath}/a3\", data:{'pwd':$(\"#pwd\").val()}, success:function (data) { if (data.toString()=='OK'){ $(\"#pwdInfo\").css(\"color\",\"green\"); }else { $(\"#pwdInfo\").css(\"color\",\"red\"); } $(\"#pwdInfo\").html(data); } }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 用户名:&lt;input type=\"text\" id=\"name\" onblur=\"a1()\"/&gt; &lt;span id=\"userInfo\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 密码:&lt;input type=\"text\" id=\"pwd\" onblur=\"a2()\"/&gt; &lt;span id=\"pwdInfo\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 【记得处理json乱码问题】 测试一下效果，动态请求响应，局部刷新，就是如此！ 11.4、补充，自己看看获取baidu接口Demo&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;JSONP百度搜索&lt;/title&gt; &lt;style&gt; #q{ width: 500px; height: 30px; border:1px solid #ddd; line-height: 30px; display: block; margin: 0 auto; padding: 0 10px; font-size: 14px; } #ul{ width: 520px; list-style: none; margin: 0 auto; padding: 0; border:1px solid #ddd; margin-top: -1px; display: none; } #ul li{ line-height: 30px; padding: 0 10px; } #ul li:hover{ background-color: #f60; color: #fff; } &lt;/style&gt; &lt;script&gt; // 2.步骤二 // 定义demo函数 (分析接口、数据) function demo(data){ var Ul = document.getElementById('ul'); var html = ''; // 如果搜索数据存在 把内容添加进去 if (data.s.length) { // 隐藏掉的ul显示出来 Ul.style.display = 'block'; // 搜索到的数据循环追加到li里 for(var i = 0;i&lt;data.s.length;i++){ html += '&lt;li&gt;'+data.s[i]+'&lt;/li&gt;'; } // 循环的li写入ul Ul.innerHTML = html; } } // 1.步骤一 window.onload = function(){ // 获取输入框和ul var Q = document.getElementById('q'); var Ul = document.getElementById('ul'); // 事件鼠标抬起时候 Q.onkeyup = function(){ // 如果输入框不等于空 if (this.value != '') { // ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ // 创建标签 var script = document.createElement('script'); //给定要跨域的地址 赋值给src //这里是要请求的跨域的地址 我写的是百度搜索的跨域地址 script.src = 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd='+this.value+'&amp;cb=demo'; // 将组合好的带src的script标签追加到body里 document.body.appendChild(script); } } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"text\" id=\"q\" /&gt; &lt;ul id=\"ul\"&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 12、拦截器概述SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。 过滤器与拦截器的区别：拦截器是AOP思想的具体应用。 过滤器 servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 12.1、自定义拦截器那如何实现拦截器呢？ 想要自定义拦截器，必须实现 HandlerInterceptor 接口。 新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持 配置web.xml 和 springmvc-servlet.xml 文件 编写一个拦截器 package com.kuang.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class MyInterceptor implements HandlerInterceptor { //在请求处理的方法之前执行 //如果返回true执行下一个拦截器 //如果返回false就不执行下一个拦截器 public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(\"------------处理前------------\"); return true; } //在请求处理方法执行之后执行 public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { System.out.println(\"------------处理后------------\"); } //在dispatcherServlet处理后执行,做清理工作. public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { System.out.println(\"------------清理------------\"); } } 在springmvc的配置文件中配置拦截器 &lt;!--关于拦截器的配置--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/** 包括路径及其子路径--&gt; &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt; &lt;!--/admin/** 拦截的是/admin/下的所有--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!--bean配置的就是拦截器--&gt; &lt;bean class=\"com.kuang.interceptor.MyInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 编写一个Controller，接收请求 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; //测试拦截器的控制器 @Controller public class InterceptorController { @RequestMapping(\"/interceptor\") @ResponseBody public String testFunction() { System.out.println(\"控制器中的方法执行了\"); return \"hello\"; } } 前端 index.jsp &lt;a href=\"${pageContext.request.contextPath}/interceptor\"&gt;拦截器测试&lt;/a&gt; 启动tomcat 测试一下！ 12.2、验证用户是否登录 (认证用户)实现思路 有一个登陆页面，需要写一个controller访问页面。 登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。返回登陆成功。 拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面 代码编写 编写一个登陆页面 login.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;h1&gt;登录页面&lt;/h1&gt; &lt;hr&gt; &lt;body&gt; &lt;form action=\"${pageContext.request.contextPath}/user/login\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码： &lt;input type=\"password\" name=\"pwd\"&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 编写一个Controller处理请求 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.http.HttpSession; @Controller @RequestMapping(\"/user\") public class UserController { //跳转到登陆页面 @RequestMapping(\"/jumplogin\") public String jumpLogin() throws Exception { return \"login\"; } //跳转到成功页面 @RequestMapping(\"/jumpSuccess\") public String jumpSuccess() throws Exception { return \"success\"; } //登陆提交 @RequestMapping(\"/login\") public String login(HttpSession session, String username, String pwd) throws Exception { // 向session记录用户身份信息 System.out.println(\"接收前端===\"+username); session.setAttribute(\"user\", username); return \"success\"; } //退出登陆 @RequestMapping(\"logout\") public String logout(HttpSession session) throws Exception { // session 过期 session.invalidate(); return \"login\"; } } 编写一个登陆成功的页面 success.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;登录成功页面&lt;/h1&gt; &lt;hr&gt; ${user} &lt;a href=\"${pageContext.request.contextPath}/user/logout\"&gt;注销&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！ &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;hr&gt; &lt;%--登录--%&gt; &lt;a href=\"${pageContext.request.contextPath}/user/jumplogin\"&gt;登录&lt;/a&gt; &lt;a href=\"${pageContext.request.contextPath}/user/jumpSuccess\"&gt;成功页面&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 编写用户登录拦截器 package com.kuang.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; public class LoginInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException { // 如果是登陆页面则放行 System.out.println(\"uri: \" + request.getRequestURI()); if (request.getRequestURI().contains(\"login\")) { return true; } HttpSession session = request.getSession(); // 如果用户已登陆也放行 if(session.getAttribute(\"user\") != null) { return true; } // 用户没有登陆跳转到登陆页面 request.getRequestDispatcher(\"/WEB-INF/jsp/login.jsp\").forward(request, response); return false; } public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { } public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { } } 在Springmvc的配置文件中注册拦截器 &lt;!--关于拦截器的配置--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean id=\"loginInterceptor\" class=\"com.kuang.interceptor.LoginInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 再次重启Tomcat测试！ OK，测试登录拦截功能无误. 13、SpringMVC：文件上传和下载准备工作文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。 前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器； 对表单中的 enctype 属性做个详细的说明： application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。 multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。 text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。 &lt;form action=\"\" enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;input type=\"file\" name=\"file\"/&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; 一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。 Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。 而Spring MVC则提供了更简单的封装。 Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。 Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类：CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。 13.1、文件上传一、导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包； &lt;!--文件上传--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet-api导入高版本的--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; 二、配置bean：multipartResolver【注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！】 &lt;!--文件上传配置--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"/&gt; &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt; &lt;property name=\"maxInMemorySize\" value=\"40960\"/&gt; &lt;/bean&gt; CommonsMultipartFile 的 常用方法： String getOriginalFilename()：获取上传文件的原名 InputStream getInputStream()：获取文件流 void transferTo(File dest)：将上传文件保存到一个目录文件中 我们去实际测试一下 三、编写前端页面 &lt;form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;input type=\"file\" name=\"file\"/&gt; &lt;input type=\"submit\" value=\"upload\"&gt; &lt;/form&gt; 四、Controller package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.commons.CommonsMultipartFile; import javax.servlet.http.HttpServletRequest; import java.io.*; @Controller public class FileController { //@RequestParam(\"file\") 将name=file控件得到的文件封装成CommonsMultipartFile 对象 //批量上传CommonsMultipartFile则为数组即可 @RequestMapping(\"/upload\") public String fileUpload(@RequestParam(\"file\") CommonsMultipartFile file , HttpServletRequest request) throws IOException { //获取文件名 : file.getOriginalFilename(); String uploadFileName = file.getOriginalFilename(); //如果文件名为空，直接回到首页！ if (\"\".equals(uploadFileName)){ return \"redirect:/index.jsp\"; } System.out.println(\"上传文件名 : \"+uploadFileName); //上传路径保存设置 String path = request.getServletContext().getRealPath(\"/upload\"); //如果路径不存在，创建一个 File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } System.out.println(\"上传文件保存地址：\"+realPath); InputStream is = file.getInputStream(); //文件输入流 OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流 //读取写出 int len=0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1){ os.write(buffer,0,len); os.flush(); } os.close(); is.close(); return \"redirect:/index.jsp\"; } } 五、测试上传文件，OK！ 采用file.Transto 来保存上传的文件 编写Controller /* * 采用file.Transto 来保存上传的文件 */ @RequestMapping(\"/upload2\") public String fileUpload2(@RequestParam(\"file\") CommonsMultipartFile file, HttpServletRequest request) throws IOException { //上传路径保存设置 String path = request.getServletContext().getRealPath(\"/upload\"); File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } //上传文件地址 System.out.println(\"上传文件保存地址：\"+realPath); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +\"/\"+ file.getOriginalFilename())); return \"redirect:/index.jsp\"; } 前端表单提交地址修改 访问提交测试，OK！ 13.2、文件下载文件下载步骤： 设置 response 响应头 读取文件 – InputStream 写出文件 – OutputStream 执行操作 关闭流 （先开后关） 代码实现： @RequestMapping(value=\"/download\") public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception{ //要下载的图片地址 String path = request.getServletContext().getRealPath(\"/upload\"); String fileName = \"基础语法.jpg\"; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(\"UTF-8\"); //字符编码 response.setContentType(\"multipart/form-data\"); //二进制传输数据 //设置响应头 response.setHeader(\"Content-Disposition\", \"attachment;fileName=\"+URLEncoder.encode(fileName, \"UTF-8\")); File file = new File(path,fileName); //2、 读取文件--输入流 InputStream input=new FileInputStream(file); //3、 写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1){ out.write(buff, 0, index); out.flush(); } out.close(); input.close(); return null; } 前端 &lt;a href=\"/download\"&gt;点击下载&lt;/a&gt; 测试，文件下载OK，大家可以和我们之前学习的JavaWeb原生的方式对比一下，就可以知道这个便捷多了! 100、通用1.web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--encodingFilter--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session过期时间--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;/web-app&gt; 2.springmvc-servlet.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!--JSON乱码问题配置--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 3、使用到的注解@Controller注解类型用于声明Spring类的实例是一个控制器 @RequestMapping(\"/HelloController\") @PathVariable int p1 组合注解 @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping @RequestParam(\"username\") String name @ResponseBody 组合注解 @RestController 4、使用到的jar包&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; SpringMVC的执行流程 1、一个请求匹配前端控制器 DispatcherServlet 的请求映射路径(在 web.xml中指定), WEB 容器将该请求转交给 DispatcherServlet 处理2、DispatcherServlet 接收到请求后, 将根据 请求信息 交给 处理器映射器 （HandlerMapping）3、HandlerMapping 根据用户的url请求 查找匹配该url的 Handler，并返回一个执行链4、DispatcherServlet 再请求 处理器适配器(HandlerAdapter) 调用相应的 Handler 进行处理并返回 ModelAndView 给 DispatcherServlet5、DispatcherServlet 将 ModelAndView 请求 ViewReslover（视图解析器）解析，返回具体 View6、DispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）7、DispatcherServlet 将页面响应给用户 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"WrodPress建站教程","slug":"WrodPress建站教程","date":"2020-08-27T03:11:11.000Z","updated":"2020-09-18T04:43:03.004Z","comments":true,"path":"2020/08/27/WrodPress建站教程/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/27/WrodPress%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/","excerpt":"","text":"本篇文章适用于第一次建站的小白，帮助你从零搭建起一个属于自己的网站，既然是从零，那么我就会带着你从购买域名等到一直搭建成功，接下来请往下看吧。 建站准备建网站本身是没有什么难度的，毕竟现在搭建一个网站的成本也很低，只是配套需要的东西有些繁琐，我们先把要用到的准备好。 域名 服务器 WrodPress安装包 购买域名域名这里推荐使用阿里云的域名，博主的这个域名就是在阿里云注册的，现在最便宜的top域名首年才9元。博主本来想注册zou.wang这个域名的，一年四万多吓得我立马关掉了浏览器。 购买服务器服务器的选择就很多了，如果不想备案的话还是要买海外的服务器（比如香港的）博主买的是腾讯云服务器，不要以为博主花了很多钱，我正好处在25岁以下，买的是腾讯云学生服务器，一个月才十元，并且可以以这个价格续费三次，配置我觉得还可以，作为初始建站是够用了，当然这是属于国内的服务器是要备案的并且服务器购买三个月才可以备案，博主当时就被这里坑掉了。这里一定要记住一次性购买三个月服务器才可以备案。 这里系统选择CentOS 7.4 64位为什么必须选择Linux呢，因为后面用的就是Linux，记得保存好账户密码。 安装宝塔面板安装宝塔面板之前，确保你的系统是纯净的（刚买的肯定是纯净的吧），如果之前使用其他的一键安装，建议重装系统为Centos7系统 。首先我们要进入刚买的服务器 点击登陆，选择标准登陆方式，输入之前保存的密码，成功登陆之后在命令行输入以下命令安装宝塔面板 yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh 中途一直yes就行，等待几分钟安装完毕。 等待安装完成之后，命令行会显示面板的登录地址、账号以及密码，一定将这些信息保存下来，后期的管理都需要使用该信息登录面板 安装网络环境宝塔面板安装完成后，我们就可以登录后台面板了，使用刚刚记录的后台地址登录，登陆进去之后最好在面板设置里修改一下访问端口和密码什么的。 进入到宝塔后台面板我们就可以看到一键安装网络环境的界面，一般我们会选择左侧的LNMP架构，编译安装 然后就是等待安装完成就可以了，一般会持续半小时到1个小时，根据你服务器的性能决定 。 服务器新建站点现在所有的环境已经搭建好了，我们就可以开始建网站了，宝塔面板新建一个网站，点击下图中绿色的按钮新建一个站点。 这里需要输入我们的域名，把不带www的和带www的都填上，比如zouwang.vip和www.zouwang.vip, 该步骤就是绑定域名，FTP可以不用创建后面也用不上，数据库是一定要创建的，把这些信息都记录下来之后要用到 所有设置完毕之后我们点击提交，网站即创建完毕 。 域名解析这个其实很简单，就是添加域名解析的ip地址，使域名可以解析到服务器，不同的域名商操作方法不一样，这里我演示下阿里云的域名解析。 我们先在域名控制台里找到域名列表，点击解析，然后添加解析。 先来讲一下添加域名解析记录的每个词都是什么意思 记录类型要指向空间商提供的 IP 地址，选择「类型 A」，要指向一个域名，选择「类型 CNAME」 A记录：地址记录，用来指定域名的IPv4地址（如：8.8.8.8），如果需要将域名指向一个IP地址，就需要添加A记录。 CNAME： 如果需要将域名指向另一个域名，再由另一个域名提供ip地址，就需要添加CNAME记录，例如添加cdn NS：域名服务器记录，如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录。 AAA：用来指定主机名（或域名）对应的IPv6地址（例如：ff06:0:0:0:0:0:0:c3）记录。 MX：如果需要设置邮箱，让邮箱能收到邮件，就需要添加MX记录。 主机记录主机记录就是域名前缀，常见用法有： www：解析后的域名为 www.zouwang.vip @：直接解析主域名 zouwang.vip *：泛解析，匹配其他所有域名 *.zouwang.vip 解析线路让指定线路的用户访问这个IP，常见用法有： 默认：必须添加，否则只有单独指定的线路才能访问您的网站。如果双线解析，建议「默认」线路填写「电信IP」 联通：单独为「联通用户」指定服务器 IP，其他用户依然访问「默认」 搜索引擎：指定一个服务器 IP 让抓取 记录值最常见的是将空间商提供的「IP地址」填写在这里，比如我填写的就是腾讯云服务器的ip 各类型的记录值一般是这样的： A记录：填写你服务器 IP，如果你不知道，请咨询你的空间商 CNAME记录：填写空间商给你提供的域名，例如：2.com MX记录：填写你邮件服务器的IP地址或企业邮局给你提供的域名，如果你不知道，请咨询你的邮件服务提供商 AAAA：不常用。解析到 IPv6 的地址。 NS记录：不常用。系统默认添加的两个NS记录请不要修改。NS向下授权，填写dns域名，例如：ns3.dnsv3.com TTL即 Time To Live，缓存的生存时间。指地方dns缓存您域名记录信息的时间，缓存失效后会再次到DNSPod获取记录值。 我们默认的 600 秒是最常用的，不用修改 600（10分钟）：建议正常情况下使用 600。 60（1分钟）：如果你经常修改IP，修改记录一分钟即可生效。长期使用 60，解析速度会略受影响。 3600（1小时）：如果你IP极少变动（一年几次），建议选择 3600，解析速度快。如果要修改IP，提前一天改为 60，即可快速生效。 该理解的应该都理解差不多了吧，接下来我们开始解析域名，这里我们需要解析两个域名。 一个是 www 记录，这里设置www通用的，比如 www.zouwang.vip 还有就是 @ 记录，这个是设置根域名，比如说我的就是 zouwang.vip，虽然说有时候用不到，最好还是设置一下，毕竟还是有很多人直接输入域名不输入www的，听说不带www的百度收录会更快也不知道是真假。 设置好解析之后等待十分钟，然后访问网页看到一个创建成功的页面，就证明解析已经好了，可以进行下一步 。 下载WordPress安装包服务器和域名都已经购买完毕，那么网站采用什么搭建呢，当然是非常流行的WordPress。作为知名的博客平台，采用php语言开发，当然你不懂php也没关系，我也不懂。我们需要到WordPress中国站去下载安装包。 下载完成之后不用解压，留着安装包就好。接下来我们需要把下载好的安装包上传到服务器上，因为我们有宝塔面板所以上传很方便，不需要第三方工具。我们在宝塔面板找到文件管理的界面，然后找到网站对应的目录，宝塔面板的目录一般是固定的，比如我刚刚新建的网站目录就是 /www/wwwroot/zouwang.vip/ ，一般宝塔面板安装时你没有修改的话就是在这个 /www/wwwroot 目录下的。 点击上传，选择刚才下载好的安装包， 上传成功之后可以在wordpress.zip的看到右下角有一个箭头，鼠标指向就能看见，这里选择解压，直接确认即可，解压完成之后可以把zip的压缩包删除了 安装WordPress网站在域名解析和网站程序目录结构都没有问题后，我们就可以安装网站了，安装是最简单的 直接访问自己的域名，会看到wordpress的安装界面，它说的东西我们前期已经准备好，第一步可以直接开始 这里填写的是服务器数据库信息，包括数据库名、用户名、密码、数据库主机、表前缀，数据库主机和表前缀没有特殊需求的话一般都不需要修改，数据库密码刚刚我们已经记下了，按照要求填写即可(注意不要和服务器的用户名密码搞混) 如果你之前没有记录数据库信息也没关系，你可以到宝塔面板 – 数据库 查看信息。 数据库信息填好以后点击提交，下一步就是安装WordPress 填写自己的网站信息，用户名和密码最好是找个地方记下来，这个是你登录WordPress需要的账号密码，邮箱一定要填写自己的，找回密码用，而且网站有留言审核之类的问题也会给你发送邮件 网站安装成功，接下来就可以登陆到后台进行各种设置了。 结语到这里一个基本网站的搭建就已经完成了，相信你也从中学到了很多东西，这篇文章更多是为了防止初次建站的小白走弯路，想当初博主可是踩了很多坑，最后总结一下整个过程：购买域名-&gt;购买服务器-&gt;安装宝塔面板-&gt;安装网络环境-&gt;新建站点-&gt;域名解析-&gt;安装wordpress。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Linux服务器后台运行jar包","slug":"Linux服务器后台运行jar包","date":"2020-08-22T17:02:00.000Z","updated":"2020-09-18T04:43:02.979Z","comments":true,"path":"2020/08/23/Linux服务器后台运行jar包/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/23/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8Cjar%E5%8C%85/","excerpt":"上代码将运行日志输入到 logs.txt (jar包所在的目录) nohup java -jar xxx.jar &gt;logs.txt &amp; 分解介绍 首先最基本的运行jar包命令是: java -jar xxx.jar 这个命令会锁定命令窗口，只能看到当前运行的输出信息。而无法发送其他指令。 这种方式当ssh窗口关闭时，程序中止运行,或者是运行时没法切出去执行其他任务 让jar包后台运行 用”&amp;“符号结尾表示，让程序在后台运行。这样的话，命令窗口就不会被锁定，而可以发送其他指令，但是当窗口关闭时，后台运行的程序依然会被停止。 nohup命令：nohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断信号。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。 简单地说就是，nohup命令可以阻止窗口关闭是的挂断信号，使程序继续运行。这样，命令就修改为了 nohup java -jar xxx.jar &amp; 设置输出文件 在这个命令下已经可以实现需要的功能了。最后的 &gt;logs.txt 表示输出文件。可以随意写随意指定路径。如果不写情况下（缺省），就回默认在jar包所在目录，创建nohup.out文件。 如果项目中已经指定了日志输出，就会重复输出，生成两个文件，把 &gt;logs.txt 删了的话，当前的运行程序不会再生成新的文件。 nohup java -jar xxx.jar &gt;logs.txt &amp; 命令运行成功后，会返回一个进程号，可以通过 kill -9 命令杀死这个进程来直接关闭。 如果忘了进程号，可以通过 ps -ef|grep xxx.jar 来查看当前运行的jar包程序进程号 查询当前活动的进程 ps -aux|grep java 查看linux系统内存大小的详细信息，可以查看总内存，剩余内存、可使用内存等信息 cat /proc/meminfo","text":"上代码将运行日志输入到 logs.txt (jar包所在的目录) nohup java -jar xxx.jar &gt;logs.txt &amp; 分解介绍 首先最基本的运行jar包命令是: java -jar xxx.jar 这个命令会锁定命令窗口，只能看到当前运行的输出信息。而无法发送其他指令。 这种方式当ssh窗口关闭时，程序中止运行,或者是运行时没法切出去执行其他任务 让jar包后台运行 用”&amp;“符号结尾表示，让程序在后台运行。这样的话，命令窗口就不会被锁定，而可以发送其他指令，但是当窗口关闭时，后台运行的程序依然会被停止。 nohup命令：nohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断信号。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。 简单地说就是，nohup命令可以阻止窗口关闭是的挂断信号，使程序继续运行。这样，命令就修改为了 nohup java -jar xxx.jar &amp; 设置输出文件 在这个命令下已经可以实现需要的功能了。最后的 &gt;logs.txt 表示输出文件。可以随意写随意指定路径。如果不写情况下（缺省），就回默认在jar包所在目录，创建nohup.out文件。 如果项目中已经指定了日志输出，就会重复输出，生成两个文件，把 &gt;logs.txt 删了的话，当前的运行程序不会再生成新的文件。 nohup java -jar xxx.jar &gt;logs.txt &amp; 命令运行成功后，会返回一个进程号，可以通过 kill -9 命令杀死这个进程来直接关闭。 如果忘了进程号，可以通过 ps -ef|grep xxx.jar 来查看当前运行的jar包程序进程号 查询当前活动的进程 ps -aux|grep java 查看linux系统内存大小的详细信息，可以查看总内存，剩余内存、可使用内存等信息 cat /proc/meminfo document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"SVN中文网 - svn安装、svn部署、svn操作手册","slug":"SVN中文网 - svn安装、svn部署、svn操作手册","date":"2020-08-21T17:30:00.000Z","updated":"2020-09-18T04:43:02.988Z","comments":true,"path":"2020/08/22/SVN中文网 - svn安装、svn部署、svn操作手册/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/22/SVN%E4%B8%AD%E6%96%87%E7%BD%91%20-%20svn%E5%AE%89%E8%A3%85%E3%80%81svn%E9%83%A8%E7%BD%B2%E3%80%81svn%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/","excerpt":"http://www.svn.org.cn/","text":"http://www.svn.org.cn/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"SVN","slug":"SVN","permalink":"https://melodyjerry.github.io/blog/tags/SVN/"}]},{"title":"SVN 安装","slug":"SVN-安装","date":"2020-08-21T17:02:00.000Z","updated":"2020-09-18T04:43:02.995Z","comments":true,"path":"2020/08/22/SVN-安装/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/22/SVN-%E5%AE%89%E8%A3%85/","excerpt":"","text":"在windows下安装 SVN1、准备svn的安装文件 下载地址：https://sourceforge.net/projects/win32svn/ 2、下载完成后，在相应的盘符中会有一个Setup-Subversion-1.8.16.msi的文件，目前最新的版本是1.8.16， 这里就使用这个版本。然后双击安装文件进行安装。我们指定安装在D:\\Program Files (x86)\\Subversion目录里。 3、查看目录结构 把svn安装目录里的bin目录添加到path路径中，在命令行窗口中输入 svnserve –help ,查看安装正常与否。 至此，windows下的SVN安装完成 在CentOS下安装 SVN大多数 GNU/Linux 发行版系统自带了Subversion ，所以它很有可能已经安装在你的系统上了。可以使用下面命令检查是否安装了。 svn --version 如果 Subversion 客户端没有安装，命令将报告svn命令找不到的错误。 [runoob@centos6 ~]$ svn --version bash: svn: command not found 我们可以使用 yum install subversion 命令进行安装。 [runoob@centos6 root]$ su - 密码： [root@centos6 ~]# yum install subversion 已加载插件：fastestmirror, security 设置安装进程 Loading mirror speeds from cached hostfile * base: mirrors.aliyun.com * epel: mirrors.neusoft.edu.cn * extras: mirrors.zju.edu.cn * updates: mirrors.aliyun.com 解决依赖关系 --&amp;gt; 执行事务检查 ... 安装成功之后，执行 svn –version 命令。 [root@centos6 ~]# svn --version svn，版本 1.6.11 (r934486) 编译于 Aug 17 2015，08:37:43 至此，centos下的SVN安装完成。 在Ubuntu下安装 SVN如果 Subversion 客户端没有安装，命令将报告svn命令找不到的错误。 root@runoob:~# svn --version The program 'svn' is currently not installed. You can install it by typing: apt-get install subversion 我们可以使用 apt-get 命令进行安装 root@runoob:~# apt-get install subversion Reading package lists... Done Building dependency tree Reading state information... Done The following packages were automatically installed and are no longer required: augeas-lenses hiera libaugeas0 libxslt1.1 ruby-augeas ruby-deep-merge ruby-json ruby-nokogiri ruby-rgen ruby-safe-yaml ruby-selinux ruby-shadow Use 'apt-get autoremove' to remove them. The following extra packages will be installed: libserf-1-1 libsvn1 ... 安装成功之后，执行 svn –version 命令。 root@runoob:~# svn --version svn, version 1.8.13 (r1667537) compiled Sep 8 2015, 14:59:01 on x86_64-pc-linux-gnu 至此，Ubuntu下的SVN安装完成。 来源：菜鸟教程（https://www.runoob.com/svn/svn-install.html） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"SVN","slug":"SVN","permalink":"https://melodyjerry.github.io/blog/tags/SVN/"}]},{"title":"SVN 简介","slug":"SVN-简介","date":"2020-08-21T17:00:00.000Z","updated":"2020-09-18T04:43:02.991Z","comments":true,"path":"2020/08/22/SVN-简介/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/22/SVN-%E7%AE%80%E4%BB%8B/","excerpt":"SVN 简介 Subversion(SVN) 是一个开源的版本控制系統, 也就是说 Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库(repository) 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。","text":"SVN 简介 Subversion(SVN) 是一个开源的版本控制系統, 也就是说 Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库(repository) 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。 SVN 的一些概念 repository（源代码库）:源代码统一存放的地方 Checkout（提取）:当你手上没有源代码的时候，你需要从repository checkout一份 Commit（提交）:当你已经修改了代码，你就需要Commit到repository Update (更新):当你已经Checkout了一份源代码， Update一下你就可以和Repository上的源代码同步，你手上的代码就会有最新的变更 日常开发过程其实就是这样的（假设你已经Checkout并且已经工作了几天）：Update(获得最新的代码) –&gt;作出自己的修改并调试成功 –&gt; Commit(大家就可以看到你的修改了) 。 如果两个程序员同时修改了同一个文件呢, SVN 可以合并这两个程序员的改动，实际上SVN管理源代码是以行为单位的，就是说两个程序员只要不是修改了同一行程序，SVN都会自动合并两种修改。如果是同一行，SVN 会提示文件 Conflict, 冲突，需要手动确认。 SVN 的主要功能 （1）目录版本控制 CVS 只能跟踪单个文件的历史, 不过 Subversion 实作了一个 “虚拟” 的版本控管文件系统, 能够依时间跟踪整个目录的变动。 目录和文件都能进行版本控制。 （2）真实的版本历史 自从CVS限制了文件的版本记录，CVS并不支持那些可能发生在文件上，但会影响所在目录内容的操作，如同复制和重命名。除此之外，在CVS里你不能用拥有同样名字但是没有继承老版本历史或者根本没有关系的文件替换一个已经纳入系统的文件。在Subversion中，你可以增加（add）、删除（delete）、复制（copy）和重命名（rename），无论是文件还是目录。所有的新加的文件都从一个新的、干净的版本开始。 （3）自动提交 一个提交动作，不是全部更新到了档案库中，就是不完全更新。这允许开发人员以逻辑区间建立并提交变动，以防止当部分提交成功时出现的问题。 （4）纳入版本控管的元数据 每一个文件与目录都附有一組属性关键字并和属性值相关联。你可以创建, 并儲存任何你想要的Key/Value对。 属性是随着时间来作版本控管的,就像文件內容一样。 （5）选择不同的网络层 Subversion 有抽象的档案库存取概念, 可以让人很容易地实作新的网络机制。 Subversion 可以作为一个扩展模块嵌入到Apache HTTP 服务器中。这个为Subversion提供了非常先进的稳定性和协同工作能力，除此之外还提供了许多重要功能: 举例来说, 有身份认证, 授权, 在线压缩, 以及文件库浏览等等。还有一个轻量级的独立Subversion服务器， 使用的是自定义的通信协议, 可以很容易地通过 ssh 以 tunnel 方式使用。 （6）一致的数据处理方式 Subversion 使用二进制差异算法来异表示文件的差异, 它对文字(人类可理解的)与二进制文件(人类无法理解的) 两类的文件都一视同仁。 这两类的文件都同样地以压缩形式储存在档案库中, 而且文件差异是以两个方向在网络上传输的。 （7）有效的分支(branch)与标签(tag) 在分支与标签上的消耗并不必一定要与项目大小成正比。 Subversion 建立分支与标签的方法, 就只是复制该项目, 使用的方法就类似于硬连接（hard-link）。 所以这些操作只会花费很小, 而且是固定的时间。 （8）Hackability Subversion没有任何的历史包袱; 它主要是一群共用的 C 程序库, 具有定义完善的API。这使得 Subversion 便于维护, 并且可被其它应用程序与程序语言使用。 优于CVS之处1、原子提交。一次提交不管是单个还是多个文件，都是作为一个整体提交的。在这当中发生的意外例如传输中断，不会引起数据库的不完整和数据损坏。 2、重命名、复制、删除文件等动作都保存在版本历史记录当中。 3、对于二进制文件，使用了节省空间的保存方法。（简单的理解，就是只保存和上一版本不同之处） 4、目录也有版本历史。整个目录树可以被移动或者复制，操作很简单，而且能够保留全部版本记录。 5、分支的开销非常小。 6、优化过的数据库访问，使得一些操作不必访问数据库就可以做到。这样减少了很多不必要的和数据库主机之间的网络流量。 来源：菜鸟教程（https://www.runoob.com/svn/svn-intro.html） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"SVN","slug":"SVN","permalink":"https://melodyjerry.github.io/blog/tags/SVN/"}]},{"title":"两个简单的导航网页","slug":"两个简单的导航网页","date":"2020-08-21T16:00:00.000Z","updated":"2020-09-18T04:43:03.050Z","comments":true,"path":"2020/08/22/两个简单的导航网页/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/22/%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AF%BC%E8%88%AA%E7%BD%91%E9%A1%B5/","excerpt":"极简、拟物风格 源码Gitee：https://gitee.com/melodyjerry/SimpleIndex 简单的、聚合式 源码Gitee：https://gitee.com/melodyjerry/MyIndex","text":"极简、拟物风格 源码Gitee：https://gitee.com/melodyjerry/SimpleIndex 简单的、聚合式 源码Gitee：https://gitee.com/melodyjerry/MyIndex document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://melodyjerry.github.io/blog/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"},{"name":"JQuery","slug":"JQuery","permalink":"https://melodyjerry.github.io/blog/tags/JQuery/"}]},{"title":"网易云官方接口免费解析VIP音乐","slug":"网易云官方接口免费解析VIP音乐","date":"2020-08-21T16:00:00.000Z","updated":"2020-09-18T04:43:03.280Z","comments":true,"path":"2020/08/22/网易云官方接口免费解析VIP音乐/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/22/%E7%BD%91%E6%98%93%E4%BA%91%E5%AE%98%E6%96%B9%E6%8E%A5%E5%8F%A3%E5%85%8D%E8%B4%B9%E8%A7%A3%E6%9E%90VIP%E9%9F%B3%E4%B9%90/","excerpt":"复制歌曲的链接：https://music.163.com/song?id=496869422&amp;userid=517240734（取song?id） 把后缀ID加入接口访问即可：http://music.163.com/song/media/outer/url?id=496869422.mp3","text":"复制歌曲的链接：https://music.163.com/song?id=496869422&amp;userid=517240734（取song?id） 把后缀ID加入接口访问即可：http://music.163.com/song/media/outer/url?id=496869422.mp3 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"XPath教程","slug":"XPath教程","date":"2020-08-20T16:01:00.000Z","updated":"2020-09-18T04:43:03.001Z","comments":true,"path":"2020/08/21/XPath教程/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/21/XPath%E6%95%99%E7%A8%8B/","excerpt":"XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。 XPath 是 W3C XSLT 标准的主要元素，并且 XQuery 和 XPointer 都构建于 XPath 表达之上。 因此，对 XPath 的理解是很多高级 XML 应用的基础。 W3school：https://www.w3school.com.cn/xpath/index.asp","text":"XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。 XPath 是 W3C XSLT 标准的主要元素，并且 XQuery 和 XPointer 都构建于 XPath 表达之上。 因此，对 XPath 的理解是很多高级 XML 应用的基础。 W3school：https://www.w3school.com.cn/xpath/index.asp document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"Web","slug":"Web","permalink":"https://melodyjerry.github.io/blog/tags/Web/"}]},{"title":"Beyond Compare 4 试用期已过的解决办法","slug":"Beyond-Compare-4-试用期已过的解决办法","date":"2020-08-20T16:00:00.000Z","updated":"2020-09-18T04:43:02.944Z","comments":true,"path":"2020/08/21/Beyond-Compare-4-试用期已过的解决办法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/21/Beyond-Compare-4-%E8%AF%95%E7%94%A8%E6%9C%9F%E5%B7%B2%E8%BF%87%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"方法修改注册表 在搜索栏中输入 regedit ，打开注册表 删除项目：计算机 \\HKEY_CURRENT_USER\\Software\\Scooter Software\\Beyond Compare 4\\CacheId。 删除该路径下的 CacheId 即可。不过这样也只是能再使用 30 天，要是到期了重复上面步骤就好了。","text":"方法修改注册表 在搜索栏中输入 regedit ，打开注册表 删除项目：计算机 \\HKEY_CURRENT_USER\\Software\\Scooter Software\\Beyond Compare 4\\CacheId。 删除该路径下的 CacheId 即可。不过这样也只是能再使用 30 天，要是到期了重复上面步骤就好了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"[转]Spring IoC有什么好处呢？","slug":"[转]Spring-IoC有什么好处呢？","date":"2020-08-20T16:00:00.000Z","updated":"2020-09-24T08:55:08.033Z","comments":true,"path":"2020/08/21/[转]Spring-IoC有什么好处呢？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/21/[%E8%BD%AC]Spring-IoC%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%E5%91%A2%EF%BC%9F/","excerpt":"引子比如这个例子：① B{ A a=new Aimpl(); //其他代码 } ② B{ A a; //其他代码 public void setA(A a) { this.a = a; } } 第一个是直接合成使用A，第二个是用控制反转进行管理。书上只讲理论，我现在都不能体会Spring的IoC和不用相比有什么好处，能具体说一下么？由spring托管有什么好处呢？我现在感觉用spring 的set注入就是看起来代码牛逼点，完全不理解到底有什么优势啊…… 正解以下内容摘自知乎，保存转载声明。 作者：Mingqi链接：https://www.zhihu.com/question/23277575/answer/169698662 要了解控制反转( Inversion of Control ), 我觉得有必要先了解软件设计的一个重要思想：依赖倒置原则（Dependency Inversion Principle ）。","text":"引子比如这个例子：① B{ A a=new Aimpl(); //其他代码 } ② B{ A a; //其他代码 public void setA(A a) { this.a = a; } } 第一个是直接合成使用A，第二个是用控制反转进行管理。书上只讲理论，我现在都不能体会Spring的IoC和不用相比有什么好处，能具体说一下么？由spring托管有什么好处呢？我现在感觉用spring 的set注入就是看起来代码牛逼点，完全不理解到底有什么优势啊…… 正解以下内容摘自知乎，保存转载声明。 作者：Mingqi链接：https://www.zhihu.com/question/23277575/answer/169698662 要了解控制反转( Inversion of Control ), 我觉得有必要先了解软件设计的一个重要思想：依赖倒置原则（Dependency Inversion Principle ）。 ) 什么是依赖倒置原则？假设我们设计一辆汽车：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计车身，最后根据车身设计好整个汽车。这里就出现了一个“依赖”关系：汽车依赖车身，车身依赖底盘，底盘依赖轮子。 ) 这样的设计看起来没问题，但是可维护性却很低。假设设计完工之后，上司却突然说根据市场需求的变动，要我们把车子的轮子设计都改大一码。这下我们就蛋疼了：因为我们是根据轮子的尺寸设计的底盘，轮子的尺寸一改，底盘的设计就得修改；同样因为我们是根据底盘设计的车身，那么车身也得改，同理汽车设计也得改——整个设计几乎都得改！ 我们现在换一种思路。我们先设计汽车的大概样子，然后根据汽车的样子来设计车身，根据车身来设计底盘，最后根据底盘来设计轮子。这时候，依赖关系就倒置过来了：轮子依赖底盘， 底盘依赖车身， 车身依赖汽车。 ) 这时候，上司再说要改动轮子的设计，我们就只需要改动轮子的设计，而不需要动底盘，车身，汽车的设计了。 这就是依赖倒置原则——把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。这样就不会出现前面的“牵一发动全身”的情况。 ) 控制反转（Inversion of Control） 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的依赖注入（Dependency Injection）。其实这些概念初次接触都会感到云里雾里的。说穿了，这几种概念的关系大概如下： ) 为了理解这几个概念，我们还是用上面汽车的例子。只不过这次换成代码。我们先定义四个Class，车，车身，底盘，轮胎。然后初始化这辆车，最后跑这辆车。代码结构如下： ) 这样，就相当于上面第一个例子，上层建筑依赖下层建筑——每一个类的构造函数都直接调用了底层代码的构造函数。假设我们需要改动一下轮胎（Tire）类，把它的尺寸变成动态的，而不是一直都是30。我们需要这样改： ) 由于我们修改了轮胎的定义，为了让整个程序正常运行，我们需要做以下改动： ) 由此我们可以看到，仅仅是为了修改轮胎的构造函数，这种设计却需要修改整个上层所有类的构造函数！在软件工程中，这样的设计几乎是不可维护的——在实际工程项目中，有的类可能会是几千个类的底层，如果每次修改这个类，我们都要修改所有以它作为依赖的类，那软件的维护成本就太高了。 所以我们需要进行控制反转（IoC），及上层控制下层，而不是下层控制着上层。我们用依赖注入（Dependency Injection）这种方式来实现控制反转。所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制”。这里我们用构造方法传递的依赖注入方式重新写车类的定义： ) 这里我们再把轮胎尺寸变成动态的，同样为了让整个系统顺利运行，我们需要做如下修改： ) 看到没？这里我只需要修改轮胎类就行了，不用修改其他任何上层类。这显然是更容易维护的代码。不仅如此，在实际的工程中，这种设计模式还有利于不同组的协同合作和单元测试：比如开发这四个类的分别是四个不同的组，那么只要定义好了接口，四个不同的组可以同时进行开发而不相互受限制；而对于单元测试，如果我们要写Car类的单元测试，就只需要Mock一下Framework类传入Car就行了，而不用把Framework, Bottom, Tire全部new一遍再来构造Car。 这里我们是采用的构造函数传入的方式进行的依赖注入。其实还有另外两种方法：Setter传递和接口传递。这里就不多讲了，核心思路都是一样的，都是为了实现控制反转。 ) ) 看到这里你应该能理解什么控制反转和依赖注入了。那什么是控制反转容器(IoC Container)呢？其实上面的例子中，对车类进行初始化的那段代码发生的地方，就是控制反转容器。 ) 显然你也应该观察到了，因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new。这里IoC容器就解决了这个问题。这个容器可以自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码），而不用每次初始化一辆车都要亲手去写那一大段初始化的代码。这是引入IoC Container的第一个好处。 IoC Container的第二个好处是：我们在创建实例的时候不需要了解其中的细节。在上面的例子中，我们自己手动创建一个车instance时候，是从底层往上层new的： ) 这个过程中，我们需要了解整个Car/Framework/Bottom/Tire类构造函数是怎么定义的，才能一步一步new/注入。 而IoC Container在进行这个工作的时候是反过来的，它先从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new（有点像深度优先遍历）： ) 这里IoC Container可以直接隐藏具体的创建实例的细节，在我们来看它就像一个工厂： ) 我们就像是工厂的客户。我们只需要向工厂请求一个Car实例，然后它就给我们按照Config创建了一个Car实例。我们完全不用管这个Car实例是怎么一步一步被创建出来。 实际项目中，有的Service Class可能是十年前写的，有几百个类作为它的底层。假设我们新写的一个API需要实例化这个Service，我们总不可能回头去搞清楚这几百个类的构造函数吧？IoC Container的这个特性就很完美的解决了这类问题——因为这个架构要求你在写class的时候需要写相应的Config文件，所以你要初始化很久以前的Service类的时候，前人都已经写好了Config文件，你直接在需要用的地方注入这个Service就可以了。这大大增加了项目的可维护性且降低了开发难度。 ) 这里只是很粗略的讲了一下我自己对IoC和DI的理解。主要的目的是在于最大限度避免晦涩难懂的专业词汇，用尽量简洁，通俗，直观的例子来解释这些概念。如果让大家能有一个类似“哦！原来就是这么个玩意嘛！”的印象，我觉得就OK了。想要深入了解的话，可以上网查阅一些更权威的资料。这里推荐一下 Dependency injection 和 Inversion of Control Containers and the Dependency Injection pattern 这两篇文章，讲的很好很详细。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"Java web","slug":"Java-web","permalink":"https://melodyjerry.github.io/blog/tags/Java-web/"}]},{"title":"mysql 连接池连接超时的问题(The last packet successfully received from the server was 2,431 milliseconds ago.  The last packet sent successfully to the server was 2,417 milliseconds ago.)","slug":"mysql 连接池连接超时的问题","date":"2020-08-17T09:24:41.000Z","updated":"2020-09-18T04:43:03.029Z","comments":true,"path":"2020/08/17/mysql 连接池连接超时的问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/17/mysql%20%E8%BF%9E%E6%8E%A5%E6%B1%A0%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure The last packet successfully received from the server was 2,431 milliseconds ago. The last packet sent successfully to the server was 2,417 milliseconds ago. ### The error may exist in com/melodyhub/mapper/UserMapper.xml ### The error may involve com.melodyhub.mapper.UserMapper.selectUser ### The error occurred while executing a query ### Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure The last packet successfully received from the server was 2,431 milliseconds ago. The last packet sent successfully to the server was 2,417 milliseconds ago. at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:149) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:140) 解决：是mysql超时设置的问题如果连接闲置8小时 (8小时内没有进行数据库操作), mysql就会自动断开连接。 在connection url中加参数: autoReconnect=true jdbc.url=jdbc:mysql://localhost:3306/database?autoReconnect=true&amp;amp;autoReconnectForPools=true","text":"org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure The last packet successfully received from the server was 2,431 milliseconds ago. The last packet sent successfully to the server was 2,417 milliseconds ago. ### The error may exist in com/melodyhub/mapper/UserMapper.xml ### The error may involve com.melodyhub.mapper.UserMapper.selectUser ### The error occurred while executing a query ### Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure The last packet successfully received from the server was 2,431 milliseconds ago. The last packet sent successfully to the server was 2,417 milliseconds ago. at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:149) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:140) 解决：是mysql超时设置的问题如果连接闲置8小时 (8小时内没有进行数据库操作), mysql就会自动断开连接。 在connection url中加参数: autoReconnect=true jdbc.url=jdbc:mysql://localhost:3306/database?autoReconnect=true&amp;amp;autoReconnectForPools=true document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"SpringMVC：回顾MVC","slug":"SpringMVC：回顾MVC","date":"2020-08-16T16:00:00.000Z","updated":"2020-09-18T04:43:02.996Z","comments":true,"path":"2020/08/17/SpringMVC：回顾MVC/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/17/SpringMVC%EF%BC%9A%E5%9B%9E%E9%A1%BEMVC/","excerpt":"","text":"什么是MVC MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示，三者分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 \\** Model1时代 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model1优点：架构简单，比较适合小型项目开发； Model1缺点：JSP职责不单一，职责过重（Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度），不便于维护； Model2时代Model2把一个项目分成三部分，包括视图、控制、模型。 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析： Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model2消除了Model1的缺点。 回顾Servlet 新建一个Maven工程当做父工程！ pom依赖！ &lt;dependencies&gt; &lt;!-- 测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet，jsp，jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！ 导入servlet 和 jsp 的 jar 依赖 &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; 编写一个Servlet类，用来处理用户的请求 package com.kuang.servlet; //实现Servlet接口 public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //取得参数 String method = req.getParameter(\"method\"); if (method.equals(\"add\")){ req.getSession().setAttribute(\"msg\",\"执行了add方法\"); } if (method.equals(\"delete\")){ req.getSession().setAttribute(\"msg\",\"执行了delete方法\"); } //业务逻辑 //视图跳转 req.getRequestDispatcher(\"/WEB-INF/jsp/hello.jsp\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } 编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 在web.xml中注册Servlet &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/user&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 配置Tomcat，并启动测试 localhost:8080/user?method=add localhost:8080/user?method=delete MVC框架要做哪些事情 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求–调用相关的业务处理–封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明： 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF； 常见前端MVC框架：vue、angularjs、react、backbone； 由MVC演化出了另外一些模式如：MVP、MVVM等等…. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"MySQL复习基础语句","slug":"MySQL复习基础语句","date":"2020-08-16T09:24:41.000Z","updated":"2020-09-18T04:43:02.982Z","comments":true,"path":"2020/08/16/MySQL复习基础语句/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/16/MySQL%E5%A4%8D%E4%B9%A0%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5/","excerpt":"什么是约束 约束：constraintMySQL中的约束，实则是对数据表中数据的限制条件 约束的作用 约束保证数据的完整性和一致性 比如：设计数据表时，要求username字段不允许重复，这时候就需要在CREATE数据表时加入相应的约束。再比如注册时候必须填写邮箱、性别等。 约束的分类按约束定义的位置可分 列级约束 表级约束 按约束的作用可分 主键 约束 PRIMARY KEY 外键 约束 FOREIGN KEY 非空 约束 NOT NULL 唯一 约束 UNIQUE KEY 默认 约束 DEFAULT","text":"什么是约束 约束：constraintMySQL中的约束，实则是对数据表中数据的限制条件 约束的作用 约束保证数据的完整性和一致性 比如：设计数据表时，要求username字段不允许重复，这时候就需要在CREATE数据表时加入相应的约束。再比如注册时候必须填写邮箱、性别等。 约束的分类按约束定义的位置可分 列级约束 表级约束 按约束的作用可分 主键 约束 PRIMARY KEY 外键 约束 FOREIGN KEY 非空 约束 NOT NULL 唯一 约束 UNIQUE KEY 默认 约束 DEFAULT 列级约束、表级约束区别 列级约束：只能应用于一列上。 表级约束：可以应用于一列上，也可以应用在一个表中的多个列上。 即：如果你创建的约束涉及到该表的多个属性列，则必须创建的是表级约束（必须定义在表级上）；否则既可以定义在列级上也可以定义在表级上此时只是SQL语句格式不同而已。 列级约束：包含在列定义中，直接跟在该列的其它定义之后 ，用空格分隔；不必指定列名。 表级约束：与列定义相互独立，不包含在列定义中；与定义用‘，’分隔；必须指出要约束的列的名称。 注：因为在创建列级约束时，只需将创建列约束的语句添加到该字段（列）的定义子句后面；而在创建表级约束时，需要将创建表级约束的语句添加到各个字段（列）定义语句的后面，因为并不是每个定义的字段都要创建约束，所以必须指明需要创建的约束的列名。 举例说明Create Table project( 项目编号 INT CONSTRAINT pk_pno PRIMARY kEY， 项目名称 CHAR(20)， 项目负责人 CHAR(20)， CONSTRAINT un_pname_pm UNIQUE(项目名称，项目负责人) ); 分析：“项目编号”字段设置为主键，主键约束名为pk_pno，此主键约束为列主键约束。“项目名称”和“项目负责人”的组合字段设置唯一性约束，此约束为表级约束） 具体说明一：既可以创建列级约束又可以创建表级约束的： 1、主键约束（primary key constraint）： （1）定义列约束：CONSTRAINT &lt;约束名&gt; PRIMARY KEY （2）定义表约束：[CONSTRAINT &lt;约束名&gt;] PRIMARY KEY( &lt;列名&gt; [{&lt;列名&gt;}]) 2、唯一性约束（unique key constraint）： （1）定义列约束：[CONSTRAINT &lt;约束名&gt;] UNIQUE [KEY] （2）定义表约束：CONSTRAINT &lt;约束名&gt; UNIQUE [KEY] ( &lt;列名&gt; [{&lt;列名&gt;}]) 3、外键约束（foreign key constraint）： 定义 列级约束：[CONSTRAINT &lt;约束名&gt;] FOREIGN KEY REFERENCES &lt;外表名&gt; 定义表级约束：[CONSTRAINT &lt;约束名&gt;] FOREIGN KEY REFERENCES &lt;外表名&gt;( &lt;列名&gt; [{&lt;列名&gt;}]) 二：只能创建列级约束的： 1，缺省约束（default constraint）： [CONSTRAINT &lt;约束名&gt;] DEFAULT 约束条件 2，NULL 约束： [CONSTRAINT &lt;约束名&gt;] [NULL | NOT NULL] 主键约束 PRIMARY KEY“主键（PRIMARY KEY）”的完整称呼是“主键约束”。MySQL 主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。 涉及术语 主键约束 主键字段 主键值 三种术语的关系： 表中的某个字段添加主键约束后，该字段为主键字段，主键字段中出现的每一个数据都称为主键值 特点 保证数据的实体完整性 要求 一张表应该有主键字段，如果没有，表示该表无效 主键值：是当前行数据的唯一标识、是当前行数据的身份证号 即使表中两行记录相关数据相同，但由于主键值不同，所以也认为是两行不同的记录 按主键约束的字段数量分类 在MySQL的一个表中只有唯一的一个主键，不能有多列主键，但可以有复合主键。一个表中可以：单列做主键、多列做主键（复合主键）。 单一主键：给一个字段添加主键约束 复合主键：给多个字段联合添加一个主键约束(只能用表级定义) 单一主键（列级定义）mysql&gt; create table t_user( -&gt; id int(10) primary key, -&gt; name varchar(32) -&gt; ); Query OK, 0 rows affected (0.07 sec) 单一主键（表级定义）mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; constraint t_user_id_pk primary key(id) -&gt; ); Query OK, 0 rows affected (0.01 sec) 复合主键（表级定义） 一定要在表级定义。 mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; email varchar(128) unique, -&gt; primary key(id,name) -&gt; ); Query OK, 0 rows affected (0.05 sec) 配合AUTO_INCREMENT 在MySQL数据库提供了一个自增的数字，专门用来自动生成主键值，主键值不用用户维护，自动生成，自增数从1开始，以1递增(auto_increment) mysql&gt; create table t_user( -&gt; id int(10) primary key auto_increment, -&gt; name varchar(32) not null -&gt; ); Query OK, 0 rows affected (0.03 sec) /*插入两行记录，id主键值会自动增加*/ mysql&gt; insert into t_user(name) values('jay'); Query OK, 1 row affected (0.04 sec) mysql&gt; insert into t_user(name) values('man'); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from t_user; +----+------+ | id | name | +----+------+ | 1 | jay | | 2 | man | +----+------+ 2 rows in set (0.00 sec) 外键约束 FOREIGN KEY外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。 外键的主要作用是保持数据的一致性、完整性。例如，部门表 tb_dept 的主键是 id，在员工表 tb_emp5 中有一个键 deptId 与这个 id 关联。 主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表。 从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表。 快速理解之前创建表的时候都是在一张表中添加记录，比如如下表： 公司有3个部门，但是有1个亿的员工，那意味着部门这个字段需要重复存储，部门名字越长，越浪费。这个时候，解决方法：我们完全可以定义一个部门表，然后让员工信息表关联该表，如何关联，即foreign key。 我们可以将上表改为如下结构： 涉及到的术语 外键约束 外键字段 外键值 三种术语的关系： 某个字段添加外键约束之后，该字段称为外键字段，外键字段中每个数据都是外键值 特点 保持数据的一致性 完整性 实现一对一或者一对多关系 这也是为什么称为MySQL关系型数据库的原因 要求 ★父表（子表所参照的表）和子表（具有外键列的表）必须使用使用相同的存储引擎，而且禁止使用临时表。 ★外键对应的是参照完整性，一个表的外键可以为NULL，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。 ★定义外键时，创建先创建父表。定义外键后，插入先插入父表数据，同理，删除先删除子表数据。 数据表的存储引擎只能为InnoDB。（编辑数据库的默认存储引擎，修改完需要重启MySQL服务） 外键列（加FOREIGN KEY关键词的一列）和参照列（外键列参照的一列）必须具有相似的数据类型,如果是数字数据类型，则数字长度或者是否有符号位必须相同；如果为字符数据类型长度可以不同。 ★外键列和参照列（主键在创建的同时，会自动创建索引seq_in_index）必须创建索引。如果外键列不存在索引的话，MySQL将自动创建。 与主键的区别 一张表可以有多个外键，但是主键最多只有一个。 按外键约束的字段数量分类 单一外键：给一个字段添加外键约束 复合外键：给多个字段联合添加一个外键约束 表复合外键（表级定义）FOREIGN KEY(classno) REFERENCES t_class(cno); 非空约束用NOT NULL约束的字段不能为NULL值，必须给定具体的数据。 注意的是 NULL，表示空，并不是字符串中的空。两者需要区分开。 实例mysql&gt; CREATE TABLE t12(id INT NOT NULL); #设置字段id不为空 Query OK, 0 rows affected (0.03 sec) mysql&gt; DESC t12; +-------+---------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+---------+------+-----+---------+-------+ | id | int(11) | NO | | NULL | | +-------+---------+------+-----+---------+-------+ row in set (0.01 sec) 验证 mysql&gt; INSERT INTO t12 VALUES(); #不能插入空 ERROR 1364 (HY000): Field 'id' doesn't have a default value 唯一约束UNIQUE约束的字段，具有唯一性，不可重复，但可以为NULL。 列级约束mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; email varchar(128) unique -&gt; ); Query OK, 0 rows affected (0.03 sec) 表级约束mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; email varchar(128）， -&gt; unique(email) -&gt; ); 如果插入相同email会报错 mysql&gt; insert into t_user(id,name,email) values(1,'xlj','932834897@qq.com'); Query OK, 1 row affected (0.00 sec) mysql&gt; insert into t_user(id,name,email) values(2,'jay','932834897@qq.com'); ERROR 1062 (23000): Duplicate entry '932834897@qq.com' for key 'email' 扩展：联合唯一约束# 创建services表 mysql&gt; create table services( id int, ip char(15), port int, unique(id), unique(ip,port) ); Query OK, 0 rows affected (0.05 sec) mysql&gt; desc services; +-------+----------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+----------+------+-----+---------+-------+ | id | int(11) | YES | UNI | NULL | | | ip | char(15) | YES | MUL | NULL | | | port | int(11) | YES | | NULL | | +-------+----------+------+-----+---------+-------+ rows in set (0.01 sec) #联合唯一，只要两列记录，有一列不同，既符合联合唯一的约束 mysql&gt; insert into services values (1,'192,168,11,23',80), (2,'192,168,11,23',81), (3,'192,168,11,25',80); Query OK, 3 rows affected (0.01 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql&gt; select * from services; +------+---------------+------+ | id | ip | port | +------+---------------+------+ | 1 | 192,168,11,23 | 80 | | 2 | 192,168,11,23 | 81 | | 3 | 192,168,11,25 | 80 | +------+---------------+------+ rows in set (0.00 sec) mysql&gt; insert into services values (4,'192,168,11,23',80); ERROR 1062 (23000): Duplicate entry '192,168,11,23-80' for key 'ip' 更多可参考 mysql 给表添加唯一约束、联合唯一约束，指定唯一约束的名字 默认约束为某一字段提供默认值。 创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值 实例create table tb1( id int not null, sex char defalut 'b' ); 验证 mysql&gt; insert into tb1(id) values(1); #给t11表插一个空的值 Query OK, 1 row affected (0.00 sec) #查询结果如下 mysql&gt; select * from t11; +------+------+ | id | sex | +------+------+ | 1 | b | +------+------+ row in set (0.00 sec) 主要文献：[部分概念来自C语言中文网] http://c.biancheng.net/view/2440.html[大部分案例的代码块来自CSDN] https://blog.csdn.net/w_linux/article/details/79655073 注：案例中的SQL语句并非作者写的，存在规范问题，但不影响阅读。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[转]事务的ACID理解","slug":"[转]事务的ACID理解","date":"2020-08-16T09:24:41.000Z","updated":"2020-09-18T04:43:03.020Z","comments":true,"path":"2020/08/16/[转]事务的ACID理解/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/16/[%E8%BD%AC]%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%90%86%E8%A7%A3/","excerpt":"作者：malaikuangren原文链接：https://www.cnblogs.com/malaikuangren/archive/2012/04/06/2434760.html 简介 ACID，是指在可靠数据库管理系统（DBMS）中，事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）.这是可靠数据库所应具备的几个特性.下面针对这几个特性进行逐个讲解.","text":"作者：malaikuangren原文链接：https://www.cnblogs.com/malaikuangren/archive/2012/04/06/2434760.html 简介 ACID，是指在可靠数据库管理系统（DBMS）中，事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）.这是可靠数据库所应具备的几个特性.下面针对这几个特性进行逐个讲解. 理解原子性(Atomicity) 原子性意味着数据库中的事务执行是作为原子。即不可再分，整个语句要么执行，要么不执行。 在SQL SERVER中，每一个单独的语句都可以看作是默认包含在一个事务之中: 所以，每一个语句本身具有原子性，要么全部执行，这么全部不执行，不会有中间状态: 上面说了，每一条T-SQL语句都可以看作是默认被包裹在一个事务之中的,SQL Server对于每一条单独的语句都实现了原子性，但这种原子粒度是非常小的，如果用户想要自己定义原子的大小，则需要包含在事务中来构成用户自定义的原子粒度: 对于用户来说，要用事务实现的自定义原子性往往是和业务相关的，比如银行转账，从A账户减去100，在B账户增加100，如果这两个语句不能保证原子性的话，比如从A账户减去100后，服务器断电，而在B账户中却没有增加100.虽然这种情况会让银行很开心，但作为开发人员的你可不希望这种结果.而默认事务中，即使出错了也不会整个事务进行回滚。而是失败的语句抛出异常，而正确的语句成功执行。这样会破坏原子性。所以SQL SERVER给予了一些选项来保证事务的原子性. SQL SERVER提供了两大类方式来保证自定义事务的原子性： 1.通过SET XACT_ABORT ON来设置事务必须符合原子性 ​ 利用设置XACT_ABORT选项设置为ON,来设置所有事务都作为一个原子处理.下面例子利用两个语句插入到数据库，可以看到开启SET XACT_ABORT ON选项后，事务具有了原子性: 2.按照用户设置进行回滚(ROLLBACK) ​ 这种方式具有更高的灵活性，开发人员可以自定义在什么情况进行ROLLBACK,利用TRY CATCH语句和@@ERROR进行判断都属于这种方式. 理解一致性(Consistency) 一致性,即在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 一致性分为两个层面 1.数据库机制层面 数据库层面的一致性是，在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束,Check约束等)和触发器设置.这一点是由SQL SERVER进行保证的. 2.业务层面 对于业务层面来说,一致性是保持业务的一致性.这个业务一致性需要由开发人员进行保证.很多业务方面的一致性可以通过转移到数据库机制层面进行保证.比如，产品只有两个型号，则可以转移到使用CHECK约束使某一列必须只能存这两个型号. 理解隔离性（Isolation) 隔离性。事务的执行是互不干扰的，一个事务不可能看到其他事务运行时，中间某一时刻的数据。 在Windows中，如果多个进程对同一个文件进行修改是不允许的，Windows通过这种方式来保证不同进程的隔离性 而SQL Server中，通过SQL SERVER对数据库文件进行管理，从而可以让多个进程可以同时访问数据库: SQL Server利用加锁和阻塞来保证事务之间不同等级的隔离性. 一般情况下，完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样的性能可想而知.想要理解SQL Server中对于隔离性的保障，首先要了解事务之间是如何干扰的. 事务之间的互相影响的情况分为几种，分别为:脏读(Dirty Read)，不可重复读，幻读 脏读 脏读意味着一个事务读取了另一个事务未提交的数据,而这个数据是有可能回滚的,下面来看一个例子: 两个事务，事务A插入一条数据，但未提交，事务B在此期间进行了读取，读取到了事务A未提交的数据，造成脏读 不可重复读(Unrepeatable Read) 不可重复读意味着，在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。 下面来看一个不可重复读的例子: 事务B中对某个查询执行两次，当第一次执行完时，事务A对其数据进行了修改。事务B中再次查询时，数据发生了改变: ) 幻读(phantom read) 幻读,是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样. 下面来看一个例子: 事务B更新表中所有的数据，在此期间事务A插入了一条数据，事务B再次查询后，发现居然还有没有修改的数据，产生幻读: 理解SQL SERVER中的隔离级别 为了避免上述几种事务之间的影响,SQL Server通过设置不同的隔离等级来进行不同程度的避免。因为高的隔离等级意味着更多的锁，从而牺牲性能.所以这个选项开放给了用户根据具体的需求进行设置。不过默认的隔离等级Read Commited符合了99%的实际需求. SQL Server隔离事务之间的影响是通过锁来实现的，这个概念比较繁杂，所以本文不会详细对这个概念进行讲解.通过阻塞来阻止上述效果 SQL Server提供了5种选项来避免不同级别的事务之间的影响 隔离等级由低到高分别为 Read Uncommited(最高的性能，但可能出现脏读，不可重复读，幻读) Read commited(可能出现不可重复读，幻读) Repeatable Read(可能出现幻读) Serializable(最低的性能，一次只能执行一个事务，但避免了上述所有情况) SNOPSHOT(这个是通过在tempDB中创建一个额外的副本来避免脏读，不可重复读，会给tempDB造成额外负担，因为不是标准ANSI SQL标准，不详细讨论) 总之，不同的隔离级别是通过加不同的锁，造成阻塞来实现的，来看一个例子: SQL SERVER通过阻塞来阻止脏读，所以保持独立性会以付出性能作为代价： 理解持久性（Durability) 持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 即使出现了任何事故比如断电等，事务一旦提交，则持久化保存在数据库中. SQL SERVER通过write-ahead transaction log来保证持久性。write-ahead transaction log的意思是，事务中对数据库的改变在写入到数据库之前，首先写入到事务日志中。而事务日志是按照顺序排号的（LSN）。当数据库崩溃或者服务器断点时，重启动SQL SERVER，SQL SERVER首先会检查日志顺序号，将本应对数据库做更改而未做的部分持久化到数据库，从而保证了持久性. “若要了解预写日志的工作原理，最重要的是了解如何将修改的数据写入磁盘。SQL Server 维护当必须检索数据时，将数据页读入的缓冲区高速缓存。数据修改不是直接在磁盘上进行，而是修改高速缓冲存储器中的页副本。直到数据库中出现检查点，或者必须将修改写入磁盘才能使用缓冲区来容纳新页时，才将修改写入磁盘。将修改后的数据页从高速缓冲存储器写入磁盘的操作称为刷新页。在高速缓存中修改但尚未写入磁盘的页称为“脏页”。 对缓冲区中的页进行修改时，将在记录修改的日志高速缓存中生成一条日志记录。在将关联的脏页从高速缓冲存储器刷新到磁盘之前，必须将这条日志记录写入磁盘。如果在写入日志记录前刷新脏页，则该脏页便会在磁盘上创建修改。如果服务器在将日志记录写入磁盘前失败，则不能回滚此修改。SQL Server 具有防止在写入关联的日志记录前刷新脏页的逻辑。日志记录将在提交事务时写入磁盘。”(MSDN) 总结 本文简单讲述了ACID的概念和ACID在SQL SERVER中的实现.ACID只是一个理念，并不是某项具体的技术.对于健壮数据库来说，保证ACID是可靠数据库的前提. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"事务","slug":"事务","permalink":"https://melodyjerry.github.io/blog/tags/%E4%BA%8B%E5%8A%A1/"}]},{"title":"连接JDBC报错com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException Could not create connection to database server.","slug":"连接JDBC报错","date":"2020-08-16T09:24:41.000Z","updated":"2020-09-18T04:43:03.295Z","comments":true,"path":"2020/08/16/连接JDBC报错/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/08/16/%E8%BF%9E%E6%8E%A5JDBC%E6%8A%A5%E9%94%99/","excerpt":"问题：Spring整合Mybatis时候，出现数据库连接异常： com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server. Attempted reconnect 3 times. Giving up. 分析： 找了好半天的原因，最后发现是相关jdbc驱动包版本太低！ 解决方法： 下载最新版的mysql-connector-java即可。虽然可以连接成功，但是控制台还是提示： Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. 修改一下mybatis-config.xml： &lt;!--&lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt;--&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;","text":"问题：Spring整合Mybatis时候，出现数据库连接异常： com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server. Attempted reconnect 3 times. Giving up. 分析： 找了好半天的原因，最后发现是相关jdbc驱动包版本太低！ 解决方法： 下载最新版的mysql-connector-java即可。虽然可以连接成功，但是控制台还是提示： Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. 修改一下mybatis-config.xml： &lt;!--&lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt;--&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"}]},{"title":"[转]Java集合框架知识整理","slug":"[转]Java集合框架知识整理","date":"2020-07-29T13:00:00.000Z","updated":"2020-09-18T04:43:03.011Z","comments":true,"path":"2020/07/29/[转]Java集合框架知识整理/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/29/[%E8%BD%AC]Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/","excerpt":"文章作者：blinkfox 文章链接：https://blinkfox.github.io/2018/10/24/hou-duan/java/java-ji-he-kuang-jia-zhi-shi-zheng-li/ Java集合框架主要由Collection和Map两个根接口及其子接口、实现类组成。","text":"文章作者：blinkfox 文章链接：https://blinkfox.github.io/2018/10/24/hou-duan/java/java-ji-he-kuang-jia-zhi-shi-zheng-li/ Java集合框架主要由Collection和Map两个根接口及其子接口、实现类组成。 集合类关系梳理 Collection接口继承了Iterable接口，依赖了Predicate、Spliterator、Stream接口（这些均为Java8新增），Iterable接口依赖了Iterator接口。 List接口继承自Collection接口,依赖了UnaryOperator接口（Java8新增）、ListIterator、Comparator接口 Queue接口继承了Collection接口 Deque接口继承了Queue接口 BlockingQueue接口继承了Queue接口 BlockingDeque接口继承了BlockingQueue、Deque接口 TransferQueue接口继承了BlockingQueue接口 AbstractCollection抽象类实现了Collection接口 - `AbstractList`抽象类继承了`AbstractCollection`抽象类，实现了`List`接口，依赖了`List`、`RandomAccess`、`Cloneable`、`Serializable`接口 - `ArrayList`类继承了`AbstractList`抽象类，实现了`List`、`RandomAccess`、`Cloneable`、`Serializable`接口 - `AbstractSequentialList`抽象类继承了`AbstractList`抽象类 - `LinkedList`类继承了`AbstractSequentialList`抽象类，实现了`List`、`Deque`、`Cloneable`、`Serializable`接口 - `CopyOnWriteArrayList`实现了`List`、`RandomAccess`、`Cloneable`、`Serializable`接口 - `Vector`类继承了`AbstractList`抽象类，实现了`List`、`RandomAccess`、`Cloneable`、`Serializable`接口 - `Stack`类继承了`Vector`类 AbstractQueue抽象类继承了AbstractCollection接口，实现了Queue接口 SynchronousQueue类继承了AbstractQueue接口，实现了BlockingQueue、Serializable接口，依赖了Collection、Spliterator接口 ArrayBlockingQueue类继承了AbstractQueue接口，实现了BlockingQueue、Serializable接口 LinkedBlockingQueue类继承了AbstractQueue接口，实现了BlockingQueue、Serializable接口 PriorityBlockingQueue类继承了AbstractQueue接口，实现了BlockingQueue、Serializable接口，聚合了Comparator接口，依赖了Collection、Comparator、Comparable接口 DelayQueue类继承了AbstractQueue接口，实现了BlockingQueue接口 LinkedBlockingDeque类继承了AbstractQueue接口，实现了BlockingDeque、Serializable接口 PriorityQueue类继承了AbstractQueue接口 LinkedTransferQueue类继承了AbstractQueue接口，实现了TransferQueue、Serializable接口（Java7新增） ConcurrentLinkedDeque类继承了AbstractCollection抽象类，实现了Deque、Cloneable、Serializable接口 ArrayDeque类继承了AbstractCollection抽象类，实现了Deque、Serializable接口 Set接口继承自Collection接口 AbstractSet抽象类继承了AbstractCollection抽象类，实现了Set接口 HashSet类继承了AbstractSet抽象类，实现了Set、Cloneable、Serializable接口，聚合了HashMap LinkedHashSet类继承了HashSet类，实现了Set、Cloneable、Serializable接口 TreeSet类继承了AbstractSet抽象类，实现了NavigableSet、Cloneable、Serializable接口，聚合了NavigableMap，依赖了Comparator、SortedSet接口 EnumSet抽象类继承了AbstractSet抽象类，实现了Cloneable、Serializable接口，依赖了Comparator、SortedSet接口 RegularEnumSet类继承了EnumSet抽象类 JumboEnumSet类继承了EnumSet抽象类 ConcurrentSkipListSet类继承了AbstractSet抽象类，实现了NavigableSet、Cloneable、Serializable接口 CopyOnWriteArraySet类继承了AbstractSet抽象类，实现了Serializable接口，聚合了CopyOnWriteArrayList类，依赖了Predicate、Consumer接口 SortedSet接口继承自Set接口，依赖了Comparator接口 NavigableSet接口继承自SortedSet接口(Java6新增) Map接口依赖了Set、Collection、BiConsumer、Function、BiFunction接口，Map.Entry是Map中的内部接口 AbstractMap抽象类实现了Map接口，聚合了Collection、Set接口 HashMap类继承了AbstractMap抽象类，实现了Map、Cloneable、Serializable接口，依赖了Collection、Set接口 LinkedHashMap继承了HashMap类，实现了Map接口，依赖了Collection、Set、Consumer、BiConsumer接口 TreeMap类继承了AbstractMap抽象类，实现了NavigableMap、Cloneable、Serializable接口，依赖了Comparator、SortedMap、Collection、Set、BiConsumer、BiFunction接口 EnumMap类继承了AbstractMap抽象类，实现了Cloneable、Serializable接口，依赖了AbstractSet类，Collection、Set接口 WeakHashMap类继承了AbstractMap抽象类，实现了Map接口，依赖了Collection、Set、Consumer、BiConsumer、BiFunction接口 IdentityHashMap类继承了AbstractMap抽象类，实现了Map、Serializable、Cloneable接口，依赖了Collection、Set、Consumer、BiConsumer、BiFunction接口 ConcurrentHashMap类继承了AbstractMap抽象类，实现了ConcurrentMap、Serializable接口，依赖了Comparable、ParameterizedType、Collection、Set、Spliterator、Consumer、BiConsumer、Function、BiFunction、ToDoubleFunction、DoubleBinaryOperator等接口 ConcurrentSkipListMap类继承了AbstractMap抽象类，实现了ConcurrentNavigableMap、Cloneable、Serializable接口，聚合了Comparator接口，依赖了Collection、Set、Consumer、BiConsumer、BiFunction、NavigableSet接口 SortedMap接口继承自Map接口，依赖了Set、Collection、Comparator接口 NavigableMap接口继承了SortedMap接口，依赖了NavigableSet接口 ConcurrentNavigableMap接口继承了ConcurrentMap、NavigableMap接口，聚合了NavigableSet接口 ConcurrentMap接口继承了Map接口，依赖了BiConsumer、BiFunction接口 Hashtable类继承了Dictionary抽象类，实现了Map、Cloneable、Serializable接口，聚合了Collection、Set接口，依赖了Enumeration、BiConsumer、BiFunction接口 Properties类继承了Hashtable类 Collections是Collection的辅助工具类，依赖了上述大多数接口和类 Arrays是数组的辅助工具类，依赖了上述一些接口和类 集合UML关系图Java Collection UML类关系图如下： Java Map UML类关系图如下： 各集合接口、类的介绍 Collection：Collection是最基本集合接口，它定义了一组允许重复的对象。Collection接口派生了三个子接口List、Set和Queue。Collection所有实现类的遍历都可以使用Iterator接口或者是foreach来循环。 List：List代表有序、可重复的集合。 ArrayList：底层使用数组的形式来实现，排列有序可重复，查询速度快、增删数据慢，线程不安全，效率高。ArrayList创建时的大小为0；当加入第一个元素时，进行第一次扩容时，默认容量大小为10，每次扩容都以当前数组大小的1.5倍去扩容。 Vector：底层使用数组的形式来实现，排列有序可重复，查询速度快、增删数据慢，线程安全，效率低。Vector创建时的默认大小为10；Vector每次扩容都以当前数组大小的2倍去扩容。当指定了capacityIncrement之后，每次扩容仅在原先基础上增加capacityIncrement个单位空间。ArrayList和Vector的add、get、size方法的复杂度都为O(1)，remove方法的复杂度为O(n)。 Stack：Vector的一个子类，是标准的先进后出(FILO, First In Last Out)的栈。底层通过数组实现的，线程安全。 LinkedList：底层使用双向循环链表的数据结构来实现，排列有序可重复，查询速度慢、增删数据快，线程不安全。 CopyOnWriteArrayList：底层使用Copy-On-Write的优化策略实现，适用于读多写少的场景，同ArrayList功能相似，线程安全。CopyOnWriteArrayList在某些情况下比Collections.synchronizedList(List list)有更好的性能。缺点是：内存占用大和数据一致性问题，只能保证最终一致性。 Set：Set代表无序、不可重复的集合。 HastSet：底层使用Hash表来实现，内部使用了HashMap，排列无序不可重复，存取速度快，线程不安全。 LinkedHashSet：底层采用Hash表存储，并用双向链表记录插入顺序，排列有序不可重复，存取速度较HashSet略慢，比TreeSet快，线程不安全。 TreeSet：底层使用红黑树来实现，内部使用了NavigableMap，按自然顺序或者自定义顺序存放、不可重复，线程不安全。 CopyOnWriteArraySet：底层使用Copy-On-Write的优化策略实现，适用于读多写少的场景，内部使用了CopyOnWriteArrayList，同HastSet功能相似，线程安全。 ConcurrentSkipListSet：底层使用跳跃列表来实现，适用于高并发的场景，内部使用了ConcurrentNavigableMap，同TreeSet功能相似，线程安全。 EnumSet：是抽象类，只能用来存储Enum常量或其子类，不能存储其它类型，EnumSet有两种实现方式，RegularEnumSet和JumboEnumSet，但是这两种实现方式是包私有的，不能在包外访问，因此必须使用工厂方法来创建并返回EnumSet实例，不能通过构造函数来创建。EnumSet中提供了多种创建EnumSet实例的静态工厂方法，例如of方法（进行了函数重载），copyOf方法，noneOf方法等。存储效率快，线程不安全。存储枚举常量时使用EnumSet而不要用HashSet。 Queue：Queue是Java 5之后增加的集合体系，表示队列集合的相关实现，大多遵循先进先出(FIFO, First-In-First-Out)的模式。 PriorityQueue：即优先队列，底层基于优先堆的一个无界队列来实现，无界但可选容量界限。这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序，而不是先进先出。不允许空值、不支持non-comparable（不可比较）的对象，每次从队列中取出的是具有最高优先权的元素，线程不安全。 ArrayBlockingQueue：底层基于定长数组的阻塞队列实现，即是线程安全的有界阻塞队列。ArrayBlockingQueue内部通过互斥锁保护竞争资源，实现了多线程对竞争资源的互斥访问。队列中的锁是没有分离的，所以在添加的同时就不能读取，读取的同时就不能添加，所以锁方面性能不如LinkedBlockingQueue。 LinkedBlockingQueue：即链接队列，底层基于单向链表的阻塞队列实现，无界但可选容量界限，线程安全。队列中的锁是分离的，即添加用的是putLock，获取是takeLock，所以在添加获取方面理论上性能会高于ArrayBlockingQueue。所以LinkedBlockingQueue更适合实现生产者-消费者队列。 PriorityBlockingQueue：即优先阻塞队列，底层基于优先堆的一个无界队列来实现，无界但可选容量界限的阻塞队列，线程安全，功能同PriorityQueue、LinkedBlockQueue相似。其所含对象的排序不是先进先出，而是依据对象的自然排序顺序或者是构造函数的Comparator决定的顺序。 SynchronousQueue：即同步队列，是一种线程安全无缓冲的无界阻塞队列。其操作必须是放和取交替完成的，即每个put必须等待一个take，反之亦然。 DelayQueue：即延迟队列，是一种有序无界阻塞队列，只有在延迟期满时才能从中提取元素，线程安全。 ArrayDeque：底层采用了循环数组的方式来完成双端队列的实现，无限扩展且可选容量。Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque来实现栈的功能，非线程安全。 LinkedBlockingDeque：底层采用了双向链表实现的双端阻塞并发队列，无限扩展且可选容量。该阻塞队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。 ConcurrentLinkedDeque：底层采用了双向链表实现的双端非阻塞并发队列，无限扩展且可选容量。该队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。 LinkedTransferQueue：底层采用了单向链表实现的无界传输阻塞队列，先进先出，无限扩展且可选容量线程安全。 Map：Map代表具有映射关系的集合。 HashMap：底层是用链表数组，Java8后又加了红黑树来实现，键无序不可重复可为null、值可重复可为null，存取速度快，线程不安全。 LinkedHashMap：底层是用链表数组存储，并用双向链表记录插入顺序，键有序不可重复可为null、值可重复可为null，存取速度快较HashMap略慢，比TreeMap快，线程不安全。 HashTable：底层是用链表数组，键无序不可重复可为null、值可重复可为null，存取速度较HashMap慢，线程安全。 Properties：是HashTable的子类，是&lt;String,String&gt;的映射，比HashTable多了load、store两个方法，线程安全。 TreeMap：底层使用红黑树来实现，内部使用了Comparator，按自然顺序或自定义顺序存放键，键不可重复不可为null、值可重复可为null，存取速度较HashMap慢，线程不安全。 EnumMap：底层使用数组来实现，是专门为枚举类型量身定做的Map，性能更好。只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以EnumMap使用数组来存放与枚举类型对应的值，线程不安全。 WeakHashMap：同HashMap基本相似。区别在于，HashMap的key保留对象的强引用，这意味着只要该HashMap对象不被销毁，该HashMap对象所有key所引用的对象不会被垃圾回收，HashMap也不会自动删除这些key所对应的key-value对象；但WeakHashMap的key只保留对实际对象的弱引用，这意味着当垃圾回收了该key所对应的实际对象后，WeakHashMap会自动删除该key对应的key-value对象。 IdentityHashMap：同HashMap基本相似。区别在于，在处理两个key相等时，对于普通HashMap而言，只要key1和key2通过equals比较返回true时就认为key相同；在IdentityHashMap中，当且仅当两个key严格相等时(key1 = key2)时才认为两个key相同。 ConcurrentHashMap：底层使用锁分段技术来实现线程安全，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 ConcurrentSkipListMap：底层使用跳跃列表来实现，适用于高并发的场景，内部使用了ConcurrentNavigableMap，同TreeMap功能相似，是一个并发的、可排序的Map，线程安全。因此它可以在多线程环境中弥补ConcurrentHashMap不支持排序的问题。 Java集合框架功能介绍思维导图如下： 一些概念解释 跳表：是一种采用了用空间换时间思想的数据结构。它会随机地将一些节点提升到更高的层次，以创建一种逐层的数据结构，以提高操作的速度。 阻塞队列和非阻塞的区别：如果队列里面已经放满了，如果是阻塞队列那么线程会一直阻塞，而非阻塞对垒则会抛出异常。 一些数据结构的优缺点 Hash表：插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。 红黑树：插入、查找为O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。 SkipList：插入、查找为O(logn)，但常数项比红黑树要大；底层结构为链表，可无锁实现；数据天然有序。 一些接口的主要方法梳理Collection接口中的抽象方法 int size()，返回集合的大小 boolean isEmpty()，返回集合是否为空的布尔值 boolean contains(Object o)，返回集合是否包含元素o的布尔值 Iterator&lt;E&gt; iterator()，返回该集合中元素的迭代器，继承自Iterable接口 Object[] toArray()，返回一个包含此集合中所有元素的数组 &lt;T&gt; T[] toArray(T[] a)，toArray()方法的泛型版本，返回一个包含此集合中所有元素的数组，返回类型由传入数组参数的类型决定 boolean add(E e)，返回向集合中插入元素e是否成功的布尔值 boolean remove(Object o)，返回从集合中删除元素o是否成功的布尔值 boolean containsAll(Collection&lt;?&gt; c)，返回本集合中是否完全包含集合c的布尔值，即判断集合c是否是本集合子集 boolean addAll(Collection&lt;? extends E&gt; c)，将集合c中的所有元素添加到本集合中并返回 boolean removeAll(Collection&lt;?&gt; c)，移除本集合中所有包含集合c的所有元素 default boolean removeIf(Predicate&lt;? super E&gt; filter)，Java8新增的接口默认方法。将会批量删除符合filter条件的所有元素，该方法需要一个Predicate对象作为作为参数，Predicate也是函数式接口，因此可使用Lambda表达式作为参数。 boolean retainAll(Collection&lt;?&gt; c)，返回本集合和集合c中相同的元素并存到本集合中,集合c保持不变，返回值表示的是本集合是否发生过改变。即该方法是用来求两个集合的交集，交集的结果存到本集合中，如果本集合没发生变化则返回true void clear()，清空本集合中的所有元素 boolean equals(Object o)，返回本集合是否和对象o相等的布尔值 int hashCode()，返回此集合的Hash码值 default Spliterator&lt;E&gt; spliterator()，在集合中创建Spliterator对象 Spliterator是Java 8引入的新接口，顾名思义，Spliterator可以理解Iterator的Split版本（但用途要丰富很多）。使用Iterator的时候，我们可以顺序地遍历容器中的元素，使用Spliterator的时候，我们可以将元素分割成多份，分别交于不于的线程去遍历，以提高效率。使用Spliterator每次可以处理某个元素集合中的一个元素 — 不是从Spliterator中获取元素，而是使用tryAdvance()或forEachRemaining()方法对元素应用操作。但Spliterator还可以用于估计其中保存的元素数量，而且还可以像细胞分裂一样变为一分为二。这些新增加的能力让流并行处理代码可以很方便地将工作分布到多个可用线程上完成。 default Stream&lt;E&gt; stream()，返回一个顺序的Stream对象。Java8引入了Stream以实现对集合更方便地进行函数式编程。 default Stream&lt;E&gt; parallelStream()，返回一个可能并行的Stream对象。Java8新增的方法。流可以是顺序的也可以是并行的。顺序流的操作是在单线程上执行的，而并行流的操作是在多线程上并发执行的。 List接口中的额外抽象方法 boolean addAll(int index, Collection&lt;? extends E&gt; c)，将指定集合c中的所有元素插入到指定索引位置处 default void replaceAll(UnaryOperator&lt;E&gt; operator)，Java8新增的使用Lambda的方式，通过应用UnaryOperator获得的结果来替换列表中的每个元素 default void sort(Comparator&lt;? super E&gt; c)，在比较器的基础上将本列表排序 E get(int index)，获取本集合中指定索引位置处的元素 E set(int index, E element)，设置或替换本集合中指定索引位置处的元素 void add(int index, E element)，在本集合中的指定索引位置处插入指定的元素 E remove(int index)，移除本集合中指定索引位置处的元素 int indexOf(Object o)，返回指定元素第一次出现的索引位置 int lastIndexOf(Object o)，返回指定元素最后出现的索引位置 ListIterator&lt;E&gt; listIterator()，返回本集合中的ListIterator迭代器 ListIterator&lt;E&gt; listIterator(int index)，返回本集合中从指定索引位置开始的ListIterator迭代器 List&lt;E&gt; subList(int fromIndex, int toIndex)，返回指定开始和结束索引位置的子集合 Set接口中的额外抽象方法无 Map接口中的抽象方法 boolean containsKey，判断本Map集合中是否包含指定的key键 boolean containsValue，判断本Map集合中是否包含指定的value值 V get(Object key)，根据key获取本Map集合中的value值 V get(Object key)，向本Map集合中存放key键和value值,返回value值 V remove(Object key)，根据key删除本Map集合中的key和value值，并返回删除的value值 void putAll(Map&lt;? extends K, ? extends V&gt; m)，将指定的Map集合添加到本的Map集合当中 Set&lt;K&gt; keySet()，获取本Map集合中的所有key值，并以Set接口的结果作为返回 Collection&lt;V&gt; values()，获取本Map集合中的所有value值，并以Collection接口的结果作为返回 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()，获取本Map集合中的所有key和value值，并以Set&lt;Map.Entry&lt;K, V&gt;&gt;的结果作为返回 default V getOrDefault(Object key, V defaultValue)，根据key获取本Map集合中的value值，如果没找到对应的值或者value值是null,则返回defaultValue的值 default void forEach(BiConsumer&lt;? super K, ? super V&gt; action)，Java8新增的使用Lambda的方式遍历操作Map中的元素的默认接口方法 default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)，Java8新增的使用Lambda的方式遍历替换Map中的元素的默认接口方法 default V putIfAbsent(K key, V value)，Java8新增的不用写是否为null值的检测语句向Map中保存key和value的元素的默认接口方法，即如果通过key获取到的value是空的，则在调用put(key, value)方法并返回value值 default boolean remove(Object key, Object value)，Java8新增的默认接口方法，删除给定key所对应的元素，如果value不存在、为null或者与参数中的value不等，则不能删除。即删除操作需要满足给定的值需要和map中的值相等的条件 default boolean replace(K key, V oldValue, V newValue)，Java8新增的默认接口方法，替换给定key所对应的元素，如果value不存在、为null或者与参数中的oldValue不等，则不能替换。即替换操作需要满足给定的值需要和map中的值相等的条件 default V replace(K key, V value)，Java8新增的默认接口方法，替换给定key所对应的元素，如果value不为null，则value值与参数中的value值做替换。 default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)，Java8新增的默认接口方法，根据key获取到的value如果不为null，则直接返回value值，否则将Lambda表达式中的结果值存放到Map中 default V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)，Java8新增的默认接口方法，根据key获取到的value和新计算的值如果不为null，则直接新计算的值，否则移除该key，且返回null default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)，Java8新增的默认接口方法，将Lambda表达式中的结果值存放到Map中，如果计算的新值为null则返回null，且移除以前有的key和value值 default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)，Java8新增的默认接口方法，将新计算的值覆盖Map中原key对应的value值 SortedSet接口中的额外抽象方法 Comparator&lt;? super E&gt; comparator()，返回本SortedSet集合中的Comparator比较器 SortedSet&lt;E&gt; subSet(E fromElement, E toElement)，获取开始元素和结束元素之间的子SortedSet集合 SortedSet&lt;E&gt; headSet(E toElement)，获取开始元素和toElement元素之间的子SortedSet集合 SortedSet&lt;E&gt; tailSet(E fromElement)，获取fromElement元素和结束元素之间的子SortedSet集合 E first()，获取本SortedSet集合中的第一个元素 E last()，获取本SortedSet集合中的最后一个元素 SortedMap接口中的额外抽象方法 Comparator&lt;? super K&gt; comparator()，返回本SortedMap集合中的Comparator比较器 SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)，获取开始key和结束key之间的子SortedMap集合 SortedMap&lt;K,V&gt; headMap(K toKey)，获取开始key和toKey元素之间的子SortedMap集合 SortedMap&lt;K,V&gt; tailMap(K fromKey)，获取fromKey元素和结束key之间的子SortedMap集合 K firstKey()，获取本SortedMap集合中的第一个key K lastKey()，获取本SortedMap集合中的最后一个key Set&lt;K&gt; keySet()，获取本SortedMap集合中所有key的Set集合 Collection&lt;V&gt; values()，获取本SortedMap集合中所有value的Collection集合 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()，获取本SortedMap集合中所有key和value的Map集合 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Spring入门踩坑记录","slug":"Spring入门踩坑记录","date":"2020-07-26T16:00:00.000Z","updated":"2020-09-18T04:43:03.008Z","comments":true,"path":"2020/07/27/Spring入门踩坑记录/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/27/Spring%E5%85%A5%E9%97%A8%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"记录一下学习Spring时的踩坑经验。","text":"记录一下学习Spring时的踩坑经验。 Jdk8不兼容Spring4.x以下版本入门三天，我一直被这控制台一片红苦恼着。 在视频的评论区中没有解决，上论坛上也没有解决。 详细报错： org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions 信息: Loading XML bean definitions from class path resource [beans.xml] Exception in thread \"main\" java.lang.NoSuchMethodError: org.springframework.core.annotation.AnnotationUtils.clearCache()V at org.springframework.context.support.AbstractApplicationContext.resetCommonCaches(AbstractApplicationContext.java:924) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:575) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:144) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:85) at MyTest.main(MyTest.java:13) 解决知道我无意间看到这个！！！ Ctrl+Shift+Alt+S，进入项目设置，更换项目的Jdk版本为8以上，我选择的是Jdk12： 如果以上设置还法子解决，那可能还需要再多一步： 不支持发行版本5 或 Compilation failed: internal java compiler error提示 Error: java: 错误: 不支持发行版本 5 或 ``Error: java: 错误: Compilation failed: internal java compiler error` 分析： 导致这个错误的原因主要是因为jdk版本问题，此处有两个原因，一个是编译版本不匹配，一个是当前项目jdk版本不支持。我的是编译器版本的问题。 解决： Ctrl+Alt+S，进入IDEA设置，Compiler中设置Java编译器的版本。 解决来源：https://blog.csdn.net/wo541075754/article/details/82119860 NoSuchBeanDefinitionException: No bean named ‘user’ available控制台提示以下错误: org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'user' available 解决:检查XML文件中Bean对象的id是否有问题？检查绑定的class是否有问题？等等……结果，我发现是绑定的XML文件，userbeans.xml绑定成了beans.xml。。。 ApplicationContext context = new ClassPathXmlApplicationContext(\"userbeans.xml\"); 同时使用p命名空间、c命名空间同时使用p命名空间、c命名空间，因为类中缺少无参构造器，控制台会报错： org.springframework.context.support.AbstractApplicationContext refresh 警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'user' defined in class path resource [userbeans.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.melodyhub.pojo.User]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.melodyhub.pojo.User.&lt;init&gt;() org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'user' defined in class path resource [userbeans.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.melodyhub.pojo.User]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.melodyhub.pojo.User.&lt;init&gt;() 解决： 类中加上无参构造器，即可。 NullPointerException控制台报错：出现空指针 java.lang.NullPointerException 解决上述问题存在多种情况。 可能是使用了注解，但是applicationContext.xml中没有该语句 &lt;!--开启对注解的支持--&gt; &lt;context:annotation-config/&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"【LeetCode】392. 判断子序列","slug":"【LeetCode】392.-判断子序列","date":"2020-07-26T06:00:00.000Z","updated":"2020-09-18T04:43:03.035Z","comments":true,"path":"2020/07/26/【LeetCode】392.-判断子序列/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/26/%E3%80%90LeetCode%E3%80%91392.-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"题目描述给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。 字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1: s = \"abc\", t = \"ahbgdc\" 返回 true. 示例 2: s = \"axc\", t = \"ahbgdc\" 返回 false. 后续挑战 : 如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？","text":"题目描述给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。 字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1: s = \"abc\", t = \"ahbgdc\" 返回 true. 示例 2: s = \"axc\", t = \"ahbgdc\" 返回 false. 后续挑战 : 如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 题解贪心法+双指针简单的办法就是使用双滑动指针，思路好理解，直接上算法： class Solution { /* 双指针的贪心算法 */ public boolean isSubsequence(String s, String t) { int sL = s.length(); int tL = t.length(); int i = 0, j = 0; //包含了s为空或s&gt;t的情况 while(i &lt; sL &amp;&amp; j &lt; tL){ if(s.charAt(i) == t.charAt(j)){ i++; j++; } else { j++; } } return i == sL; } } 动态规划从双指针的贪心算法中，可以推导出下面这两个式子： s.charAt(i-1) == t.charAt(j-1) =&gt; dp[i][j] = dp[i-1][j-1] s.charAt(i-1) != t.charAt(j-1) =&gt; dp[i][j] = dp[i][j-1] dff class Solution { /* 动态规划 */ public boolean isSubsequence(String s, String t) { if(s.length()==0) return true; if(s.length() &gt; t.length()) return false; boolean[][] dp = new boolean[s.length()+1][t.length()+1]; //初始化 for (int j = 0; j &lt; t.length(); j++) { dp[0][j] = true; } int sL = s.length(); int tL = t.length(); //dp for (int i = 1; i &lt;= sL; i++) { for (int j = 1; j &lt;= tL; j++) { if (s.charAt(i - 1) == t.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = dp[i][j - 1]; } } } return dp[sL][tL]; } } 递归迭代+单指针 对于两个字符串，判断其中一个字符串是否是另外一个字符串的子序列，可以采用循环迭代+单指针的方式实现判断，能够简单快速实现功能。 以最短字符串为基准，循环迭代，分别获取位置由小到大的字符； 设置字符串t的指针位置index，用于判断s的字符是否处于字符串t中的指针位置index到字符串尾部； 如果s的字符处于字符串t的指定字符串范围中，则index加1，不断重复该操作； 如果s的字符不处于字符串t的指定字符串范围中，则直接返回false； 作者：andy_fu链接：https://leetcode-cn.com/problems/is-subsequence/solution/xun-huan-die-dai-dan-zhi-zhen-jian-dan-kuai-su-shi/ class Solution { /* 递归迭代+单指针 */ public boolean isSubsequence(String s, String t) { if(s.length() &gt; t.length()) return false; int index = 0; for(int i=0;i&lt;s.length();i++){ // if exists next index positioin if((index = t.indexOf(String.valueOf(s.charAt(i)),index) + 1) == 0){ return false; } } return true; } } String.valueOf String.indexOf LCS最长公共子序列这题是可以用最长公共子序列的模板来做，但是估计时间复杂度会比较大。算法，略。 精选题解 官方题解 java的4种解法（第三种方式双百）（公共子序列，双指针，逐个查找，动态规划） 我们知道java中String类有这样一个方法public int indexOf(int ch, int fromIndex) ，他表示的是在字符串中是否存在一个字符ch，并且是从字符串的下标fromIndex开始查找的。我们要做的是在t字符串中查找s中的每一个字符，如果没查到，直接返回false。如果查到，就从t的下一个位置继续开始查。 作者：sdwwld链接：https://leetcode-cn.com/problems/is-subsequence/solution/javade-2chong-jie-fa-by-sdwwld/ public boolean isSubsequence(String s, String t) { int index = -1; for (char c : s.toCharArray()) { //index表示上一次查找的位置(第一次查找的时候为-1)，所以这里要从t的下标(index+1)开始查找 index = t.indexOf(c, index + 1); //没找到，返回false if (index == -1) return false; } return true; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"“内聚性”和“耦合性”","slug":"“内聚性”和“耦合性”","date":"2020-07-25T11:05:50.000Z","updated":"2020-09-18T04:43:03.032Z","comments":true,"path":"2020/07/25/“内聚性”和“耦合性”/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/25/%E2%80%9C%E5%86%85%E8%81%9A%E6%80%A7%E2%80%9D%E5%92%8C%E2%80%9C%E8%80%A6%E5%90%88%E6%80%A7%E2%80%9D/","excerpt":"内聚性 又称块内联系 指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。 特性 内聚性是对一个模块内部各个组成元素之间相互结合的紧密程度的度量指标。 模块中组成元素结合的越紧密，模块的内聚性就越高，模块的独立性也就越高。 理想的内聚性要求模块的功能应明确、单一，即一个模块只做一件事情。 模块的内聚性和耦合性是两个相互对立且又密切相关的概念。 耦合性 也叫耦合度，是对模块间关联程度的度量。 耦合的强弱取决与模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。 特性 模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。 模块间联系越多，其耦合性越强，同时表明其独立性越差。 软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。 划分模块的一个准则就是“高内聚、低耦合”。","text":"内聚性 又称块内联系 指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。 特性 内聚性是对一个模块内部各个组成元素之间相互结合的紧密程度的度量指标。 模块中组成元素结合的越紧密，模块的内聚性就越高，模块的独立性也就越高。 理想的内聚性要求模块的功能应明确、单一，即一个模块只做一件事情。 模块的内聚性和耦合性是两个相互对立且又密切相关的概念。 耦合性 也叫耦合度，是对模块间关联程度的度量。 耦合的强弱取决与模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。 特性 模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。 模块间联系越多，其耦合性越强，同时表明其独立性越差。 软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。 划分模块的一个准则就是“高内聚、低耦合”。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"Java动态代理详解","slug":"Java动态代理详解","date":"2020-07-24T16:00:00.000Z","updated":"2020-09-18T04:43:02.966Z","comments":true,"path":"2020/07/25/Java动态代理详解/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/25/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/","excerpt":"java动态代理详解","text":"java动态代理详解 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"初识Spring框架","slug":"初识Spring框架","date":"2020-07-24T16:00:00.000Z","updated":"2020-09-18T04:43:03.059Z","comments":true,"path":"2020/07/25/初识Spring框架/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/25/%E5%88%9D%E8%AF%86Spring%E6%A1%86%E6%9E%B6/","excerpt":"SpringSpring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。 Spring : 春天 —&gt; 给软件行业带来了春天 2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。 2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。 很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。 理念使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术 官网&amp;文档&amp;下载官网 : http://spring.io/ 官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/ GitHub : https://github.com/spring-projects Spring 官方文档 Spring 中文文档 &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 优点Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。 Spring是一个开源的免费的框架（容器）！！！ Spring是一个轻量级的、非侵入式的框架！！！ 控制反转 IoC , 面向切面 Aop（面试经常问到） 支持对事务的处理 支持对框架的整合 Spring框架是一种非侵入式的轻量级框架——摘自《Spring框架技术》 非侵入式的技术体现 允许在应用系统中自由选择和组装Spring框架的各个功能模块，并且不强制要求应用系统的类必须从Spring框架的系统API的某个类来继承或者实现某个接口。 如何实现非侵入式的设计目标的 1）应用反射机制，通过动态调用的方式来提供各方面的功能，建立核心组间BeanFactory 2）配合使用Spring框架中的BeanWrapper和BeanFactory组件类最终达到对象的实例创建和属性注入 3）优点：允许所开发出来的应用系统能够在不用的环境中自由移植，不需要修改应用系统中的核心功能实现的代码","text":"SpringSpring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。 Spring : 春天 —&gt; 给软件行业带来了春天 2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。 2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。 很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。 理念使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术 官网&amp;文档&amp;下载官网 : http://spring.io/ 官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/ GitHub : https://github.com/spring-projects Spring 官方文档 Spring 中文文档 &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 优点Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。 Spring是一个开源的免费的框架（容器）！！！ Spring是一个轻量级的、非侵入式的框架！！！ 控制反转 IoC , 面向切面 Aop（面试经常问到） 支持对事务的处理 支持对框架的整合 Spring框架是一种非侵入式的轻量级框架——摘自《Spring框架技术》 非侵入式的技术体现 允许在应用系统中自由选择和组装Spring框架的各个功能模块，并且不强制要求应用系统的类必须从Spring框架的系统API的某个类来继承或者实现某个接口。 如何实现非侵入式的设计目标的 1）应用反射机制，通过动态调用的方式来提供各方面的功能，建立核心组间BeanFactory 2）配合使用Spring框架中的BeanWrapper和BeanFactory组件类最终达到对象的实例创建和属性注入 3）优点：允许所开发出来的应用系统能够在不用的环境中自由移植，不需要修改应用系统中的核心功能实现的代码 组成 拓展 现代化的Java开发（即，基于Spring的开发）！！！ Spring Boot Spring Cloud 现在大多数公司都在使用SpringBoot进行快速开发。 承上启下：学习SpringBoot的前提，是完全掌握Spring以及SpringMVC！！！ Spring Boot Spring Boot 是 Spring 的一套快速配置脚手架 可以基于Spring Boot 快速开发单个微服务 Spring Boot专注于快速、方便集成的单个微服务个体 Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 弊端 发展太久了，违背了原来的理念！！！ 配置十分繁琐，人称“配置地狱”！！！ Spring Cloud Spring Cloud是基于Spring Boot实现的 Spring Cloud关注全局的服务治理框架 Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系 SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot IoC 理论推导 UserDao 接口 UserDaoImpl 实现类 UserService 业务接口 UserServiceImpl 业务实现类 原来的实现1、先写一个UserDao接口 public interface UserDao { public void getUser(); } 2、再去写Dao的实现类 public class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(\"获取用户数据\"); } } 3、然后去写UserService的接口 public interface UserService { public void getUser(); } 4、最后写Service的实现类 public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); @Override public void getUser() { userDao.getUser(); } } 5、测试一下 @Test public void test(){ UserService service = new UserServiceImpl(); service.getUser(); } 修改这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 . 把Userdao的实现类增加一个 . public class UserDaoMySqlImpl implements UserDao { @Override public void getUser() { System.out.println(\"MySql获取用户数据\"); } } 紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现 public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoMySqlImpl(); @Override public void getUser() { userDao.getUser(); } } 在假设, 我们再增加一个Userdao的实现类 . public class UserDaoOracleImpl implements UserDao { @Override public void getUser() { System.out.println(\"Oracle获取用户数据\"); } } 那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类吧 . 用户的需求可能会影响我们原来的代码 我们需要根据用户的需求去修改原代码！ 如果程序代码量十分大，修改一次的成本代价十分昂贵！ 根据每次变动 , 都需要修改大量代码 ! 这种设计的耦合性太高了, 牵一发而动全身 ! 改进优化我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用一个set接口 , 我们去代码里修改下 : public class UserServiceImpl implements UserService { private UserDao userDao; //利用set实现值的动态注入 public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void getUser() { userDao.getUser(); } } 现在去我们的测试类里 , 进行测试 ; @Test public void test(){ UserServiceImpl service = new UserServiceImpl(); service.setUserDao( new UserDaoMySqlImpl() ); service.getUser(); //那我们现在又想用Oracle去实现呢 service.setUserDao( new UserDaoOracleImpl() ); service.getUser(); } 发现了区别没有？ 他们已经发生了根本性的变化 , 很多地方都不一样了。 之前，所有东西都是由程序去进行控制创建，控制权在程序员手上！ 现在，使用set注入后，是由我们自行控制创建对象 , 把主动权交给了调用者。程序不再有主动性，而是变成了被动的接收对象。 程序不用去管怎么创建，怎么实现了。它只负责提供一个接口。 这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 ! IoC本质 控制反转IoC(Inversion of Control) 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。 是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。 没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 Spring和IoC的关系 IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC： ①可以使用XML配置 ②也可以使用注解 ③新版本的Spring也可以零配置实现IoC（即自动装配）。 Spring容器在初始化时先读取配置文件， 根据配置文件或元数据创建与组织对象存入容器中， 程序使用时再从Ioc容器中取出需要的对象。 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的 而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 HelloSpring入门程序①基础环境 JDK ：12 Spring：5.2.7 Junit：4.12 IDEA：2020.1.2 ②导入jar包 注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ③编写代码1、编写一个Hello实体类 package com.melodyhub.pojo; public class Hello { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Hello{\" + \"name='\" + name + '\\'' + '}'; } } 2、编写我们的spring文件 , 这里我们命名为beans.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--使用Spring来创建对象，在Spring中这些都成为bean 类型 变量名 = new 类型(); Hello hello = new Hello(); id = 变量名 class = new 的对象 property 相当于给对象中的属性赋值 注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写。 引用另外一个bean , 不是用value, 而是用 ref 。 &lt;bean id=\"...\" class=\"...\"&gt; &amp;lt;!&amp;ndash; collaborators and configuration for this bean go here &amp;ndash;&amp;gt; &lt;/bean&gt;--&gt; &lt;!--bean就是java对象, 在Spring中都成为Bean，由Spring创建和管理--&gt; &lt;bean id=\"hello\" class=\"com.melodyhub.pojo.Hello\"&gt; &lt;property name=\"str\" value=\"Spring\"/&gt; &lt;/bean&gt; &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写。 ref:引用Spring容器中创建好的对象。引用另外一个bean , 不是用value, 而是用ref。 value：具体的值，基本数据类型！ --&gt; &lt;!-- more bean definitions go here --&gt; &lt;/beans&gt; 3、我们可以去进行测试了 import com.melodyhub.pojo.Hello; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest { public static void main(String[] args) { //获取Spring的上下文对象 //解析beans.xml文件,生成管理相应的Bean对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //我们的对象现在在Spring中创建和管理了 //要使用对象，直接去Spring中取出来就可以了 //getBean:参数即为spring配置文件中bean的id Hello hello = (Hello) context.getBean(\"hello\"); System.out.println(hello.toString()); } } 入门踩坑JDK8不兼容Spring4.x以下版本入门三天，我一直被这控制台一片红苦恼着。 在视频的评论区中没有解决，上论坛上也没有解决。 详细报错： org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions 信息: Loading XML bean definitions from class path resource [beans.xml] Exception in thread \"main\" java.lang.NoSuchMethodError: org.springframework.core.annotation.AnnotationUtils.clearCache()V at org.springframework.context.support.AbstractApplicationContext.resetCommonCaches(AbstractApplicationContext.java:924) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:575) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:144) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:85) at MyTest.main(MyTest.java:13) 解决知道我无意间看到这个！！！ Ctrl+Shift+Alt+S，进入项目设置，更换项目的JDK版本为8以上，我选择的是JDK12： 如果以上设置还法子解决，那可能还需要再修改spring-study.iml文件： 不支持发行版本5 或 Compilation failed: internal java compiler error提示 Error: java: 错误: 不支持发行版本 5 或 ``Error: java: 错误: Compilation failed: internal java compiler error` 分析： 导致这个错误的原因主要是因为JDK版本问题，此处有两个原因，一个是编译版本不匹配，一个是当前项目JDK版本不支持。我的是编译器版本的问题。 解决： Ctrl+Alt+S，进入IDEA设置，Compiler中设置Java编译器的版本。 解决来源：https://blog.csdn.net/wo541075754/article/details/82119860 思考Hello对象是谁创建的？Hello对象是由Spring创建的 Hello对象的属性是怎么设置的？Hello对象的属性是由Spring容器设置的 这个过程就叫控制反转 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 反转 : 程序本身不创建对象 , 而变成被动的接收对象 依赖注入(DI) : 就是利用set方法来进行注入的 IOC是一种编程思想，由主动的编程变成被动的接收 可以通过newClassPathXmlApplicationContext去浏览一下底层源码 OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring来创建 , 管理 , 装配 ! IoC创建对象的方式一、默认：使用无参构造创建对象Spring中默认：使用无参构造创建对象 传送门：依赖注入-构造器 二、使用有参构造创建对象 通过 下标 赋值 通过 类型 赋值 直接通过 属性名 赋值 1.下标赋值&lt;!--第1种方式：下标赋值--&gt; &lt;bean id=\"user\" class=\"com.melodyhub.pojo.User\"&gt; &lt;!--&lt;property name=\"name\" value=\"MelodyJerry\"/&gt;--&gt; &lt;constructor-arg index=\"0\" value=\"下标赋值：MeloduHub-MelodyJerry\"/&gt; &lt;/bean&gt; 2.类型赋值&lt;!--第2种方式：类型赋值--&gt; &lt;bean id=\"user\" class=\"com.melodyhub.pojo.User\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"类型赋值：MeloduHub-MelodyJerry\"/&gt; &lt;/bean&gt; 3.直接通过属性名赋值&lt;!--第3种方式：直接通过属性值实现赋值--&gt; &lt;bean id=\"user\" class=\"com.melodyhub.pojo.User\"&gt; &lt;constructor-arg name=\"nmae\" value=\"直接通过属性值实现赋值：MeloduHub-MelodyJerry\"/&gt; &lt;/bean&gt; 总结：在Spring配置文件加载(即创建Bean)时，容器中管理的对象就已经被初始化/实例化了，而且内存中只有1份实例！UserTwo.java中： public class UserTwo { private String name; //必须要有无参构造子，没有就会报错！！！ public UserTwo(){ System.out.println(\"UserTwo被创建了！！！\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\"name = \" + name); } } beans.xml文件中： &lt;!--Spring创建Bean的时候就实例化对象--&gt; &lt;bean id=\"userTwo\" class=\"com.melodyhub.pojo.UserTwo\"&gt;&lt;/bean&gt; MyTest.java中： public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"user\"); User user2 = (User) context.getBean(\"user\"); //user.show(); System.out.println(user == user2); } } 控制台输出： UserTwo被创建了！！！ true Spring的xml配置文件说明alias：别名 如果增加了别名，我们也可以通过别名获取到这个对象！ Demo为user增加别名：woshibieming &lt;bean id=\"user\" class=\"com.melodyhub.pojo.User\"&gt; &lt;constructor-arg name=\"nmae\" value=\"直接通过属性值实现赋值：MeloduHub-MelodyJerry\"/&gt; &lt;/bean&gt; &lt;!--alias:别名.如果增加了别名,我们也可以通过别名获取到这个对象--&gt; &lt;alias name=\"user\" alias=\"woshibieming\"/&gt; 修改getBean中的参数：woshibieming public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"woshibieming\"); user.show(); } } bean标签的配置 id：bean的唯一标识符，也就是相当于我们学的对象名 class：bean对象所对应的全限定名：包名+类名 name：也是别名，而且name可以同时取多个别名 分隔符：逗号、空格、分号 autowire：自动导入 scope：作用域。默认singleton(单例模式)，可选prototype(原型模式)、request、session、globalsession。更多详见：spring常用注解-@Scope、Spring Bean的scope(作用域) Demo测试bean标签的配置，并同时设置多个别名：two、u2、u3、u4 &lt;bean id=\"userTwo\" class=\"com.melodyhub.pojo.UserTwo\" name=\"two u2,u3;u4\"&gt; &lt;property name=\"name\" value=\"测试bean标签的配置，并同时设置多个别名：two、u2、u3、u4\"/&gt; &lt;/bean&gt; 修改getBean中的参数：u3 public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserTwo user = (UserTwo) context.getBean(\"u3\"); user.show(); } } 控制台输出： UserTwo被创建了！！！ name = 测试bean标签的配置，并同时设置多个别名：two、u2、u3、u4 import 一般用于团队开发使用，import可以将多个配置文件，导入合并为一个。 而且，相同 id的对象的属性也会被合并到一起！！！ Demo假设现在项目中有多个人开发，张三（beans.xml）、李四（beans2.xml）、王五（beans3.xml），这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的applicationContext.xml！ 张三（beans.xml） 李四（beans2.xml） 王五（beans3.xml） applicationContext.xml 新建applicationContext.xml文件，在IDEA的编辑区的右上角会看到蓝色的Configure application contex，单击并合并到原先的beans.xml中去 但是现在要合并到applicationContext.xml，使用的时候，直接使用总的配置就可以了👇 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;import resource=\"beans.xml\"/&gt; &lt;import resource=\"beans2.xml\"/&gt; &lt;import resource=\"beans3.xml\"/&gt; &lt;/beans&gt; 当然 也可以在ClassPathXmlApplicationContext中直接获取多个配置文件👇 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\",\"beans2.xml\",\"beans3.xml\"); //ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 现在来看看对象的属性的合并，修改Bean2.xml、bean3.xml中user的别名 MyTest中修改getBean的参数为：u8 public class MyTest { public static void main(String[] args) { // ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\",\"beans2.xml\",\"beans3.xml\"); ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserTwo user = (UserTwo) context.getBean(\"u8\"); user.show(); } } 控制台输出： UserTwo被创建了！！！ name = 测试bean标签的配置，并同时设置多个别名：two、u2、u3、u8 总结 import可以将多个配置文件，导入合并为一个。 而且，相同 id的对象的属性也会被合并到一起！！！ 依赖注入（DI） 依赖注入：Dependency Injection，简称DI 依赖注入(DI)是控制反转(IoC)的一种方式。 官方文档：https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies 拥有三种依赖注入的方式 构造器（构造方法）注入 Setter方式注入【重点】 接口注入 更多详见：三种依赖注入的方式 构造器注入传送门：IoC创建对象的方式 Setter方式注入【重点】 依赖注入：Set注入！ 依赖：bean对象的创建依赖于容器！ 注入：bean对象中的所有属性，由容器来注入！ DEMO 复杂类型 public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \"Address{\" + \"address='\" + address + '\\'' + '}'; } } 真是测试对象 package com.melodyhub.pojo; import java.util.*; public class Student { private String name; private Address address; private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String, String &gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; public String getName() { return name; } public void setName(String name) { this.name = name; } public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } public String[] getBooks() { return books; } public void setBooks(String[] books) { this.books = books; } public List&lt;String&gt; getHobbys() { return hobbys; } public void setHobbys(List&lt;String&gt; hobbys) { this.hobbys = hobbys; } public Map&lt;String, String&gt; getCard() { return card; } public void setCard(Map&lt;String, String&gt; card) { this.card = card; } public Set&lt;String&gt; getGames() { return games; } public void setGames(Set&lt;String&gt; games) { this.games = games; } public String getWife() { return wife; } public void setWife(String wife) { this.wife = wife; } public Properties getInfo() { return info; } public void setInfo(Properties info) { this.info = info; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", address=\" + address.toString() + \", books=\" + Arrays.toString(books) + \", hobbys=\" + hobbys + \", card=\" + card + \", games=\" + games + \", wife='\" + wife + '\\'' + \", info=\" + info + '}'; } } beans.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean name=\"student\" class=\"com.melodyhub.pojo.Student\"&gt; &lt;!--第一种：普通值注入，value--&gt; &lt;property name=\"name\" value=\"MelodyJerry\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 测试类 public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student student = (Student) context.getBean(\"student\"); System.out.println(student.toString()); } } 完善注入信息 &lt;bean id=\"address\" class=\"com.melodyhub.pojo.Address\"/&gt; &lt;bean name=\"student\" class=\"com.melodyhub.pojo.Student\"&gt; &lt;!--第一种：普通值注入，value--&gt; &lt;property name=\"name\" value=\"MelodyJerry\"/&gt; &lt;!--第二种：Bean注入，ref--&gt; &lt;property name=\"address\" ref=\"address\"/&gt; &lt;!--数组注入--&gt; &lt;property name=\"books\"&gt; &lt;array&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--List注入--&gt; &lt;property name=\"hobbys\"&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;打球&lt;/value&gt; &lt;value&gt;跑步&lt;/value&gt; &lt;value&gt;学习&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Map注入--&gt; &lt;property name=\"card\"&gt; &lt;map&gt; &lt;entry key=\"身份证\" value=\"1234567890\"/&gt; &lt;entry key=\"银行卡\" value=\"2364101\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--Set注入--&gt; &lt;property name=\"games\"&gt; &lt;set&gt; &lt;value&gt;王者荣耀&lt;/value&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--NULL注入--&gt; &lt;property name=\"wife\"&gt; &lt;null/&gt; &lt;/property&gt; &lt;!--Property注入--&gt; &lt;!-- &lt;prop key=\"键\"&gt;值&lt;/prop&gt; --&gt; &lt;property name=\"info\"&gt; &lt;props&gt; &lt;prop key=\"性别\"&gt;男&lt;/prop&gt; &lt;prop key=\"年龄\"&gt;21&lt;/prop&gt; &lt;prop key=\"身高\"&gt;186cm&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 扩展方式注入官方文档: p-命名空间注入 p：property The p-namespace lets you use the beanelement’s attributes (instead of nested &lt;property/&gt; elements) to describe your property values collaborating beans, or both. 必须导入： xmlns:p=\"http://www.springframework.org/schema/p\" c-命名空间注入 c：constructor-arg 类中必须存在 有参构造器 Similar to the XML Shortcut with the p-namespace, the c-namespace, introduced in Spring 3.1, allows inlined attributes for configuring the constructor arguments rather then nested constructor-arg elements. 必须导入： xmlns:c=\"http://www.springframework.org/schema/c\" Demo User.java package com.melodyhub.pojo; public class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } public User() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } userbeans.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--p命名空间注入，可以直接注入属性的值。property--&gt; &lt;bean id=\"user\" class=\"com.melodyhub.pojo.User\" p:age=\"21\" p:name=\"MelodyJerry\"/&gt; &lt;!--c命名空间注入，可以通过构造器注入属性的值。constructor-arg--&gt; &lt;bean id=\"user2\" class=\"com.melodyhub.pojo.User\" c:age=\"18\" c:name=\"Jerry\"/&gt; &lt;/beans&gt; MyTest.java @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"userbeans.xml\"); User user = context.getBean(\"user\",User.class); User user2 = context.getBean(\"user2\",User.class); System.out.println(user); System.out.println(user2); } 重点注意 使用前，必须导入对应的xml约束：xmlns:p或xmlns:c 使用c-命名空间的前提：类中必须存在有参构造器 同时使用p命名空间、c命名空间：类中必须存在 无参构造器、有参构造器 Bean作用域官方文档：Bean Scopes &lt;bean id=\"beanname\" class=\"com.linjie.Bean\" scope=\"prototype\"/&gt; singleton（重点） prototype（重点） request session application websocket Scope 描述 singleton单例模式 (Spring默认使用singleton) 每一个Spring容器中，一个Bean定义只有一个对象实例 prototype原型模式 允许Bean的定义可以被实例化任意次（每次调用都创建一个实例） request 一次HTTP请求中，每个Bean定义对应一个实例，该作用域仅在基于Web的Spring上下文（例如SpringMVC）中才有效 session 在一个HTTP Session中，每个Bean定义对应一个实例。该作用域仅在基于Web的Spring上下文（例如SpringMVC）中才有效 application Scopes a single bean definition to the lifecycle of a ServletContext.该作用域仅在基于Web的Spring上下文（例如SpringMVC）中才有效 websocket Scopes a single bean definition to the lifecycle of a WebSocket. 该作用域仅在基于Web的Spring上下文（例如SpringMVC）中才有效 更多参考： Spring Bean的scope(作用域) spring常用注解-@Scope singleton 单例模式 Spring模式机制 并发开发中可能存在问题 一般在单线程中会使用 &lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt; &lt;bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"singleton\"/&gt; prototype 原型模式 每次从容器中get的时候，都产生一个新对象！ 特别浪费资源 一般在多线程中会使用 &lt;bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"prototype\"/&gt; 注意 其余的request、session、application这些只能在web开发中使用！ 一般，单线程使用singleton，多线程使用prototype Spring其他一些细节bean标签的使用①改进Spring的程序，加上beans.xml配置： ②Spring创建Bean的时候就实例化对象 ApplicationContext.getBean() getBean(String name) getBean(Class&lt;T&gt; type) getBean(String name,Class&lt;T&gt; type) getBean(String name,Object[] args) 更多详见：ApplicationContext之getBean方法详解 直接获取所要的、某类型的对象 调用 getBean(String name,Class&lt;T&gt; type) context.getBean(\"people\", People.class); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"[转]String、StringBuffer与StringBuilder之间区别","slug":"[转]String、StringBuffer与StringBuilder之间区别","date":"2020-07-23T17:00:00.000Z","updated":"2020-09-24T08:55:08.032Z","comments":true,"path":"2020/07/24/[转]String、StringBuffer与StringBuilder之间区别/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/24/[%E8%BD%AC]String%E3%80%81StringBuffer%E4%B8%8EStringBuilder%E4%B9%8B%E9%97%B4%E5%8C%BA%E5%88%AB/","excerpt":"https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303","text":"https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"技术文档集合","slug":"技术文档集合","date":"2020-07-23T16:01:00.000Z","updated":"2020-09-18T04:43:03.204Z","comments":true,"path":"2020/07/24/技术文档集合/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/24/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%E9%9B%86%E5%90%88/","excerpt":"中文技术文档集合 SpringSpring 官方文档 Spring 中文文档 Spring与Mybatis相结合使用的中文文档 第三方： Spring官方文档中文版 Spring Framework 中文文档 Spring Boot 中文文档 Spring Cloud 中文文档 Spring Security 中文文档 Spring Session 中文文档 Spring AMQP 中文文档 Spring Data Spring Data JPA Spring Data JDBC Spring Data Redis MyBatisMybatis官方中文文档 Spring与Mybatis相结合使用的中文文档","text":"中文技术文档集合 SpringSpring 官方文档 Spring 中文文档 Spring与Mybatis相结合使用的中文文档 第三方： Spring官方文档中文版 Spring Framework 中文文档 Spring Boot 中文文档 Spring Cloud 中文文档 Spring Security 中文文档 Spring Session 中文文档 Spring AMQP 中文文档 Spring Data Spring Data JPA Spring Data JDBC Spring Data Redis MyBatisMybatis官方中文文档 Spring与Mybatis相结合使用的中文文档 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"Spring文档","slug":"Spring文档","date":"2020-07-23T16:00:00.000Z","updated":"2020-09-18T04:43:03.013Z","comments":true,"path":"2020/07/24/Spring文档/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/24/Spring%E6%96%87%E6%A1%A3/","excerpt":"Spring 官方文档 Spring 中文文档 第三方： Spring官方文档中文版 Spring Framework 中文文档 Spring Boot 中文文档 Spring Cloud 中文文档 Spring Security 中文文档 Spring Session 中文文档 Spring AMQP 中文文档 Spring Data Spring Data JPA Spring Data JDBC Spring Data Redis","text":"Spring 官方文档 Spring 中文文档 第三方： Spring官方文档中文版 Spring Framework 中文文档 Spring Boot 中文文档 Spring Cloud 中文文档 Spring Security 中文文档 Spring Session 中文文档 Spring AMQP 中文文档 Spring Data Spring Data JPA Spring Data JDBC Spring Data Redis document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"ico图标下载","slug":"ico图标下载","date":"2020-07-23T16:00:00.000Z","updated":"2020-09-18T04:43:03.022Z","comments":true,"path":"2020/07/24/ico图标下载/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/24/ico%E5%9B%BE%E6%A0%87%E4%B8%8B%E8%BD%BD/","excerpt":"站长素材http://sc.chinaz.com/tubiao/index.html","text":"站长素材http://sc.chinaz.com/tubiao/index.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"[转]狂神说SSM框架系列连载","slug":"[转]狂神说SSM框架系列连载","date":"2020-07-22T16:00:00.000Z","updated":"2020-09-24T08:55:08.037Z","comments":true,"path":"2020/07/23/[转]狂神说SSM框架系列连载/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/23/[%E8%BD%AC]%E7%8B%82%E7%A5%9E%E8%AF%B4SSM%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E8%BF%9E%E8%BD%BD/","excerpt":"狂神说SSM框架系列连载 MyBatis狂神说MyBatis02：CRUD操作及配置解析狂神说MyBatis03：ResultMap及分页狂神说MyBatis04：使用注解开发狂神说MyBatis05：一对多和多对一处理狂神说MyBatis06：动态SQL狂神说MyBatis07：缓存 Spring狂神说Spring03：依赖注入（DI）狂神说Spring04：自动装配狂神说Spring05：使用注解开发狂神说Spring06：静态/动态代理模式狂神说Spring07：AOP就这么简单狂神说Spring08：整合MyBatis狂神说Spring09：声明式事务 SpingMVC狂神说SpringMVC01：什么是SpringMVC狂神说SpringMVC02：第一个MVC程序狂神说SpringMVC03：RestFul和控制器狂神说SpringMVC04：数据处理及跳转狂神说SpringMVC05：整合SSM框架狂神说SpringMVC06：Json交互处理狂神说SpringMVC07：Ajax研究狂神说SpringMVC08：拦截器+文件上传下载","text":"狂神说SSM框架系列连载 MyBatis狂神说MyBatis02：CRUD操作及配置解析狂神说MyBatis03：ResultMap及分页狂神说MyBatis04：使用注解开发狂神说MyBatis05：一对多和多对一处理狂神说MyBatis06：动态SQL狂神说MyBatis07：缓存 Spring狂神说Spring03：依赖注入（DI）狂神说Spring04：自动装配狂神说Spring05：使用注解开发狂神说Spring06：静态/动态代理模式狂神说Spring07：AOP就这么简单狂神说Spring08：整合MyBatis狂神说Spring09：声明式事务 SpingMVC狂神说SpringMVC01：什么是SpringMVC狂神说SpringMVC02：第一个MVC程序狂神说SpringMVC03：RestFul和控制器狂神说SpringMVC04：数据处理及跳转狂神说SpringMVC05：整合SSM框架狂神说SpringMVC06：Json交互处理狂神说SpringMVC07：Ajax研究狂神说SpringMVC08：拦截器+文件上传下载 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"博客网页内的鼠标样式","slug":"博客网页内的鼠标样式","date":"2020-07-22T16:00:00.000Z","updated":"2020-09-18T04:43:03.063Z","comments":true,"path":"2020/07/23/博客网页内的鼠标样式/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/23/%E5%8D%9A%E5%AE%A2%E7%BD%91%E9%A1%B5%E5%86%85%E7%9A%84%E9%BC%A0%E6%A0%87%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"在css样式body里加 body { cursor: url(https://cdn.jsdelivr.net/gh/fz6m/Private-web@1.5/image/cursor/normal.cur), default; } a:hover{cursor:url(https://cdn.jsdelivr.net/gh/fz6m/Private-web@1.5/image/cursor/ayuda.cur) 15 15, pointer;} body{ cursor: url(https://files-cdn.cnblogs.com/files/zouwangblog/cursor.ico),auto;} 补充：png和jpg可以直接转换为ico格式，使用一个在线生成ico图标的网站即可 http://www.bitbug.net/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"[转]Java源码详解系列(十)--全面分析mybatis的使用、源码和代码生成器(总计5篇博客)","slug":"[转]Java源码详解系列(十)--全面分析mybatis的使用、源码和代码生成器(总计5篇博客)","date":"2020-07-21T15:01:00.000Z","updated":"2020-09-24T08:55:08.029Z","comments":true,"path":"2020/07/21/[转]Java源码详解系列(十)--全面分析mybatis的使用、源码和代码生成器(总计5篇博客)/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/21/[%E8%BD%AC]Java%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3%E7%B3%BB%E5%88%97(%E5%8D%81)--%E5%85%A8%E9%9D%A2%E5%88%86%E6%9E%90mybatis%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81%E6%BA%90%E7%A0%81%E5%92%8C%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8(%E6%80%BB%E8%AE%A15%E7%AF%87%E5%8D%9A%E5%AE%A2)/","excerpt":"原文链接：https://www.cnblogs.com/ZhangZiSheng001/p/13237670.html 简介Mybatis 是一个持久层框架，它对 JDBC 进行了高级封装，使我们的代码中不会出现任何的 JDBC 代码，另外，它还通过 xml 或注解的方式将 sql 从 DAO/Repository 层中解耦出来，除了这些基本功能外，它还提供了动态 sql、延迟加载、缓存等功能。 相比 Hibernate，Mybatis 更面向数据库，可以灵活地对 sql 语句进行优化。 针对 Mybatis 的分析，我拆分成使用、源码分析、生成器等部分，已更新5篇博客，都放在 Mybatis 这个系列里，内容将持续更新。 Mybatis详解系列(一)–持久层框架解决了什么及如何使用Mybatis Mybatis源码详解系列(二)–Mybatis如何加载配置及初始化 Mybatis源码详解系列(三)–从Mapper接口开始看Mybatis的执行逻辑 Mybatis源码详解系列(四)–你不知道的Mybatis用法和细节 Mybatis详解系列(五)–Mybatis Generator和全注解风格的MyBatis3DynamicSql 相关源码请移步：mybatis-demo","text":"原文链接：https://www.cnblogs.com/ZhangZiSheng001/p/13237670.html 简介Mybatis 是一个持久层框架，它对 JDBC 进行了高级封装，使我们的代码中不会出现任何的 JDBC 代码，另外，它还通过 xml 或注解的方式将 sql 从 DAO/Repository 层中解耦出来，除了这些基本功能外，它还提供了动态 sql、延迟加载、缓存等功能。 相比 Hibernate，Mybatis 更面向数据库，可以灵活地对 sql 语句进行优化。 针对 Mybatis 的分析，我拆分成使用、源码分析、生成器等部分，已更新5篇博客，都放在 Mybatis 这个系列里，内容将持续更新。 Mybatis详解系列(一)–持久层框架解决了什么及如何使用Mybatis Mybatis源码详解系列(二)–Mybatis如何加载配置及初始化 Mybatis源码详解系列(三)–从Mapper接口开始看Mybatis的执行逻辑 Mybatis源码详解系列(四)–你不知道的Mybatis用法和细节 Mybatis详解系列(五)–Mybatis Generator和全注解风格的MyBatis3DynamicSql 相关源码请移步：mybatis-demo document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"[转]给你的网站增加护盾-开启SSL【白嫖】","slug":"[转]给你的网站增加护盾-开启SSL【白嫖】","date":"2020-07-21T15:00:00.000Z","updated":"2020-09-24T08:55:08.039Z","comments":true,"path":"2020/07/21/[转]给你的网站增加护盾-开启SSL【白嫖】/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/21/[%E8%BD%AC]%E7%BB%99%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E5%A2%9E%E5%8A%A0%E6%8A%A4%E7%9B%BE-%E5%BC%80%E5%90%AFSSL%E3%80%90%E7%99%BD%E5%AB%96%E3%80%91/","excerpt":"","text":"本文转自：会打篮球的程序猿 原文链接：https://www.lzhpo.com/article/102 了解开启SSL的作用一、防止网站被劫持，常见的是手机广告劫持与流量劫持。二、网站交流数据的加密传输。三、搜索引擎优先收录HTTPS站点，更有利SEO优化。四、网站源码与系统受到全站SSL协议安全。五、网站容易被识别，增加网站信任度与形象。六、帮助用户识别钓鱼网站。七、保障用户隐私信息安全与网站隐私。八、用于微信小程序与APP开发接入服务。还有就是，就算是你nginx配置了websocket，谷歌浏览器要https才能接收通知了，微软的edg就可以。 https： 下载软件法1：在FreeSSL开启【选择免费的】https://freessl.cn/ 在这个网站创建免费证书，之后会让你下载一个软件，那个是生成证书和秘钥的。选择免费的！！！土豪除外！ 就是这个软件： 按提示操作 服务器配置ssl# HTTPS server server { listen 443 ssl; server_name www.lzhpo.com; ssl on; #root html; #index index.html index.htm; ssl_certificate /etc/nginx/cert/web-ssl/cert.pem; ssl_certificate_key /etc/nginx/cert/web-ssl/key.pem; # ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { proxy_pass http://ip地址:端口; proxy_redirect off; add_header Access-Control-Allow-Origin *; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host:$server_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 声明支持websocket proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; } } emmm…sorry，手抖没注意，写错了不是主机名，是IP地址！！！不改了，还得重新截图，麻烦，在这里说明一下就好。 服务器强制httpsreturn 301 https://$server_name$request_uri; 配置完之后，重启nginx。 systemctl restart nginx 法2：在阿里开启方法都和上面的一样，只是阿里的免费的有一些限制就是…… 效果访问你的域名，自动跳转到https。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"IDEA中使用Git","slug":"IDEA中使用Git","date":"2020-07-21T05:00:00.000Z","updated":"2020-09-18T04:43:02.960Z","comments":true,"path":"2020/07/21/IDEA中使用Git/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/21/IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Git/","excerpt":"","text":"步骤 在IDEA中设置Git，在File–&gt;Setting-&gt;Version Control–&gt;Git–&gt;Path to Git executable选择你的git安装后的git.exe文件，然后点击Test，测试是否设置成功 可以设置不被git追踪的文件 参考：IDEA忽略文件，防止git提交不想提交的文件的探索 参考：【Git版本控制】Idea中设置Git忽略对某些文件的版本追踪 在IDEA中设置GitHub，File–&gt;Setting-&gt;Version Control–&gt;GibHub 连接GitHub成功后，会显示出用户头像、用户名等信息 创建本地仓库，VCS–&gt;Import into Version Control–&gt;Create Git Repository… 在弹出对话框中，选择所在项目的位置，即创建本地仓库，点击OK 创建完本地仓库后，工作区当前项目都会变成 红色字体 上传项目到本地仓库，项目右键选择Git–&gt;add 此时项目文件变成 绿色字体 此时文件只是处于暂存区，并没有真正进入到版本库中 添加提交信息，下方Git选项卡，右键Default Changelist –&gt;Commit Files… –&gt;Commit Message –&gt; Commit（或Commit and Push…） 等待 Pushing… 完成，前往远程仓库查看 参考 IDEA忽略文件，防止git提交不想提交的文件的探索 【Git版本控制】Idea中设置Git忽略对某些文件的版本追踪 IDEA中Git的使用 IDEA配置GIT IntelliJ IDEA下的使用git ☆【精选】Dit教程-廖雪峰老师 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://melodyjerry.github.io/blog/tags/Git/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"解决Mybatis报错Could not find resource mybatis-config.xml","slug":"解决Mybatis报错Could-not-find-resource-mybatis-config.xml","date":"2020-07-21T05:00:00.000Z","updated":"2020-09-18T04:43:03.288Z","comments":true,"path":"2020/07/21/解决Mybatis报错Could-not-find-resource-mybatis-config.xml/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/21/%E8%A7%A3%E5%86%B3Mybatis%E6%8A%A5%E9%94%99Could-not-find-resource-mybatis-config.xml/","excerpt":"下午移植远程仓库项目的时候，控制台报错： java.io.IOException: Could not find resource mybatis-config.xml 经过排查，发现是我没有一直夫工程的pom.xml文件。 Maven clean清除缓存，然后build，即可。","text":"下午移植远程仓库项目的时候，控制台报错： java.io.IOException: Could not find resource mybatis-config.xml 经过排查，发现是我没有一直夫工程的pom.xml文件。 Maven clean清除缓存，然后build，即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"}]},{"title":"hexo发布文章报错","slug":"hexo发布文章报错","date":"2020-07-20T09:21:35.763Z","updated":"2020-08-27T05:55:24.169Z","comments":true,"path":"2020/07/20/hexo发布文章报错/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/20/hexo%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0%E6%8A%A5%E9%94%99/","excerpt":"","text":"1提示YAMLException: end of the stream or a document separator is expected at line 2, column 5: $ hexo g INFO Start processing ERROR Process failed: _posts/Druid的配置及连接.md YAMLException: end of the stream or a document separator is expected at line 2, column 5: date: 2020-02-23 17:36:53 ^ 解决 出现这种情况，一般都是缺少空格，在 : 冒号之后要有空格！ 检查x行y列附近的冒号，其之后是否跟了空格。 2提示YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 2, column 5: ERROR Process failed: _posts/随机动漫图片api.md YAMLException: end of the stream or a document separator is expected at line 2, column 5: tags: ^ 解决 可能是缺少了必要的空格，和上面的解决一样 但是也可能是缺少必要的引号，比如'' 更多官方问题解答：https://hexo.io/zh-cn/docs/troubleshooting.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[]},{"title":"【LeetCode】167. 两数之和 II - 输入有序数组","slug":"【LeetCode】167-两数之和-II-输入有序数组","date":"2020-07-20T03:28:57.000Z","updated":"2020-09-18T04:43:03.037Z","comments":true,"path":"2020/07/20/【LeetCode】167-两数之和-II-输入有序数组/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/20/%E3%80%90LeetCode%E3%80%91167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 题解暴力法时间复杂度：O(n2) class Solution { public int[] twoSum(int[] numbers, int target) { int[] ans = new int[2]; int len = numbers.length; for (int i = 0; i &lt; len - 1; i++) { int need = target - numbers[i]; for (int j = i + 1; j &lt; len; j++) { if (numbers[j] == need) { ans[0] = i + 1; ans[1] = j + 1; return ans; } } } return ans; } } 双指针时间复杂度：O(n) class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0, right = numbers.length - 1, mid; while(left &lt; right){ mid = numbers[left] + numbers[right]; if(mid == target) return new int[] {left + 1, right + 1}; else if(mid &lt; target) left ++; else right --; } return null; } } 二分查找时间复杂度：O(nlogn) class Solution { public int[] twoSum(int[] num, int target) { for (int i = 0; i &lt; num.length; i++) { int low = i + 1, high = num.length - 1; int val = target - num[i]; while (low &lt;= high) { int mid = low + (high - low) / 2; //用&gt;&gt;会超时。。。 if (num[mid] == val) return new int[]{i + 1, mid + 1}; else if (num[mid] &lt; val) low = mid + 1; else high = mid - 1; } } return null; } } 哈希表时间复杂度：O(n)空间复杂度：O(n) class Solution { public int[] twoSum(int[] num, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(num.length); for (int i = 0; i &lt; num.length; i++) { if (map.get(target - num[i]) != null) { return new int[]{map.get(target - num[i]) + 1, i + 1}; } map.put(num[i], i); } return null; } } /* 或者 public int[] twoSum(int[] numbers, int target) { int[] ans = new int[2]; int len = numbers.length; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; len; i++) { map.put(numbers[i], i + 1); } for (int i = 0; i &lt; len; i++) { int need = target - numbers[i]; if (map.containsKey(need)) { ans[0] = i + 1; ans[1] = map.get(need); return ans; } } return ans; } */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java获取项目访问路径的相关方法","slug":"Java获取项目访问路径的相关方法","date":"2020-07-20T02:33:41.000Z","updated":"2020-09-18T04:43:02.974Z","comments":true,"path":"2020/07/20/Java获取项目访问路径的相关方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/20/Java%E8%8E%B7%E5%8F%96%E9%A1%B9%E7%9B%AE%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/","excerpt":"在jsp和class文件中调用的相对路径不同。 在jsp里，根目录是WebRoot在class文件中，根目录是WebRoot/WEB-INF/classes当然你也可以用System.getProperty(\"user.dir\")获取你工程的绝对路径。","text":"在jsp和class文件中调用的相对路径不同。 在jsp里，根目录是WebRoot在class文件中，根目录是WebRoot/WEB-INF/classes当然你也可以用System.getProperty(\"user.dir\")获取你工程的绝对路径。 1.jsp中取得路径： 以工程名为TEST为例： (1)得到包含工程名的当前页面全路径：request.getRequestURI() 结果：/TEST/test.jsp (2)得到工程名：request.getContextPath() 结果：/TEST (3)得到当前页面所在目录下全名称：request.getServletPath() 结果：如果页面在jsp目录下 /TEST/jsp/test.jsp (4)得到页面所在服务器的全路径：application.getRealPath(\"页面.jsp\") 结果：D:\\resin\\webapps\\TEST\\test.jsp (5)得到页面所在服务器的绝对路径：absPath=new java.io.File(application.getRealPath(request.getRequestURI())).getParent(); 结果：D:\\resin\\webapps\\TEST 2.在类中取得路径： (1)类的绝对路径：Class.class.getClass().getResource(\"/\").getPath() 结果：/D:/TEST/WebRoot/WEB-INF/classes/pack/ (2)得到工程的路径：System.getProperty(\"user.dir\") 结果：D:\\TEST 3.在Servlet中取得路径： (1)得到工程目录：request.getSession().getServletContext().getRealPath(\"\") 参数可具体到包名。 结果：E:\\Tomcat\\webapps\\TEST (2)得到IE地址栏地址：request.getRequestURL() 结果：http://localhost:8080/TEST/test (3)得到相对地址：request.getRequestURI() 结果：/TEST/test 另，Class类还有一个getResourceAsStream方法，记得以前有个项目要读取在同一个包内的一个xml，就用的这个。 1.如何获得当前文件路径 常用： (1).Test.class.getResource(\"\") 得到的是当前类FileTest.class文件的URI目录。不包括自己！ (2).Test.class.getResource(\"/\") 得到的是当前的classpath的绝对URI。 (3).Thread.currentThread().getContextClassLoader().getResource(\"\") 得到的也是当前ClassPath的绝对URI。 (4).Test.class.getClassLoader().getResource(\"\") 得到的也是当前ClassPath的绝对URI。 (5).ClassLoader.getSystemResource(\"\") 得到的也是当前ClassPath的绝对URI。 尽量不要使用相对于System.getProperty(\"user.dir\")当前用户目录的相对路径，后面可以看出得出结果五花八门。 (6) new File(\"\").getAbsolutePath()也可用。 注：若这些路径中出现空格，并且空格被 代替，则可以使用path = java.net.URLDecoder.decode(path,\"utf-8\")进行转化; 2.Web服务器 (1).Tomcat 在类中输出System.getProperty(\"user.dir\");显示的是%Tomcat_Home%/bin (2).Resin 不是你的JSP放的相对路径，是JSP引擎执行这个JSP编译成Servlet的路径为根.比如用新建文件法测试File f = new File(\"a.htm\"); 这个a.htm在resin的安装目录下 (3).如何读文件 使用ServletContext.getResourceAsStream()就可以 (4).获得文件真实路径 String file_real_path=ServletContext.getRealPath(\"mypath/filename\"); 不建议使用request.getRealPath(\"/\"); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"java","slug":"java","permalink":"https://melodyjerry.github.io/blog/tags/java/"}]},{"title":"js代码屏蔽网站鼠标右键，屏蔽按键刷新审核元素","slug":"短短代码屏蔽网站鼠标右键，屏蔽按键刷新审核元素","date":"2020-07-20T02:29:55.000Z","updated":"2020-09-18T04:43:03.282Z","comments":true,"path":"2020/07/20/短短代码屏蔽网站鼠标右键，屏蔽按键刷新审核元素/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/20/%E7%9F%AD%E7%9F%AD%E4%BB%A3%E7%A0%81%E5%B1%8F%E8%94%BD%E7%BD%91%E7%AB%99%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%EF%BC%8C%E5%B1%8F%E8%94%BD%E6%8C%89%E9%94%AE%E5%88%B7%E6%96%B0%E5%AE%A1%E6%A0%B8%E5%85%83%E7%B4%A0/","excerpt":"","text":"&lt;script type=\"text/javascript\"&gt; $(function(){ var OriginTitile = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if (document.hidden) { $('[rel=\"shortcut icon\"]').attr('href', \"http://pjax.cn/loss.ico\"); document.title = '404 Not Found'; clearTimeout(titleTime); } else { $('[rel=\"shortcut icon\"]').attr('href', \"http://pjax.cn/favicon.ico\"); document.title = '(/≧▽≦/)咦！又好了！' + OriginTitile; titleTime = setTimeout(function () { document.title = OriginTitile; }, 2000); } }); //屏蔽鼠标右键 document.oncontextmenu = function(e){ return false; }; //屏蔽f12等 document.onkeydown = function(e){ var e = e || event; var nums = [113,114,115,116,117,118,119,120,121,122,123]; for(var i in nums){ if(e.keyCode == nums[i]){ return false; } } }; }); &lt;/script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"}]},{"title":"给网站加入欢迎语音","slug":"给网站加入欢迎语音","date":"2020-07-20T02:27:35.000Z","updated":"2020-09-18T04:43:03.290Z","comments":true,"path":"2020/07/20/给网站加入欢迎语音/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/20/%E7%BB%99%E7%BD%91%E7%AB%99%E5%8A%A0%E5%85%A5%E6%AC%A2%E8%BF%8E%E8%AF%AD%E9%9F%B3/","excerpt":"有一个网站，想让用户进入主页后听到语音欢迎，其实就是给网站加背景音乐的代码啊!这里我提供的代码是调用的百度语音，代码如下： &lt;embed height=\"0\" width=\"0\" src=\"http://tts.baidu.com/text2audio?lan=zh&amp;ie=UTF-8&amp;text=欢迎访问笑忘歌\"&gt;&lt;/embed&gt;","text":"有一个网站，想让用户进入主页后听到语音欢迎，其实就是给网站加背景音乐的代码啊!这里我提供的代码是调用的百度语音，代码如下： &lt;embed height=\"0\" width=\"0\" src=\"http://tts.baidu.com/text2audio?lan=zh&amp;ie=UTF-8&amp;text=欢迎访问笑忘歌\"&gt;&lt;/embed&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"MyBatis入门踩坑记录","slug":"MyBatis入门踩坑记录","date":"2020-07-19T15:01:00.000Z","updated":"2020-09-18T04:43:02.971Z","comments":true,"path":"2020/07/19/MyBatis入门踩坑记录/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/19/MyBatis%E5%85%A5%E9%97%A8%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"MyBatis入门程序问题说明学习过程中遇到很多问题，记录一下。","text":"MyBatis入门程序问题说明学习过程中遇到很多问题，记录一下。 Maven静态资源过滤问题 &lt;!--在build中配置resource，来防止我们资源导出失败的问题--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; Junit测试时，可能会提示org.apache.ibatis.binding.BindingException: Type interface com.melodyhub.dao.UserDao is not known to the MapperRegistry. MapperRegistry是什么？ 每一个Mapper.xml都需要在MyBatis核心配置文件中注册！！！ &lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册！！！--&gt; &lt;mappers&gt; &lt;mapper resource=\"com/melodyhub/dao/UserMapper.xml\"/&gt; &lt;/mappers&gt; MySQL时区由于MySQL底层是使用的时区是CST，跟中国时间相差挣好8个小时。 解决办法是在mybatis-config.xml中``jdbc的url`末尾加上，二选一即可： &amp;amp;serverTimezone=GMT%2B8 &amp;amp;useTimezone=true&amp;amp;serverTimezone=UTC ` 参考：https://blog.csdn.net/ziningyihao/article/details/90644295 MySQL驱动/版本问题所有的代码都没有问题，但是就是连接不上数据库，经过排查，发现我的MySQL版本是8.0，驱动包是5.1.47，差距太大，不兼容。 将MySQL降级到5.7.29，问题解决。 解决Mybatis报错Could not find resource mybatis-config.xml下午移植远程仓库项目的时候，控制台报错： java.io.IOException: Could not find resource mybatis-config.xml 经过排查，发现是我没有一直夫工程的pom.xml文件。 Maven clean清除缓存，然后build，即可。 -解决Mybatis报错Could not find resource mybatis-config.xml MyBatis问题解决Error building SqlSession. 解决🐤 改为全类名：com.melodyhub.pojo.User MyBatis问题解决Error building SqlSession. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"MyBatis入门程序","slug":"MyBatis入门程序","date":"2020-07-19T15:00:00.000Z","updated":"2020-09-18T04:43:02.981Z","comments":true,"path":"2020/07/19/MyBatis入门程序/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/19/MyBatis%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/","excerpt":"思路流程搭建环境–&gt;导入Mybatis—&gt;编写代码—&gt;测试","text":"思路流程搭建环境–&gt;导入Mybatis—&gt;编写代码—&gt;测试 代码演示1、搭建实验数据库CREATE DATABASE `mybatis`; USE `mybatis`; DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(20) NOT NULL, `name` varchar(30) DEFAULT NULL, `pwd` varchar(30) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `user`(`id`,`name`,`pwd`) values (1,'狂神','123456'),(2,'张三','abcdef'),(3,'李四','987654'); 2、导入MyBatis相关 jar 包 GitHub上找，或https://mvnrepository.com，或https://maven.aliyun.com/mvn/search pom.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--父工程--&gt; &lt;groupId&gt;com.melodyhub&lt;/groupId&gt; &lt;artifactId&gt;Mybatis-Study&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--子模块--&gt; &lt;modules&gt; &lt;module&gt;mybatis-01&lt;/module&gt; &lt;module&gt;mybatis-02&lt;/module&gt; &lt;module&gt;mybatis-03&lt;/module&gt; &lt;/modules&gt; &lt;!--导入依赖--&gt; &lt;dependencies&gt; &lt;!--MyBatis--&gt; &lt;!--https://mvnrepository.com/artifact/org.mybatis/mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--在build中配置resource，来防止我们资源导出失败的问题--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;/project&gt; 3、编写MyBatis核心配置文件 查看帮助文档 mybatis-config.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;!--configuration 核心配置文件--&gt; &lt;configuration&gt; &lt;!--environments 可配置多个环境--&gt; &lt;environments default=\"development\"&gt; &lt;!--多个环境，不同id--&gt; &lt;environment id=\"development\"&gt; &lt;!--事务管理--&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=GMT%2B8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册！！！--&gt; &lt;mappers&gt; &lt;mapper resource=\"com/melodyhub/dao/UserMapper.xml\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 4、编写MyBatis工具类 查看帮助文档 package com.melodyhub.utils; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; //sqlSessionFactory --&gt; sqlSession public class MyBatisUtils { private static SqlSessionFactory sqlSessionFactory; static { //使用MyBatis获取sqlSessionFactory对象 try { String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //获取SqlSession连接 //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例4 //SqlSession 提供了在数据库执行 SQL 命令所需的所有方法 public static SqlSession getSqlSession() { return sqlSessionFactory.openSession(); /* SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; */ } } 5、创建实体类package com.melodyhub.pojo; public class User { //变量名必须和数据库的列名相同 private int id; private String name; private String pwd; public User() { toString(); } public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public int getId() { return id; } public String getName() { return name; } public String getPwd() { return pwd; } public void setId(int id) { this.id = id; } public void setName(String name) { this.name = name; } public void setPwd(String pwd) { this.pwd = pwd; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '}'; } } 6、编写Mapper接口类package com.melodyhub.dao; import com.melodyhub.pojo.User; import java.util.List; public interface UserMapper { //查询全部用户 List&lt;User&gt; getUserList(); //根据id查询用户 User getUserById(int id); //insert一个用户 int addUser(User user); //修改用户 int updateUser(User user); //删除一个用户 int deleteUser(int id); } 7、编写Mapper.xml配置文件 namespace 十分重要，不能写错！ 原理：#探究已映射的 SQL 语句 UserMapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!--namespace=\"绑定一个对应的Dao/Mapper接口\"--&gt; &lt;mapper namespace=\"com.melodyhub.dao.UserMapper\"&gt; &lt;!--select查询语句--&gt; &lt;select id=\"getUserList\" resultType=\"com.melodyhub.pojo.User\"&gt; select * from mybatis.user; &lt;/select&gt; &lt;/mapper&gt; 8、编写测试类 Junit 包测试（在绿色图标的java包中） test/java/com/melody/dao/UserDaoTest.java package com.melodyhub.dao; import com.melodyhub.pojo.User; import com.melodyhub.utils.MyBatisUtils; import org.apache.ibatis.session.SqlSession; import org.junit.Test; import java.util.List; public class UserDaoTest { @Test public void test(){ //第一步：获取SqlSession对象 SqlSession sqlSession = MyBatisUtils.getSqlSession(); //第二部：执行SQL //方式1：getMapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = userMapper.getUserList(); //方式2： //遍历结果集 for (User user : userList) { System.out.println(user); } //关闭SqlSession对象 sqlSession.close(); } } 9、运行测试，成功的查询出来的我们的数据，ok！ 问题说明学习过程中遇到很多问题，记录一下。 Maven静态资源过滤问题 &lt;!--在build中配置resource，来防止我们资源导出失败的问题--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; Junit测试时，可能会提示org.apache.ibatis.binding.BindingException: Type interface com.melodyhub.dao.UserDao is not known to the MapperRegistry. MapperRegistry是什么？ 每一个Mapper.xml都需要在MyBatis核心配置文件中注册！！！ &lt;!--每一个Mapper.xml都需要在MyBatis核心配置文件中注册！！！--&gt; &lt;mappers&gt; &lt;mapper resource=\"com/melodyhub/dao/UserMapper.xml\"/&gt; &lt;/mappers&gt; MySQL时区由于MySQL底层是使用的时区是CST，跟中国时间相差挣好8个小时。 解决办法是在mybatis-config.xml中``jdbc的url`末尾加上，二选一即可： &amp;amp;serverTimezone=GMT%2B8 &amp;amp;useTimezone=true&amp;amp;serverTimezone=UTC ` 参考：https://blog.csdn.net/ziningyihao/article/details/90644295 MySQL驱动/版本问题所有的代码都没有问题，但是就是连接不上数据库，经过排查，发现我的MySQL版本是8.0，驱动包是5.1.47，差距太大，不兼容。 将MySQL降级到5.7.29，问题解决。 特别要点命名空间提示 对命名空间的一点补充 在之前版本的 MyBatis 中，命名空间（Namespaces）的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。 命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。 命名解析：为了减少输入量，MyBatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。 全限定名（比如 “com.mypackage.MyMapper.selectAllThings）将被直接用于查找及使用。 短名称（比如 “selectAllThings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectAllThings” 和 “com.bar.selectAllThings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。 作用域（Scope）和生命周期理解我们之前讨论过的不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。 作用域：SqlSessionFactoryBuilder –&gt;SqlSessionFactory –&gt;SqlSession 提示 对象生命周期和依赖注入框架依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。 SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了（经常地就封装到工具类中）。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。 SqlSessionFactorySqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式： try (SqlSession session = sqlSessionFactory.openSession()) { // 你的应用逻辑代码 } 在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。 映射器实例映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样： try (SqlSession session = sqlSessionFactory.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class); // 你的应用逻辑代码 } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"MyBatis问题解决Error building SqlSession.","slug":"MyBatis问题解决Error-building-SqlSession","date":"2020-07-19T12:59:52.000Z","updated":"2020-09-18T04:43:02.978Z","comments":true,"path":"2020/07/19/MyBatis问题解决Error-building-SqlSession/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/19/MyBatis%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3Error-building-SqlSession/","excerpt":"解决改为全类名：com.melodyhub.pojo.User","text":"解决改为全类名：com.melodyhub.pojo.User document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"MySQL配置文件参数详解","slug":"MySQL配置文件参数详解","date":"2020-07-19T12:31:32.000Z","updated":"2020-09-18T04:43:02.999Z","comments":true,"path":"2020/07/19/MySQL配置文件参数详解/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/19/MySQL%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/","excerpt":"Windows中是my.ini Linux中是my.cnf","text":"Windows中是my.ini Linux中是my.cnf #*** client options 相关选项 ***# #以下选项会被MySQL客户端应用读取。注意只有MySQL附带的客户端应用程序保证可以读取这段内容。如果你想你自己的MySQL应用程序获取这些值。需要在MySQL客户端库初始化的时候指定这些选项。 [client] port = 3309 socket = /usr/local/mysql/tmp/mysql.sock [mysqld] !include /usr/local/mysql/etc/mysqld.cnf #包含的配置文件 ，把用户名，密码文件单独存放 port = 3309 bind-address = 0.0.0.0 server-id = 1 #表示是本机的序号为1,唯一 socket = /usr/local/mysql/tmp/mysql.sock pid-file = /usr/local/mysql/var/mysql.pid basedir = /usr/local/mysql/ datadir = /usr/local/mysql/var/ tmpdir = /usr/local/mysql/tmp/ #此目录被 MySQL用来保存临时文件.例如,它被用来处理基于磁盘的大型排序,和内部排序一样，以及简单的临时表.如果你不创建非常大的临时文件,将其放置到 swapfs/tmpfs 文件系统上也许比较好。另一种选择是你也可以将其放置在独立的磁盘上.你可以使用”;”来放置多个路径，他们会按照 roud-robin 方法被轮询使用. slave-load-tmpdir = /usr/local/mysql/tmp/ #当 slave 执行 load data infile 时用 #*** skip options 相关选项 ***# skip-name-resolve #禁止 MySQL 对外部连接进行 DNS 解析，使用这一选项可以消除 MySQL 进行 DNS 解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用 IP 地址方式，否则 MySQL 将无法正常处理连接请求！ skip-symbolic-links #不能使用连接文件，多个客户可能会访问同一个数据库，因此这防止外部客户锁定 MySQL 服务器。 该选项默认开启 skip-external-locking #不使用系统锁定，要使用 myisamchk,必须关闭服务器 ,避免 MySQL的外部锁定，减少出错几率增强稳定性。 skip-slave-start #启动 mysql,不启动复制 skip-networking #开启该选项可以彻底关闭 MySQL 的 TCP/IP 连接方式，如果 WEB 服务器是以远程连接的方式访问 MySQL 数据库服务器则不要开启该选项！否则将无法正常连接！ 如果所有的进程都是在同一台服务器连接到本地的 mysqld, 这样设置将是增强安全的方法 sysdate-is-now = 1 #把SYSDATE 函数编程为 NOW的别名 #*** 系统资源相关选项 ***# back_log = 50 #接受队列，对于没建立 tcp 连接的请求队列放入缓存中，队列大小为 back_log，受限制与 OS 参数，试图设定 back_log 高于你的操作系统的限制将是无效的。默认值为 50。对于 Linux 系统推荐设置为小于512的整数。如果系统在一个短时间内有很多连接，则需要增大该参数的值 max_connections = 1000 #指定MySQL允许的最大连接进程数。如果在访问数据库时经常出现\"Too Many Connections\"的错误提 示，则需要增大该参数值。 max_connect_errors = 10000 #如果某个用户发起的连接 error 超过该数值，则该用户的下次连接将被阻塞，直到管理员执行 flush hosts ; 命令或者服务重启， 防止黑客 ， 非法的密码以及其他在链接时的错误会增加此值 open_files_limit = 10240 #MySQL打开的文件描述符限制，默认最小1024;当open_files_limit没有被配置的时候，比较max_connections*5和ulimit-n的值，哪个大用哪个，当open_file_limit被配置的时候，比较open_files_limit和max_connections*5的值，哪个大用哪个。 connect-timeout = 10 #连接超时之前的最大秒数,在 Linux 平台上，该超时也用作等待服务器首次回应的时间 wait-timeout = 28800 #等待关闭连接的时间 interactive-timeout = 28800 #关闭连接之前，允许 interactive_timeout（取代了wait_timeout）秒的不活动时间。客户端的会话 wait_timeout 变量被设为会话interactive_timeout 变量的值。如果前端程序采用短连接，建议缩短这2个值, 如果前端程序采用长连接，可直接注释掉这两个选项，默认配置(8小时) slave-net-timeout = 600 #从服务器也能够处理网络连接中断。但是，只有从服务器超过slave_net_timeout 秒没有从主服务器收到数据才通知网络中断 net_read_timeout = 30 #从服务器读取信息的超时 net_write_timeout = 60 #从服务器写入信息的超时 net_retry_count = 10 #如果某个通信端口的读操作中断了，在放弃前重试多次 net_buffer_length = 16384 #包消息缓冲区初始化为 net_buffer_length 字节，但需要时可以增长到 max_allowed_packet 字节 max_allowed_packet = 64M # 服务所能处理的请求包的最大大小以及服务所能处理的最大的请求大小(当与大的BLOB 字段一起工作时相当必要)， 每个连接独立的大小.大小动态增加。 设置最大包,限制server接受的数据包大小，避免超长SQL的执行有问题 默认值为16M，当MySQL客户端或mysqld 服务器收到大于 max_allowed_packet 字节的信息包时，将发出“信息包过大”错误，并关闭连接。对于某些客户端，如果通信信息包过大，在执行查询期间，可能会遇到“丢失与 MySQL 服务器的连接”错误。默认值 16M。 table_cache = 512 # 所有线程所打开表的数量. 增加此值就增加了mysqld所需要的文件描述符的数量这样你需要确认在[mysqld_safe]中 “open-files-limit” 变量设置打开文件数量允许至少4096 thread_stack = 192K # 线程使用的堆大小. 此容量的内存在每次连接时被预留.MySQL 本身常不会需要超过 64K 的内存如果你使用你自己的需要大量堆的 UDF 函数或者你的操作系统对于某些操作需要更多的堆,你也许需要将其设置的更高一点.默认设置足以满足大多数应用 thread_cache_size = 20 # 我们在 cache 中保留多少线程用于重用.当一个客户端断开连接后,如果 cache 中的线程还少于 thread_cache_size,则客户端线程被放入 cache 中.这可以在你需要大量新连接的时候极大的减少线程创建的开销(一般来说如果你有好的线程模型的话, 这不会有明显的性能提升.)服务器线程缓存这个值表示可以重新利用保存在缓存中线程的数量,当断开连接时如果缓存中还有空间,那么客户端的线程将被放到缓存中,如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建, 如果有很多新的线程，增加这个值可以改善系统性能.通过比较 Connections 和 Threads_created 状态的变量，可以看到这个变量的作用 根据物理内存设置规则如下： 1G —&gt; 8 2G —&gt; 16 3G —&gt; 32 大于3G —&gt; 64 thread_concurrency = 8 #此允许应用程序给予线程系统一个提示在同一时间给予渴望被运行的线程的数量.该参数取值为服务器逻辑CPU数量×2，在本例中，服务器有 2 颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为 4 × 2 ＝ 8.设置 thread_concurrency的值的正确与否, 对 mysql 的性能影响很大, 在多个 cpu(或多核)的情况下，错误设置了 thread_concurrency 的值, 会导致 mysql 不能充分利用多 cpu(或多核),出现同一时刻只能一个 cpu(或核)在工作的情况。 thread_concurrency 应设为 CPU 核数的 2 倍.比如有一个双核的 CPU, 那么 thread_concurrency 的应该为 4; 2 个双核的 cpu,thread_concurrency 的值应为 8,属重点优化参数 #*** qcache settings 相关选项 ***# query_cache_limit = 2M #不缓存查询大于该值的结果.只有小于此设定值的结果才会被缓冲, 此设置用来保护查询缓冲,防止一个极大的结果集将其他所有的查询结果都覆盖. query_cache_min_res_unit = 2K #查询缓存分配的最小块大小.默认是 4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费 查询缓存碎片率 = Qcache_free_blocks / Qcache_total_blocks * 100% 如果查询缓存碎片率超过 20%，可以用 FLUSH QUERY CACHE 整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。 查询缓存利用率 = (query_cache_size – Qcache_free_memory) / query_cache_size *100% 查询缓存利用率在 25%以下的话说明 query_cache_size 设置的过大，可适当减小;查询缓存利用率在 80%以上而且 Qcache_lowmem_prunes &gt; 50 的话说明 query_cache_size 可能有点小，要不就是碎片太多。 查询缓存命中率 = (Qcache_hits – Qcache_inserts) / Qcache_hits * 100% query_cache_size = 64M #指定 MySQL 查询缓冲区的大小。可以通过在 MySQL 控制台执行以下命令观察： 代码: &gt; SHOW VARIABLES LIKE '%query_cache%'; &gt; SHOW STATUS LIKE 'Qcache%';如果 Qcache_lowmem_prunes 的值非常大，则表明经常出现缓冲不够的情况； 如果 Qcache_hits 的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓冲； Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。 memlock # 如果你的系统支持 memlock() 函数,你也许希望打开此选项用以让运行中的 mysql 在在内存高度 紧张的时候,数据在内存中保持锁定并且防止可能被 swapping out,此选项对于性能有益 #*** default settings 相关选项 ***# default_table_type = InnoDB # 当创建新表时作为默认使用的表类型,如果在创建表示没有特别执行表类型,将会使用此值 default-time-zone = system #服务器时区 character-set-server = utf8 #server 级别字符集 default-storage-engine = InnoDB #默认存储引擎 #*** tmp &amp;&amp; heap settings 相关选项 ***# tmp_table_size = 512M #临时表的最大大小，如果超过该值，则结果放到磁盘中,此限制是针对单个表的,而不是总和. max_heap_table_size = 512M #独立的内存表所允许的最大容量.此选项为了防止意外创建一个超大的内存表导致永尽所有的内存资源. #*** log settings 相关选项 ***# log-bin = mysql-bin #打开二进制日志功能.在复制(replication)配置中,作为 MASTER 主服务器必须打开此项.如果你需要从你最后的备份中做基于时间点的恢复,你也同样需要二进制日志.这些路径相对于 datadir log_slave_updates = 1 #表示slave将复制事件写进自己的二进制日志 log-bin-index = mysql-bin.index #二进制的索引文件名 relay-log = relay-log #定义relay_log的位置和名称，如果值为空，则默认位置在数据文件的目录，文件名为host_name-relay-bin.nnnnnn（By default, relay log file names have the form host_name-relay-bin.nnnnnn in the data directory）； relay_log_index = relay-log.index #relay-log的索引文件名 log-warnings = 1 # 将警告打印输出到错误 log 文件.如果你对于MySQL有任何问题，你应该打开警告 log 并且仔细审查错误日志,查出可能的原因. log-error = /usr/local/mysql/log/mysql.err #错误日志路径 log_output = FILE #参数 log_output 指定了慢查询输出的格式，默认为 FILE，你可以将它设为 TABLE，然后就可以查询 mysql 架构下的 slow_log 表了 log_slow_queries #指定是否开启慢查询日志(该参数要被slow_query_log取代，做兼容性保留) slow_query_log = 1 # 指定是否开启慢查询日志. 慢查询是指消耗了比 “long_query_time” 定义的更多时间的查询.如果 log_long_format 被打开,那些没有使用索引的查询也会被记录.如果你经常增加新查询到已有的系统内的话. 一般来说这是一个好主意, long-query-time = 1 #设定慢查询的阀值，超出次设定值的SQL即被记录到慢查询日志，缺省值为10s.所有的使用了比这个时间(以秒为单位)更多的查询会被认为是慢速查询.不要在这里使用”1″, 否则会导致所有的查询,甚至非常快的查询页被记录下来(由于MySQL 目前时间的精确度只能达到秒的级别). log_long_format # 在慢速日志中记录更多的信息.一般此项最好打开，打开此项会记录使得那些没有使用索引的查询也被作为到慢速查询附加到慢速日志里 slow_query_log_file = /usr/local/mysql/log/slow.log # 指定慢日志文件存放位置，可以为空，系统会给一个缺省的文件host_name-slow.log log-queries-not-using-indexes #如果运行的SQL语句没有使用索引，则mysql数据库同样会将这条SQL语句记录到慢查询日志文件中。 min_examined_row_limit=1000 #记录那些由于查找了多余1000次而引发的慢查询 long-slow-admin-statements #记录那些慢的optimize table，analyze table和alter table语句 log-slow-slave-statements #记录由Slave所产生的慢查询 general_log = 1 #将所有到达MySQL Server的SQL语句记录下来,默认关闭 general_log_file = /usr/local/mysql/log/mysql.log #general_log路径 max_binlog_size = 1G #如果二进制日志写入的内容超出给定值，日志就会发生滚动。你不能将该变量设置为大于1GB或小于4096字节。 默认值是1GB。如果你正使用大的事务，二进制日志还会超过max_binlog_size max_relay_log_size = 1G #标记relaylog允许的最大值，如果该值为0，则默认值为max_binlog_size(1G)；如果不为0，则max_relay_log_size则为最大的relay_log文件大小； relay-log-purge = 1 #是否自动清空不再需要中继日志时。默认值为1(启用) expire_logs_days = 30 #超过 30 天的 binlog 删除 binlog_cache_size = 1M # 在一个事务中 binlog 为了记录 SQL 状态所持有的 cache 大小,如果你经常使用大的,多声明的事务,你可以增加此值来获取更大的性能.所有从事务来的状态都将被缓冲在 binlog 缓冲中然后在提交后一次性写入到 binlog 中,如果事务比此值大, 会使用磁盘上的临时文件来替代.此缓冲在每个连接的事务第一次更新状态时被创建.session 级别 replicate-wild-ignore-table = mysql.% #复制时忽略数据库及表 slave_skip_errors=all #定义复制过程中从服务器可以自动跳过的错误号，当复制过程中遇到定义的错误号，就可以自动跳过，直接执行后面的SQL语句。 slave_skip_errors选项有四个可用值，分别为：off，all，ErorCode，ddl_exist_errors。 默认情况下该参数值是off，我们可以列出具体的error code，也可以选择all，mysql5.6及MySQL Cluster NDB 7.3以及后续版本增加了参数ddl_exist_errors，该参数包含一系列error code（1007,1008,1050,1051,1054,1060,1061,1068,1094,1146） 一些error code代表的错误如下： 1007：数据库已存在，创建数据库失败 1008：数据库不存在，删除数据库失败 1050：数据表已存在，创建数据表失败 1051：数据表不存在，删除数据表失败 1054：字段不存在，或程序文件跟数据库有冲突 1060：字段重复，导致无法插入 1061：重复键名 1068：定义了多个主键 1094：位置线程ID 1146：数据表缺失，请恢复数据库 1053：复制过程中主服务器宕机 1062：主键冲突 Duplicate entry '%s' for key %d #*** MyISAM 相关选项 ***# key_buffer_size = 256M #指定用于索引的缓冲区大小，增加它可得到更好的索引处理性能。如果是以InnoDB引擎为主的DB，专用于MyISAM引擎的 key_buffer_size 可以设置较小，8MB 已足够 如果是以MyISAM引擎为主，可设置较大，但不能超过4G. 在这里，强烈建议不使用MyISAM引擎，默认都是用InnoDB引擎.注意：该参数值设置的过大反而会是服务器整体效率降低！ sort_buffer_size = 2M #查询排序时所能使用的缓冲区大小。排序缓冲被用来处理类似 ORDER BY 以及 GROUP BY 队列所引起的排序.一个用来替代的基于磁盘的合并分类会被使用.查看 “Sort_merge_passes” 状态变量. 在排序发生时由每个线程分配 注意：该参数对应的分配内存是每连接独占！如果有 100 个连接，那么实际分配的总共排序缓冲区大小为 100 × 6 ＝600MB,所以,对于内存在 4GB 左右的服务器推荐设置为 6-8M。 read_buffer_size = 2M #读查询操作所能使用的缓冲区大小。和 sort_buffer_size 一样，该参数对应的分配内存也是每连接独享！用来做 MyISAM 表全表扫描的缓冲大小.当全表扫描需要时,在对应线程中分配. join_buffer_size = 8M #联合查询操作所能使用的缓冲区大小，和 sort_buffer_size 一样，该参数对应的分配内存也是每连接独享!此缓冲被使用来优化全联合(full JOINs 不带索引的联合).类似的联合在极大多数情况下有非常糟糕的性能表现, 但是将此值设大能够减轻性能影响.通过 “Select_full_join”状态变量查看全联合的数量， 当全联合发生时,在每个线程中分配。 read_rnd_buffer_size = 8M #MyISAM 以索引扫描(Random Scan)方式扫描数据的 buffer大小 bulk_insert_buffer_size = 64M #MyISAM 使用特殊的类似树的 cache 来使得突发插入(这些插入是,INSERT … SELECT, INSERT … VALUES (…), (…), …, 以及 LOAD DATAINFILE) 更快. 此变量限制每个进程中缓冲树的字节数.设置为 0 会关闭此优化.为了最优化不要将此值设置大于 “key_buffer_size”.当突发插入被检测到时此缓冲将被分配MyISAM 用在块插入优化中的树缓冲区的大小。注释：这是一个 per thread 的限制 （ bulk 大量）.此缓冲当 MySQL 需要在 REPAIR, OPTIMIZE, ALTER 以及 LOAD DATA INFILE到一个空表中引起重建索引时被分配.这在每个线程中被分配.所以在设置大值时需要小心. myisam_sort_buffer_size = 64M #MyISAM 设置恢复表之时使用的缓冲区的尺寸,当在REPAIR TABLE 或用 CREATE INDEX 创建索引或 ALTER TABLE 过程中排序 MyISAM 索引分配的缓冲区 myisam_max_sort_file_size = 10G #mysql重建索引时允许使用的临时文件最大大小 myisam_repair_threads = 1 #如果该值大于 1，在 Repair by sorting 过程中并行创建MyISAM 表索引(每个索引在自己的线程内).如果一个表拥有超过一个索引, MyISAM 可以通过并行排序使用超过一个线程去修复他们.这对于拥有多个 CPU 以及大量内存情况的用户,是一个很好的选择. myisam_recover = 64K #允许的 GROUP_CONCAT()函数结果的最大长度 transaction_isolation = REPEATABLE-READ # 设定默认的事务隔离级别.可用的级别如下:READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ,SERIALIZABLE 1.READ UNCOMMITTED-读未提交 2.READ COMMITTE-读已提交 3.REPEATABLE READ -可重复读 4.SERIALIZABLE -串行 # *** INNODB 相关选项 ***# skip-innodb # 如果你的 MySQL 服务包含 InnoDB 支持但是并不打算使用的话,使用此选项会节省内存以及磁盘空间,并且加速某些部分 innodb_file_per_table = 1 # InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间 独立表空间优点： 1．每个表都有自已独立的表空间。 2．每个表的数据和索引都会存在自已的表空间中。 3．可以实现单表在不同的数据库中移动。 4．空间可以回收（除drop table操作处，表空不能自已回收） 缺点： 1.单表增加过大，如超过100G 结论： 共享表空间在Insert操作上少有优势。其它都没独立表空间表现好。当启用独立表空间时，请合理调整：innodb_open_files innodb_status_file = 1 #启用InnoDB的status file，便于管理员查看以及监控等 innodb_open_files = 2048 # 限制Innodb能打开的表的数据，如果库里的表特别多的情况，请增加这个。这个值默认是300 innodb_additional_mem_pool_size = 100M #设置InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，所以当我们一个MySQL Instance中的数据库对象非常多的时候，是需要适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率的。 innodb_buffer_pool_size = 2G #包括数据页、索引页、插入缓存、锁信息、自适应哈希所以、数据字典信息.InnoDB 使用一个缓冲池来保存索引和原始数据, 不像 MyISAM.这里你设置越大,你在存取表里面数据时所需要的磁盘 I/O 越少.在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的 80%,不要设置过大,否则,由于物理内存的竞争可能导致操作系统的换页颠簸.注意在 32 位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制,所以不要设置的太高. innodb_write_io_threads = 4 innodb_read_io_threads = 4 # innodb使用后台线程处理数据页上的读写 I/O(输入输出)请求,根据你的 CPU 核数来更改,默认是4 # 注:这两个参数不支持动态改变,需要把该参数加入到my.cnf里，修改完后重启MySQL服务,允许值的范围从 1-64 innodb_data_home_dir = /usr/local/mysql/var/ #设置此选项如果你希望 InnoDB 表空间文件被保存在其他分区.默认保存在 MySQL 的 datadir 中. innodb_data_file_path = ibdata1:500M;ibdata2:2210M:autoextend #InnoDB将数据保存在一个或者多个数据文件中成为表空间.如果你只有单个逻辑驱动保存你的数据,一个单个的自增文件就足够好了.其他情况下.每个设备一个文件一般都是个好的选择.你也可以配置 InnoDB 来使用裸盘分区 – 请参考手册来获取更多相关内容 innodb_file_io_threads = 4 #用来同步 IO 操作的 IO 线程的数量. 此值在 Unix 下被硬编码为 4,但是在 Windows 磁盘 I/O 可能在一个大数值下表现的更好. innodb_thread_concurrency = 16 #在 InnoDb 核心内的允许线程数量,InnoDB 试着在 InnoDB 内保持操作系统线程的数量少于或等于这个参数给出的限制,最优值依赖于应用程序,硬件以及操作系统的调度方式.过高的值可能导致线程的互斥颠簸.默认设置为 0,表示不限制并发数，这里推荐设置为0，更好去发挥CPU多核处理能力，提高并发量 innodb_flush_log_at_trx_commit = 1 #如果设置为 1 ,InnoDB 会在每次提交后刷新(fsync)事务日志到磁盘上,这提供了完整的 ACID 行为.如果你愿意对事务安全折衷, 并且你正在运行一个小的食物, 你可以设置此值到 0 或者 2 来减少由事务日志引起的磁盘 I/O 代表日志只大约每秒写入日志文件并且日志文件刷新到磁盘. 代表日志写入日志文件在每次提交后,但是日志文件只有大约每秒才会刷新到磁盘上. innodb_log_buffer_size = 8M #用来缓冲日志数据的缓冲区的大小.当此值快满时, InnoDB 将必须刷新数据到磁盘上.由于基本上每秒都会刷新一次,所以没有必要将此值设置的太大(甚至对于长事务而言) innodb_log_file_size = 500M #事物日志大小.在日志组中每个日志文件的大小，你应该设置日志文件总合大小到你缓冲池大小的5%~100%，来避免在日志文件覆写上不必要的缓冲池刷新行为.不论如何, 请注意一个大的日志文件大小会增加恢复进程所需要的时间. innodb_log_files_in_group = 2 #在日志组中的文件总数.通常来说 2~3 是比较好的. innodb_log_group_home_dir = /usr/local/mysql/var/ # InnoDB 的日志文件所在位置. 默认是 MySQL 的 datadir.你可以将其指定到一个独立的硬盘上或者一个 RAID1 卷上来提高其性能innodb_max_dirty_pages_pct = 90 #innodb 主线程刷新缓存池中的数据，使脏数据比例小于 90%,这是一个软限制,不被保证绝对执行. innodb_lock_wait_timeout = 50 #InnoDB 事务在被回滚之前可以等待一个锁定的超时秒数。InnoDB 在它自己的 锁定表中自动检测事务死锁并且回滚事务。 InnoDB 用 LOCK TABLES 语句注意到锁定设置。默认值是 50 秒 innodb_flush_method = O_DSYNC # InnoDB 用来刷新日志的方法.表空间总是使用双重写入刷新方法.默认值是 “fdatasync”, 另一个是 “O_DSYNC”. innodb_force_recovery=1 # 如果你发现 InnoDB 表空间损坏, 设置此值为一个非零值可能帮助你导出你的表.从1 开始并且增加此值知道你能够成功的导出表. innodb_fast_shutdown # 加速 InnoDB 的关闭. 这会阻止 InnoDB 在关闭时做全清除以及插入缓冲合并.这可能极大增加关机时间, 但是取而代之的是 InnoDB 可能在下次启动时做这些操作. # *** 其他 相关选项 ***# [mysqldump] quick #支持较大数据库的转储，在导出非常巨大的表时需要此项。增加该变量的值十分安全，这是因为仅当需要时才会分配额外内存。例如，仅当你发出长查询或mysqld必须返回大的结果行时mysqld才会分配更多内存。该变量之所以取较小默认值是一种预防措施，以捕获客户端和服务器之间的错误信息包，并确保不会因偶然使用大的信息包而导致内存溢出。 如果你正是用大的BLOB值，而且未为mysqld授予为处理查询而访问足够内存的权限，也会遇到与大信息包有关的奇怪问题。如果怀疑出现了该情况，请尝试在mysqld_safe脚本开始增加ulimit -d 256000，并重启mysqld。 [mysql] auto-rehash #允许通过 TAB 键提示 default-character-set = utf8 #数据库字符集 connect-timeout = 3 [mysqld_safe] open-files-limit = 8192 #增加每个进程的可打开文件数量.确认你已经将全系统限制设定的足够高!打开大量表需要将此值设大 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"IDEA技巧","slug":"IDEA技巧","date":"2020-07-19T09:20:29.000Z","updated":"2020-09-18T04:43:02.953Z","comments":true,"path":"2020/07/19/IDEA技巧/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/19/IDEA%E6%8A%80%E5%B7%A7/","excerpt":"快速遍历数组","text":"快速遍历数组 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"服务器开启可任意IP远程连接数据库","slug":"服务器开启可任意IP远程连接数据库","date":"2020-07-19T06:00:00.000Z","updated":"2020-09-18T04:43:03.206Z","comments":true,"path":"2020/07/19/服务器开启可任意IP远程连接数据库/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%90%AF%E5%8F%AF%E4%BB%BB%E6%84%8FIP%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"首先进入sql安装目录： cd C:\\mysql-5.6.17\\bin //这是本人的目录，找到自己的mysql安装目录 登录： mysql -u root -p 输入密码 use mysql #打开mysql数据库 将host设置为%表示任何ip都能连接mysql，当然您也可以将host指定为某个ipd” update user set host='%' where user='root' and host='localhost'; flush privileges; #刷新权限表，使配置生效 然后我们就能远程连接我们的mysql了。 如果您想关闭远程连接，恢复mysql的默认设置（只能本地连接），您可以通过以下步骤操作： use mysql #打开mysql数据库 将host设置为localhost表示只能本地连接mysql update user set host='localhost' where user='root'; flush privileges; #刷新权限表，使配置生效 备注：您也可以添加一个用户名为root，密码为123456，权限为%（表示任意ip都能连接）的远程连接用户。命令参考如下： grant all on *.* to 'root'@'%' identified by '123456'; flush privileges;","text":"首先进入sql安装目录： cd C:\\mysql-5.6.17\\bin //这是本人的目录，找到自己的mysql安装目录 登录： mysql -u root -p 输入密码 use mysql #打开mysql数据库 将host设置为%表示任何ip都能连接mysql，当然您也可以将host指定为某个ipd” update user set host='%' where user='root' and host='localhost'; flush privileges; #刷新权限表，使配置生效 然后我们就能远程连接我们的mysql了。 如果您想关闭远程连接，恢复mysql的默认设置（只能本地连接），您可以通过以下步骤操作： use mysql #打开mysql数据库 将host设置为localhost表示只能本地连接mysql update user set host='localhost' where user='root'; flush privileges; #刷新权限表，使配置生效 备注：您也可以添加一个用户名为root，密码为123456，权限为%（表示任意ip都能连接）的远程连接用户。命令参考如下： grant all on *.* to 'root'@'%' identified by '123456'; flush privileges; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"Mybatis中文文档","slug":"Mybatis中文文档","date":"2020-07-18T09:15:39.000Z","updated":"2020-09-18T04:43:02.986Z","comments":true,"path":"2020/07/18/Mybatis中文文档/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/18/Mybatis%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/","excerpt":"Mybatis文档学习和研究Mybatis框架，我一般会参考Mybatis中文文档，这是Mybatis官方维护的一份指导学习文档，具有权威性： https://mybatis.org/mybatis-3/zh/index.html 此文档开头会标明Mybatis当前最新版本号： Mybatis中文文档分为以下几个部分： XML配置：https://mybatis.org/mybatis-3/zh/configuration.html XML映射：https://mybatis.org/mybatis-3/zh/sqlmap-xml.html 动态SQL：https://mybatis.org/mybatis-3/zh/dynamic-sql.html Java API：https://mybatis.org/mybatis-3/zh/java-api.html SQL语句构建器：https://mybatis.org/mybatis-3/zh/statement-builders.html 日志：https://mybatis.org/mybatis-3/zh/logging.html 另外，Spring与Mybatis相结合使用的中文文档为：http://mybatis.org/spring/zh/","text":"Mybatis文档学习和研究Mybatis框架，我一般会参考Mybatis中文文档，这是Mybatis官方维护的一份指导学习文档，具有权威性： https://mybatis.org/mybatis-3/zh/index.html 此文档开头会标明Mybatis当前最新版本号： Mybatis中文文档分为以下几个部分： XML配置：https://mybatis.org/mybatis-3/zh/configuration.html XML映射：https://mybatis.org/mybatis-3/zh/sqlmap-xml.html 动态SQL：https://mybatis.org/mybatis-3/zh/dynamic-sql.html Java API：https://mybatis.org/mybatis-3/zh/java-api.html SQL语句构建器：https://mybatis.org/mybatis-3/zh/statement-builders.html 日志：https://mybatis.org/mybatis-3/zh/logging.html 另外，Spring与Mybatis相结合使用的中文文档为：http://mybatis.org/spring/zh/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"IntelliJ全家桶永久激活","slug":"IntelliJ全家桶永久激活","date":"2020-07-18T06:00:00.000Z","updated":"2020-09-18T04:43:02.956Z","comments":true,"path":"2020/07/18/IntelliJ全家桶永久激活/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/18/IntelliJ%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB/","excerpt":"IDEA2020.1激活，IntelliJ IDEA2020注册码，IntelliJ全家桶激活码申明：本教程 IntelliJ IDEA 破解补丁、激活码均收集于网络，请勿商用，仅供个人学习使用，如有侵权，请联系作者删除 IntelliJ全家桶IDEA 2020.1.3 激活方式 激活到 2089 年 1、 本教程适用于 IntelliJ IDEA 2020.1.3 以下所有版本，请放心食用~2、 本教程适用于 JetBrains 全系列产品，包括 IDEA、 Pycharm、WebStorm、Phpstorm、Datagrip、RubyMine、CLion、AppCode 等3、 本教程适用 Windows/Mac/Linux 系统，文中以 Windows 系统为例做讲解。","text":"IDEA2020.1激活，IntelliJ IDEA2020注册码，IntelliJ全家桶激活码申明：本教程 IntelliJ IDEA 破解补丁、激活码均收集于网络，请勿商用，仅供个人学习使用，如有侵权，请联系作者删除 IntelliJ全家桶IDEA 2020.1.3 激活方式 激活到 2089 年 1、 本教程适用于 IntelliJ IDEA 2020.1.3 以下所有版本，请放心食用~2、 本教程适用于 JetBrains 全系列产品，包括 IDEA、 Pycharm、WebStorm、Phpstorm、Datagrip、RubyMine、CLion、AppCode 等3、 本教程适用 Windows/Mac/Linux 系统，文中以 Windows 系统为例做讲解。 二、下载最新的 IDEA 2020 版本安装包我们选择从 IDEA 官网下载： https://www.jetbrains.com/idea/download 点击下载，下载完成即可。 三、开始激活1、 下载完成后，双击 ideaIU-2020.1.3.exe,打开安装软件； PS: 确保电脑没有安装老版本软件，如有请卸载。 2、 安装目录选择； 3、 按自己电脑配置勾选： 4、 点击 next, 安心等待其安装完成： 5、 安装完成后，勾选 Run IntelliJ IDEA，点击 finish 运行软件: 6、 会先弹出一个注册框，勾选 Evaluate for free, 点击 Evaluate: 7、 将激活补丁 jetbrains-agent.jar拖入 IDEA 界面中 链接: https://pan.baidu.com/s/1s6tiktsNDAOSxvb9WCPH_w 提取码: 2iyt 补丁，拖不进去，请重启 IDEA ，新建一个Java 项目，写一个空的 main 方法，再次试试 注意 激活补丁，拖进去之后，激活补丁的位置不要更换，不要删除。否则激活之后还会失效， 激活补丁，拖进去，等于是程序，帮你去写一个激活补丁的位置，你换补丁jar位置，或者，删除补丁jar，就找不到激活补丁了 8、 拖入补丁后会弹框，点击 restart 重启 idea： 9、 配置助手会提示您，需要使用哪种激活方式，这里我们选择默认的 Activation Code，通过注册码来激活，点击为IDEA安装： 10、 点击是，重启 IDEA 即可三、验证是否激活成功验证步骤如下： 1、 进入 IDEA 界面后，点击 Help -&gt; Register 查看： 2、 可以看到，已经成功激活至 2089 年，为确保不失效，请勿随意更新 注：补丁来自公众号，回复关键词 “IDEA” 获取 2020 版本文件夹中的激活补丁，或关注本文补丁链接的更新 链接: https://pan.baidu.com/s/1s6tiktsNDAOSxvb9WCPH_w 提取码: 2iyt document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"本站已接入音乐播放器API","slug":"本站已接入音乐播放器API","date":"2020-07-17T14:00:00.000Z","updated":"2020-09-18T04:43:03.201Z","comments":true,"path":"2020/07/17/本站已接入音乐播放器API/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/17/%E6%9C%AC%E7%AB%99%E5%B7%B2%E6%8E%A5%E5%85%A5%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8API/","excerpt":"优先接入：宅音乐播放器-一款方便快捷的HTML5音乐播放器效果如左下角 备选接入：明月浩空音乐播放器（免费版只能最多使用一个播放器、一个站点）","text":"优先接入：宅音乐播放器-一款方便快捷的HTML5音乐播放器效果如左下角 备选接入：明月浩空音乐播放器（免费版只能最多使用一个播放器、一个站点） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"【LeetCode】35. 搜索插入位置","slug":"【LeetCode】35.-搜索插入位置","date":"2020-07-17T07:17:00.000Z","updated":"2020-09-18T04:43:03.044Z","comments":true,"path":"2020/07/17/【LeetCode】35.-搜索插入位置/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/17/%E3%80%90LeetCode%E3%80%9135.-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","excerpt":"题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0","text":"题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 题解暴力匹配/* 暴力匹配 */ class Solution { public int searchInsert(int[] nums, int target) { if(nums == null || nums.length == 0){ return 0; } //考虑边界情况 if(target &lt; nums[0]){ return 0; } if(target == nums[nums.length -1]){ return nums.length-1; } if (target &gt; nums[nums.length - 1]) { //正序，判断最后一位数是否比目标值小 return nums.length; //如果大，直接返回数组长度 } int index = 0; for (int i = 0; i &lt; nums.length-1; i++) { if(nums[i] == target){ return i; } if ((nums[i] &lt; target &amp;&amp; nums[i+1] &gt; target)) { //相邻的两个数比较 return i+1; } } return index; } } 二分查找class Solution { public int searchInsert(int[] nums, int target) { // 不需要额外考虑数组为空的情况，因为此时low(0)&lt;=low(-1)不成立，直接返回0 int low = 0, high = nums.length - 1, mid = 0; while(low &lt;= high) { mid = (low + high) &gt;&gt; 1; if(nums[mid] == target) return mid; else if(nums[mid] &gt; target) high = mid - 1; else low = mid + 1; } return low; } } 精选题解 二分查找算法简介 踩坑实验室一兄弟使用js提交，但是遇到了这样的问题 将let mid = (hi + lo) &gt;&gt; 1;改为let mid = (hi + lo) / 2; 结果不通过 let mid = (hi + lo) &gt;&gt; 1; let mid = (hi + lo) / 2; 请路过的大佬，能不能解决？欢迎评论/私信我！！！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"正则表达式及工具","slug":"正则表达式及工具","date":"2020-07-17T07:00:00.000Z","updated":"2020-09-18T04:43:03.278Z","comments":true,"path":"2020/07/17/正则表达式及工具/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%B7%A5%E5%85%B7/","excerpt":"相关工具 RegExr – 正则表达式在线测试工具。 Regulex – 正则表达式在线测试工具。 正则表达式在线测试 – 菜鸟教程","text":"相关工具 RegExr – 正则表达式在线测试工具。 Regulex – 正则表达式在线测试工具。 正则表达式在线测试 – 菜鸟教程 常用正则表达式一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})$ 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数：^-[1-9][]0-9”*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*|0?.0+|0$ 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*))|0?.0+|0$ 正浮点数：^[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*$ 或 ^(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*|0?.0+|0)$ 校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\"等字符：[^%&amp;’,;=?$\\x22]+ 禁止输入含有的字符：**[^\\x22]+** 三、特殊需求表达式 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*.\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d{11})|^((\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1})|(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; ( 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Java 正则表达式","slug":"Java-正则表达式","date":"2020-07-17T06:00:00.000Z","updated":"2020-09-18T04:43:02.962Z","comments":true,"path":"2020/07/17/Java-正则表达式/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/17/Java-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"Java 正则表达式正则表达式定义了字符串的模式。 正则表达式可以用来搜索、编辑或处理文本。 正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。 Java正则表达式和Perl的是最为相似的。 java.util.regex包主要包括以下三个类： Pattern类： pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher类： Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。 PatternSyntaxException： PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。","text":"Java 正则表达式正则表达式定义了字符串的模式。 正则表达式可以用来搜索、编辑或处理文本。 正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。 Java正则表达式和Perl的是最为相似的。 java.util.regex包主要包括以下三个类： Pattern类： pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher类： Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。 PatternSyntaxException： PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 捕获组捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。 例如，正则表达式(dog) 创建了单一分组，组里包含”d”，”o”，和”g”。 捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组： ((A)(B(C))) (A) (B(C)) (C) 可以通过调用matcher对象的groupCount方法来查看表达式有多少个分组。groupCount方法返回一个int值，表示matcher对象当前有多个捕获组。 还有一个特殊的组（组0），它总是代表整个表达式。该组不包括在groupCount的返回值中。 实例下面的例子说明如何从一个给定的字符串中找到数字串： import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexMatches { public static void main( String args[] ){ // 按指定模式在字符串查找 String line = \"This order was placed for QT3000! OK?\"; String pattern = \"(.*)(\\\\d+)(.*)\"; // 创建 Pattern 对象 Pattern r = Pattern.compile(pattern); // 现在创建 matcher 对象 Matcher m = r.matcher(line); if (m.find( )) { System.out.println(\"Found value: \" + m.group(0) ); System.out.println(\"Found value: \" + m.group(1) ); System.out.println(\"Found value: \" + m.group(2) ); } else { System.out.println(\"NO MATCH\"); } } } 以上实例编译运行结果如下： Found value: This order was placed for QT3000! OK? Found value: This order was placed for QT300 Found value: 0 正则表达式语法 字符 说明 \\ 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\\n”匹配换行符。序列”\\“匹配”\"，”(“匹配”(“。 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\\n”或”\\r”之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\\n”或”\\r”之前的位置匹配。 * 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。 + 一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。 ? 零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。 {n} n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。 {n,} n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。 {n,m} M 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。 ? 当此字符紧随任何其他限定符（、+、?、{*n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。 . 匹配除”\\r\\n”之外的任何单个字符。若要匹配包括”\\r\\n”在内的任意字符，请使用诸如”[\\s\\S]”之类的模式。 (pattern) 匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。 (?:pattern) 匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。 (?=pattern) 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 (?!pattern) 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 x|y 匹配 x 或 y。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。 [xyz] 字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。 [^xyz] 反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。 [a-z] 字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。 [^a-z] 反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。 \\b 匹配一个字边界，即字与空格间的位置。例如，”er\\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。 \\B 非字边界匹配。”er\\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。 \\cx 匹配 x 指示的控制字符。例如，\\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。 \\d 数字字符匹配。等效于 [0-9]。 \\D 非数字字符匹配。等效于 [^0-9]。 \\f 换页符匹配。等效于 \\x0c 和 \\cL。 \\n 换行符匹配。等效于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等效于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效。 \\S 匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效。 \\t 制表符匹配。与 \\x09 和 \\cI 等效。 \\v 垂直制表符匹配。与 \\x0b 和 \\cK 等效。 \\w 匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。 \\W 与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。 \\xn 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\\x41”匹配”A”。”\\x041”与”\\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。 *num* 匹配 num*，此处的 *num 是一个正整数。到捕获匹配的反向引用。例如，”(.)\\1”匹配两个连续的相同字符。 *n* 标识一个八进制转义码或反向引用。如果 *n* 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。 *nm* 标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 *nm* 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 nm*，其中 *n 和 m 是八进制数字 (0-7)。 \\nml 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。 \\un 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\\u00A9 匹配版权符号 (©)。 Matcher类的方法索引方法索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配： 序号 方法及说明 1 public int start() 返回以前匹配的初始索引。 2 public int start(int group) 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引 3 public int end() 返回最后匹配字符之后的偏移量。 4 public int end(int group) 返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。 研究方法研究方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式： 序号 方法及说明 1 public boolean lookingAt() 尝试将从区域开头开始的输入序列与该模式匹配。 2 public boolean find() 尝试查找与该模式匹配的输入序列的下一个子序列。 3 public boolean find(int start**）** 重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。 4 public boolean matches() 尝试将整个区域与模式匹配。 替换方法替换方法是替换输入字符串里文本的方法： 序号 方法及说明 1 public Matcher appendReplacement(StringBuffer sb, String replacement) 实现非终端添加和替换步骤。 2 public StringBuffer appendTail(StringBuffer sb) 实现终端添加和替换步骤。 3 public String replaceAll(String replacement) 替换模式与给定替换字符串相匹配的输入序列的每个子序列。 4 public String replaceFirst(String replacement) 替换模式与给定替换字符串匹配的输入序列的第一个子序列。 5 public static String quoteReplacement(String s) 返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。 start 和end 方法下面是一个对单词”cat”出现在输入字符串中出现次数进行计数的例子： import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexMatches { private static final String REGEX = \"\\\\bcat\\\\b\"; private static final String INPUT = \"cat cat cat cattie cat\"; public static void main( String args[] ){ Pattern p = Pattern.compile(REGEX); Matcher m = p.matcher(INPUT); // 获取 matcher 对象 int count = 0; while(m.find()) { count++; System.out.println(\"Match number \"+count); System.out.println(\"start(): \"+m.start()); System.out.println(\"end(): \"+m.end()); } } } 以上实例编译运行结果如下： Match number 1 start(): 0 end(): 3 Match number 2 start(): 4 end(): 7 Match number 3 start(): 8 end(): 11 Match number 4 start(): 19 end(): 22 可以看到这个例子是使用单词边界，以确保字母 “c” “a” “t” 并非仅是一个较长的词的子串。它也提供了一些关于输入字符串中匹配发生位置的有用信息。 Start方法返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引，end方法最后一个匹配字符的索引加1。 matches 和lookingAt 方法matches 和lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是matcher要求整个序列都匹配，而lookingAt 不要求。 这两个方法经常在输入字符串的开始使用。 我们通过下面这个例子，来解释这个功能： import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexMatches { private static final String REGEX = \"foo\"; private static final String INPUT = \"fooooooooooooooooo\"; private static Pattern pattern; private static Matcher matcher; public static void main( String args[] ){ pattern = Pattern.compile(REGEX); matcher = pattern.matcher(INPUT); System.out.println(\"Current REGEX is: \"+REGEX); System.out.println(\"Current INPUT is: \"+INPUT); System.out.println(\"lookingAt(): \"+matcher.lookingAt()); System.out.println(\"matches(): \"+matcher.matches()); } } 以上实例编译运行结果如下： Current REGEX is: foo Current INPUT is: fooooooooooooooooo lookingAt(): true matches(): false replaceFirst 和replaceAll 方法replaceFirst 和replaceAll 方法用来替换匹配正则表达式的文本。不同的是，replaceFirst 替换首次匹配，replaceAll 替换所有匹配。 下面的例子来解释这个功能： import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexMatches { private static String REGEX = \"dog\"; private static String INPUT = \"The dog says meow. \" + \"All dogs say meow.\"; private static String REPLACE = \"cat\"; public static void main(String[] args) { Pattern p = Pattern.compile(REGEX); // get a matcher object Matcher m = p.matcher(INPUT); INPUT = m.replaceAll(REPLACE); System.out.println(INPUT); } } 以上实例编译运行结果如下： The cat says meow. All cats say meow. appendReplacement 和 appendTail 方法Matcher 类也提供了appendReplacement 和appendTail 方法用于文本替换： 看下面的例子来解释这个功能： import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexMatches { private static String REGEX = \"a*b\"; private static String INPUT = \"aabfooaabfooabfoob\"; private static String REPLACE = \"-\"; public static void main(String[] args) { Pattern p = Pattern.compile(REGEX); // 获取 matcher 对象 Matcher m = p.matcher(INPUT); StringBuffer sb = new StringBuffer(); while(m.find()){ m.appendReplacement(sb,REPLACE); } m.appendTail(sb); System.out.println(sb.toString()); } } 以上实例编译运行结果如下： -foo-foo-foo- PatternSyntaxException 类的方法PatternSyntaxException 是一个非强制异常类，它指示一个正则表达式模式中的语法错误。 PatternSyntaxException 类提供了下面的方法来帮助我们查看发生了什么错误。 序号 方法及说明 1 public String getDescription() 获取错误的描述。 2 public int getIndex() 获取错误的索引。 3 public String getPattern() 获取错误的正则表达式模式。 4 public String getMessage() 返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视化指示。 更多详见正则表达式 - 菜鸟教程 相关工具 RegExr – 正则表达式在线测试工具。 Regulex – 正则表达式在线测试工具。 正则表达式在线测试 – 菜鸟教程 常用正则表达式 一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})$ 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数：^-[1-9][]0-9”*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*|0?.0+|0$ 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*))|0?.0+|0$ 正浮点数：^[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*$ 或 ^(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d*.\\d*|0.\\d*[1-9]\\d*|0?.0+|0)$ 校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\"等字符：[^%&amp;’,;=?$\\x22]+ 禁止输入含有的字符：**[^\\x22]+** 三、特殊需求表达式 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*.\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d{11})|^((\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})|(\\d{4}|\\d{3})-(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1})|(\\d{7,8})-(\\d{4}|\\d{3}|\\d{2}|\\d{1}))$) 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$) 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; ( 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"配置NodeJs环境变量","slug":"配置NodeJs环境变量","date":"2020-07-17T04:57:00.000Z","updated":"2020-09-18T04:43:03.298Z","comments":true,"path":"2020/07/17/配置NodeJs环境变量/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/17/%E9%85%8D%E7%BD%AENodeJs%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"环境配置写在前面的话： 这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\\Users\\用户名\\AppData\\Roaming\\npm】路径中，占C盘空间。 在F:\\node新建一个文件夹，名称为node_global 在F:\\node新建一个文件夹，名称为node_cache 如果你是zip安装直接接着往下走，如果你是msi安装方式，请直接到第五步； 配置npm系统环境path变量“我的电脑”-右键-“属性”-“高级系统设置”（快速点，直接win+R输入``sysdm.cpl）-“高级”-“环境变量”-“path`” 创建完两个空文件夹之后，打开cmd命令窗口，输入； npm config set prefix “F:\\node\\node_global”； npm config set cache “F:\\node\\node_cache”； 修改”F:\\node\\node_modules\\npm”的npmrc文件： prefix=F:\\node\\node_global cache=F:\\node\\node_cache “我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量”； 在【系统变量】下新建【NODE_PATH】，输入【F:\\node\\node_global\\node_modules 将【用户变量】下的【Path】修改为prefix的值【F:\\node\\node_global】","text":"环境配置写在前面的话： 这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\\Users\\用户名\\AppData\\Roaming\\npm】路径中，占C盘空间。 在F:\\node新建一个文件夹，名称为node_global 在F:\\node新建一个文件夹，名称为node_cache 如果你是zip安装直接接着往下走，如果你是msi安装方式，请直接到第五步； 配置npm系统环境path变量“我的电脑”-右键-“属性”-“高级系统设置”（快速点，直接win+R输入``sysdm.cpl）-“高级”-“环境变量”-“path`” 创建完两个空文件夹之后，打开cmd命令窗口，输入； npm config set prefix “F:\\node\\node_global”； npm config set cache “F:\\node\\node_cache”； 修改”F:\\node\\node_modules\\npm”的npmrc文件： prefix=F:\\node\\node_global cache=F:\\node\\node_cache “我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量”； 在【系统变量】下新建【NODE_PATH】，输入【F:\\node\\node_global\\node_modules 将【用户变量】下的【Path】修改为prefix的值【F:\\node\\node_global】 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"利用GitHub博客连接多仓库","slug":"利用GitHub博客连接多仓库","date":"2020-07-16T10:55:00.000Z","updated":"2020-08-27T05:55:24.192Z","comments":true,"path":"2020/07/16/利用GitHub博客连接多仓库/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/16/%E5%88%A9%E7%94%A8GitHub%E5%8D%9A%E5%AE%A2%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%BB%93%E5%BA%93/","excerpt":"在根目录下执行npm run build 后，会将项目文件生成到 dist 目录。 然后，你可以将dist目录部署到你喜欢的服务器托管商。 下面以GithubPage 举例： 新建 你的用户名.github.io 仓库 cd dist git init git add -A git commit -am\"init\" git remote add origin https://github.com/你的用户名/你的用户名.github.io.git git push -f origin master 然后在Github设置好仓库的GithubPage 选项 访问 你的用户名.github.io 即可浏览啦！ 假如你之前的用户名.github.io仓库已经有内容了,可以新建另一个的仓库，比如blog。 再将所占用项目迁移到blog，并设置好这个仓库的GithubPage 选项。 而这个仓库即成为了一个子目录用户名.github.io/blog。 如此一来，你的用户名.github.io仓库便可留给首页了！","text":"在根目录下执行npm run build 后，会将项目文件生成到 dist 目录。 然后，你可以将dist目录部署到你喜欢的服务器托管商。 下面以GithubPage 举例： 新建 你的用户名.github.io 仓库 cd dist git init git add -A git commit -am\"init\" git remote add origin https://github.com/你的用户名/你的用户名.github.io.git git push -f origin master 然后在Github设置好仓库的GithubPage 选项 访问 你的用户名.github.io 即可浏览啦！ 假如你之前的用户名.github.io仓库已经有内容了,可以新建另一个的仓库，比如blog。 再将所占用项目迁移到blog，并设置好这个仓库的GithubPage 选项。 而这个仓库即成为了一个子目录用户名.github.io/blog。 如此一来，你的用户名.github.io仓库便可留给首页了！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"随机图片API","slug":"随机图片API","date":"2020-07-16T09:55:00.000Z","updated":"2020-07-16T06:58:48.522Z","comments":true,"path":"2020/07/16/随机图片API/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/16/%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87API/","excerpt":"","text":"https://api.mz-moe.cn/img.php https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture https://ds.qqlepay.cn/ 内含2个接口 高清壁纸：https://acg.xydwz.cn/gqapi/gqapi.php 动漫壁纸：https://acg.xydwz.cn/api/api.php https://img.xjh.me https://misaka.asia https://acg.iclart.com https://api.paugram.com/help/wallpaper https://s0.xinger.ink https://api.isoyu.com https://ds.qqlepay.cn https://api.meetgudu.com https://api.btstu.cn/doc/sjbz.php https://acg.toubiec.cn http://api.mtyqx.cn https://api.w0ai1uo.org https://api.yuzhitu.cn/sjbz http://api.52yi.vip http://api.laolibab.cn/king/dm_tupian.php document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"API","slug":"API","permalink":"https://melodyjerry.github.io/blog/tags/API/"}]},{"title":"添加GitHub的star/fork/watch按钮","slug":"添加GitHub的starforkwatch按钮","date":"2020-07-16T07:58:00.000Z","updated":"2020-07-16T06:58:48.514Z","comments":true,"path":"2020/07/16/添加GitHub的starforkwatch按钮/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/16/%E6%B7%BB%E5%8A%A0GitHub%E7%9A%84starforkwatch%E6%8C%89%E9%92%AE/","excerpt":"要实现上面的效果，首先必须了解一些参数👇","text":"要实现上面的效果，首先必须了解一些参数👇 所需参数您必须为以下每个 URL 参数声明一个值： 选项 描述 user 拥有仓库的 GitHub 用户名 repo GitHub 仓库名称 type 要显示的按钮类型: star、watch、fork、sponsor、follow 可选参数不需要以下 URL参数。根据需要添加它们。 选项 描述 count 显示可选的观察器或分叉计数：默认情况下没有或true size 用于使用较大按钮的可选标志：默认情况下没有或large Star &lt;iframe src=\"https://ghbtns.com/github-btn.html?user=twbs&amp;repo=bootstrap&amp;type=star&amp;count=true&amp;size=large\" frameborder=\"0\" scrolling=\"0\" width=\"170\" height=\"30\" title=\"GitHub\"&gt;&lt;/iframe&gt; &lt;iframe src=\"https://ghbtns.com/github-btn.html?user=twbs&amp;repo=bootstrap&amp;type=star&amp;count=true\" frameborder=\"0\" scrolling=\"0\" width=\"150\" height=\"20\" title=\"GitHub\"&gt;&lt;/iframe&gt; Watch &lt;iframe src=\"https://ghbtns.com/github-btn.html?user=twbs&amp;repo=bootstrap&amp;type=watch&amp;count=true&amp;size=large&amp;v=2\" frameborder=\"0\" scrolling=\"0\" width=\"170\" height=\"30\" title=\"GitHub\"&gt;&lt;/iframe&gt; &lt;iframe src=\"https://ghbtns.com/github-btn.html?user=twbs&amp;repo=bootstrap&amp;type=watch&amp;count=true&amp;v=2\" frameborder=\"0\" scrolling=\"0\" width=\"150\" height=\"20\" title=\"GitHub\"&gt;&lt;/iframe&gt; Fork &lt;iframe src=\"https://ghbtns.com/github-btn.html?user=twbs&amp;repo=bootstrap&amp;type=fork&amp;count=true&amp;size=large\" frameborder=\"0\" scrolling=\"0\" width=\"170\" height=\"30\" title=\"GitHub\"&gt;&lt;/iframe&gt; &lt;iframe src=\"https://ghbtns.com/github-btn.html?user=twbs&amp;repo=bootstrap&amp;type=fork&amp;count=true\" frameborder=\"0\" scrolling=\"0\" width=\"150\" height=\"20\" title=\"GitHub\"&gt;&lt;/iframe&gt; 可用选项SSL 支持示例按钮与 URL 一起显示。当 SSL 选项托管在 GitHub 页面上时，SSL 选项通过CloudFlare 的免费通用 SSL 产品提供。如果您愿意，您仍然可以使用 。https:// http:// 更多详见文档：https://ghbtns.com/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"[转]KMP 算法详解","slug":"KMP-算法详解","date":"2020-07-16T07:55:00.000Z","updated":"2020-08-27T05:55:24.123Z","comments":true,"path":"2020/07/16/KMP-算法详解/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/16/KMP-%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/","excerpt":"转载保存一份关于【KMP】算法的笔记，作者是我很喜欢的一个算法大佬 labuladong。在向他学习的同时顺便帮他宣传一下，记得去GitHub上给他点个star👉 致力于把算法讲清楚！欢迎关注我的微信公众号 labuladong，查看更多通俗易懂的文章： GitHub：刷算法全靠套路，认准 labuladong 就够了！","text":"转载保存一份关于【KMP】算法的笔记，作者是我很喜欢的一个算法大佬 labuladong。在向他学习的同时顺便帮他宣传一下，记得去GitHub上给他点个star👉 致力于把算法讲清楚！欢迎关注我的微信公众号 labuladong，查看更多通俗易懂的文章： GitHub：刷算法全靠套路，认准 labuladong 就够了！ 动态规划之KMP字符匹配算法读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目： 28.实现 strStr() KMP 算法（Knuth-Morris-Pratt 算法）是一个著名的字符串匹配算法，效率很高，但是确实有点复杂。 很多读者抱怨 KMP 算法无法理解，这很正常，想到大学教材上关于 KMP 算法的讲解，也不知道有多少未来的 Knuth、Morris、Pratt 被提前劝退了。有一些优秀的同学通过手推 KMP 算法的过程来辅助理解该算法，这是一种办法，不过本文要从逻辑层面帮助读者理解算法的原理。十行代码之间，KMP 灰飞烟灭。 先在开头约定，本文用 pat 表示模式串，长度为 M，txt 表示文本串，长度为 N。KMP 算法是在 txt 中查找子串 pat，如果存在，返回这个子串的起始索引，否则返回 -1。 为什么我认为 KMP 算法就是个动态规划问题呢，等会再解释。对于动态规划，之前多次强调了要明确 dp 数组的含义，而且同一个问题可能有不止一种定义 dp 数组含义的方法，不同的定义会有不同的解法。 读者见过的 KMP 算法应该是，一波诡异的操作处理 pat 后形成一个一维的数组 next，然后根据这个数组经过又一波复杂操作去匹配 txt。时间复杂度 O(N)，空间复杂度 O(M)。其实它这个 next 数组就相当于 dp 数组，其中元素的含义跟 pat 的前缀和后缀有关，判定规则比较复杂，不好理解。本文则用一个二维的 dp 数组（但空间复杂度还是 O(M)），重新定义其中元素的含义，使得代码长度大大减少，可解释性大大提高。 PS：本文的代码参考《算法4》，原代码使用的数组名称是 dfa（确定有限状态机），因为我们的公众号之前有一系列动态规划的文章，就不说这么高大上的名词了，我对书中代码进行了一点修改，并沿用 dp 数组的名称。 一、KMP 算法概述首先还是简单介绍一下 KMP 算法和暴力匹配算法的不同在哪里，难点在哪里，和动态规划有啥关系。 暴力的字符串匹配算法很容易写，看一下它的运行逻辑： // 暴力匹配（伪码） int search(String pat, String txt) { int M = pat.length; int N = txt.length; for (int i = 0; i &lt;= N - M; i++) { int j; for (j = 0; j &lt; M; j++) { if (pat[j] != txt[i+j]) break; } // pat 全都匹配了 if (j == M) return i; } // txt 中不存在 pat 子串 return -1; } 对于暴力算法，如果出现不匹配字符，同时回退 txt 和 pat 的指针，嵌套 for 循环，时间复杂度 $O(MN)$，空间复杂度$O(1)$。最主要的问题是，如果字符串中重复的字符比较多，该算法就显得很蠢。 比如 txt = “aaacaaab” pat = “aaab”： 很明显，pat 中根本没有字符 c，根本没必要回退指针 i，暴力解法明显多做了很多不必要的操作。 KMP 算法的不同之处在于，它会花费空间来记录一些信息，在上述情况中就会显得很聪明： 再比如类似的 txt = “aaaaaaab” pat = “aaab”，暴力解法还会和上面那个例子一样蠢蠢地回退指针 i，而 KMP 算法又会耍聪明： 因为 KMP 算法知道字符 b 之前的字符 a 都是匹配的，所以每次只需要比较字符 b 是否被匹配就行了。 KMP 算法永不回退 txt 的指针 i，不走回头路（不会重复扫描 txt），而是借助 dp 数组中储存的信息把 pat 移到正确的位置继续匹配，时间复杂度只需 O(N)，用空间换时间，所以我认为它是一种动态规划算法。 KMP 算法的难点在于，如何计算 dp 数组中的信息？如何根据这些信息正确地移动 pat 的指针？这个就需要确定有限状态自动机来辅助了，别怕这种高大上的文学词汇，其实和动态规划的 dp 数组如出一辙，等你学会了也可以拿这个词去吓唬别人。 还有一点需要明确的是：计算这个 dp 数组，只和 pat 串有关。意思是说，只要给我个 pat，我就能通过这个模式串计算出 dp 数组，然后你可以给我不同的 txt，我都不怕，利用这个 dp 数组我都能在 O(N) 时间完成字符串匹配。 具体来说，比如上文举的两个例子： txt1 = \"aaacaaab\" pat = \"aaab\" txt2 = \"aaaaaaab\" pat = \"aaab\" 我们的 txt 不同，但是 pat 是一样的，所以 KMP 算法使用的 dp 数组是同一个。 只不过对于 txt1 的下面这个即将出现的未匹配情况： dp 数组指示 pat 这样移动： PS：这个j 不要理解为索引，它的含义更准确地说应该是状态（state），所以它会出现这个奇怪的位置，后文会详述。 而对于 txt2 的下面这个即将出现的未匹配情况： dp 数组指示 pat 这样移动： 明白了 dp 数组只和 pat 有关，那么我们这样设计 KMP 算法就会比较漂亮： public class KMP { private int[][] dp; private String pat; public KMP(String pat) { this.pat = pat; // 通过 pat 构建 dp 数组 // 需要 O(M) 时间 } public int search(String txt) { // 借助 dp 数组去匹配 txt // 需要 O(N) 时间 } } 这样，当我们需要用同一 pat 去匹配不同 txt 时，就不需要浪费时间构造 dp 数组了： KMP kmp = new KMP(\"aaab\"); int pos1 = kmp.search(\"aaacaaab\"); //4 int pos2 = kmp.search(\"aaaaaaab\"); //4 二、状态机概述为什么说 KMP 算法和状态机有关呢？是这样的，我们可以认为 pat 的匹配就是状态的转移。比如当 pat = “ABABC”： 如上图，圆圈内的数字就是状态，状态 0 是起始状态，状态 5（pat.length）是终止状态。开始匹配时 pat 处于起始状态，一旦转移到终止状态，就说明在 txt 中找到了 pat。比如说当前处于状态 2，就说明字符 “AB” 被匹配： 另外，处于不同状态时，pat 状态转移的行为也不同。比如说假设现在匹配到了状态 4，如果遇到字符 A 就应该转移到状态 3，遇到字符 C 就应该转移到状态 5，如果遇到字符 B 就应该转移到状态 0： 具体什么意思呢，我们来一个个举例看看。用变量 j 表示指向当前状态的指针，当前 pat 匹配到了状态 4： 如果遇到了字符 “A”，根据箭头指示，转移到状态 3 是最聪明的： 如果遇到了字符 “B”，根据箭头指示，只能转移到状态 0（一夜回到解放前）： 如果遇到了字符 “C”，根据箭头指示，应该转移到终止状态 5，这也就意味着匹配完成： 当然了，还可能遇到其他字符，比如 Z，但是显然应该转移到起始状态 0，因为 pat 中根本都没有字符 Z： 这里为了清晰起见，我们画状态图时就把其他字符转移到状态 0 的箭头省略，只画 pat 中出现的字符的状态转移： KMP 算法最关键的步骤就是构造这个状态转移图。要确定状态转移的行为，得明确两个变量，一个是当前的匹配状态，另一个是遇到的字符；确定了这两个变量后，就可以知道这个情况下应该转移到哪个状态。 下面看一下 KMP 算法根据这幅状态转移图匹配字符串 txt 的过程： 请记住这个 GIF 的匹配过程，这就是 KMP 算法的核心逻辑！ 为了描述状态转移图，我们定义一个二维 dp 数组，它的含义如下： dp[j][c] = next 0 &lt;= j &lt; M，代表当前的状态 0 &lt;= c &lt; 256，代表遇到的字符（ASCII 码） 0 &lt;= next &lt;= M，代表下一个状态 dp[4]['A'] = 3 表示： 当前是状态 4，如果遇到字符 A， pat 应该转移到状态 3 dp[1]['B'] = 2 表示： 当前是状态 1，如果遇到字符 B， pat 应该转移到状态 2 根据我们这个 dp 数组的定义和刚才状态转移的过程，我们可以先写出 KMP 算法的 search 函数代码： public int search(String txt) { int M = pat.length(); int N = txt.length(); // pat 的初始态为 0 int j = 0; for (int i = 0; i &lt; N; i++) { // 当前是状态 j，遇到字符 txt[i]， // pat 应该转移到哪个状态？ j = dp[j][txt.charAt(i)]; // 如果达到终止态，返回匹配开头的索引 if (j == M) return i - M + 1; } // 没到达终止态，匹配失败 return -1; } 到这里，应该还是很好理解的吧，dp 数组就是我们刚才画的那幅状态转移图，如果不清楚的话回去看下 GIF 的算法演进过程。下面讲解：如何通过 pat 构建这个 dp 数组？ 三、构建状态转移图回想刚才说的：要确定状态转移的行为，必须明确两个变量，一个是当前的匹配状态，另一个是遇到的字符，而且我们已经根据这个逻辑确定了 dp 数组的含义，那么构造 dp 数组的框架就是这样： for 0 &lt;= j &lt; M: # 状态 for 0 &lt;= c &lt; 256: # 字符 dp[j][c] = next 这个 next 状态应该怎么求呢？显然，如果遇到的字符 c 和 pat[j] 匹配的话，状态就应该向前推进一个，也就是说 next = j + 1，我们不妨称这种情况为状态推进： 如果字符 c 和 pat[j] 不匹配的话，状态就要回退（或者原地不动），我们不妨称这种情况为状态重启： 那么，如何得知在哪个状态重启呢？解答这个问题之前，我们再定义一个名字：影子状态（我编的名字），用变量 X 表示。所谓影子状态，就是和当前状态具有相同的前缀。比如下面这种情况： 当前状态 j = 4，其影子状态为 X = 2，它们都有相同的前缀 “AB”。因为状态 X 和状态 j 存在相同的前缀，所以当状态 j 准备进行状态重启的时候（遇到的字符 c 和 pat[j] 不匹配），可以通过 X 的状态转移图来获得最近的重启位置。 比如说刚才的情况，如果状态 j 遇到一个字符 “A”，应该转移到哪里呢？首先只有遇到 “C” 才能推进状态，遇到 “A” 显然只能进行状态重启。状态 j 会把这个字符委托给状态 X 处理，也就是 dp[j]['A'] = dp[X]['A']： 为什么这样可以呢？因为：既然 j 这边已经确定字符 “A” 无法推进状态，只能回退，而且 KMP 就是要尽可能少的回退，以免多余的计算。那么 j 就可以去问问和自己具有相同前缀的 X，如果 X 遇见 “A” 可以进行「状态推进」，那就转移过去，因为这样回退最少。 当然，如果遇到的字符是 “B”，状态 X 也不能进行「状态推进」，只能回退，j 只要跟着 X 指引的方向回退就行了： 你也许会问，这个 X 怎么知道遇到字符 “B” 要回退到状态 0 呢？因为 X 永远跟在 j 的身后，状态 X 如何转移，在之前就已经算出来了。动态规划算法不就是利用过去的结果解决现在的问题吗？ 这样，我们就细化一下刚才的框架代码： int X # 影子状态 for 0 &lt;= j &lt; M: for 0 &lt;= c &lt; 256: if c == pat[j]: # 状态推进 dp[j][c] = j + 1 else: # 状态重启 # 委托 X 计算重启位置 dp[j][c] = dp[X][c] 四、代码实现如果之前的内容你都能理解，恭喜你，现在就剩下一个问题：影子状态 X 是如何得到的呢？下面先直接看完整代码吧。 public class KMP { private int[][] dp; private String pat; public KMP(String pat) { this.pat = pat; int M = pat.length(); // dp[状态][字符] = 下个状态 dp = new int[M][256]; // base case dp[0][pat.charAt(0)] = 1; // 影子状态 X 初始为 0 int X = 0; // 当前状态 j 从 1 开始 for (int j = 1; j &lt; M; j++) { for (int c = 0; c &lt; 256; c++) { if (pat.charAt(j) == c) dp[j][c] = j + 1; else dp[j][c] = dp[X][c]; } // 更新影子状态 X = dp[X][pat.charAt(j)]; } } public int search(String txt) {...} } 先解释一下这一行代码： // base case dp[0][pat.charAt(0)] = 1; 这行代码是 base case，只有遇到 pat[0] 这个字符才能使状态从 0 转移到 1，遇到其它字符的话还是停留在状态 0（Java 默认初始化数组全为 0）。 影子状态 X 是先初始化为 0，然后随着 j 的前进而不断更新的。下面看看到底应该如何更新影子状态 X： int X = 0; for (int j = 1; j &lt; M; j++) { ... // 更新影子状态 // 当前是状态 X，遇到字符 pat[j]， // pat 应该转移到哪个状态？ X = dp[X][pat.charAt(j)]; } 更新 X 其实和 search 函数中更新状态 j 的过程是非常相似的： int j = 0; for (int i = 0; i &lt; N; i++) { // 当前是状态 j，遇到字符 txt[i]， // pat 应该转移到哪个状态？ j = dp[j][txt.charAt(i)]; ... } 其中的原理非常微妙，注意代码中 for 循环的变量初始值，可以这样理解：后者是在 txt 中匹配 pat，前者是在 pat 中匹配 pat[1..end]，状态 X 总是落后状态 j 一个状态，与 j 具有最长的相同前缀。所以我把 X 比喻为影子状态，似乎也有一点贴切。 另外，构建 dp 数组是根据 base case dp[0][..] 向后推演。这就是我认为 KMP 算法就是一种动态规划算法的原因。 下面来看一下状态转移图的完整构造过程，你就能理解状态 X 作用之精妙了： 至此，KMP 算法的核心终于写完啦啦啦啦！看下 KMP 算法的完整代码吧： public class KMP { private int[][] dp; private String pat; public KMP(String pat) { this.pat = pat; int M = pat.length(); // dp[状态][字符] = 下个状态 dp = new int[M][256]; // base case dp[0][pat.charAt(0)] = 1; // 影子状态 X 初始为 0 int X = 0; // 构建状态转移图（稍改的更紧凑了） for (int j = 1; j &lt; M; j++) { for (int c = 0; c &lt; 256; c++) dp[j][c] = dp[X][c]; dp[j][pat.charAt(j)] = j + 1; // 更新影子状态 X = dp[X][pat.charAt(j)]; } } public int search(String txt) { int M = pat.length(); int N = txt.length(); // pat 的初始态为 0 int j = 0; for (int i = 0; i &lt; N; i++) { // 计算 pat 的下一个状态 j = dp[j][txt.charAt(i)]; // 到达终止态，返回结果 if (j == M) return i - M + 1; } // 没到达终止态，匹配失败 return -1; } } 经过之前的详细举例讲解，你应该可以理解这段代码的含义了，当然你也可以把 KMP 算法写成一个函数。核心代码也就是两个函数中 for 循环的部分，数一下有超过十行吗？ 五、最后总结传统的 KMP 算法是使用一个一维数组 next 记录前缀信息，而本文是使用一个二维数组 dp 以状态转移的角度解决字符匹配问题，但是空间复杂度仍然是 O(256M) = O(M)。 在 pat 匹配 txt 的过程中，只要明确了「当前处在哪个状态」和「遇到的字符是什么」这两个问题，就可以确定应该转移到哪个状态（推进或回退）。 对于一个模式串 pat，其总共就有 M 个状态，对于 ASCII 字符，总共不会超过 256 种。所以我们就构造一个数组 dp[M][256] 来包含所有情况，并且明确 dp 数组的含义： dp[j][c] = next 表示，当前是状态 j，遇到了字符 c，应该转移到状态 next。 明确了其含义，就可以很容易写出 search 函数的代码。 对于如何构建这个 dp 数组，需要一个辅助状态 X，它永远比当前状态 j 落后一个状态，拥有和 j 最长的相同前缀，我们给它起了个名字叫「影子状态」。 在构建当前状态 j 的转移方向时，只有字符 pat[j] 才能使状态推进（dp[j][pat[j]] = j+1）；而对于其他字符只能进行状态回退，应该去请教影子状态 X 应该回退到哪里（dp[j][other] = dp[X][other]，其中 other 是除了 pat[j] 之外所有字符）。 对于影子状态 X，我们把它初始化为 0，并且随着 j 的前进进行更新，更新的方式和 search 过程更新 j 的过程非常相似（X = dp[X][pat[j]]）。 KMP 算法也就是动态规划那点事，我们的公众号文章目录有一系列专门讲动态规划的，而且都是按照一套框架来的，无非就是描述问题逻辑，明确 dp 数组含义，定义 base case 这点破事。希望这篇文章能让大家对动态规划有更深的理解。 致力于把算法讲清楚！欢迎关注我的微信公众号 labuladong，查看更多通俗易懂的文章： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"获取音乐链接以及歌词","slug":"获取音乐链接以及歌词","date":"2020-07-16T03:57:00.000Z","updated":"2020-09-18T04:43:03.285Z","comments":true,"path":"2020/07/16/获取音乐链接以及歌词/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/16/%E8%8E%B7%E5%8F%96%E9%9F%B3%E4%B9%90%E9%93%BE%E6%8E%A5%E4%BB%A5%E5%8F%8A%E6%AD%8C%E8%AF%8D/","excerpt":"获取音乐链接以及歌词：https://music.liuzhijin.cn/","text":"获取音乐链接以及歌词：https://music.liuzhijin.cn/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"音乐解析","slug":"音乐解析","date":"2020-07-16T03:55:00.000Z","updated":"2020-07-22T10:21:04.301Z","comments":true,"path":"2020/07/16/音乐解析/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/16/%E9%9F%B3%E4%B9%90%E8%A7%A3%E6%9E%90/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"『MelodyHub』书写是对思维的缓存","slug":"博客同步站点","date":"2020-07-15T07:57:00.000Z","updated":"2020-09-24T08:55:08.045Z","comments":true,"path":"2020/07/15/博客同步站点/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/15/%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%AD%A5%E7%AB%99%E7%82%B9/","excerpt":"站点名称： MelodyHub 站长名称： MelodyJerry 头像链接： https://i.loli.net/2020/02/10/6yndjPI2rHL94vJ.png 博客地址： 博客园：https://www.cnblogs.com/melodyjerry/ Gitee：https://melodyjerry.gitee.io/ GitHub：https://melodyjerry.github.io/ CSDN：https://blog.csdn.net/weixin_43438052 标签： #Java #音乐 #后台(全栈) 博客内容会同步到所有站点（CSDN后续同步） 按访问速度：博客园 &gt; Gitee &gt; GitHub 按网页特效：Gitee &gt; 博客园 &gt; GitHub 国内用户推荐访问：博客园、Gitee 国外用户推荐访问：GitHub 来呀，干杯~~","text":"站点名称： MelodyHub 站长名称： MelodyJerry 头像链接： https://i.loli.net/2020/02/10/6yndjPI2rHL94vJ.png 博客地址： 博客园：https://www.cnblogs.com/melodyjerry/ Gitee：https://melodyjerry.gitee.io/ GitHub：https://melodyjerry.github.io/ CSDN：https://blog.csdn.net/weixin_43438052 标签： #Java #音乐 #后台(全栈) 博客内容会同步到所有站点（CSDN后续同步） 按访问速度：博客园 &gt; Gitee &gt; GitHub 按网页特效：Gitee &gt; 博客园 &gt; GitHub 国内用户推荐访问：博客园、Gitee 国外用户推荐访问：GitHub 来呀，干杯~~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"JUnit-Java单元测试框架","slug":"JUnit-Java单元测试框架","date":"2020-07-15T05:57:00.000Z","updated":"2020-07-16T06:58:48.358Z","comments":true,"path":"2020/07/15/JUnit-Java单元测试框架/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/15/JUnit-Java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/","excerpt":"JUnit概述官网：https://junit.org/junit5/ JUnit是一个Java语言的单元测试框架。 它由Kent Beck和Erich Gamma建立，逐渐成为源于Kent Beck的sUnit的xUnit家族中为最成功的一个。 JUnit有它自己的JUnit扩展生态圈。 多数Java的开发环境都已经集成了JUnit作为单元测试的工具。","text":"JUnit概述官网：https://junit.org/junit5/ JUnit是一个Java语言的单元测试框架。 它由Kent Beck和Erich Gamma建立，逐渐成为源于Kent Beck的sUnit的xUnit家族中为最成功的一个。 JUnit有它自己的JUnit扩展生态圈。 多数Java的开发环境都已经集成了JUnit作为单元测试的工具。 教程视频 jUnit 教程 编写Mapper子项目的junit测试程序 Junit的基本使用（详解） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"SSM整合及Maven配置文件","slug":"SSM整合及Maven配置文件","date":"2020-07-15T04:57:00.000Z","updated":"2020-07-16T06:58:48.471Z","comments":true,"path":"2020/07/15/SSM整合及Maven配置文件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/15/SSM%E6%95%B4%E5%90%88%E5%8F%8AMaven%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"下载 🔗 SSM整合及Maven配置文件.zip ├── maven_ssm │ ├── pom.xml │ ├── pom_test.xml │ └── ssm │ ├── applicationContext_mapper.xml │ ├── applicationContext_service.xml │ ├── applicationContext_transaction.xml │ ├── db.properties │ ├── ItemMapper.xml │ ├── springmvc.xml │ └── web.xml ├── pom.xml └── web.xml","text":"下载 🔗 SSM整合及Maven配置文件.zip ├── maven_ssm │ ├── pom.xml │ ├── pom_test.xml │ └── ssm │ ├── applicationContext_mapper.xml │ ├── applicationContext_service.xml │ ├── applicationContext_transaction.xml │ ├── db.properties │ ├── ItemMapper.xml │ ├── springmvc.xml │ └── web.xml ├── pom.xml └── web.xml 如何使用 ？ pom.xml&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!-- maven版本 --&gt; &lt;groupId&gt;com.sikiedu&lt;/groupId&gt;&lt;!-- 域名反写 + 项目名 --&gt; &lt;artifactId&gt;HelloMaven&lt;/artifactId&gt;&lt;!-- 项目名 子项目名 模块名 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;!-- 版本号-类型 --&gt; &lt;packaging&gt;war&lt;/packaging&gt;&lt;!-- 打包类型 --&gt; &lt;name&gt;mavenProject&lt;/name&gt;&lt;!-- 当前项目名 --&gt; &lt;description&gt;我的第一个maven工程&lt;/description&gt;&lt;!-- 项目描述 --&gt; &lt;dependencies&gt;&lt;!-- 依赖标签 配置项目中依赖的jar包坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt;&lt;!-- 插件列表 --&gt; &lt;plugin&gt;&lt;!-- 通过坐标获取插件 --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; SSM整合pom.xml&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.sikiedu&lt;/groupId&gt; &lt;artifactId&gt;MavenSSM2&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;!-- lib version --&gt; &lt;spring.version&gt;5.0.8.RELEASE&lt;/spring.version&gt; &lt;mybais.version&gt;3.4.6&lt;/mybais.version&gt; &lt;mybatis-spring.version&gt;1.3.2&lt;/mybatis-spring.version&gt; &lt;mysql-connector.version&gt;5.1.46&lt;/mysql-connector.version&gt; &lt;ojdbc7.version&gt;12.1.0.2.0&lt;/ojdbc7.version&gt; &lt;druid.version&gt;1.0.16&lt;/druid.version&gt; &lt;aopalliance.version&gt;1.0&lt;/aopalliance.version&gt; &lt;aspectj.weaver.version&gt;1.6.4.RELEASE&lt;/aspectj.weaver.version&gt; &lt;commons.logging.version&gt;1.1.1&lt;/commons.logging.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;log4j.version&gt;1.2.16&lt;/log4j.version&gt; &lt;slf4j-api.version&gt;1.6.1&lt;/slf4j-api.version&gt; &lt;slf4j-nop.version&gt;1.6.4&lt;/slf4j-nop.version&gt; &lt;fileupload.version&gt;1.3.1&lt;/fileupload.version&gt; &lt;jackson.version&gt;2.9.6&lt;/jackson.version&gt; &lt;junit.version&gt;4.9&lt;/junit.version&gt; &lt;servlet-api.version&gt;8.5.32&lt;/servlet-api.version&gt; &lt;jsp-api.version&gt;8.5.32&lt;/jsp-api.version&gt; &lt;!-- plugins version --&gt; &lt;maven-compiler-plugin.version&gt;3.8.0&lt;/maven-compiler-plugin.version&gt; &lt;tomcat7-maven-plugin.version&gt;2.2&lt;/tomcat7-maven-plugin.version&gt; &lt;/properties&gt; &lt;!-- 锁定版本， --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring end --&gt; &lt;!-- mybais --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybais.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis - spring 整合包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;${mybatis-spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- json end --&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring end --&gt; &lt;!-- mybais --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis - spring 整合包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql-connector.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.easyproject&lt;/groupId&gt; &lt;artifactId&gt;ojdbc7&lt;/artifactId&gt; &lt;version&gt;${ojdbc7.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql end --&gt; &lt;!-- 阿里巴巴的数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;${druid.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop --&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;${aopalliance.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;com.springsource.org.aspectj.weaver&lt;/artifactId&gt; &lt;version&gt;${aspectj.weaver.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop end --&gt; &lt;!-- logging --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;com.springsource.org.apache.commons.logging&lt;/artifactId&gt; &lt;version&gt;${commons.logging.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jsp标准标签库 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;${jstl.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j-api.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;${slf4j-nop.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!--文件上传--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;${fileupload.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- json end --&gt; &lt;!-- junit单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- servlet-api 8.5.32 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;/artifactId&gt; &lt;version&gt;${servlet-api.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp-api 8.5.32 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jsp-api&lt;/artifactId&gt; &lt;version&gt;${jsp-api.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-compiler-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${tomcat7-maven-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt; &lt;username&gt;joey&lt;/username&gt; &lt;password&gt;123123&lt;/password&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!-- 配置文件放行 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;!-- 放行main/resources下的配置文件 如果不放行spring mybatis等配置文件不会被打到包里从而导致错误 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;/project&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"Maven","slug":"Maven","permalink":"https://melodyjerry.github.io/blog/tags/Maven/"}]},{"title":"Spring事务失效的 8 大原因","slug":"Spring事务失效的-8-大原因","date":"2020-07-11T16:00:00.000Z","updated":"2020-09-18T04:43:02.997Z","comments":true,"path":"2020/07/12/Spring事务失效的-8-大原因/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/12/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84-8-%E5%A4%A7%E5%8E%9F%E5%9B%A0/","excerpt":"","text":"数据库引擎不支持事务这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB。根据 MySQL 的官方文档： https://dev.mysql.com/doc/refman/5.5/en/storage-engine-setting.html 从 MySQL 5.5.5 开始的默认存储引擎是：InnoDB，之前默认的都是：MyISAM，所以这点要值得注意，底层引擎不支持事务再怎么搞都是白搭。 没有被 Spring 管理如下面例子所示： // @Service public class OrderServiceImpl implements OrderService { @Transactional public void updateOrder(Order order) { // update order } } 如果此时把 @Service 注解注释掉，这个类就不会被加载成一个 Bean，那这个类就不会被 Spring 管理了，事务自然就失效了。 方法不是 public 的以下来自 Spring 官方文档： When using proxies, you should apply the @Transactional annotation only to methods with public visibility. If you do annotate protected, private or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings. Consider the use of AspectJ (see below) if you need to annotate non-public methods. 大概意思就是 @Transactional 只能用于 public 的方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启 AspectJ 代理模式。 自身调用问题来看两个示例： @Service public class OrderServiceImpl implements OrderService { public void update(Order order) { updateOrder(order); } @Transactional public void updateOrder(Order order) { // update order } } update方法上面没有加 @Transactional 注解，调用有@Transactional 注解的 updateOrder 方法，updateOrder 方法上的事务管用吗？ 再来看下面这个例子： @Service public class OrderServiceImpl implements OrderService { @Transactional public void update(Order order) { updateOrder(order); } @Transactional(propagation = Propagation.REQUIRES_NEW) public void updateOrder(Order order) { // update order } } 这次在 update 方法上加了 @Transactional，updateOrder 加了 REQUIRES_NEW 新开启一个事务，那么新开的事务管用么？ 这两个例子的答案是：不管用！ 因为它们发生了自身调用，就调该类自己的方法，而没有经过 Spring 的代理类，默认只有在外部调用事务才会生效，这也是老生常谈的经典问题了。 这个的解决方案之一就是在的类中注入自己，用注入的对象再调用另外一个方法，这个不太优雅，另外一个可行的方案可以参考《Spring 如何在一个事务中开启另一个事务？》这篇文章。 数据源没有配置事务管理器@Bean public PlatformTransactionManager transactionManager(DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } 如上面所示，当前数据源若没有配置事务管理器，那也是白搭！ 不支持事务来看下面这个例子： @Service public class OrderServiceImpl implements OrderService { @Transactional public void update(Order order) { updateOrder(order); } @Transactional(propagation = Propagation.NOT_SUPPORTED) public void updateOrder(Order order) { // update order } } Propagation.NOT_SUPPORTED： 表示不以事务运行，当前若存在事务则挂起，详细的可以参考《事务隔离级别和传播机制》这篇文章。 都主动不支持以事务方式运行了，那事务生效也是白搭！ 异常被吃了这个也是出现比较多的场景： // @Service public class OrderServiceImpl implements OrderService { @Transactional public void updateOrder(Order order) { try { // update order } catch { } } } 把异常吃了，然后又不抛出来，事务怎么回滚吧！ 异常类型错误上面的例子再抛出一个异常： // @Service public class OrderServiceImpl implements OrderService { @Transactional public void updateOrder(Order order) { try { // update order } catch { throw new Exception(\"更新错误\"); } } } 这样事务也是不生效的，因为默认回滚的是：RuntimeException，如果你想触发其他异常的回滚，需要在注解上配置一下，如： @Transactional(rollbackFor = Exception.class) 这个配置仅限于 Throwable 异常类及其子类。 总结本文总结了八种事务失效的场景，其实发生最多就是自身调用、异常被吃、异常抛出类型不对这三个了。 也像文章开头说的那样，本文不一定总结得全，只是总结常见的事务失效的场景 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"Maven项目管理","slug":"Maven项目管理","date":"2020-07-11T11:55:00.000Z","updated":"2020-08-27T05:55:24.127Z","comments":true,"path":"2020/07/11/Maven项目管理/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/11/Maven%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/","excerpt":"","text":"左者使用SSM框架，需要导入jar包； 右者使用Maven，不需要导入jar包。 Maven是什么？ Maven是Apache下的项目管理工具，它由纯Java语言开发，可以帮助我们更方便的管理和构建Java项目。 为什么要使用Maven？1、 jar包管理： a) 从Maven中央仓库获取标准的规范的jar包以及相关依赖的jar包，避免自己下载到错误的jar包； b) 本地仓库统一管理jar包，使jar包与项目分离，减轻项目体积。 2、 maven是跨平台的可以在window、linux上使用。 3、 清晰的项目结构； 4、 多工程开发，将模块拆分成若干工程，利于团队协作开发。 5、 一键构建项目：使用命令可以对项目进行一键构建，操作系统中无需安装eclipse和tomcat。 下载、安装、配置环境变量Mavena) http://maven.apache.org/download.cgi b) 安装JDK 1.8； c) 配置环境变量； i. win + r 打开运行窗口 或者 进入cmd命令窗口； ii. 输入sysdm.cpl打开系统属性 -&gt; 高级 -&gt; 环境变量； iii. 新建系统变量，变量名：MAVEN_HOME，变量值：Maven安装路径； iv. 在Path下追加一条属性指向Maven的bin目录 %MAVEN_HOME%/bin Maven的优点a) jar包管理：依赖管理 i. 从Maven中央仓库获取标准的规范的jar包以及相关依赖的jar包，避免自己下载到错误的jar包； ii. 本地仓库统一管理jar包，使jar包与项目分离，减轻项目体积。 iii. Maven项目通过坐标的方式从本地仓库获取jar包； 坐标 本地仓库 由公司/组织名(groupId) + 项目名/子项目名(artifactId) + 版本号(version)组成 存放很多jar包，供Maven项目使用 Maven通过建立本地仓库索引，可以快速的找到符合要求的jar包，从而解决效率问题； 多个Maven项目都可以从本地仓库获取jar包； 设置本地仓库：maven根目录 -&gt; conf -&gt; settings.xml，将localRepository标签中的路径替换成自己本地仓库的路径； iv. Maven三种仓库概念：本地仓库、远程仓库、中央仓库 中央仓库-官方：https://mvnrepository.com/ 中央仓库-阿里云：https://maven.aliyun.com/mvn/search v. 设置阿里云Maven仓库镜像： 在settings.xml文件中的mirrors下添加mirror标签； &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; b) maven由纯Java语言开发，是跨平台的可以在window、linux、mac上使用。 c) 清晰的项目结构； d) 使用Maven将大型项目按照模块拆分成若干工程，不同的团队维护各自的工程，可大大的提升开发效率； i. 大型商城项目按业务分成商品管理、用户管理、订单管理等等模块。 ii. 中小型项目按照传统项目分为Web、Service、Dao层，依照员工自身的业务能力分配工作。 e) 一键构建项目：使用命令可以对项目进行一键构建，操作系统中无需安装eclipse和tomcat。 Maven常用命令 clean： 清理，编译后的目录； compile： 编译，只编译main目录，不编译test中的代码； test-compile：编译test目录中的代码； test： 运行test里边的代码； package： 打包 i. java项目-&gt;打成jar包； ii. web项目-&gt;打成war包； install：发布项目到本地仓库，用在打jar包上，打成jar包可以被其他项目使用； tomcat:run：一键构建项目； Maven命令的生命周期 不同的生命周期可以一起执行，例如：先clean 再compile 命令 生命周期 Clean clean Default compile、test-compile、test、package、install Site site命令，生成项目描述文档静态页 Maven命令的执行顺序 在相同生命周期中的命令才会受执行顺序的影响； Default生命周期中的命令执行顺序： compile &lt;- test-compile &lt;- test &lt;- package &lt;- install； Maven入门程序Ø 入门程序： 创建Maven项目； 在src -&gt; main -&gt; webapp下创建WEB-INF目录，并在目录下创建web.xml； 修改Maven默认编译级别： a) 全局编译级别 -&gt; 修改settings.xml b) 项目级别修改 -&gt; 项目对应的pom.xml 在Java Resourcese -&gt; src/main/java下写代码，创建包和Servlet； 添加servlet-api： 在servlet-api中添加scope标签，值为：proviede； a) 如果不加此标签有很大几率报错，因为tomcat中也有servlet-api的包导致冲突； 运行：发生错误，原因是maven默认使用tomcat6.xx，不支持@WebServle注解； a) 解决方案1：需要去web.xml中配置Servlet; b) 解决方案2：配置高版本tomcat插件； 最后测试，启动服务，在地址栏输入请求，显示结果； Ø 使用tomcat7插件运行项目 Ø Scope依赖作用域也可称作依赖范围：maven中的依赖，会根据程序所处的阶段和场景发生变化，所以maven用scope属性来做限制； a) compile（默认值）：在编译、运行、测试、打包都有效； b) provided：编译、测试时有效，运行、打包无效； c) test：仅在测试时有效； d) runtime：测试、运行、打包时有效； e) system：不推荐使用，使用system作用域不会去本地仓库寻找依赖，要指定本地路径； Maven热部署Maven 3.5.4 + tomcat 8.5.32 热部署： 热部署：在tomcat运行时将项目部署上去； 开启tomcat热部署： a) 修改tomcat -&gt; conf-&gt; tomcat-users.xml 配置文件； b) 在tomcat-users标签中加入以下代码： &lt;role rolename=\"manager-gui\"/&gt; &lt;role rolename=\"manager-script\"/&gt; &lt;user username=\"joey\" password=\"123123\" roles=\"manager-gui, manager-script\"/&gt; c) 启动tomcat； d) 修改项目中pom.xml，在tomcat7的插件上添加以下代码： &lt;configuration&gt; &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt; &lt;username&gt;joey&lt;/username&gt; &lt;password&gt;123123&lt;/password&gt; &lt;/configuration&gt; e) 右键项目-&gt; run as -&gt; maven build… 在goals中使用tomcat7:deploy或tomcat7:redeploy来进行热部署； i. tomcat7:deploy，第一次部署时使用。 ii. tomcat7:redeploy，非第一次部署时使用。 f) 部署完毕，打开浏览器测试； Maven整合SSM框架 Maven+SSM框架整合； a) 加入SSM框架所需的依赖； b) 配置插件； c) 导入SSM框架所需配置文件, 配置文件下载：https://www.cnblogs.com/melodyjerry/p/13304361.html； d) 配置Maven Resources资源放行： i. 因为Maven会把src/main/java下的*.java文件文件编译放到target/classes目录目录中，但这目录中的其他文件会被忽略； ii. Mybatis Mapper映射文件也要放在src/main/java下，所以不能忽略； iii. 因此我们需要对src/main/java下的配置文件进行过滤，不能被忽略； iv. 利用Maven中的Resources标签可以进行配置； 测试； a) 新建名为User的bean对象，有username，password俩字段； b) 新建login.jsp，可以输入用户名和密码，通过表单提交到后台； c) 后台接受用户名和密码，跳转页面，并显示； 读取数据库显示游戏列表； a) 导入item_info表； b) 在login.jsp中增加button，点击后跳转页面，显示列表； Maven模块化开发 Ø 需求：将Maven-SSM项目以层为单位拆分，按模块开发； 创建父项目，在父项目中加入依赖； 创建mapper层子项目继承父项目； 子项目可以继承父项目的依赖； 利用junit测试mapper模块项目； Maven的依赖传递，与依赖版本管理； a) 依赖传递：添加依赖的jar包如果还依赖其他jar包，则在添加时会一起引入； b) 依赖冲突：Base-project由3个子项目组成，A-project依赖Tools.jar 1.0版本，C-project依赖Tools.jar 2.0版本，根据依赖传递机制，Base-project将同时依赖Tools.jar两个版本，但这造成了冲突。根据路径最近获胜策略，该项目最终依赖Tools.jar 1.0，导致C-project无法调用getAll方法从而报错，因此我们要手动选择一个适合项目的版本。 c) 解决依赖冲突的办法： i. 直接声明：直接添加Tools.jar 2.0依赖； ii. 排除：使用&lt;dependency&gt;标签中的&lt;exclusions&gt;标签排除A-project中的Tools.jar 1.0依赖； iii. 依赖管理，版本锁定：&lt;dependencyManagement&gt; 1. &lt;dependencyManagement&gt;是依赖管理，该标签下添加的&lt;dependencies&gt;可以声明依赖，但是不会引入jar包； 2. 只有声明在&lt;project&gt;标签下&lt;dependencies&gt;中的依赖才会被引用到项目中； 3. 在&lt;dependencyManagement&gt;下添加jar包坐标后，&lt;project&gt;标签下&lt;dependencies&gt;标签的版本号可以忽略不写； 4. &lt; properties&gt;标签可以自定义版本号，用el表达式赋值给&lt;version&gt;标签； 5. 统一管理jar包版本，修改方便； 创建scervice模块项目，利用junit测试service模块项目； 依赖作用域对依赖传递的影响； 创建controller模块项目，运行程序； Maven远程仓库Nexus（私服）Ø Nexus获取与配置： 1、 下载Nexus 点击我下载 2、 Nexus安装，解压缩到本地即可； 3、 Nexus安装目录下nexus-3.14.0-04/etc/nexus-default.properties配置表中可以修改以下属性： ​ a) application-host : Nexus服务监听的主机； ​ b) application-port: Nexus服务监听的端口； ​ c) nexus-context-path : Nexus服务的上下文路径； 4、 Nexus服务配置和启动： ​ a) 以管理员身份运行cmd -&gt; 进入到nexus安装目录../nexus-3.14.0-04/bin目录下； ​ b) 在cmd中运行 nexus.exe/install 可以安装nexus服务； ​ c) 在cmd中运行 nexus.exe/start 可以启动nexus服务； ​ d) 在cmd中运行 nexus.exe/stop 可以停止nexus服务； 5、 登录Nexus： ​ a) 启动服务后，根据nexus-default.properties的配置进行登录，如果没有修改，可以在浏览器中输入http://localhost:8081来登录； ​ b) 默认用户名是admin，密码是admin123； 6、 仓库类型：nexus有多种仓库类型： ​ Ø Nexus使用： 需求：将项目中的mapper.jar包提交到远程仓库中， 使service项目从远程仓库获取； ✧☼ 上传jar包到远程仓库； 1、 在Maven的 setting.xml中配置nexus访问权限； 2、 在项目的pom.xml中配置nexus仓库位置； 3、 以上2个配置标签中的id要一致； 4、 使用deploy命令将项目打包，发布到nexus中； 5、 检查仓库中是否有上传好的jar包； ✧☼ 从远程仓库下载jar包： 1、 使用profiles标签在Maven的setting.xml中配置仓库位置； 2、 激活profiles标签，使它发生作用； 3、 如果之前打包了，删除本地仓库下的mapper.jar； 4、 关闭mapper子项目，让service子项目依赖mapper.jar包； 5、 更新项目，从远程仓库中获取mapper.jar； ✧☼ 使用自定义用户和自定义仓库进行上传和下载jar包： 1、 建议先将管理员密码修改； 2、 在Roles中可以增加用户权限组，里边可以自定义用户权限； 3、 在Users中可以增加用户，分配设置好的权限； 4、 在Repositories中新建仓库； ​ a) name：仓库名称； ​ b) version pollcy：版本策略； ​ i. Release：发行版； ​ ii. Snapshot：快照版； ​ iii. Mixed：混合模式； ​ c) Layout pollcy：布局策略； ​ i. Strict：严格； ​ ii. Permissive：宽松； ​ d) Deployment pollcy：部署策略； ​ i. Allow redeploy：允许重新部署； ​ ii. Disable redeploy：禁止重新部署； ​ iii. Read-only：只读； 5、 修改配置，将jar包上传到自定义仓库，然后从自定义仓库下载jar包； 资源下载：http://www.sikiedu.com/course/284/material/14783/download document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"Maven","slug":"Maven","permalink":"https://melodyjerry.github.io/blog/tags/Maven/"}]},{"title":"Mybatis-Java持久层框架","slug":"Mybatis-Java持久层框架","date":"2020-07-11T07:55:00.000Z","updated":"2020-09-18T04:43:02.984Z","comments":true,"path":"2020/07/11/Mybatis-Java持久层框架/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/11/Mybatis-Java%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/","excerpt":"概述 mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 采用ORM(Object Relational Mapping)思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。","text":"概述 mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 采用ORM(Object Relational Mapping)思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。 持久化？持久层？持久化 持久化是将程序数据在持久状态和瞬时状态间转换的机制。 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 闪存：断电即失 JDBC就是一种持久化机制。文件IO也是一种持久化机制，但IO很浪费资源。 在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。 为什么需要持久化服务呢？那是由于内存本身的缺陷引起的 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。 持久层什么是持久层？ 完成持久化工作的代码块 什么是层？联系dao层 【DAO (Data Access Object) 数据访问对象】 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。 不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现. 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】 为什么需要Mybatis Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 . 传统的jdbc操作 , 有很多重复代码块。比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 . MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping对象关系映射) 所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！技术没有高低之分，只有使用这个技术的人有高低之别 MyBatis的优点 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供xml标签，支持编写动态sql。 ……. 最重要的一点，使用的人多！公司需要！ 什么是 MyBatis？ MyBatis 官网：https://mybatis.org/mybatis-3/zh/index.html MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 MyBatis 是一款优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。 MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。 2013年11月迁移到Github . Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html GitHub : https://github.com/mybatis/mybatis-3 特点 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql。 动态SQL MyBatis 最强大的特性之一就是它的动态语句功能。如果您以前有使用JDBC或者类似框架的经历，您就会明白把SQL语句条件连接在一起是多么的痛苦，要确保不能忘记空格或者不要在columns列后面省略一个逗号等。动态语句能够完全解决掉这些痛苦。 尽管与动态SQL一起工作不是在开一个party，但是MyBatis确实能通过在任何映射SQL语句中使用强大的动态SQL来改进这些状况。动态SQL元素对于任何使用过JSTL或者类似于XML之类的文本处理器的人来说，都是非常熟悉的。在上一版本中，需要了解和学习非常多的元素，但在MyBatis 3 中有了许多的改进，现在只剩下差不多二分之一的元素。MyBatis使用了基于强大的OGNL表达式来消除了大部分元素。 功能架构 我们把Mybatis的功能架构分为三层： API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。 数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。 基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑 文档文档入口：https://mybatis.org/mybatis-3/zh/getting-started.html 参考文档 简介 入门 XML 配置 XML 映射文件 动态 SQL Java API SQL 语句构建器 项目文档 项目信息 项目报表 MyBatis 入门程序思路流程：搭建环境–&gt;导入Mybatis—&gt;编写代码—&gt;测试 第一个MyBatis程序：https://www.cnblogs.com/melodyjerry/p/13307057.html 部分文字及图片来自百度百科 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"Mybatis框架概述","slug":"Mybatis框架概述","date":"2020-07-11T07:55:00.000Z","updated":"2020-07-16T06:58:48.477Z","comments":true,"path":"2020/07/11/Mybatis框架概述/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/11/Mybatis%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/","excerpt":"mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 采用ORM(Object Relational Mapping)思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。","text":"mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 采用ORM(Object Relational Mapping)思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"博客添加图片查看器","slug":"博客添加图片查看器","date":"2020-07-11T06:35:00.000Z","updated":"2020-07-16T06:58:48.486Z","comments":true,"path":"2020/07/11/博客添加图片查看器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/11/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8/","excerpt":"在阅读博文时，对图片的放大查看是一种普遍的需求，而fancybox就是这样一种插件，配置方法十分简单。","text":"在阅读博文时，对图片的放大查看是一种普遍的需求，而fancybox就是这样一种插件，配置方法十分简单。 引入js和css页脚插入代码 &lt;script type=\"text/javascript\" src=\"https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.css\"&gt; 指定fancybox作用的区域在页脚插入这样一段代码 &lt;script&gt; $(\".forFlow img\").each(function () { var element = document.createElement(\"a\"); $(element).attr(\"data-fancybox\", \"gallery\"); $(element).attr(\"href\", $(this).attr(\"src\")); $(this).wrap(element); }); &lt;/script&gt; 上述代码将指定区域内的图片添加了父元素，从而使得当点击图片时，触发fancybox查看器。 样式微调fancybox在手机端默认最大图片宽度为300px,没有居中，这里在CSS中添加一段代码 .fancybox-image{ max-width:100%!important; margin:0 auto; } 效果预览非常不错的查看器，支持图片队列，支持放大缩小！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"What？框架？","slug":"What？框架？","date":"2020-07-11T04:55:00.000Z","updated":"2020-07-16T06:58:48.482Z","comments":true,"path":"2020/07/11/What？框架？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/11/What%EF%BC%9F%E6%A1%86%E6%9E%B6%EF%BC%9F/","excerpt":"什么是框架 框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。 前者是从应用方面而后者是从目的方面给出的定义。 ​ 简而言之，框架其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。 ​ 它是我门软件开发种的一套解决方案，不同框架解决不同问题。","text":"什么是框架 框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。 前者是从应用方面而后者是从目的方面给出的定义。 ​ 简而言之，框架其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。 ​ 它是我门软件开发种的一套解决方案，不同框架解决不同问题。 框架要解决的问题框架要解决的最重要的一个问题是技术整合的问题。 在J2EE的框架中，有着各种各样的技术，不同的软件企业需要从J2EE中选择不同的技术，这就使得软件企业最终的应用依赖于这些技术，技术自身的复杂性和技术的风险性将会直接对应用造成冲击。 而应用是软件企业的核心，是竞争力的关键所在，因此应该将应用自身的设计和具体的实现技术解耦。 这样，软件企业的研发将集中在应用的设计上，而不是具体的技术实现，技术实现是应用的底层支撑，它不应该直接对应用产生影响。 框架一般处在低层应用平台（如J2EE）和高层业务逻辑之间的中间层。 软件开发的分层重要性框架的重要性在于它实现了部分功能，并且能够很好的将低层应用平台和高层业务逻辑进行了缓和。 为了实现软件工程中的“高内聚、低耦合”。 把问题划分开来各个解决，易于控制，易于延展，易于分配资源。 我们常见的MVC软件设计思想就是很好的分层思想。 👉关于MVC：开发模式 分层开发下的常见框架常见的JavaEE开发框架1.解决数据的持久化问题的框架 作为持久层的框架，还有一个封装程度更高的框架就是Hibernate，但这个框架因为各种原因目前在国内的流行程度下降太多，现在公司开发也越来越少使用。 目前使用Spring Data来实现数据持久化也是一种趋势。 2.解决Web层问题的MVC框架 3.解决技术整合问题的框架 三层架构 表示层 用于展示数据 业务层 处理业务需求 持久层 和数据库交互 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"Web","slug":"Web","permalink":"https://melodyjerry.github.io/blog/tags/Web/"}]},{"title":"博客建筑常用的JS特效","slug":"博客建筑常用的JS特效","date":"2020-07-11T04:55:00.000Z","updated":"2020-07-16T06:58:48.494Z","comments":true,"path":"2020/07/11/博客建筑常用的JS特效/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/11/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AD%91%E5%B8%B8%E7%94%A8%E7%9A%84JS%E7%89%B9%E6%95%88/","excerpt":"随机图片API https://api.mz-moe.cn/img.php https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture","text":"随机图片API https://api.mz-moe.cn/img.php https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture &lt;!--动态线条背景--&gt; &lt;script type=\"text/javascript\" color=\"255,0,0\" opacity='1' zIndex=\"-2\" count=\"100\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt; &lt;/script&gt; &lt;!-- 天气挂件 --&gt; &lt;!-- &lt;div id=\"tp-weather-widget\"&gt;&lt;/div&gt; &lt;script&gt; (function(a,h,g,f,e,d,c,b){b=function(){d=h.createElement(g);c=h.getElementsByTagName(g)[0];d.src=e;d.charset=\"utf-8\";d.async=1;c.parentNode.insertBefore(d,c)};a[\"SeniverseWeatherWidgetObject\"]=f;a[f]||(a[f]=function(){(a[f].q=a[f].q||[]).push(arguments)});a[f].l=+new Date();if(a.attachEvent){a.attachEvent(\"onload\",b)}else{a.addEventListener(\"load\",b,false)}}(window,document,\"script\",\"SeniverseWeatherWidget\",\"//cdn.sencdn.com/widget2/static/js/bundle.js?t=\"+parseInt((new Date().getTime() / 100000000).toString(),10))); window.SeniverseWeatherWidget('show', { flavor: \"bubble\", location: \"WS0E9D8WN298\", geolocation: true, language: \"zh-Hans\", unit: \"c\", theme: \"auto\", token: \"5fd5b254-57fe-4f8a-8a13-f92485efeb0b\", hover: \"enabled\", container: \"tp-weather-widget\" }) &lt;/script&gt;--&gt; &lt;div id=\"tp-weather-widget\"&gt;&lt;/div&gt; &lt;script&gt; (function(a,h,g,f,e,d,c,b){b=function(){d=h.createElement(g);c=h.getElementsByTagName(g)[0];d.src=e;d.charset=\"utf-8\";d.async=1;c.parentNode.insertBefore(d,c)};a[\"SeniverseWeatherWidgetObject\"]=f;a[f]||(a[f]=function(){(a[f].q=a[f].q||[]).push(arguments)});a[f].l=+new Date();if(a.attachEvent){a.attachEvent(\"onload\",b)}else{a.addEventListener(\"load\",b,false)}}(window,document,\"script\",\"SeniverseWeatherWidget\",\"//cdn.sencdn.com/widget2/static/js/bundle.js?t=\"+parseInt((new Date().getTime() / 100000000).toString(),10))); window.SeniverseWeatherWidget('show', { flavor: \"bubble\", location: \"WS0E9D8WN298\", geolocation: true, language: \"zh-Hans\", unit: \"c\", theme: \"auto\", token: \"5fd5b254-57fe-4f8a-8a13-f92485efeb0b\", hover: \"disabled\", container: \"tp-weather-widget\" }) &lt;/script&gt; &lt;!--浏览器搞笑标题--&gt; &lt;script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@3.0.6/js/FunnyTitle.js\"&gt;&lt;/script&gt; &lt;!--图片放缩-fancybox插件--&gt; &lt;script src=\"https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js\"&gt;&lt;/script&gt; &lt;!--放大图片--&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"https://blog-static.cnblogs.com/files/zouwangblog/zoom.css\"&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/1.8.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/bootstrap/3.2.0/js/transition.js\"&gt;&lt;/script&gt; &lt;script src=\"https://blog-static.cnblogs.com/files/zouwangblog/zoom.js\"&gt;&lt;/script&gt; &lt;script type='text/javascript'&gt;$('#cnblogs_post_body img').attr('data-action', 'zoom');&lt;/script&gt; &lt;!--放大图片end--&gt; &lt;!--樱花瓣飘落--&gt; &lt;script src=\"https://cdn.jsdelivr.net/gh/TRHX/CDN-for-love109.cn@2.0.6/js/sakura.js\"&gt;&lt;/script&gt; &lt;!--速度优化脚本--&gt; &lt;script src=\"https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.6/js/instantclick-1.2.2.js\" type=\"module\"&gt;&lt;/script&gt; &lt;!--热门标签，旋转，来自https://arlxn.xyz/--&gt; &lt;!--tagcloud.ejs--&gt; &lt;script src=\"https://createdestruction.github.io/js/tagcanvas.js\"&gt;&lt;/script&gt; &lt;script src=\"https://createdestruction.github.io/js/tagcloud.js\"&gt;&lt;/script&gt; &lt;!--宅音乐播放器 https://player.ilt.me/admin--&gt; &lt;script id=\"ilt\" src=\"https://player.ilt.me/player/js/player.js\" key=\"992f0d81b6b74b93b6bbdb56f57a6c58\"&gt;&lt;/script&gt; &lt;!--闲聊么http://www.xianliao.me/faq&lt;script&gt;var xlm_wid='15920';var xlm_url='https://www.xianliao.me/';&lt;/script&gt;&lt;script type=\"text/javascript\" charset=\"UTF-8\" src=\"https://www.xianliao.me/embed.js\"&gt;&lt;/script&gt;--&gt; &lt;center&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.11\"&gt;&lt;/script&gt; &lt;!--打字机--&gt; &lt;div style=\"text-align: center;font-weight: bold;color: #1BC3FB;\"&gt; &lt;span id=\"subtitle1\"&gt;没有伞的孩子必须努力奔跑！&lt;/span&gt;&lt;span class=\"typed-cursor typed-cursor--blink\"&gt;|&lt;/span&gt; &lt;span id=\"typed-cursor\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;!-- 打字特效（蓝色字体） --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.11\"&gt;&lt;/script&gt; &lt;script&gt;var typed = new Typed(\"#subtitle1\", { strings: [\"Live a good life, write some good code !!!\", \"愿自己的努力终将获得回报。\", \"花开不是为了花落，而是为了开的更加灿烂。\", \"没有伞的孩子必须努力奔跑！\", \"欲望以提升热忱，毅力以磨平高山。\", \"如果放弃太早，你永远都不知道自己会错过什么。\", \"没有礁石，就没有美丽的浪花；没有挫折，就没有壮丽的人生。\"], startDelay: 1000, typeSpeed: 100, loop: !0, backSpeed: 60, backDelay: 2000, showCursor: !0 })&lt;/script&gt; &lt;!--建站运行时长--&gt; &lt;script&gt; var now = new Date(); function createtime() { var grt= new Date(\"06/11/2019 17:38:00\");//在此处修改你的建站时间，格式：月/日/年 时:分:秒 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 ){hnum = \"0\" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = \"0\" + mnum;} seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 ){snum = \"0\" + snum;} document.getElementById(\"timeDate\").innerHTML = \"小站勉强运行了 \"+dnum+\" 天 \"; document.getElementById(\"times\").innerHTML = hnum + \" 小时 \" + mnum + \" 分 \" + snum + \" 秒 ( ͡° ͜ʖ ͡°)✧ \"; } setInterval(\"createtime()\",250); &lt;/script&gt;&lt;div&gt; &lt;span id=\"timeDate\"&gt;载入天数...&lt;/span&gt;&lt;span id=\"times\"&gt;载入时分秒...&lt;/span&gt;&lt;/div&gt; &lt;!--网站访客地理信息--&gt; &lt;script type=\"text/javascript\" src=\"//rf.revolvermaps.com/0/0/8.js?i=5eqiqb8vl6p&amp;m=2&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;z=17&amp;rx=-40&amp;lx=-540&amp;ly=520&amp;hi=60\" async=\"async\"&gt;&lt;/script&gt; &lt;/center&gt; &lt;!--cnzz统计--&gt; &lt;center&gt; &lt;script type=\"text/javascript\"&gt;document.write(unescape(\"%3Cspan id='cnzz_stat_icon_'%3E%3C/span%3E%3Cscript src='' type='text/javascript'\"));&lt;/script&gt; &lt;/center&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Git Bash 命令大全","slug":"Git-Bash-命令大全","date":"2020-07-10T14:25:00.000Z","updated":"2020-09-24T08:55:08.016Z","comments":true,"path":"2020/07/10/Git-Bash-命令大全/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/10/Git-Bash-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","excerpt":"","text":"仓库在当前目录新建一个Git代码库 $ git init 新建一个目录，将其初始化为Git代码库 $ git init [project-name] 下载一个项目和它的整个代码历史 $ git clone [url] 配置显示当前的Git配置 $ git config --list 编辑Git配置文件 $ git config -e [--global] 设置提交代码时的用户信息 $ git config [--global] user.name \"[name]\" $ git config [--global] user.email \"[email address]\" 增加/删除文件添加指定文件到暂存区 $ git add [file1] [file2] ... 添加指定目录到暂存区，包括子目录 $ git add [dir] 添加当前目录的所有文件到暂存区 $ git add . 添加每个变化前，都会要求确认，对于同一个文件的多处变化，可以实现分次提交 $ git add -p 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 代码提交提交暂存区到仓库区 $ git commit -m [message] 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a 提交时显示所有diff信息 $ git commit -v 使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 分支列出所有本地分支 $ git branch 列出所有远程分支 $ git branch -r 列出所有本地分支和远程分支 $ git branch -a 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] 新建一个分支，并切换到该分支 $ git checkout -b [branch] 新建一个分支，指向指定commit $ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区 $ git checkout [branch-name] 切换到上一个分支 $ git checkout - 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支 $ git merge [branch] 选择一个commit，合并进当前分支 $ git cherry-pick [commit] 删除分支 $ git branch -d [branch-name] 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 标签列出所有tag $ git tag 新建一个tag在当前commit $ git tag [tag] 新建一个tag在指定commit $ git tag [tag] [commit] 删除本地tag $ git tag -d [tag] 删除远程tag $ git push origin :refs/tags/[tagName] 查看tag信息 $ git show [tag] 提交指定tag $ git push [remote] [tag] 提交所有tag $ git push [remote] --tags 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 查看信息显示有变更的文件 $ git status 显示当前分支的版本历史 $ git log 显示commit历史，以及每次commit发生变更的文件 $ git log --stat 搜索提交历史，根据关键词 $ git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件 $ git log [tag] HEAD --grep feature 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] 显示指定文件相关的每一次diff $ git log -p [file] 显示过去5次提交 $ git log -5 --pretty --oneline 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn 显示指定文件是什么人在什么时间修改过 $ git blame [file] 显示暂存区和工作区的差异 $ git diff 显示暂存区和上一个commit的差异 $ git diff --cached [file] 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] 显示今天你写了多少行代码 $ git diff --shortstat \"@{0 day ago}\" 显示某次提交的元数据和内容变化 $ git show [commit] 显示某次提交发生变化的文件 $ git show --name-only [commit] 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] 显示当前分支的最近几次提交 $ git reflog 远程同步下载远程仓库的所有变动 $ git fetch [remote] 显示所有远程仓库 $ git remote -v 显示某个远程仓库的信息 $ git remote show [remote] 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] 上传本地指定分支到远程仓库 $ git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force 推送所有分支到远程仓库 $ git push [remote] --all 撤销恢复暂存区的指定文件到工作区 $ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] 恢复暂存区的所有文件到工作区 $ git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] 新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 其他生成一个可供发布的压缩包 $ git archive document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://melodyjerry.github.io/blog/tags/Git/"}]},{"title":"网易云解析/接口","slug":"网易云解析接口","date":"2020-07-10T07:55:00.000Z","updated":"2020-07-16T06:58:48.498Z","comments":true,"path":"2020/07/10/网易云解析接口/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/10/%E7%BD%91%E6%98%93%E4%BA%91%E8%A7%A3%E6%9E%90%E6%8E%A5%E5%8F%A3/","excerpt":"文档来源：https://api.paugram.com/help/netease 方法调用地址 https://api.paugram.com/netease/ 并输入参数 id 或 title，即可获得一段歌曲 JSON 信息。 如果您已开始使用本 API 服务，则默认视为遵守 本约定。 音乐版权归网易云音乐所有，本站不为滥用本 API 进行违规操作者承担责任。","text":"文档来源：https://api.paugram.com/help/netease 方法调用地址 https://api.paugram.com/netease/ 并输入参数 id 或 title，即可获得一段歌曲 JSON 信息。 如果您已开始使用本 API 服务，则默认视为遵守 本约定。 音乐版权归网易云音乐所有，本站不为滥用本 API 进行违规操作者承担责任。 参数建议使用 id 的方式获得歌曲信息，性能相对较好。 参数 要求 描述 id 二选一 有效的音乐 ID，例：517567145 音乐 ID title 二选一 可以搜索到且无版权限制的歌曲，暂无加速 音乐名称 playlist（施工中） 有多首音乐的音乐列表 音乐列表 play 参数值为 true 则启用跳转 是否直接跳转到歌曲所在地址 返回内容 参数名称 描述 值 id 音乐 ID string title 音乐名称 string artist 音乐艺术家 string album 音乐专辑名称 string cover 音乐专辑图片链接（https） string link 音乐源地址链接 string lyric 音乐 LRC 歌词内容 string sub_lyric 翻译版 LRC 歌词内容（如果有） string served 是否为 VIP 或无版权歌曲（测试功能） true false 示例通过 ID 获得一首歌的信息 https://api.paugram.com/netease/?id=517567145 返回的是： { \"id\": 517567145, \"title\": \"初登校\", \"artist\": \"橋本由香利\", \"album\": \"ひなこのーと COMPLETE SOUNDTRACK\", \"cover\": 封面地址, \"lyric\": 歌词内容, \"sub_lyric\": 翻译歌词内容, \"link\": 音乐地址 } 通过 ID 获得一首歌，并跳转到实际地址 https://api.paugram.com/netease/?id=517567145&amp;play=true 通过歌名获得一首歌的信息 https://api.paugram.com/netease/?title=Paradise 返回的是： { \"id\": 17177380, \"title\": \"Paradise\", \"artist\": \"Coldplay\", \"album\": \"Paradise\", \"cover\": 封面地址, \"lyric\": 歌词内容, \"sub_lyric\": 翻译歌词内容, \"link\": 音乐地址 } 结合 Kico Style 和 Kico Player 使用本 API ks.ajax({ method: \"GET\", url: \"https://api.paugram.com/netease/\" + \"?id=\" + id, success: function (req){ var item = JSON.parse(req.response); 声明的播放器.add([item]); }, failed: function (req){ ks.notice(\"获取音乐信息错误了！\", {color: \"red\"}); } }); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"API","slug":"API","permalink":"https://melodyjerry.github.io/blog/tags/API/"}]},{"title":"「hexo.sh」一个方便管理与发布hexo博客的脚本","slug":"「hexo.sh」一个方便管理与发布hexo博客的脚本","date":"2020-07-10T07:09:00.000Z","updated":"2020-07-16T06:58:48.491Z","comments":true,"path":"2020/07/10/「hexo.sh」一个方便管理与发布hexo博客的脚本/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/10/%E3%80%8Chexo.sh%E3%80%8D%E4%B8%80%E4%B8%AA%E6%96%B9%E4%BE%BF%E7%AE%A1%E7%90%86%E4%B8%8E%E5%8F%91%E5%B8%83hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%84%9A%E6%9C%AC/","excerpt":"「hexo.sh」脚本可以很方便执行各种 hexo 命令，开启后会一直保持会话，随时输入 c、cs、cg、cgd 等简短的命令去执行一系列操作，提高效率。 例如，`cs`相当于：hexo clean hexo s `cgd`相当于：hexo clean hexo g hexo d git add --all git commit -am \"update all\" git push origin","text":"「hexo.sh」脚本可以很方便执行各种 hexo 命令，开启后会一直保持会话，随时输入 c、cs、cg、cgd 等简短的命令去执行一系列操作，提高效率。 例如，`cs`相当于：hexo clean hexo s `cgd`相当于：hexo clean hexo g hexo d git add --all git commit -am \"update all\" git push origin 下载并安装脚本打开终端，输入这行命令： curl -s https://xaoxuu.com/install | sh -s hexo.sh 如需安装指定版本，在后面加上版本号即可，例如： curl -s https://xaoxuu.com/install | sh -s hexo.sh 2.1.0 启动脚本在终端输入如下命令即可打开脚本： hexo.sh 使用方法在终端输入如下命令即可查看脚本所有支持的指令： hexo.sh help 如果是脚本已经启动（可以看到脚本菜单，处于待输入指令的状态），则只需要输入 help，下文其它情景同理。 下面是一些常见使用场景： A. 使用脚本快速搭建博客let path = 你想把博客放在哪里，打开终端 cd 到 path 。 在终端输入如下命令自动检查并安装所有需要的环境，然后搭建并启动博客： COPYhexo.sh init 脚本会依次执行以下这些操作： 检测node.js环境，如果没有就安装。 检测hexo环境，如果没有就安装。 输入自定义博客名，在当前目录执行初始化。 安装Material X主题。 安装所有依赖包。 注意：安装node.js或者hexo的时候需要输入一次本机密码，别忘了哦。搭建博客的时候你需要输入博客名，其他时间就可以坐和放宽了。 B. 使用脚本快速更新博客let path = 你的博客路径，打开终端 cd 到 path 。 在终端输入如下命令启动博客： hexo.sh s 然后修改你的文章、博客主题，如果修改了 _config.yml 是需要重新启动博客的，有些参数甚至需要 clean 之后重启才能生效，这时候你只需要在终端脚本【请输入指令】后面输入： cs 就执行 hexo clean，然后执行 hexo server 了。 如果你已经修改完毕，需要发布更新，可以在终端脚本【请输入指令】后面输入： cgd 脚本就会执行 hexo clean、hexo generate、hexo deploy，然后执行一系列的git命令把源码的更新提交至远程仓库。 所有支持的命令这是 2.1.0 版本中的所有命令，可能未必准确，以脚本中的帮助信息为准。 常用: c (clean) 执行 hexo clean s (server) 执行 hexo server g (generate) 执行 hexo generate d (deploy) 执行 hexo deploy cs 执行 c, s 的组合 cg 执行 c, g 的组合 cgd 执行 c, g, d 的组合，然后提交代码 安装: i (install) 用于安装的命令，下面是install命令的参数: n (node) 安装node.js环境 h (hexo) 安装hexo环境(npm install hexo-cli -g) b (blog) 搭建博客(hexo init, npm install) d (dependency) 安装依赖包(npm install) v (volantis) 下载并应用「Volantis」主题 自动: init 自动检查并安装所有需要的环境，然后搭建并启动博客。👍🏼 vut 下载并运行「Volantis」主题的单元测试。 脚本: cd + `path` 选择路径 docs 查看文档(https://xaoxuu.com/wiki/hexo.sh) gh (github) GitHub页面(https://github.com/xaoxuu/hexo.sh) u (update) 更新脚本文件(当前版本：2.1.0) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"Linux命令小记","slug":"Linux命令小记","date":"2020-07-10T07:03:00.000Z","updated":"2020-07-15T07:10:03.123Z","comments":true,"path":"2020/07/10/Linux命令小记/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/10/Linux%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"rpm -q xx 查询xx是否安装 yum install xx 安装xx软件包 yum remove xx 卸载xx软件包 vim /路径 读写文件 i：编辑模式 Exc：退出到命令模式 :wq：保存并退出Vim startx （一次性地）从命令行切换到桌面环境 systemctl get-default 获取当前启动模式 systemctl set-default graphical.target 修改启动模式为图形化 systemctl set-default multi-user.target 修改启动模式为命令行 安装桌面环境 安装桌面环境（这里安装 GNOME） systemctl start xx 启动xx服务 systemctl enable xx 开机自启动xx服务 firewall-cmd --permanent --zone=public --add-port=3389/tcp 防火墙开放3389端口 firewall-cmd --reload 重启防火墙 systemctl stop firewalld 关闭防火墙 systemctl disable firewalld 禁止防火墙开机启动 cp /路径 复制文件 systemctl daemon-reload 让服务文件修改生效 netstat -lnpt|grep xx 查看xx的服务端口 sudo yum update -y 更新服务器地软件包 sudo yum install java-1.8.0-openjdk -y 安装 OpenJRE java -version 检测jre是否安装成功 sudo useradd -m halo 创建一个低权限地用户halo sudo su halo 登录用户halo wget url 下载xx安装包 useradd [-d home] [-s shell] [-c comment] [-m [-k template]] [-f inactive] [-e expire ] [-p passwd] [-r] name useradd或adduser命令用来建立用户帐号和创建用户的起始目录，使用权限是超级用户 主要参数 -c：加上备注文字，备注文字保存在passwd的备注栏中。 -d：指定用户登入时的主目录，替换系统默认值/home/&lt;用户名&gt; -D：变更预设值。 -e：指定账号的失效日期，日期格式为MM/DD/YY，例如06/30/12。缺省表示永久有效。 -f：指定在密码过期后多少天即关闭该账号。如果为0账号立即被停用；如果为-1则账号一直可用。默认值为-1. -g：指定用户所属的群组。值可以使组名也可以是GID。用户组必须已经存在的，期默认值为100，即users。 -G：指定用户所属的附加群组。 -m：自动建立用户的登入目录。 -M：不要自动建立用户的登入目录。 -n：取消建立以用户名称为名的群组。 -r：建立系统账号。 -s：指定用户登入后所使用的shell。默认值为/bin/bash。 -u：指定用户ID号。该值在系统中必须是唯一的。0~499默认是保留给系统用户账号使用的，所以该值必须大于499。 https://www.cnblogs.com/irisrain/p/4324593.html w # whoami 查看当前登陆用户 12:10:27 up 21:13, 1 user, load average: 0.00, 0.01, 0.08 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root pts/0 ***.**.***.** 11:33 0.00s 0.08s 0.00s w tmp_3254 ps1 ***.**.***.** 11:33 0.00s 0.08s 0.00s ls su xxx # 或者直接 exit 退出当前用户登录，进入一个有管理员权限的用户 pkill -kill -t [TTY] 强制退出已经登陆用户 0pkill -kill -t ps1 ls -a # ls --all 查看当前目录下的所有文件 service xx restart 重启xx应用 curl -o /路径 --create-dirs url 下载配置文件、模板等文件 sudo nginx -t 检查Nginx配置是否有误 sudo nginx -s reload 重载Nginx配置 sudo service xx status 查看xx的运行状态 sudo service halo stop 停止xx sudo service halo restart 重启xx sudo service halo start 启动xx sudo systemctl daemon-reload 修改service文件之后需要刷新Systemd sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 添加软件源信息 sudo yum makecache fast 更新yum缓存 镜像加速 # 新建 daemon.json 文件 sudo vim /etc/docker/daemon.json 将下面的配置复制进去即可： { \"registry-mirrors\": [\"http://hub-mirror.c.163.com\"] } 注意：修改完配置文件之后需要执行 service docker restart 才可生效。 sudo docker pull ruibaby/xx 拉取xx的最新镜像 docker run --rm -it -d --name halo -p 8090:8090 -v ~/.halo:/root/.halo ruibaby/halo 创建容器并运行halo –rm：停止之后自动删除容器。 –name：容器名。 -p：占用端口，前者为宿主机端口，后者为 Halo 的运行端口，可在 application.yaml 配置。 -v：目录映射，一般不要修改。 netstat -tln # netstat -tln | grep 8080 查找被占用的端口（可接特定端口号） netstat -ntlp 查看其他端口 lsof -i:8060 查看端口属于哪个程序、端口被哪个进程占用 kill -9 进程id 杀掉占用端口的进程 根据pid杀掉 shutdown -h now 立即关机 shutdown -r now # reboot 立即重启 docker run --name some-wordpress --link some-mysql:mysql -d wordpress 参数说明： --name 容器的的名字 --link 和其他容器做连接 -d/--detach 后台运行 docker run -d --privileged=true --name myMysql -v /data/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -p 33306:3306 mysql:5.6 参数解释： -p: 端口映射，33306表示宿主，3306表示容器中的端口。 这里表示将宿主机的33306映射给镜像的3306. -e: 环境变量， 环境变量和具体的Docker容器制作时设置有关，这里表示设置镜像中MySQL的root 密码时123456 -v: 指定数据卷，也就是将我们MySQL容器的/var/lib/mysql映射到宿主机的/data/mysql --privileged=true: CentOS系统下的安全Selinux禁止了一些安全权限，导致MySQL容器在运行时会因为权限不足而报错，所以需要增加该选项 docker ps -a 查看MySQL是否正常运行 docker stop 容器名 停止运行 docker rm 容器名 删除容器（之后去掉-d选项重新运行排查错误） 快速批量删除docker镜像或容器 Docker本身并没有提供批量删除的功能，当有大量的镜像或者容器需要删除的时候，手动的一个一个删就比较麻烦了。 # 直接删除所有镜像或容器 # 直接删除所有镜像 docker rmi `docker images -q` # 直接删除所有容器 docker rm `docker ps -aq` # 按条件筛选之后删除 # 按条件筛选之后删除镜像 docker rmi `docker images | grep xxxxx | awk '{print $3}'` # 按条件筛选之后删除容器 docker rm `docker ps -a | grep xxxxx | awk '{print $1}'` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"Docker学习笔记","slug":"Docker学习笔记","date":"2020-07-08T04:55:00.000Z","updated":"2020-07-11T01:51:50.361Z","comments":true,"path":"2020/07/08/Docker学习笔记/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/08/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Docker安装部署CentOS yum 包更新到最新（花的时间比较多） yum update 安装需要的软件包，yum-util 提供的yum-config-manager功能，另外两个是devicemapper驱动依赖的 yum install -y yum-utils device-mapper-persistent-data lvm2 设置yum源 yum-confi-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 安装docker，出现输入的页面都按 y yum install -y docker-ce 查看docker版本，验证是否安装成功 docker -v 其他安装方式(推荐)教程链接：Here! Docker命令Docker服务相关命令 启动docker服务 systemctl start docker systemctl start docker 停止docker服务 systemctl stop docker 重启docker服务 systemctl restart docker 查看docker服务状态 systemctl status docker 设置开机启动docker服务 systemstl enable docker Docker镜像相关命令 查看镜像：查看本地所有的镜像 docker images docker images -q # 查看所有镜像id 搜索镜像：从网络中查找需要的镜像 docker search 镜像名称 拉取镜像：从docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新版本。如果不知道镜像版本，可以去docker hub 搜索对应镜像查看 docker pull 镜像名称 删除镜像 docker rmi 镜像id docker rmi `docker images -q` # 删除所有本地镜像 Docker容器相关的命令 查看容器 docker ps # 查看正在运行的容器 docker ps -a # 查看所有容器 创建并启动容器 docker run 参数 参数说明： -i：保持容器运行。通常与-t同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。 -t：为容器重新分配一个伪输入终端，通常与-i同时使用。 -d:以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec进入容器。退出时，容器不会关闭。 -it：创建的容器一般称为交互式容器。 -id：创建的容器一般称为守护式容器。 –name：为创建的容器命名。 进入容器 docker exec 参数 # 退出容器，容器不会关闭 启动容器 docker start 容器名称 停止容器 docker stop 容器名称 删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除 docker rm 容器名称 查看容器信息 docker inspect 容器名称 Docker容器的数据卷数据卷概念和作用思考 Docker容器删除后，在容器中产生的数据也会随之销毁吗？ 会。 Docker容器和外部机器可以直接交换文件吗？ 不可以。 容器之间想要进行数据交互？ 不可以。 那咋办嘛？这就要用到数据卷了 数据卷 数据卷是宿主机中的一个目录或文件 当容器目录和数据卷目录绑定后，对方的修改会立即同步 一个数据卷可以被多个容器同时挂载 一个容器也可以被挂载多个数据卷 数据卷的作用 容器数据持久化 外部机器和容器间接通信 容器之间数据交换 配置数据卷 创建启动容器时，使用-v参数设置数据卷 docker run ...-v 宿主机目录(文件):容器内目录(文件)... 注意事项： 目录必须是绝对路径 如果目录不存在，会自动创建 可以挂载多个数据卷 数据卷容器配置数据卷容器 创建启动c3数据卷容器，使用-v参数设置数据卷 docker run -it --name-=c3 -v /volume centos:7 /bin/bash 创建启动c1 c2数据卷容器，使用-volumes-from参数设置数据卷 docker run -it --name-=c1 -volumes-from c3 centos:7 /bin/bash docker run -it --name-=c2 -volumes-from c3 centos:7 /bin/bash #Docker应用部署 MySQL部署 搜索MySQL镜像 docker search mysql 拉取MySQL镜像 docker pull mysql:5.6 创建容器，设置端口映射、目录映射 # 在/root目录下创建mysql目录用于存储mysql数据信息 mkdir ~/mysql cd ~/mysql docker run -id \\ --name=c_mysql \\ -p 3307:3306 \\ -v $PWD/conf:/etc/mysql/confi.d \\ -v $PWD/logs:/logs \\ -v $PWD/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ mysql:5.6 参数说明： -p 3307:3306：将容器的3306端口映射到宿主机的3307端口。 -v $PWD/conf:/etc/mysql/confi.d：将主机当前目录下的conf/my.cnf挂载到容器的/etc/mysql/my.cnf。配置目录 -v $PWD/logs:/logs：将主机当前目录下的logs目录挂载到容器的/logs。日志目录 -v $PWD/data:/var/lib/mysql：将主机当前目录下的data目录挂载到容器的/var/lib/mysql。数据目录 -e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码。 Tomcat部署 搜索Tomcat镜像 docker search tomcat 拉取Tomcat镜像 docker pull tomcat 创建容器，设置端口映射、目录映射 # 在/root目录下创建tomcat目录用于存储tomcat数据信息 mkdir ~/tomcat cd ~/tomcat docker run -id \\ --name=c_tomcat \\ -p 8080:8080 \\ -v $PWD:/usr/local/tomcat/webapps \\ tomcat 参数说明： -p 8000:8080：将容器的8080端口映射到宿主机的8000端口。 -v $PWD:/usr/local/tomcat/webapps：将主机当前目录挂载到容器的/usr/local/tomcat/webapps。 Nginx部署 搜索Nginx镜像 docker search nginx 拉取Nginx镜像 docker pull nginx 创建容器，设置端口映射、目录映射 # 在/root目录下创建nginx目录用于存储nginx数据信息 mkdir ~/nginx cd ~/nginx mkdir conf cd conf # 在~/nginx/conf/下创建nginx.conf文件，粘贴下面内容 vim nginx.conf user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } docker run -id \\ --name=c_nginx \\ -p 81:80 \\ -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \\ -v $PWD/logs:/var/log/nginx \\ -v $PWD/html:/usr/share/nginx/html \\ nginx 参数说明： -p 81:80：将容器的80端口映射到宿主机的81端口。 v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机当前目录下的/conf/nginx.conf挂载到容器的/etc/nginx/nginx.conf。配置目录 -v $PWD/logs:/var/log/nginx：将主机当前目录下的logs目录挂载到容器的/var/log/nginx。日志目录 -v $PWD/html:/usr/share/nginx/html：将主机当前目录下的/html挂载到容器的/usr/share/nginx/html。 Redis部署 搜索Redis镜像 docker search redis 拉取Redis镜像 docker pull redis:5.0 创建容器，设置端口映射、目录映射 docker run -id --name=c_redis -p 6379:6379 redis:5.0 参数说明： -p 6379:6379：将容器的6379端口映射到宿主机的6379端口。 使用外部机器连接redis ./redis-cli.exe -h &lt;your ipAddress&gt; -p 6379 DockerfileDocker镜像原理思考 Docker镜像本质是什么？ 是一个分层的文件系统 Docker中一个centos镜像为什么只有200MB，而一个centos操作系统的 iso 文件要几个GB？ Centos的iso镜像文件包含bootfs和rootfs，而docker的centos镜像复用操作系统的bootfs，只包含rootfs和其他镜像层 Docker中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？ 由于docker中镜像是分层的，tomcat虽然只有70多MB，但它需要依赖于父镜像和子镜像，所有整个对外暴露的tomcat镜像大小有500多MB Linux文件系统 bootfs：包含bootloader（引导加载系统）和kernel（内核） rootfs：root文件系统，包含的就是典型的Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件 不用的Linux发行版，bootfs基本一样，而rootfs不同，如Ubuntu，centos等 Docker镜像 Docker镜像是由特殊的文件系统叠加而成 最底端是bootfs,并使用宿主机的bootfs 第二层是root文件系统rootfs,称为base image 然后再往上可以叠加其他的镜像文件 统一文件系统(Union File System)\\技术能够将不同的层整合成一个文件系统,为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来,只存在一个文件系统。 一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像\\，最底部的镜像成为基础镜像\\。 当从一个镜像启动容器时，Docker会从最顶层加载一个读写文件系统作为容器 镜像制作 容器转为镜像 docker commit 容器id 镜像名称:版本号 # 将容器转换为镜像文件 docker save -o 压缩文件名称 镜像名称:版本号 # 将镜像文件打包成压缩文件，之后就能对压缩文件传送了 docker load -i 压缩文件名称 # 将压缩文件解压称为镜像文件 Dockerfile 看下面内容 Dockerfile概念及作用概念 Dockerfile是一个文本文件 包含了一条条的指令 每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像 对于开发人员：可以为开发团队提供一个完全一致的开发环境 对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了 对于运维人员：在部署时，可以实现应用的无缝移植 Dockerfile关键字列举一些常用的 关键字 作用 备注 FROM 指定父镜像 指定dockerfile基于那个image构建 MAINTAINER 作者信息 用来标明这个dockerfile谁写的 LABEL 标签 用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看 RUN 执行命令 执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”] CMD 容器启动命令 提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”] ENTRYPOINT 入口 一般在制作一些执行就关闭的容器中会使用 COPY 复制文件 build的时候复制文件到image中 ADD 添加文件 build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务 ENV 环境变量 指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value ARG 构建参数 构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数 VOLUME 定义外部可以挂载的数据卷 指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”] EXPOSE 暴露端口 定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp WORKDIR 工作目录 指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径 USER 指定执行用户 指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户 HEALTHCHECK 健康检查 指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制 ONBUILD 触发器 当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大 STOPSIGNAL 发送信号量到宿主机 该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。 SHELL 指定执行脚本的shell 指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell 制作自定义centos镜像自定义需求 默认登录路径为/usr 可以使用vim 操作 创建编辑dockerfile文件 mkdir /root/dockerfile cd dockerfile vim centos_dockerfile 定义父镜像：FROM centos:7 定义作者信息：MAINTAINER adongyo &lt;adongyo@it.cn&gt; 执行安装vim命令：RUN yum install -y vim 定义默认的工作目录：WORKDIR /usr 定义容器启动执行的命令：CMD /bin/bash 执行命令 docker build -f ./centos_dockerfile -t myCentos:1 . 参数说明： -f： 指定dockerfile文件 -t： 设置生成的新的镜像的名称 .： 别漏了后面还有一个’.’ 参考资料 b站转载黑马程序员 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"https://melodyjerry.github.io/blog/tags/Docker/"}]},{"title":"Hexo部署到云服务器","slug":"Hexo部署到云服务器","date":"2020-07-08T04:49:00.000Z","updated":"2020-07-15T07:10:03.120Z","comments":true,"path":"2020/07/08/Hexo部署到云服务器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/08/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"阿里云VPS搭建自己的的Hexo博客：https://segmentfault.com/a/1190000005723321Hexo个人博客部署到CentOS个人服务器：https://segmentfault.com/a/1190000010680022部署Hexo到个人服务器：https://www.huangtengxq.com/2017/08/19/BuildHexoOnVps/HEXO部署到unbuntu服务器详细指南：http://www.laoyuyu.me/2017/10/10/hexo_deploy_vps/服务器部署Hexo博客：https://dogorgod.github.io/2017/03/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/Hexo博客部署到服务器：https://i.jakeyu.top/2016/12/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/通过Git将Hexo博客部署到服务器：https://www.jianshu.com/p/e03e363713f9部署Hexo博客到linux云主机并实现自动发布：https://ghui.me/post/2016/07/host-hexo-vps/将Hexo博客部署到云主机：https://blog.fundebug.com/2017/05/18/deploy-hexo-on-cloud/配合Travis CI，将Hexo博客自动部署到你的服务器上：https://blog.keep.moe/2015/11/06/hexo-and-travis-ci/使用Git Hook自动部署Hexo到个人VPS：http://www.swiftyper.com/2016/04/17/deploy-hexo-with-git-hook/VPS Centos7安装Git服务器，部署Hexo静态博客：https://www.micronbot.com/blog/8.html在Ubuntu 14.04服务器上部署Hexo博客：https://cloud.tencent.com/developer/article/1004587阿里云ubuntu部署hexo,并与本地同步，实现自动部署：http://blog.csdn.net/nghuyong/article/details/54430093阿里云搭建Git服务，实现Hexo自动部署：https://imys.net/20160303/hexo-nginx-auto-deploy.htmlhexo博客部署到linux服务器上：https://lvshen9.github.io/2018/01/08/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"},{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"服务器安装宝塔面板","slug":"宝塔面板Linux命令大全","date":"2020-07-07T15:32:00.000Z","updated":"2020-07-15T07:10:03.401Z","comments":true,"path":"2020/07/07/宝塔面板Linux命令大全/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BFLinux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","excerpt":"","text":"安装宝塔Centos安装脚本 yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh Ubuntu/Deepin安装脚本 wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh Debian安装脚本 wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; bash install.sh Fedora安装脚本 wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; bash install.sh 管理宝塔宝塔工具箱(包含下列绝大部分功能 直接ssh中执行bt命令 仅限6.x以上版本面板) bt 停止 /etc/init.d/bt stop 启动 /etc/init.d/bt start 重启 /etc/init.d/bt restart 卸载 /etc/init.d/bt stop &amp;&amp; chkconfig --del bt &amp;&amp; rm -f /etc/init.d/bt &amp;&amp; rm -rf /www/server/panel 查看当前面板端口 cat /www/server/panel/data/port.pl 修改面板端口，如要改成8881（centos 6 系统） echo '8881' &gt; /www/server/panel/data/port.pl &amp;&amp; /etc/init.d/bt restart iptables -I INPUT -p tcp -m state --state NEW -m tcp --dport 8881 -j ACCEPT service iptables save service iptables restart 修改面板端口，如要改成8881（centos 7 系统） echo '8881' &gt; /www/server/panel/data/port.pl &amp;&amp; /etc/init.d/bt restart firewall-cmd --permanent --zone=public --add-port=8881/tcp firewall-cmd --reload 强制修改MySQL管理(root)密码，如要改成123456 cd /www/server/panel &amp;&amp; python tools.py root 123456 修改面板密码，如要改成123456 cd /www/server/panel &amp;&amp; python tools.py panel 123456 查看宝塔日志 cat /tmp/panelBoot.pl 查看软件安装日志 cat /tmp/panelExec.log 站点配置文件位置 /www/server/panel/vhost 删除域名绑定面板 rm -f /www/server/panel/data/domain.conf 清理登陆限制 rm -f /www/server/panel/data/*.login 查看面板授权IP cat /www/server/panel/data/limitip.conf 关闭访问限制 rm -f /www/server/panel/data/limitip.conf 查看许可域名 cat /www/server/panel/data/domain.conf 关闭面板SSL rm -f /www/server/panel/data/ssl.pl &amp;&amp; /etc/init.d/bt restart 查看面板错误日志 cat /tmp/panelBoot 查看数据库错误日志 cat /www/server/data/*.err 站点配置文件目录(nginx) /www/server/panel/vhost/nginx 站点配置文件目录(apache) /www/server/panel/vhost/apache 站点默认目录 /www/wwwroot 数据库备份目录 /www/backup/database 站点备份目录 /www/backup/site 站点日志 /www/wwwlogs Nginx服务管理nginx安装目录 /www/server/nginx 启动 /etc/init.d/nginx start 停止 /etc/init.d/nginx stop 重启 /etc/init.d/nginx restart 启载 /etc/init.d/nginx reload nginx配置文件 /www/server/nginx/conf/nginx.conf Apache服务管理apache安装目录 /www/server/httpd 启动 /etc/init.d/httpd start 停止 /etc/init.d/httpd stop 重启 /etc/init.d/httpd restart 启载 /etc/init.d/httpd reload apache配置文件 /www/server/apache/conf/httpd.conf MySQL服务管理mysql安装目录 /www/server/mysql phpmyadmin安装目录 /www/server/phpmyadmin 数据存储目录 /www/server/data 启动 /etc/init.d/mysqld start 停止 /etc/init.d/mysqld stop 重启 /etc/init.d/mysqld restart 启载 /etc/init.d/mysqld reload mysql配置文件 /etc/my.cnf FTP服务管理ftp安装目录 /www/server/pure-ftpd 启动 /etc/init.d/pure-ftpd start 停止 /etc/init.d/pure-ftpd stop 重启 /etc/init.d/pure-ftpd restart ftp配置文件 /www/server/pure-ftpd/etc/pure-ftpd.conf PHP服务管理php安装目录 /www/server/php 启动(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 start) /etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} start 停止(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 stop) /etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} stop 重启(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 restart) /etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} restart 启载(请根据安装PHP版本号做更改，例如：/etc/init.d/php-fpm-54 reload) /etc/init.d/php-fpm-{52|53|54|55|56|70|71|72|73|74} reload 配置文件(请根据安装PHP版本号做更改，例如：/www/server/php/52/etc/php.ini) /www/server/php/{52|53|54|55|56|70|71|72|73|74}/etc/php.ini Redis服务管理redis安装目录 /www/server/redis 启动 /etc/init.d/redis start 停止 /etc/init.d/redis stop redis配置文件 /www/server/redis/redis.conf Memcached服务管理memcached安装目录 /usr/local/memcached 启动 /etc/init.d/memcached start 停止 /etc/init.d/memcached stop 重启 /etc/init.d/memcached restart 启载 /etc/init.d/memcached reload document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"},{"name":"宝塔","slug":"宝塔","permalink":"https://melodyjerry.github.io/blog/tags/%E5%AE%9D%E5%A1%94/"}]},{"title":"服务器安装宝塔面板","slug":"服务器安装宝塔面板","date":"2020-07-07T13:24:00.000Z","updated":"2020-07-15T07:10:03.408Z","comments":true,"path":"2020/07/07/服务器安装宝塔面板/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/","excerpt":"这里两篇文章关于“CentOS安装宝塔面板” https://developer.aliyun.com/ask/233242?spm=a2c6h.13524658 http://tencent.yundashi168.com/327.html?spm=a2c6h.13066369.0.0.328d79c6znCKp6","text":"这里两篇文章关于“CentOS安装宝塔面板” https://developer.aliyun.com/ask/233242?spm=a2c6h.13524658 http://tencent.yundashi168.com/327.html?spm=a2c6h.13066369.0.0.328d79c6znCKp6 ①购买完云服务器ECS后，对于新手而言如何搭建Web环境是比较棘手的，分享一款简单易用的主机面板：宝塔面板，分享阿里云服务器安装宝塔面板图文教程： 本文以：Linux云服务器，CentOS 7.4 64位系统为例。 一：开放安全组端口什么是安全组？是阿里云ECS云服务器特有的虚拟防火墙，是一种安全机制，默认情况下宝塔面板依赖的端口并没有开放，所以我们第一步是自定义安全组开放端口，如下图所示： 我们以开放8888号端口为例：1、登录到云服务器ECS控制台；2、点击“更多”–“网络和安全组”–“安全组配置”，点击“配置规则”3、如下图所示，端口范围填：8888/8888，授权对象填：0.0.0.0/0 端口范围按照格式，填写我们需要开放的端口；授权对象填0.0.0.0/0的意思是对所有人开放这个端口，授权范围大家可以按照自己的需求自定义。宝塔面板需要开放的端口有：8888、888、80、443、20、21，这6个端口都需要开放，大家按照上面的方法开放即可。 安全组不会操作，可以参考阿里云官方文档： 阿里云安全组的典型应用示例 二：安装宝塔面板SSH的方式登录到你的云服务器ECS上，命令：ssh root@你的服务器IP执行命令：yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh然后输入字母“y”，等待程序自行安装，大约2分钟 三：保存宝塔面板后台登录名和密码执行上述命令后，程序自动安装，安装完毕后，会出现宝塔后台登录的账户名和密码，大家保存下来Complete!==================================================================Congratulations! Install succeeded!==================================================================Bt-Panel: http://47.104.71.103:8888username: adminpassword: 66d52887Warning:If you cannot access the panel,release the following port (8888|888|80|443|20|21) in the security group==================================================================宝塔面板后台登录地址为：http://你的服务器IP/8888默认登录名为：admin密码：安装完成后，会随机生成一段密码，请保存好 四：登录到宝塔面板后台，安装web环境使用刚才保存的账户名和密码，登录到宝塔面吧后台，一键安装Web环境，登录宝塔面板后台，地址：http://你的服务器IP/8888，输入刚才保存好的账户和密码 登录后会自动弹出安装Web环境页面，如下图所示： 可选LNMP和LAMP两种Web环境，大家按需选择（推荐选择第一个LNMP），然后点击“一键安装”，等待即可。大约需要8分钟。 五：创建站点Web环境一键安装完毕后，点击左侧“网站”—“添加站点”，如下图所示： 输入域名后，默认不会自动创建FTP和MySQL数据库，我们可以选择自动创建，方便省事，点击“提交”，创建成功后，会显示你的FTP和MySQL数据信息，例如： FTP账号资料用户：aliyunbaike_com密码：625GcrKSc3只要将网站上传至以上FTP即可访问!数据库账号资料数据库名：aliyunbaike_com用户：aliyunbaike_com密码：e8QZfQDPDT 大家将新建站点的FTP账户密码、数据库账户密码都保存好。 六：域名解析将域名解析到你的服务器IP，解析出成功后，会显示“恭喜，站点创建成功！” 七：网站安装将你的网站程序上传到域名所对应的根目录，如果是新站，输入第五步的数据库账户和密码。 ②下面稍微介绍一下如何使用阿里云服务器安装宝塔面板。 一、准备阿里云的云服务器，即 阿里云ECS，默认的用户名 root，密码的话可以修改。 远程连接云服务器使用 ssh 软件工具，使用的是公网ip。 注意事项：出于性能考虑，服务器的操作系统一定要选Linux版本（centos或者ubuntu），不要选Window。 主要步骤：拥有一台云服务器》ssh工具连接云服务器》安装宝塔面板》配置云服务器安全组(放行端口)》宝塔面板在线访问成功 二、安装面板1、使用ssh工具连接云服务器windows下可以使用XShell，macOs的可以使用终端。 因为SSH工具有很多种，找到自己用的舒服的工具就可以，不用纠结使用哪一种。 我自己是用的FinalShell这一款SSH工具来进行Linux远程连接的,如何认为不安全的话，也可以继续用Xshell，只是需要激活码,如下图 2、输入宝塔面板安装命令 温馨提示：宝塔面板最近升级到了7.0版本，Centos7以上的系统建议安装宝塔面板最新版：https://www.bt.cn/bbs/thread-19376-1-1.html（宝塔面板7.x版本，点击查看安装命令）https://www.bt.cn/bbs/thread-30562-1-1.html（宝塔面板6.x版本，点击查看安装命令） 安装方法这里也有介绍（以宝塔面板5.x版本举例）：http://www.bt.cn/bbs/thread-1186-1-1.html 以下安装命令是宝塔面板5.x版本的，请注意。如果安装出错了，就去安装宝塔面板7.x版本 Centos安装脚本： yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh Ubuntu/Deepin安装脚本： wget -O install.sh http://download.bt.cn/install/install-ubuntu.sh &amp;&amp; sudo bash install.sh Debian安装脚本： wget -O install.sh http://download.bt.cn/install/install-ubuntu.sh &amp;&amp; bash install.sh Fedora安装脚本: wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; bash install.sh 前两者偏多。根据操作系统输入不同的安装命令，然后回车 此间不需要任何操作。 3、宝塔面板安装成功稍等一分钟（有时候网速差可能久一点)，然后不要关闭窗口 最终可以看到如下界面 这里会显示宝塔后台地址和账号密码，可以手动复制到记事本暂时存起来。 三、配置安全组 如果你已经会设置安全组的话，就可以省略这一步，直接浏览器访问宝塔面板访问地址：http://云服务器公网IP地址:8888/ 上面的黄色的字也说了，如果不能访问面板，请在安全组中放行端口。 因为刚装的系统，自然也没有放行8888端口，面板后台无法打开 下面我们添加安全组 1、进入云服务器管理后台进入服务器(实例)主页，点击右边的查看更多，点击安全组配置。 2、然后可以看到一条安全组点击配置规则（如果没有就新建一条安全组） 3、点击快速创建规则 4、可以看到如下页面 常用端口可以勾选，相当于多选。也可以自定义端口，比如我们要将8888和888添加进去。 授权对象像之前已经填的 0.0.0.0/0 一样。 基本就是这样。 5、最终安全记录如下 6、浏览器访问宝塔面板成功然后我们再刷新之前的网页就能正常啦 在云服务器上安装宝塔面板成功之后，访问地址：http://云服务器公网IP地址:8888/输入安装的时候产生的默认临时账号和密码登录。登录之后，请一定记得去改账号和密码哦！ 7、修改临时账号和密码 为了安全考虑，在云服务器上安装完成宝塔面板之后，你应该马上修改你的宝塔面板登录账户和密码（注意：这个账户和密码不是宝塔面板官网的，而是每个云服务器访问宝塔面板需要用到的账户和密码） 修改账号和密码之后，后面访问登录就是你新设置的账号和密码了 8、绑定宝塔面板账号 首先解释下为什么要绑定宝塔面板账号：每一台云服务器上安装了宝塔面板之后都需要去绑定你在宝塔面板官网上注册的 宝塔账号 这样每台云服务器的宝塔面板都可以享受你这个账号付过费的服务了。 安装宝塔面板之后必做的事情：如何注册和绑定宝塔面板账号？ 9、安装LNMP网站环境LNMP网站环境是Linux+Nginx+Mysql+PHP的组合搭配网站程序环境，用来快速搭建各种开源的网站程序（WordPress,帝国CMS，织梦，Zblog等） 为什么选择LNMP? 主要归功于Nignx服务器的功能强大和性能出色，还能节省服务器内存开销。 然后会出现这个界面，需要等待十分钟左右，这会你可以去忙其它事情，过会来看。 10、安装开源建站程序完成了以上步骤之后，你就可以随心所以的基于宝塔面板来安装各种建站程序了 基于宝塔面板安装WordPress个人网站（图文教程） 基于宝塔面板搭建Typecho博客网站（图文教程） 基于宝塔面板安装Hexo个人博客（图文教程） 基于宝塔面板对WordPress网站进行备份与恢复（网站迁移教程） 宝塔面板干什么用的? 有什么优点？搭建网站为什么要用它？ 使用宝塔面板搭建网站之后的经验总结 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"},{"name":"宝塔","slug":"宝塔","permalink":"https://melodyjerry.github.io/blog/tags/%E5%AE%9D%E5%A1%94/"}]},{"title":"CentOS7操作SSH/SSHD服务(查看/启动/重启/自启)","slug":"CentOS7操作SSH、SSHD服务(查看、启动、重启、自启)","date":"2020-07-07T08:05:00.000Z","updated":"2020-07-15T07:10:03.107Z","comments":true,"path":"2020/07/07/CentOS7操作SSH、SSHD服务(查看、启动、重启、自启)/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/CentOS7%E6%93%8D%E4%BD%9CSSH%E3%80%81SSHD%E6%9C%8D%E5%8A%A1(%E6%9F%A5%E7%9C%8B%E3%80%81%E5%90%AF%E5%8A%A8%E3%80%81%E9%87%8D%E5%90%AF%E3%80%81%E8%87%AA%E5%90%AF)/","excerpt":"查看状态： systemctl status sshd.service 启动服务： systemctl start sshd.service 重启服务： systemctl restart sshd.service 开机自启： systemctl enable sshd.service","text":"查看状态： systemctl status sshd.service 启动服务： systemctl start sshd.service 重启服务： systemctl restart sshd.service 开机自启： systemctl enable sshd.service document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"CentOS服务器升级Linux版本","slug":"CentOS服务器升级Linux版本","date":"2020-07-07T06:45:00.000Z","updated":"2020-07-15T07:10:03.111Z","comments":true,"path":"2020/07/07/CentOS服务器升级Linux版本/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/CentOS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%87%E7%BA%A7Linux%E7%89%88%E6%9C%AC/","excerpt":"检查系统版本$ cat /etc/redhat-release 显示 CentOS Linux release 7.1.1503 (Core) 备份重要数据备份例如/etc、/var、/opt如果是安装在虚拟机上，那么可以使用快照进行备份。像VMware虚拟机可以快照备份，当然更奢侈一点是备份整个虚拟机。也可以针对重要程序数据进行备份，例如MySQL, Appache, Nginx, DNS等等。 运行yum命令升级$ sudo yum clean all $ sudo yum update 重启系统$ sudo reboot 查看现在系统版本$ cat /etc/redhat-release 显示 CentOS Linux release 7.8.2003 (Core)","text":"检查系统版本$ cat /etc/redhat-release 显示 CentOS Linux release 7.1.1503 (Core) 备份重要数据备份例如/etc、/var、/opt如果是安装在虚拟机上，那么可以使用快照进行备份。像VMware虚拟机可以快照备份，当然更奢侈一点是备份整个虚拟机。也可以针对重要程序数据进行备份，例如MySQL, Appache, Nginx, DNS等等。 运行yum命令升级$ sudo yum clean all $ sudo yum update 重启系统$ sudo reboot 查看现在系统版本$ cat /etc/redhat-release 显示 CentOS Linux release 7.8.2003 (Core) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"阿里云云服务器漏洞修复","slug":"阿里云云服务器漏洞修复","date":"2020-07-07T06:22:00.000Z","updated":"2020-07-15T07:10:03.412Z","comments":true,"path":"2020/07/07/阿里云云服务器漏洞修复/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D/","excerpt":"前阵子在阿里云618活动花“巨款”买下了一个T5型的云服务器，镜像版本为CentOS 7.4。由于是第一次购买阿里云的服务器，云安全中心提示需要修复的漏洞有98个，一看到就怕了，可以阿里云的修复要钱，最少都是30/台/月，耗不起。于是，百度了一下，找到了3篇有用的文章 https://www.cnblogs.com/wang-yaz/p/10563394.html https://www.cnblogs.com/ice-line/p/9590445.html https://www.v2ex.com/t/598779","text":"前阵子在阿里云618活动花“巨款”买下了一个T5型的云服务器，镜像版本为CentOS 7.4。由于是第一次购买阿里云的服务器，云安全中心提示需要修复的漏洞有98个，一看到就怕了，可以阿里云的修复要钱，最少都是30/台/月，耗不起。于是，百度了一下，找到了3篇有用的文章 https://www.cnblogs.com/wang-yaz/p/10563394.html https://www.cnblogs.com/ice-line/p/9590445.html https://www.v2ex.com/t/598779 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"Linux服务器安装Docker","slug":"Linux服务器安装Docker","date":"2020-07-07T05:56:00.000Z","updated":"2020-07-15T07:10:03.126Z","comments":true,"path":"2020/07/07/Linux服务器安装Docker/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Docker/","excerpt":"前阵子在阿里云618活动花“巨款”买下了一个T5型的云服务器，镜像版本为CentOS 7.4。现打算安装Docker。 官方文档https://docs.docker.com/install/linux/docker-ce/centos/","text":"前阵子在阿里云618活动花“巨款”买下了一个T5型的云服务器，镜像版本为CentOS 7.4。现打算安装Docker。 官方文档https://docs.docker.com/install/linux/docker-ce/centos/ 卸载旧版按官方的文档，新版Docker无法覆盖旧版的，所以无比先卸载原来的旧版本 在Linux虚拟机上，我是装有旧版的，但由于服务器是全新的，无任何配置的，可以跳过这步骤 # 移除旧版本的 Docker yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 安装 Docker 安装软件包 # 安装 Docker 依赖 yum install -y yum-utils device-mapper-persistent-data lvm2 配置阿里云Docker Yum源(个人觉的好) # 添加源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 更新 yum 缓存 yum makecache fast 安装最新版本的Docker # 安装 Docker-CE yum install -y docker-ce # 开启 Docker systemctl start docker # 安装 Docker Compose curl -L \"https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose 相关防火墙配置# Docker 和 Swarm 相关防火墙配置 systemctl status firewalld systemctl start firewalld firewall-cmd --add-port=9010/tcp --permanent firewall-cmd --add-port=9020/tcp --permanentfirewall-cmd --add-port=443/tcp --permanent firewall-cmd --add-port=80/tcp --permanent firewall-cmd --add-port=80/udp --permanentfirewall-cmd --add-port=22/tcp --permanent firewall-cmd --add-port=22/udp --permanent firewall-cmd --reload systemctl restart docker 这里说明一下如果开始 firewalld 服务被锁定Unit is masked 需要先解除锁定，然后才能开放端口 systemctl unmask firewall 开机启动# 开机自启动 systemctl enable firewalld systemctl enable docker 可能出现的问题在配置阿里云Docker Yum源时候，可能出现Loaded plugins: fastestmirror的错误提示，百度上的解决如下： 1、 # vi /etc/yum/pluginconf.d/fastestmirror.conf enabled=0 //由 1 改成0 ，禁用该插件 verbose=0 always_print_best_host = true socket_timeout=3 # Relative paths are relative to the cachedir (and so works for users as well # as root). hostfilepath=timedhosts.txt maxhostfileage=10 maxthreads=15 #exclude=.gov, facebook #include_only=.nl,.de,.uk,.ie 2、 #vi /etc/yum.conf [main] cachedir=/var/cache/yum/$basearch/$releasever keepcache=0 debuglevel=2 logfile=/var/log/yum.log exactarch=1 obsoletes=1 gpgcheck=1 plugins=1 #将plugins的值修改为0 installonly_limit=5 3、 $ yum clean dbcache 4、重新执行配置源和安装命令即可 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"https://melodyjerry.github.io/blog/tags/Docker/"}]},{"title":"服务器安装Nginx","slug":"服务器安装Nginx","date":"2020-07-07T05:26:00.000Z","updated":"2020-07-15T07:10:03.404Z","comments":true,"path":"2020/07/07/服务器安装Nginx/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Nginx/","excerpt":"图方便，用了个自动脚本： wget http://mirrors.linuxeye.com/oneinstack-full.tar.gz &amp;&amp; tar xzf oneinstack-full.tar.gz &amp;&amp; ./oneinstack/install.sh --nginx_option 1 安装 Nginx 成功，重启服务器，连接 SSH","text":"图方便，用了个自动脚本： wget http://mirrors.linuxeye.com/oneinstack-full.tar.gz &amp;&amp; tar xzf oneinstack-full.tar.gz &amp;&amp; ./oneinstack/install.sh --nginx_option 1 安装 Nginx 成功，重启服务器，连接 SSH document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"Hexo+GitEE 搭建、备份、恢复、多终端","slug":"Hexo + GitEE 搭建、备份、恢复、多终端","date":"2020-07-07T05:21:00.000Z","updated":"2020-07-15T07:10:03.114Z","comments":true,"path":"2020/07/07/Hexo + GitEE 搭建、备份、恢复、多终端/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/Hexo%20+%20GitEE%20%E6%90%AD%E5%BB%BA%E3%80%81%E5%A4%87%E4%BB%BD%E3%80%81%E6%81%A2%E5%A4%8D%E3%80%81%E5%A4%9A%E7%BB%88%E7%AB%AF/","excerpt":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 是使用的比较多的博客框架了，之所以没有使用 GitHub 而选择了码云， 我有自己的 VPS 不需要使用 GitHub Pages ，所以本文也没有关于如何使用 GitHub Pages 的教程； GitHub 上私有仓库是收费的，码云上面能创建免费的私有仓库。也有人选择使用 Docker 来创建博客环境，做镜像备份. 这里没有使用此方案，各有所好吧！","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 是使用的比较多的博客框架了，之所以没有使用 GitHub 而选择了码云， 我有自己的 VPS 不需要使用 GitHub Pages ，所以本文也没有关于如何使用 GitHub Pages 的教程； GitHub 上私有仓库是收费的，码云上面能创建免费的私有仓库。也有人选择使用 Docker 来创建博客环境，做镜像备份. 这里没有使用此方案，各有所好吧！ 1.环境主服务器系统版本与内核版本： [root@dbn- ~]# cat /etc/redhat-release CentOS Linux release 7.5.1804 (Core) [root@dbn- ~]# uname -r 3.10.0-862.3.2.el7.x86_64 测试服务器系统版本与内核版本： [root@host ~]# cat /etc/redhat-release CentOS Linux release 7.3.1611 (Core) [root@host ~]# uname -r 4.10.4-1.el7.elrepo.x86_64 2.安装2.1 wgetyum install -y wget 2.2 NodeJS# 下载nodejs最新的bin包 wget https://nodejs.org/dist/v12.18.2/node-v12.18.2-linux-x64.tar.xz # 解压 xz -d node-v12.18.2-linux-x64.tar.xz tar -xf node-v12.18.2-linux-x64.tar # 移动目录 mv node-v12.18.2-linux-x64 /usr/local/nodejs # 部署文件 ln -s /usr/local/nodejs/bin/node /usr/bin/node ln -s /usr/local/nodejs/bin/npm /usr/bin/npm 可以去官方网站下载，我这里使用的类型为：Linux Binaries (x64) 测试 [root@dbn-japan packages]# node -v v12.18.2 [root@dbn-japan packages]# npm -v 6.14.5 如果输出了版本号，说明安装成功。 2.3 Gityum install -y git 初始化设置： git config --global user.email \"vip@email.com\" git config --global user.name \"MelodyJerry\" 2.4 Hexonpm install -g hexo-cli 安装后尝试执行命令： hexo 如果出现下面的输出，按我下面的方法解决，没有则跳过。 [root@dbn-japan packages]# hexo -bash: hexo: command not found 编辑环境变量文件： vim /etc/profile ，在文件末尾增加下面设置： export PATH=$PATH:/usr/local/nodejs/lib/node_modules/hexo-cli/bin 刷新环境变量： source /etc/profile ，这时再运行命令 hexo 就会有正确的输出了。 3.配置3.1 创建项目与分支 创建新的分支：sources master：存放 Hexo 编译生成的静态资源。 sources：存放源文件，用来备份博客。 3.2 设置 SSH Key运行下面的命令创建 SSH Key，邮箱部分改成你创建账户时候的邮箱： [root@dbn-japan blog.dbnuo.org]# ssh-keygen -t rsa -C \"dbnuo@foxmail.com\" Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): # 目录 Enter passphrase (empty for no passphrase): # 输入密码，可回车跳过 Enter same passphrase again: # 再次输入密码 查看公开密钥： cat ~/.ssh/id_rsa.pub 将公开密钥添加至码云。 3.3 拉取项目跳转至网站根目录，克隆项目至本地： git clone https://gitee.com/dbnuo/bnd-hexo.git 跳转至拉取的项目目录： # 创建 hexo 目录 mkdir hexo # 进入 hexo 目录 cd hexo/ # 初始化 hexo 目录 hexo init npm install # 安装插件 npm install hexo-generator-index --save npm install hexo-generator-archive --save npm install hexo-generator-category --save npm install hexo-generator-tag --save npm install hexo-server --save npm install hexo-deployer-git --save npm install hexo-deployer-heroku --save npm install hexo-deployer-rsync --save npm install hexo-deployer-openshift --save npm install hexo-renderer-marked --save npm install hexo-renderer-stylus --save npm install hexo-generator-feed --save npm install hexo-generator-sitemap --save 4.建站先看文件夹里都有什么： [root@dbn-japan hexo]# ls -a . .. _config.yml .gitignore node_modules package.json package-lock.json scaffolds source themes _config.yml：站点的配置文件，需要备份； themes：主题文件夹，需要备份； source：博客文章的 .md 文件，需要备份； scaffolds：文章的模板，需要备份； package.json：安装包的名称，需要备份； .gitignore：限定在 push 时哪些文件可以忽略，需要备份； .git：主题和站点都有，标志这是一个 git 项目，不需要备份； node_modules：是安装包的目录，在执行 npm install 的时候会重新生成，不需要备份； public：是 hexo g 生成的静态网页，不需要备份； .deploy_git：同上，hexo g 也会生成，不需要备份； db.json：文件，不需要备份。 4.1 配置 _config.yml基础配置可以参考官方文档的配置说明。这里需要在末尾添加 Git 的配置： ...deploy: type: git repo: https://gitee.com/dbnuo/bnd-hexo.git branch: master message: 'web updata: {{now(\"YYYY-MM-DD HH/mm/ss\")}}' 4.2 生成页面并提交运行命令： hexo cl &amp;&amp; hexo g -d 输入用户名和密码后，页面代码就会提交至码云项目中。 将网站目录指定至 hexo 的 public 文件夹中，访问网站： cd hexo hexo s # hexo server 默认是4000端口 5.备份跳转至项目目录 bnd-hexo： git checkout -b sources # 创建切换分支 git push origin sources # 提交代码至分支 提交至码云项目分支： 至此搭建完毕，代码也备份到项目中了。为了测试备份恢复，我新建了个文章 test 并提交进行测试。 6.恢复切换至测试服务器，基础的安装和设置可以参考上面的流程。 跳转至网站的根目录： # 拉取项目至本地 git clone https://gitee.com/dbnuo/bnd-hexo.git # 跳转至目录 cd bnd-hexo # 创建分支并拉取 git checkout -b sources origin/sources # 跳转至源文件目录 cd hexo # 初始安装 npm install npm install hexo-generator-index --save npm install hexo-generator-archive --save npm install hexo-generator-category --save npm install hexo-generator-tag --save npm install hexo-server --save npm install hexo-deployer-git --save npm install hexo-deployer-heroku --save npm install hexo-deployer-rsync --save npm install hexo-deployer-openshift --save npm install hexo-renderer-marked --save npm install hexo-renderer-stylus --save npm install hexo-generator-feed --save npm install hexo-generator-sitemap --save 执行完毕，hexo 就恢复了，可以正常操作了。 7.多终端至此两台服务器都对一个项目库进行操作，可以说是多终端了，我在测试服务器新建了个文章： hexo new post “test2” 创建成功后提交上传。 切换回主服务器： # 跳转至项目目录 cd bnd-hexo # 拉取项目 git pull origin sources # 跳转至源文件目录 cd hexo/ # 重新编译 hexo cl &amp;&amp; hexo g -d 再访问网站： 看到这里出现了文章 test2 ，至此多终端编辑操作成功。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"服务器端简单Demo","slug":"服务器端简单Demo","date":"2020-07-07T05:05:00.000Z","updated":"2020-07-10T06:46:17.936Z","comments":true,"path":"2020/07/07/服务器端简单Demo/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%AE%80%E5%8D%95Demo/","excerpt":"","text":"void CSrvDemoDlg::OnBnClickedOk() { // TODO: 在此添加控件通知处理程序代码 //创建一个套接字的步骤 //定义套接字变量 SOCKET ls; //创建套接字 ls=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); //判断套接字是否成功，失败则退出 if(ls==INVALID_SOCKET){ printf(\"Error at socket():%d\\n\",WSAGetLastError()); WSACleanup(); return; } //绑定套接字和套接字地址 sockaddr_in sa; sa.sin_family=AF_INET; sa.sin_addr.S_un.S_addr=inet_addr(\"127.0.0.1\"); sa.sin_port=htons(12345); //判断是否绑定成功 if(bind(ls,(SOCKADDR*)&amp;sa,sizeof(sa))==SOCKET_ERROR){ printf(\"bind()failed.\\n\"); closesocket(ls); return; } //把套接字置入侦听状态 listen(ls,3); //接受连接请求 SOCKET snew; snew=accept(ls,NULL,NULL); char szmsg[50]; strcpy(szmsg,\"welcome to hgu.edu!\\r\\n\"); //发送数据 send(snew,szmsg,strlen(szmsg),0); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"JavaScript操作cookie存、取、删除实例","slug":"JavaScript操作cookie存、取、删除实例","date":"2020-07-07T04:00:00.000Z","updated":"2020-09-18T04:43:02.965Z","comments":true,"path":"2020/07/07/JavaScript操作cookie存、取、删除实例/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/07/JavaScript%E6%93%8D%E4%BD%9Ccookie%E5%AD%98%E3%80%81%E5%8F%96%E3%80%81%E5%88%A0%E9%99%A4%E5%AE%9E%E4%BE%8B/","excerpt":"function setCookie(name,value,iDay){ //设置cookie var oDate=new Date(); //创建日期对象 oDate.setDate(oDate.getDate()+iDay); //修改日期对象的天 document.cookie=name+\"=\"+value+\";expires=\"+oDate; //添加到cookie } function getCookie(name){ //根据名字获取cookie值 var arr=document.cookie.split(\"; \"); //用“; ”分割cookie字符串 var i = 0; for(i=0;i&lt;arr.length;i++){ var arr2 = arr[i].split(\"=\"); //再次分割“=” if(arr2[0]==name){ return arr2[1]; //找到则返回 } } return \"\"; //未找到返回空字符串 } function delCookie(name){ //根据名字删除cookie setCookie(name,\"0\",-1); //设置过期时间 前一天 }","text":"function setCookie(name,value,iDay){ //设置cookie var oDate=new Date(); //创建日期对象 oDate.setDate(oDate.getDate()+iDay); //修改日期对象的天 document.cookie=name+\"=\"+value+\";expires=\"+oDate; //添加到cookie } function getCookie(name){ //根据名字获取cookie值 var arr=document.cookie.split(\"; \"); //用“; ”分割cookie字符串 var i = 0; for(i=0;i&lt;arr.length;i++){ var arr2 = arr[i].split(\"=\"); //再次分割“=” if(arr2[0]==name){ return arr2[1]; //找到则返回 } } return \"\"; //未找到返回空字符串 } function delCookie(name){ //根据名字删除cookie setCookie(name,\"0\",-1); //设置过期时间 前一天 } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"}]},{"title":"平时学习用到的SQL语句","slug":"平时学习用到的SQL语句","date":"2020-07-06T06:00:00.000Z","updated":"2020-09-18T04:43:03.273Z","comments":true,"path":"2020/07/06/平时学习用到的SQL语句/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/06/%E5%B9%B3%E6%97%B6%E5%AD%A6%E4%B9%A0%E7%94%A8%E5%88%B0%E7%9A%84SQL%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"一、创建和删除数据库1、创建用户//创建用户且置密码，在MySQL中行，但在Oracle中行 ----必须在超级管理员身份下操作 create user hncu identified by '1234' 2、创建数据库//创建数据库 并手动指定编码格式 //错，因为根据手册的查询，数据库名应该在 EXISTS后面 CREATE DATABASE hncu IF NOT EXISTS DEFAULT CHARACTER SET 'utf8'; //改正： CREATE DATABASE IF NOT EXISTS hncu DEFAULT CHARACTER SET 'utf8'; 3、删除数据库DROP DATABASE mydb2; //删除数据库 //查询(显示数据库) SHOW DATABASES; /*注：用Tab键补全代码，类似MyEclipse中的Alt+/ */ 二、数据库编码问题1、指定数据库编码方法1：可以在MySQL的配置文件如my.ini中指定： default-character-set = GBK 或 default-character-set = utf8 方法2：在创建数据库时自己指定，如： CREATE DATABASE IF NOT EXISTS hncu DEFAULT CHARACTER SET 'utf8'; 相比较而言，对我们来讲，第2种方法更好。一是配置文件是平台，不能随意改，而且通常是由DBA来做的，我们没权设置，甚至MySQL都不在我们的电脑中。二是只 要我们自己在创建数据库时自己指定编码，无论平台默认配置的是什么编码，对我们没有影响，一句话不依赖你的平台—-可移置及兼容性好。 2、查看数据库编码SHOW VARIABLES; //查询系统中的所有变量 SHOW VARIABLES WHERE variable_name LIKE 'character%'; //查询系统中所有的编码方面的参数 查询结果： character_set_client utf8 //客户端编码 (不同的客户端显示的可能不一样，如cmd窗口和SQLyong) character_set_connection utf8 //客户端连接数据库时用的编码 character_set_database gbk //数据库的默认编码(一般来讲，这是由my.ini配置文件定的。这是没进数据库时的通用编码) character_set_filesystem binary //这是数据库自己存储数据文件时用的编码，跟我们关系不大 character_set_results utf8 //查询之后的结果集的编码 character_set_server gbk //MySQL数据库服务器自己的编码 iso8859-1在这里称Latin1 character_set_system utf8 character_set_dir MySQL安装目录 \\share\\charsets 对我们来讲，为了不出现乱码，必须保证client和connection的编码一致，否则就会乱码。 character_set_database 数据库的编码必须要能够支持中文，否则输入中文有问题的 3、设置（修改）数据编码//如何设置指定的编码 set character_set_client=gbk; SET character_set_client=gbk; SHOW VARIABLES WHERE variable_name LIKE 'character%'; SELECT * FROM stud;//原来的数据显示正常 INSERT INTO stud VALUES(1011,'城院',20,88,'数计学院'); SELECT * FROM stud;//刚刚插入的那条记录，是乱码 //因为我们这里client是gbk，而connection是utf8，不一致了 SET character_set_connection=gbk;//已经把client和connection设成gbk，一致了 INSERT INTO stud VALUES(1012,'城院2',20,88,'数计学院'); SELECT * FROM stud;//显示刚刚插入的那条记录，还是乱码。因为数据库表stud的编码是utf8，而我们客户端与它的连接都是gbk 综上，client、connection、我们所访问的数据库的编码 这三者都要一致且应该是支持中文的编码 上面只能保证添加到数据库中的汉字不会出现乱码。 如果读取出来，还要看results、所访问的数据库的编码和我们java代码中的解码是否一致。 三、创建表格//创建表格 CREATE TABLE stud( id INT PRIMARY KEY, sname VARCHAR(30) , age INT); -------------------------------------------------------------varchar(20) ----可变的char数组，类似Java当中的String char(20) ----固定长度的char数组 //SQL语言 全部忽略大小写----大小写不敏感 ------------------------------------------------------------- 四、对表格操作USE hncu; SHOW TABLES;//查询(显示)表格 DESC stud; //查看数据表student的表结构 1、往数据表中插入数据INSERT INTO stud VALUES( 1003,'Rose',22 ); //插入记录，当数据不全时，要指定列名 INSERT INTO stud(id,sname,age,score) VALUES(1010,'李小明',25,90);//未指定列名的方式赋值时，必须要给全，默认值不给也不行 INSERT INTO a(id,sname) VALUES(1,'Tom'); //错：UNIQUE限定该列的值必须唯一(可以为，但最多只能有一个) INSERT INTO a(id,sname) VALUES(2,'Tom'); //对，性别未赋，则用默认 //性能优化：指定列名的方式性能更好！ 2、查询数据SELECT * FROM stud;//查询表中所有的数据 SELECT sname,age FROM stud; //只查询(显示)表中的指定列 3、删除数据DELETE FROM stud WHERE age=30; //删除年龄为30的表记录 4、更新数据UPDATE stud SET sname='杰克' WHERE sname='Jack'; //更改数据 5、更改表结构ALTER TABLE (添加一列)ALTER TABLE stud ADD COLUMN score NUMERIC(4,2); ※※※※※建立联合主键※※※※※ ALTER TABLE sj ADD CONSTRAINT sj_pk PRIMARY KEY(studId,jectId); //添加外键约束1(为sj表的studId字段添加外键student(id)约束) ALTER TABLE sj ADD CONSTRAINT sj_fk1 FOREIGN KEY(studId) REFERENCES student(id); //添加外键约束2(为sj表的jectId字段添加外键ject(id)约束) ALTER TABLE sj ADD CONSTRAINT sj_fk2 FOREIGN KEY(jectId) REFERENCES ject(id); 6、创建视图CREATE VIEW studView AS SELECT * FROM stud WHERE score&gt;=60; SELECT * FROM studview; 五、对表查询操作中的那些事INSERT INTO stud VALUES(1004,'张三',38,60); INSERT INTO stud VALUES(1005,'王三',30,60); INSERT INTO stud VALUES(1006,'王五',30,60); INSERT INTO stud VALUES(1007,'王五六',30,80); ※1、范围查询//查询年龄在24-26之间的学生信息 1）连续区间内的查询 SELECT * FROM stud WHERE age&gt;=24 AND age&lt;27; 2）用BETWEEN是左右都包含，如下功能是[24,26] SELECT * FROM stud WHERE age BETWEEN 24 AND 26; 3）离散的多个 SELECT * FROM stud WHERE age=24 OR age=38; SELECT * FROM stud WHERE age IN(24,26,30); ※2、模糊查询LIKE 参数：%(任意匹配), _(匹配一个)//查询姓“王”的学生信息 SELECT * FROM stud WHERE sname LIKE '王%' //查询姓“王”且名为单字的学生信息 SELECT * FROM stud WHERE sname LIKE '王_'; //查询姓“王”且名为双字的学生信息 SELECT * FROM stud WHERE sname LIKE '王__'; //查询姓名中包含“五”字的学生信息 SELECT * FROM stud WHERE sname LIKE '%五%'; ※3、范围查询和模糊查询联合//查询姓名中包含“五”字 且 年龄大于30 的学生信息 SELECT * FROM stud WHERE sname LIKE '%五%' AND age&gt;30; ※4、空值查询//查询无名英雄学生的信息(VARCHAR) SELECT * FROM stud WHERE sname IS ; //查询没有年龄信息的学生 //错：SELECT * FROM stud WHERE age==; SELECT * FROM stud WHERE age IS ; ※5、聚合函数1）COUNT 统计表格的行数SELECT COUNT(*) AS TEMPTABLE FROM stud;//as temptable 含义：就是将查询出的结果（表格的行数）另命名为：temptable SELECT COUNT(1) AS TEMPTABLE FROM stud; //统计有年龄值的学生人数 SELECT COUNT(age) AS TEMPTABLE FROM stud; //统计有年龄值且有分数值的学生人数 SELECT COUNT(age) AS TEMPTABLE FROM stud WHERE score IS NOT ; 2）AVG 统计平均分且取整(注：AVG函数只统计非的数据记录)SELECT ROUND(AVG(score)) FROM stud; //这种方式一般不用，因为列名是自动生成的，我们在程序中不好访问 SELECT ROUND(AVG(score)) AS averageScore FROM stud; 3）SUM 分数求和SELECT SUM(score) AS ss FROM stud; 4）MAX年龄最大值SELECT MAX(age) AS maxAge FROM stud; ※6 、WHERE子句+ IN子句//查询年龄最小的那个人的名字 SELECT sname FROM stud WHERE age=(SELECT MIN(age) FROM stud); SELECT sname FROM stud WHERE age IN(SELECT MIN(age) FROM stud); ※7、排序SELECT * FROM stud GROUP BY age ASC; //不重复排序(即年龄相同的，只显示第一个0 SELECT * FROM stud GROUP BY age ASC; //显示出所有年龄段 SELECT * FROM stud ORDER BY age ASC; //普通排序--升序 SELECT * FROM stud ORDER BY age DESC; //普通排序--降序 ※8、distinct（不重复的值）SELECT DISTINCT sname,age FROM stud GROUP BY age DESC; ※9、EXISTS 判断括号内的内容是否存在—-注意，下面的例子，只要存在年龄为26的学生，就会输出所有数据SELECT * FROM stud WHERE EXISTS( SELECT * FROM stud WHERE age=26 ); ※10、演示分组ALTER TABLE stud ADD COLUMN dept VARCHAR(20); UPDATE stud SET dept='信息学院' WHERE score&gt;=65; UPDATE stud SET dept='通信学院' WHERE score=60; UPDATE stud SET dept='土木学院' WHERE score&lt;60; SELECT * FROM stud; //分组计算 //按学院计算平均分（每个学员的平均分） SELECT dept,AVG(score) AS '学院平均分' FROM stud GROUP BY dept; ※11、字符串处理函数SELECT * FROM stud WHERE sname='AAA'; SELECT * FROM stud WHERE TRIM(sname)='AAA';//去掉左右的空格 SELECT * FROM stud WHERE LTRIM(RTRIM(sname))='AAA';//和上面等价 UPDATE stud SET dept='数计学院' WHERE id=1011; SELECT LEFT(TRIM(sname),2) FROM stud; //取去掉空格后的左起2个字符 SELECT REVERSE(TRIM(sname)) FROM stud; CREATE TABLE person( id INT, sname VARCHAR(30) , age INT ); ALTER TABLE person ADD CONSTRAINT person_pk PRIMARY KEY(id);//更灵活 DROP TABLE person; sname VARCHAR(30) NOT , age INT ); //用NOT 限制非空输入 ※12、性别字段（例如：数据库存0、1 而显示出来为男、女）一般不定义成BOOLEAN型，因为有的数据库不支持，为考虑兼容，通常用CHAR(1) CREATE TABLE a( id INT UNIQUE, sname VARCHAR(10), sex CHAR(1) DEFAULT '0' ); //显示性别 (真实值与显示值之间的转换) SELECT * FROM a; SELECT id,sname,(CASE sex WHEN '0' THEN '女' WHEN '1' THEN '男' ELSE '' END) xb FROM a; SELECT id,sname,(CASE sex WHEN '0' THEN '女' WHEN '1' THEN '男' ELSE '' END) AS xb FROM a; SELECT id,sname,(CASE WHEN sex='0' THEN '女' WHEN sex='1' THEN '男' ELSE '' END) AS xb FROM a; ※13、无关子查询//需求：具有同龄人的学生 SELECT * FROM stud; SELECT * FROM stud WHERE age IN ( SELECT age FROM stud GROUP BY age HAVING COUNT(age)&gt;=2 ) ORDER BY age DESC; //练练别名 SELECT * FROM stud AS xs WHERE age IN ( SELECT age FROM xs GROUP BY age HAVING COUNT(age)&gt;=2 ) ORDER BY age DESC; //需求2：不但具有同龄人，而且年龄大于等于30的学生 //法1 SELECT * FROM stud WHERE age IN ( SELECT age FROM stud GROUP BY age HAVING COUNT(age)&gt;=2 AND age&gt;=30 ) ORDER BY age DESC; //法2 SELECT * FROM stud WHERE age&gt;=30 AND age IN ( SELECT age FROM stud GROUP BY age HAVING COUNT(age)&gt;=2 ) ORDER BY age DESC; ※14、固定搭配SELECT * FROM + WHERE + ORDER BY(要放在最后) GROUP BY + HAVING ※15、关系查询 NAME VARCHAR(10), sex CHAR(1), wife INT, husband INT ); INSERT INTO person VALUES(1,'小花','0',0,3); INSERT INTO person VALUES(2,'玉芬','0',0,4); INSERT INTO person VALUES(3,'张三','1',1,0); INSERT INTO person VALUES(4,'李四','1',2,0); INSERT INTO person VALUES(5,'王五','1',0,0); 1）一对一关系的操作：查出每对夫妻的姓名CREATE VIEW w AS SELECT * FROM person WHERE sex='0'; CREATE VIEW m AS SELECT * FROM person WHERE sex='1'; //不利用表与表之间的关系 SELECT w.NAME AS 妻子, m.NAME AS 丈夫 FROM w,m WHERE w.husband=m.id AND m.wife=w.id; //现在更先进的方式：利用表间的关系 SELECT w.NAME AS 妻子, m.NAME AS 丈夫 FROM w INNER JOIN m ON w.husband=m.id AND m.wife=w.id; SELECT * FROM person; 2）一对多的关系 代码演示//步骤1：画E-R图 //步骤2:分别建实体表，并给多方的表添加外键约束 CREATE TABLE person2( id VARCHAR(32) PRIMARY KEY, pname VARCHAR(30), sex CHAR(1) ); CREATE TABLE car( id VARCHAR(32) PRIMARY KEY, cname VARCHAR(30), price NUMERIC(10,2), pid VARCHAR(32), CONSTRAINT car_fk FOREIGN KEY(pid) REFERENCES person2(id) ); DROP TABLE car; //步骤3:为两个表添加测试数据 //实体表1 INSERT INTO person2(id,pname,sex) VALUES('P001','Jack','1'); INSERT INTO person2(id,pname,sex) VALUES('P002','Tom','1'); INSERT INTO person2(id,pname,sex) VALUES('P003','Rose','0'); INSERT INTO person2(id,pname,sex) VALUES('P004','Mary','0'); INSERT INTO person2(id,pname,sex) VALUES('P005','Mike','1'); SELECT * FROM person2; ////实体表2 INSERT INTO car(id,cname,price,pid) VALUES('C001','BMW',123.5,'P001'); INSERT INTO car(id,cname,price,pid) VALUES('C002','Benz',123.5,'P001'); INSERT INTO car(id,cname,price,pid) VALUES('C003','BMW',223.5,'P001'); INSERT INTO car(id,cname,price,pid) VALUES('C011','BMW',83.5,'P003'); INSERT INTO car(id,cname,price,pid) VALUES('C012','Benz',100,'P003'); INSERT INTO car(id,cname,price,pid) VALUES('C013','Audi',223.5,'P003'); INSERT INTO car(id,cname,price,pid) VALUES('C021','BMW',88.5,'P004'); INSERT INTO car(id,cname,price,pid) VALUES('C022','QQ',10,'P004'); INSERT INTO car(id,cname,price,pid) VALUES('C023','Audi',73,'P005'); INSERT INTO car(id,cname,price) VALUES('C033','Audi',1000); //该句代码执行错误，因为编号为P006的人在Person2表中不存在，这就是参照完整性 INSERT INTO car(id,cname,price,pid) VALUES('C033','Audi',1000,'P006'); SELECT * FROM car; //查询：哪些人有什么样的车 (用\"表名.列名\"的形式访问列，如果列名不重复，可以省略表名) //利用一方的主键和“多方”的外键进行关联 SELECT person2.pname,car.cname FROM person2,car WHERE person2.id=car.pid; //查询Jack有什么车 SELECT person2.pname,car.cname FROM person2,car WHERE person2.id=car.pid AND person2.pname='Jack' ; //查询哪些人有两辆以上的车 SELECT person2.pname,COUNT(pname) AS 车数量 FROM person2,car WHERE person2.id=car.pid GROUP BY pname HAVING COUNT(pname)&gt;=2 ORDER BY 车 数量; SELECT * FROM person2 WHERE id IN ( SELECT pid FROM car GROUP BY pid HAVING COUNT(pid)&gt;=2 ); ※16、关联查询//查询哪些人没有车 SELECT * FROM person2 WHERE id NOT IN( SELECT pid FROM car ); //用左关联(LEFT JOIN)来查询：哪些人有什么样的车(没车的也是一种情况，要显示) SELECT person2.pname,car.cname,car.price FROM person2 LEFT JOIN car ON person2.id=car.pid ORDER BY person2.id; //用内关联(INNER JOIN)来查询：哪些人有什么样的车(没车的不显示) SELECT person2.pname,car.cname,car.price FROM person2 INNER JOIN car ON person2.id=car.pid ORDER BY person2.id; //查询每辆车的销售情况(如果有主人就显示，没有则显示) SELECT person2.pname,car.cname,car.price FROM person2 RIGHT JOIN car ON person2.id=car.pid ORDER BY person2.id; （+在左边时 右关联 ，+右边时 左关联） \\-------------------------------------------------- DELETE FROM person2 WHERE id='P005'; CREATE TABLE student( id VARCHAR(32) PRIMARY KEY, NAME VARCHAR(30), CREATE TABLE ject( price NUMERIC(5,2) ); CREATE TABLE sj( studId VARCHAR(32) NOT , jectId VARCHAR(32) ); //建立联合主键 //添加测试数据 //学生表 INSERT INTO student(id,NAME,age) VALUES('S001','Jack',25); INSERT INTO student(id,NAME,age) VALUES('S002','Tom',24); INSERT INTO student(id,NAME,age) VALUES('S003','张三',23); INSERT INTO student(id,NAME,age) VALUES('S004','李四',24); INSERT INTO student(id,NAME,age) VALUES('S005','Rose',25); SELECT * FROM student; //课程表 INSERT INTO ject(id,NAME,price) VALUES('J001','Java',25); INSERT INTO ject(id,NAME,price) VALUES('J002','MySQL',30); INSERT INTO ject(id,NAME,price) VALUES('J003','Oracle',55.9); INSERT INTO ject(id,NAME,price) VALUES('J004','软件工程',20.25); INSERT INTO ject(id,NAME,price) VALUES('J005','WEB开发',125); SELECT * FROM ject; //选课表 INSERT INTO sj(studId,jectId) VALUES('S001','J001'); INSERT INTO sj(studId,jectId) VALUES('S001','J002'); INSERT INTO sj(studId,jectId) VALUES('S001','J003'); INSERT INTO sj(studId,jectId) VALUES('S002','J001'); INSERT INTO sj(studId,jectId) VALUES('S002','J003'); INSERT INTO sj(studId,jectId) VALUES('S003','J001'); INSERT INTO sj(studId,jectId) VALUES('S003','J002'); INSERT INTO sj(studId,jectId) VALUES('S004','J003'); INSERT INTO sj(studId,jectId) VALUES('S005','J001'); SELECT * FROM sj; 应用测试 //查询哪些人选了哪些课 ----要求显示：人名，课程名 //采用的是92标准 SELECT student.name,ject.NAME FROM student,ject,sj WHERE student.id=sj.studId AND sj.jectId=ject.id; //采用96标准 SELECT student.name,ject.NAME FROM student INNER JOIN sj ON student.id=sj.studId INNER JOIN ject ON sj.jectId=ject.id; //查询哪些人没有选课(左关联) SELECT student.name,ject.NAME FROM student LEFT JOIN sj ON student.id=sj.studId LEFT JOIN ject ON sj.jectId=ject.id WHERE ject.NAME IS ; //查询哪些课没人选(右关联) SELECT student.name,ject.NAME FROM student RIGHT JOIN sj ON student.id=sj.studId RIGHT JOIN ject ON sj.jectId=ject.id WHERE student.NAME IS ; //左右关联可以相互转换，如把上面的代码用左关联 SELECT student.name,ject.NAME FROM jec LEFT JOIN sj ON ject.id=sj.jectId LEFT JOIN student ON sj.studId=student.id WHERE student.NAME IS 六、存储过程//定义存储过程p1 // “DELIMITER ”当作结束标志(否则默认是把“;“号当作结束标记),这样存储过程中的语句结束符\";\"就不会当作过程的结束 记。 DELIMITER$$ CREATE PROCEDURE p1 BEGIN SELECT * FROM stud; INSERT INTO stud(id,sname,age,score,dept) VALUES(1014,'刘三丰',33,55,'通信学院'); END$$ DELIMITER; //把结束标记还原回来 CALL p1; //调用存储过程p1 1、带参数的存储过程DELIMITER$$ CREATE PROCEDURE p2(IN id INT, IN nm VARCHAR(30) ) BEGIN INSERT INTO stud(id,sname) VALUES(id,nm); END$$ DELIMITER ; DROP PROCEDURE p2; CALL p2(1015,'吊丝'); 2、有返回值的存储过程—-参数与变量问题( @变量名 ，一个@为用户变量，两个@即 @@为全局的系统变量 ) DELIMITER$$ CREATE PROCEDURE p3(IN id INT, IN nm VARCHAR(30), OUT num INT ) SELECT COUNT(*) INTO num FROM stud; CALL p3(1016,'无名',@aa); SELECT @aa; //输出变量aa的值 七、事务处理START TRANSACTION DELETE FROM stud WHERE id=1015; DELETE FROM stud WHERE id=1014; SELECT * FROM stud; ROLLBACK / COMMIT; ◎采用事务的java编程 try{ st.execute(\"START TRANSACTION;\"); st.execute(\"DELETE FROM stud WHERE id=1015;\"); st.execute(\"DELETE FROM stud WHERE id=1014;\"); .... st.execute(\" commit; \"); }catch(Exception e){ rollback;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"js正则表达式验证账号、手机号、电话和邮箱","slug":"js正则表达式验证账号、手机号、电话和邮箱","date":"2020-07-06T03:02:00.000Z","updated":"2020-09-18T04:43:03.040Z","comments":true,"path":"2020/07/06/js正则表达式验证账号、手机号、电话和邮箱/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/06/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%AA%8C%E8%AF%81%E8%B4%A6%E5%8F%B7%E3%80%81%E6%89%8B%E6%9C%BA%E5%8F%B7%E3%80%81%E7%94%B5%E8%AF%9D%E5%92%8C%E9%82%AE%E7%AE%B1/","excerpt":"","text":"验证帐号是否合法验证规则：字母、数字、下划线组成，字母开头，4-16位。 function checkUser(str){ var re = /^[a-zA-z]\\w{3,15}$/; if(re.test(str)){ alert(\"正确\"); }else{ alert(\"错误\"); } } checkUser(\"jihua_cnblogs\");//调用 验证手机号码验证规则：11位数字，以1开头。 function checkMobile(str) { var re = /^1\\d{10}$/ if (re.test(str)) { alert(\"正确\"); } else { alert(\"错误\"); } } checkMobile('13800138000'); //调用 checkMobile('139888888889');//错误示例 验证电话号码验证规则：区号+号码，区号以0开头，3位或4位号码由7位或8位数字组成区号与号码之间可以无连接符，也可以“-”连接如01088888888,010-88888888,0955-7777777 function checkPhone(str){ var re = /^0\\d{2,3}-?\\d{7,8}$/; if(re.test(str)){ alert(\"正确\"); }else{ alert(\"错误\"); } } checkPhone(\"09557777777\");//调用 验证邮箱验证规则：姑且把邮箱地址分成“第一部分@第二部分”这样第一部分：由字母、数字、下划线、短线“-”、点号“.”组成，第二部分：为一个域名，域名由字母、数字、短线“-”、域名后缀组成，而域名后缀一般为.xxx或.xxx.xx，一区的域名后缀一般为2-4位，如cn,com,net，现在域名有的也会大于4位 function checkEmail(str){ var re = /^(\\w-*\\.*)+@(\\w-?)+(\\.\\w{2,})+$/ if(re.test(str)){ alert(\"正确\"); }else{ alert(\"错误\"); } } checkEmail(\"contact@cnblogs.com\");//调用 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"}]},{"title":"Java普通类中获取Spring管理的实例 几种简单方式","slug":"Java普通类中获取Spring管理的实例-几种简单方式","date":"2020-07-01T03:44:00.000Z","updated":"2020-09-18T04:43:02.977Z","comments":true,"path":"2020/07/01/Java普通类中获取Spring管理的实例-几种简单方式/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/07/01/Java%E6%99%AE%E9%80%9A%E7%B1%BB%E4%B8%AD%E8%8E%B7%E5%8F%96Spring%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%9E%E4%BE%8B-%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E6%96%B9%E5%BC%8F/","excerpt":"","text":"第一种方式依赖于ServletContext，所以要先获取Request 在web.xml中配置springRequest监听器 &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.request.RequestContextListener &lt;/listener-class&gt; &lt;/listener&gt; 定义个静态方法调用工具类方便调用 public static Object getBean(String name) { ServletContext servletContext = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest().getServletContext(); ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(servletContext); return ac.getBean(name); } 第二种方法不依赖于servlet,不需要注入的方式 注意一点，在服务器启动时，Spring容器初始化时，不能通过以下方法获取Spring 容器 public static Object getBean2(String name) { WebApplicationContext wac = ContextLoader.getCurrentWebApplicationContext(); return wac.getBean(name); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"}]},{"title":"Git-将本地文件上传至GitHub远程仓库","slug":"Git-将本地文件上传至GitHub远程仓库","date":"2020-06-20T16:00:00.000Z","updated":"2020-09-18T04:43:02.950Z","comments":true,"path":"2020/06/21/Git-将本地文件上传至GitHub远程仓库/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/21/Git-%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%87%B3GitHub%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","excerpt":"","text":"首先你需要一个github账号，所有还没有的话先去注册吧！ https://github.com/ 我们使用git需要先安装git工具，这里给出下载地址，下载后一路直接安装即可： https://git-for-windows.github.io/ 1.进入Github首页，点击New repository新建一个项目 2.填写相应信息后点击create即可 Repository name: 仓库名称 Description(可选): 仓库描述介绍 Public, Private : 仓库权限（公开共享，私有或指定合作者） Initialize this repository with a README: 添加一个README.md gitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore license: 证书类型，对应生成文件LICENSE 4.点击Clone or dowload会出现一个地址，copy这个地址备用。 5.接下来就到本地操作了，首先右键你的项目，如果你之前安装git成功的话，右键会出现两个新选项，分别为Git Gui Here,Git Bash Here,这里我们选择Git Bash Here，进入如下界面，Test_Bluetooth即为我的项目名。 6.接下来输入如下代码（关键步骤），把github上面的仓库克隆到本地 git clone https://github.com/CKTim/BlueTooth.git（https://github.com/CKTim/BlueTooth.git替换成你之前复制的地址） 7.这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你github上面的项目名，如图我多出了个Test文件夹，我们把本地项目文件夹下的所有文件（除了新多出的那个文件夹不用），其余都复制到那个新多出的文件夹下， 8.接着继续输入命令 cd Test，进入Test文件夹 9.接下来依次输入以下代码即可完成其他剩余操作： git add . （注：别忘记后面的.，此操作是把Test文件夹下面的文件都添加进来） git commit -m “提交信息” （注：“提交信息”里面换成你需要，如“first commit”） git push -u origin master （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"Git","slug":"Git","permalink":"https://melodyjerry.github.io/blog/tags/Git/"}]},{"title":"[转]珍惜时间，做好规划——致大学过半的你们","slug":"[转]珍惜时间，做好规划——致大学过半的你们","date":"2020-06-15T12:31:00.000Z","updated":"2020-08-27T05:55:24.166Z","comments":true,"path":"2020/06/15/[转]珍惜时间，做好规划——致大学过半的你们/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/15/[%E8%BD%AC]%E7%8F%8D%E6%83%9C%E6%97%B6%E9%97%B4%EF%BC%8C%E5%81%9A%E5%A5%BD%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E8%87%B4%E5%A4%A7%E5%AD%A6%E8%BF%87%E5%8D%8A%E7%9A%84%E4%BD%A0%E4%BB%AC/","excerpt":"原文来自木木的随记 珍惜时间，做好规划 师弟师妹们好，好久不见。 时节如流，转眼我就要离开仲园， 没什么礼物送给大家， 所以决定开个班会， 给大家送（灌）点（点）干（鸡）货（汤）。 都说助班是新生大学的引路人， 当助班开始毕业的时候， 也意味着你们也离毕业不远了。","text":"原文来自木木的随记 珍惜时间，做好规划 师弟师妹们好，好久不见。 时节如流，转眼我就要离开仲园， 没什么礼物送给大家， 所以决定开个班会， 给大家送（灌）点（点）干（鸡）货（汤）。 都说助班是新生大学的引路人， 当助班开始毕业的时候， 也意味着你们也离毕业不远了。 总结与反思这个时候应该好好地反思与总结一下： 不知大家是否 还记得刚入学时对大学的向往与期待， 还记得那时候自己满怀期待立下的目标？ 而这两年的表现与收获， 符合你们的预期了吗？ 还是说这两年的大学生活 早已磨光了你们的斗志， 大家早已将自己的梦想抛到九霄云外了呢？ 这个时候应该要有点紧迫感了， 这也是我今天开这个班会的主要目的 ——提醒大家，大学的时光所剩不多了。 记得我大二结束的时候， 就感慨自己 “一事无成人渐老，一钱不值何消说”——李叔同 （斗胆引用“二一老人”李叔同的名言，学贯中西、才华横溢的弘一大师晚年说自己一事无成、一钱不值，我们足以见到弘一大师的清醒、睿智，看到了大师的谦虚与胸襟）。 大二结束，意味着大学生活过去了一半， 甚至可以说真正意义上的大学生活 已经过去三分之二了， 大四上学期做完一两个课程设计 就已经完全没有课程了。 大学时光真的很美好， 这个时候的试错成本很低， 而且有足够的时间可以只有支配， 去做自己喜欢的事情。 正因为有充足的自由支配时间， 这也是懒散和堕落的开端。 试问一下， 我们有多少同学前两年 是在宿舍追剧或者打机中度过的呢？ “往者不可谏，来者犹可追”——《论语·微子》 过去的两年已经过去了， 把握好当下， 珍惜大三大四的时间才是最重要的， 这也是大部分同学最后两年的校园时光了。 可能会有同学存在这样的疑问， “二本大学值得吗？ 学历有用吗？ 自己并不喜欢这个专业怎么办？” 其实， 学历不代表能力，但是学历可以决定选择。 一样是本科学历与学士学位， 毕业之后如果进体制内， 刚开始的待遇是同一层次的。 但如果连学位证都拿不到的人， 又哪里有资格去怀疑学历有没有用？ 至于专业方面， 本科阶段是素质教育， 对于专业知识的研究不会很深入， 更多的说的一种思维方式的训练吧， 如果真的尽力去读了， 保证课程及格肯定是没有问题的。 下面给大家分享个小故事： 杜克大学电子与计算机工程系陈怡然教授 他在清华大学读硕士期间创办了一家书店， 当时忙着创业，很少去实验室， 当然科研也就没什么进展，总躲着导师。 我（笔者按：指陈怡然）的导师是范崇澄教授，他当时是我们系的学术委员会主任，也是中国最早的美国光学学会会士之一。 有一天他实在忍不住了，给我打电话，说要找我谈谈。我当然心里发虚了，就去办公室跟他扯了一大堆，说我虽然没来实验室，没好好做科研，但是我在外面还是学到了很多大学里学不到的东西的。 范老师沉默良久，跟我说：“我认为大学之所以存在，一定有只有在这里才能学到的东西。” 这句话让我顿时醍醐灌顶，从此收拾心情，老老实实的把毕业设计做完。我后来去了美国读博士，也不再参与学术之外的留学生活动，专心科研。而我最后选择做大学老师，也跟范老师的这句话有莫大的关系。 ——（陈怡然《我在清华大学1994级毕业20周年纪念大会上的八分钟分享》） 第一次看到这个小故事的时候很有感触， 大学之所以存在， 一定有只有在这里才能学到的东西。 ——范崇澄 今天我也将这句话分享给大家。 在校园的时候就应该好好学习， 虽然说学习是一件终生的事情， 但是一旦离开了校园， 就再没有这么单纯的学习环境了。 规划下面给大家后两年的规划提供一些建议， 下列项目是按照重要程度排序的， 越靠前的项目越重要。 1、我们班目前还有6位同学没有修够学分， 争取在大三结束时将应修的学分都修够， 否则大四将会很被动， 甚至面临延迟毕业、留级、 无法取得毕业证、学位证等风险。 2、创新分。 我们平常所说的创新分全称是 “本科生课外创新实践学分”， 注意两个字“学分”， 这说明创新分是 人才培养方案规定的应修的学分， 是会影响到大家能否顺利毕业的， 跟学业分、思想分、文体分 这些综合测评加分不一样， 大家不要混淆了。 另外大家也不要把希望都寄托在讲座上， 每个讲座加0.3-0.5创新分， 修够4分至少要参加8个讲座， 讲座的加分上限是2分， 这意味着创新分不能单纯靠参加讲座来获得。 我的建议是趁着大三还有时间， 多去参加一些竞赛， 比如校级的IT文化节， 如果能够参加省部级的竞赛那更好， 竞赛方面加的创新分是没有上限限制的。 另外可以考一些资格证书来加创新分， 这个我后面的项目会详细讲。 3、CET4/CET6。 可能有些同学会认为四六级考不考无所谓， 反正日常生活中也不用英语交流， 也不影响获得学位证， 事实上这种想法是错误的！ 你现在觉得没用 只是因为你不知道哪里需要用到， 四六级证书比我们想象中更有用， 生活中需要用到四六级证书的地方有很多！ ①升学深造：考研复试的时候是比拼个人能力的时候，多一个证书就代表你比其他人强一分，通过的机会就会大一分；而想继续深造读博的话，六级高分是必不可少的，现在的博士入学大多数是“申请-考核”制，大部分学校对六级分数是有硬性要求的。 ②考公：在国考和省考，许多市级公务员考试职位表中，备注栏里明确规定大学英语水平需达到四级或六级。所以没有达到要求的同学，就算报考审核也是不会被通过的。 ③毕业求职：银行基本都对四级或者六级成绩有要求，这是明确的写在招聘条件中的，如果不满足的话，连报考的资格都没有。在互联网公司校园招聘中，许多岗位会要求：英语流利/英语口语、书面沟通流畅。四六级证书就是证明英语能力一个凭证。 其他的作用有校内综合测评加学业分等，想拿奖学金的同学争取一下。 （来源《中国建设银行广东省分行2020年度春季校园招聘公告》） （来源《中国工商银行北京市分行2020年度春季校园招聘公告》） 需要注意的一点是 四六级证书只有在校生才有资格考， 也就是说毕业了就没有资格考了！ 4、计算机等级考试（NCRE）。 报考公务员、事业单位编制、教师等 部分地区、部分岗位的门槛之一。 比如2018年天津市静海区事业单位招聘考试公告上就这样写道： 在2018江苏南京公务员考试资格复审材料要求： 其他的作用有校内综合测评加学业分等， 想拿奖学金的同学争取一下； 此外二级可以加1分创新分。 这里我推荐一下二级MsOffice项目， 主要是考Word、Excel、PowerPoint操作的， 实用性很强， 以后大家写毕业论文的时候， 格式要求比较严格， 良好的office操作技能可以减少很多工作量， 文档也会更加规范。 如果以后工作的职位是办公室职员的话， office操作技能也是必不可少的。 （来源：2020年某单位面试公告） 计算机等级考试一般一年两次， 一般在3 月和 9 月， 报名时间分别为12月和9月， 具体留意通知。 5、计算机技术与软件专业技术 资格(水平)考试（即软考）。 这个证我没有考过， 所以不是很了解。 我宿友考过， 听说不会很难的， 中级可以加2分创新分。 6、教师资格证。 现在不只师范生， 非师范生也都在大规模考教师资格证书， 那么考下这个证到底对我们有什么用呢？ ①编制教师； ②特岗教师； ③三支一扶——支教： 支教是国家考虑到农村师资配备不足，教师总体素质不高，鼓励优秀大学毕业生和城镇骨干教师到农村中小学任教的政策。支教是有服务年限的，但是福利还不错，而且服务期满考核合格后在今后工作、生活、学习和创业都会得到帮助和支持。 ④大学生志愿服务西部计划——研究生支教团： 大学生志愿服务西部计划是由国家主导，并财政拨款，从2003年起按照公开招募、自愿报名、组织选拔、集中派遣的方式，每年招募一定数量的普通高等院校应届毕业生，以志愿服务的方式到西部贫困县的乡镇从事为期1到2年的教育、卫生、农技、扶贫以及青年中心建设和管理，西部计划也是有服务年限的，并且有相应的经费保障。 教师资格证考试一般分为两个科目， 分别是综合素质、教育教学知识与能力， 中学会再加一门学科知识与教学能力 （或是试点地区自行组织）。 笔试一年有两次， 一般是上半年的3月中旬和下半年的11月中旬， 面试也是有两次， 一般是每年的5月中旬和11月中旬。 7、机动车驾驶证（驾照）。 考驾照要花费的时间挺长的， 现在空闲时间比较多， 争取考一下。 大四或者毕业后可能就没有时间了。 同样地， 证书不代表能力， 但是证书可以决定选择， 多一份证书多一个选择。 虽然能力不能完全通过证书来涵盖， 但证书绝对能证明你某些方面的能力和资格。 在大学期间努力获得各类具有含金量的证书和证明， 展现的是你在大学期间不偷懒，不堕落， 这代表了一种追求上进、不甘平凡的生活态度。 当然， 只有适合自己的证书含金量才是最高的， 千万不要盲目考证， 我上面只是提供一些建议， 大家要根据自己的实际情况和职业目标进行规划。 总的来说， 就是希望大家能够积极参加活动， 丰富个人简历， 避免到大四的时候写简历 或者就业推荐表不知道写什么的尴尬情形。 等到那个时候再后悔大学没有好好努力就有点晚了， 所以我想早点提醒你们。 还需要注意一点就是 管理好个人资料 比如获奖证书、聘书、加分证明等， 保存好电子版的材料， 因为这些材料在毕业前后 的一段时间内都有可能要用到。 创新分的审核是大四才进行的， 到时候需要自己提供加分证明。 而应聘一些岗位需要你 提供学生干部证明或者获奖证书， 万一原件遗失了或者不方便拿到， 这个时候电子版就派上用场了。 （来源《仲恺农业工程学院2020年公开招聘辅导员公告》） 寄语最后还有几点寄语送给大家： 一是保持理性，培养独立思考的能力。 尽量避开那些让你们上瘾的消极东西， 世界遵循等价交换的原则， 凡是让你上瘾的东西， 必定也让你痛苦。 二是寻找不断的正反馈，跳出负反馈的怪圈。 希望你们变得越来越好， 不断进步， 不断朝着更加优秀的方向前进。 三是保持热情，热爱生活。 虽然大三了就是老油条了， 心态肯定会发生一些变化。 但是我还是希望你们可以不忘初心， 保持你们刚来仲园时的热情。 Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul. （译文：岁月悠悠，衰微只及肌肤；热忱抛却，颓唐必致灵魂。） ——塞缪尔·厄尔曼《青春》 四是对自己前两年的大学生活 进行总结与反思。 总结自己过去两年的变化， 来到大学收获了什么， 反思有哪些做得不够好的地方。 做得不好的地方， 除了客观原因之外， 更希望可以找出主观的原因， 行有不得，反求诸己 ——《孟子·离娄上》 敢于直面自己的缺点， 这是获取更大进步的阶梯。 五是给自己列个目标清单， 并为之不断努力， 尽量减少大学的遗憾。 这个清单可以分为短期目标、中长期目标等， 例如大三要完成的事情、 毕业前要完成的事情等等。 目标很重要， 这决定了你的决心能支持你走多远。 就算这些目标没有实现， 你也已经在变优秀的路上， 有时候过程也很重要。 有些人会说 “听过许多道理，却依旧过不好这一生”。 在我看来， 依旧过不好这一生 可能是因为道理听听就过去了， 并没有用心去体会， 并且付诸实践。 最后希望你们能够 团结一致、和睦相处， 配合好班委的工作。 我们班没有经历过分班， 相对于我们院的其他班感情基础 算是比较深厚的了。 感谢大家过去两年里对我的信任， 有疑惑的时候愿意来找我解答， 我也算尽心尽力帮助大家了， 基本上是有求必应。 最后祝愿大家 在大学里都有所收获， 学有所成， 走向人生巅峰。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"【LeetCode】9. 回文数","slug":"【LeetCode】9. 回文数","date":"2020-06-10T03:58:00.000Z","updated":"2020-07-10T06:46:17.806Z","comments":true,"path":"2020/06/10/【LeetCode】9. 回文数/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/10/%E3%80%90LeetCode%E3%80%919.%20%E5%9B%9E%E6%96%87%E6%95%B0/","excerpt":"题目描述判断一个整数是否是回文数。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？","text":"题目描述判断一个整数是否是回文数。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 题解用数学方法直接计算出倒数 class Solution { public boolean isPalindrome(int x) { if(x &lt; 0) return false; int rec = 0; int num = x; while(num != 0) { rec = rec * 10 + num % 10; num /= 10; } return rec == x; } } 进阶 将整数转为字符串来解决动画：回文数的三种解法 | 法解种三的数文回：画动回文数 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"超星学习通脚本（油猴）","slug":"超星学习通脚本（油猴）","date":"2020-06-09T09:52:00.000Z","updated":"2020-07-10T06:46:17.942Z","comments":true,"path":"2020/06/09/超星学习通脚本（油猴）/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/09/%E8%B6%85%E6%98%9F%E5%AD%A6%E4%B9%A0%E9%80%9A%E8%84%9A%E6%9C%AC%EF%BC%88%E6%B2%B9%E7%8C%B4%EF%BC%89/","excerpt":"","text":"脚本①// ==UserScript== // @name 熊猫超星网课助手 // @namespace xiongmao // @version 9.0.1 // @description 自动挂机看尔雅MOOC，支持视频、音频、文档、图书自动完成，章节测验自动答题提交，支持自动切换任务点、挂机阅读时长、自动登录等，解除各类功能限制，开放自定义参数 // @author xiongmao // @match *://*.chaoxing.com/* // @match *://*.edu.cn/* // @connect api.xmlm8.com // @run-at document-end // @grant unsafeWindow // @grant GM_xmlhttpRequest // @grant GM_setClipboard // @license MIT // ==/UserScript== // 设置修改后，需要刷新或重新打开网课页面才会生效 var setting = { // 8E3 == 8000，科学记数法，表示毫秒数 time: 8E3 // 默认响应速度为8秒，不建议小于5秒 ,token: '' // 捐助用户可以使用定制功能，更精准的匹配答案，此处填写捐助后获取的识别码 ,review: 0 // 复习模式，完整挂机视频(音频)时长，支持挂机任务点已完成的视频和音频，默认关闭 ,queue: 1 // 队列模式，开启后任务点逐一完成，关闭则单页面所有任务点同时进行，默认开启 // 1代表开启，0代表关闭 ,video: 1 // 视频支持后台、切换窗口不暂停，支持多视频，默认开启 ,work: 0 // 自动答题功能(章节测验)，作业需要手动开启查询，高准确率，默认开启 ,audio: 1 // 音频自动播放，与视频功能共享vol和rate参数，默认开启 ,book: 1 // 图书阅读任务点，非课程阅读任务点，默认开启 ,docs: 1 // 文档阅读任务点，PPT类任务点自动完成阅读任务，默认开启 // 本区域参数，上方为任务点功能，下方为独立功能 ,jump: 1 // 自动切换任务点、章节、课程(需要配置course参数)，默认开启 ,read: '0' // 挂机课程阅读时间，单位是分钟，'65'代表挂机65分钟，请手动打开阅读页面，默认'0'分钟 ,face: 0 // 解除面部识别(不支持二维码类面部采集)，此功能仅为临时解除，默认关闭 ,total: 0 // 显示课程进度的统计数据，在学习进度页面的上方展示，默认关闭 // 仅开启video(audio)时，修改此处才会生效 ,line: '公网1' // 视频播放的默认资源线路，此功能适用于系统默认线路无资源，默认'公网1' ,http: '标清' // 视频播放的默认清晰度，无效参数则使用系统默认清晰度，默认'标清' // 本区域参数，上方为video功能独享，下方为audio功能共享 ,vol: '0' // 默认音量的百分数，设定范围：[0,100]，'0'为静音，默认'0' ,rate: '3' // 视频播放默认倍率，参数范围0∪[0.0625,16]，'0'为秒过，默认'1'倍 // 仅开启work时，修改此处才会生效 ,auto: 0 // 答题完成后自动提交，默认关闭 改为1开启 ,none: 0 // 无匹配答案时执行默认操作，关闭后若题目无匹配答案则会暂时保存已作答的题目，默认开启 ,scale: 0 // 富文本编辑器高度自动拉伸，用于文本类题目，答题框根据内容自动调整大小，默认关闭 // 仅开启jump时，修改此处才会生效 ,course: 0 // 当前课程完成后自动切换课程，仅支持按照根目录课程顺序切换，默认开启 ,lock: 1 // 跳过未开放(图标是锁)的章节，即闯关模式或定时发放的任务点，默认开启 // 自动登录功能配置区 ,school: '账号为手机号可以不修改此参数' // 学校/单位/机构码，要求完整有效可查询，例如'清华大学' ,username: '' // 学号/工号/借书证号(邮箱/手机号/账号)，例如'2018010101'，默认'' ,password: '' // 密码，例如'123456'，默认'' }, _self = unsafeWindow, url = location.pathname, top = _self; if (url != '/studyApp/studying' &amp;&amp; top != _self.top) document.domain = location.host.replace(/.+?\\./, ''); try { while (top != _self.top) { top = top.parent.document ? top.parent : _self.top; if (top.location.pathname == '/mycourse/studentstudy') break; } } catch (err) { // console.log(err); top = _self; } var $ = _self.jQuery || top.jQuery, parent = _self == top ? self : _self.parent, Ext = _self.Ext || parent.Ext || {}, UE = _self.UE, vjs = _self.videojs; String.prototype.toCDB = function() { return this.replace(/\\s/g, '').replace(/[\\uff01-\\uff5e]/g, function(str) { return String.fromCharCode(str.charCodeAt(0) - 65248); }).replace(/[“”]/g, '\"').replace(/[‘’]/g, \"'\").replace(/。/g, '.'); }; setting.normal = ''; // ':visible' // setting.time += Math.ceil(setting.time * Math.random()) - setting.time / 2; setting.job = [':not(*)']; setting.video &amp;&amp; setting.job.push('iframe[src*=\"/video/index.html\"]'); setting.work &amp;&amp; setting.job.push('iframe[src*=\"/work/index.html\"]'); setting.audio &amp;&amp; setting.job.push('iframe[src*=\"/audio/index.html\"]'); setting.book &amp;&amp; setting.job.push('iframe[src*=\"/innerbook/index.html\"]'); setting.docs &amp;&amp; setting.job.push('iframe[src*=\"/ppt/index.html\"]', 'iframe[src*=\"/pdf/index.html\"]'); setting.tip = !setting.queue || top != _self &amp;&amp; jobSort($ || Ext.query); if (url == '/mycourse/studentstudy') { _self.checkMobileBrowerLearn = $.noop; var classId = location.search.match(/cla[zs]{2}id=(\\d+)/i)[1] || 0, courseId = _self.courseId || location.search.match(/courseId=(\\d+)/i)[1] || 0; setting.lock || $('#coursetree').on('click', '[onclick*=void], [href*=void]', function() { _self.getTeacherAjax(courseId, classId, $(this).parent().attr('id').slice(3)); }); } else if (url == '/ananas/modules/video/index.html' &amp;&amp; setting.video) { if (setting.review) _self.greenligth = Ext.emptyFn; checkPlayer(_self.supportH5Video()); } else if (url == '/work/doHomeWorkNew' || url == '/api/work' || url == '/work/addStudentWorkNewWeb') { if (!UE) { var len = ($ || Ext.query || Array)('font:contains(未登录)', document).length; setTimeout(len == 1 ? top.location.reload : parent.greenligth, setting.time); } else if (setting.work) { setTimeout(relieveLimit, 0); beforeFind(); } } else if (url == '/ananas/modules/audio/index.html' &amp;&amp; setting.audio) { if (setting.review) _self.greenligth = Ext.emptyFn; _self.videojs = hookAudio; hookAudio.xhr = vjs.xhr; } else if (url == '/ananas/modules/innerbook/index.html' &amp;&amp; setting.book &amp;&amp; setting.tip) { setTimeout(function() { _self.setting ? _self.top.onchangepage(_self.getFrameAttr('end')) : _self.greenligth(); }, setting.time); } else if (url.match(/^\\/ananas\\/modules\\/(ppt|pdf)\\/index\\.html$/) &amp;&amp; setting.docs &amp;&amp; setting.tip) { setTimeout(function() { _self.setting ? _self.finishJob() : _self.greenligth(); }, setting.time); frameElement.setAttribute('download', 1); } else if (url == '/knowledge/cards') { $ &amp;&amp; checkToNext(); } else if (url.match(/^\\/(course|zt)\\/\\d+\\.html$/)) { setTimeout(function() { +setting.read &amp;&amp; _self.sendLogs &amp;&amp; $('.course_section:eq(0) .chapterText').click(); }, setting.time); } else if (url == '/ztnodedetailcontroller/visitnodedetail') { setting.read *= 60 / $('.course_section').length; setting.read &amp;&amp; _self.sendLogs &amp;&amp; autoRead(); } else if (url == '/mycourse/studentcourse') { var gv = location.search.match(/d=\\d+&amp;/g); setting.total &amp;&amp; $('&lt;a&gt;', { href: '/moocAnalysis/chapterStatisticByUser?classI' + gv[1] + 'courseI' + gv[0] + 'userId=' + _self.getCookie('_uid') + '&amp;ut=s', target: '_blank', title: '点击查看章节统计', style: 'margin: 0 25px;', html: '本课程共' + $('.icon').length + '节，剩余' + $('em:not(.openlock)').length + '节未完成' }).appendTo('.zt_logo').parent().width('auto'); } else if (url.match(/^\\/visit\\/(courses|interaction)$/)) { setting.face &amp;&amp; $('.zmodel').on('click', '[onclick^=openFaceTip]', DisplayURL); } else if (location.host.match(/^passport2/)) { setting.username &amp;&amp; getSchoolId(); } else if (location.hostname == 'i.mooc.chaoxing.com') { _self.layui.use('layer', function() { this.layer.open({content: '拖动进度条、倍速播放、秒过会导致不良记录！题库在慢慢补充，搜不到的题目系统会在次日进行自动补充', title: '超星网课助手提示', btn: '我已知悉', offset: 't', closeBtn: 0}); }); } else if (url == '/widget/pcvote/goStudentVotePage') { $(':checked').click(); $('.StudentTimu').each(function(index) { var ans = _self.questionlist[index].answer; $(':radio, :checkbox', this).each(function(num) { ans[num].isanswer &amp;&amp; this.click(); }); $(':text', this).val(function(num) { return $(ans[num].content).text().trim(); }); }); } else if (url == '/work/selectWorkQuestionYiPiYue') { submitAnswer(getIframe().parent(), $.extend(true, [], parent._data)); } function getIframe(tip, win, job) { if (!$) return Ext.get(frameElement || []).parent().child('.ans-job-icon') || Ext.get([]); do { win = win ? win.parent : _self; job = $(win.frameElement).prevAll('.ans-job-icon'); } while (!job.length &amp;&amp; win.parent.frameElement); return tip ? win : job; } function jobSort($) { var fn = $.fn ? [getIframe(1), 'length'] : [self, 'dom'], sel = setting.job.join(', :not(.ans-job-finished) &gt; .ans-job-icon' + setting.normal + ' ~ '); if ($(sel, fn[0].parent.document)[0] == fn[0].frameElement) return true; if (!getIframe()[fn[1]] || getIframe().parent().is('.ans-job-finished')) return null; setInterval(function() { $(sel, fn[0].parent.document)[0] == fn[0].frameElement &amp;&amp; fn[0].location.reload(); }, setting.time); } function checkPlayer(tip) { _self.videojs = hookVideo; hookVideo.xhr = vjs.xhr; Ext.isSogou = Ext.isIos = Ext.isAndroid = false; var data = Ext.decode(_self.config('data')) || {}; delete data.danmaku; data.doublespeed = 1; frameElement.setAttribute('data', Ext.encode(data)); if (tip) return; _self.supportH5Video = function() {return true;}; alert('此浏览器不支持html5播放器，请更换浏览器'); } function hookVideo() { _self.alert = console.log; var config = arguments[1], line = Ext.Array.filter(Ext.Array.map(config.playlines, function(value, index) { return value.label == setting.line &amp;&amp; index; }), function(value) { return Ext.isNumber(value); })[0] || 0, http = Ext.Array.filter(config.sources, function(value) { return value.label == setting.http; })[0]; config.playlines.unshift(config.playlines[line]); config.playlines.splice(line + 1, 1); config.plugins.videoJsResolutionSwitcher.default = http ? http.res : 360; config.plugins.studyControl.enableSwitchWindow = 1; config.plugins.timelineObjects.url = '/richvideo/initdatawithviewer?'; config.plugins.seekBarControl.enableFastForward = 1; if (!setting.queue) delete config.plugins.studyControl; // config.preload = setting.tip ? 'auto' : 'none'; var player = vjs.apply(this, arguments), a = '&lt;a href=\"https://d0.ananas.chaoxing.com/download/' + _self.config('objectid') + '\" target=\"_blank\"&gt;', img = '&lt;img src=\"https://d0.ananas.chaoxing.com/download/e363b256c0e9bc5bd8266bf99dd6d6bb\" style=\"margin: 6px 0 0 6px;\"&gt;'; player.volume(Math.round(setting.vol) / 100 || 0); Ext.get(player.controlBar.addChild('Button').el_).setHTML(a + img + '&lt;/a&gt;').dom.title = '下载视频'; player.on('loadstart', function() { setting.tip &amp;&amp; this.play().catch(Ext.emptyFn); this.playbackRate(setting.rate &gt; 16 || setting.rate &lt; 0.0625 ? 1 : setting.rate); }); player.one(['loadedmetadata', 'firstplay'], function() { setting.two = setting.rate === '0' &amp;&amp; setting.two &lt; 1; setting.two &amp;&amp; config.plugins.seekBarControl.sendLog(this.children_[0], 'ended', Math.floor(this.cache_.duration)); }); player.on('ended', function() { Ext.fly(frameElement).parent().addCls('ans-job-finished'); }); return player; } function hookAudio() { _self.alert = console.log; var config = arguments[1]; config.plugins.studyControl.enableSwitchWindow = 1; config.plugins.seekBarControl.enableFastForward = 1; if (!setting.queue) delete config.plugins.studyControl; var player = vjs.apply(this, arguments), a = '&lt;a href=\"https://d0.ananas.chaoxing.com/download/' + _self.config('objectid') + '\" target=\"_blank\"&gt;', img = '&lt;img src=\"https://d0.ananas.chaoxing.com/download/e363b256c0e9bc5bd8266bf99dd6d6bb\" style=\"margin: 6px 0 0 6px;\"&gt;'; player.volume(Math.round(setting.vol) / 100 || 0); player.playbackRate(setting.rate &gt; 16 || setting.rate &lt; 0.0625 ? 1 : setting.rate); Ext.get(player.controlBar.addChild('Button').el_).setHTML(a + img + '&lt;/a&gt;').dom.title = '下载音频'; player.on('loadeddata', function() { setting.tip &amp;&amp; this.play().catch(Ext.emptyFn); }); player.one('firstplay', function() { setting.rate === '0' &amp;&amp; config.plugins.seekBarControl.sendLog(this.children_[0], 'ended', Math.floor(this.cache_.duration)); }); player.on('ended', function() { Ext.fly(frameElement).parent().addCls('ans-job-finished'); }); return player; } function relieveLimit() { if (setting.scale) _self.UEDITOR_CONFIG.scaleEnabled = false; $.each(UE.instants, function() { var key = this.key; this.ready(function() { this.destroy(); UE.getEditor(key); }); }); } function beforeFind() { setting.regl = parent.greenligth || $.noop; if ($.type(parent._data) == 'array') return setting.regl(); setting.div = $( '&lt;div style=\"border: 2px dashed rgb(0, 85, 68); width: 330px; position: fixed; top: 0; right: 0; z-index: 99999; background-color: rgba(70, 196, 38, 0.6); overflow-x: auto;\"&gt;' + '&lt;span style=\"font-size: medium;\"&gt;&lt;/span&gt;' + '&lt;div style=\"font-size: medium;\"&gt;正在搜索答案...&lt;/div&gt;' + '&lt;button style=\"margin-right: 10px;\"&gt;暂停答题&lt;/button&gt;' + '&lt;button style=\"margin-right: 10px;\"&gt;' + (setting.auto ? '取消本次自动提交' : '开启本次自动提交') + '&lt;/button&gt;' + '&lt;button style=\"margin-right: 10px;\"&gt;重新查询&lt;/button&gt;' + '&lt;button&gt;折叠面板&lt;/button&gt;' + '&lt;div style=\"max-height: 300px; overflow-y: auto;\"&gt;' + '&lt;table border=\"1\" style=\"font-size: 12px;\"&gt;' + '&lt;thead&gt;' + '&lt;tr&gt;' + '&lt;th style=\"width: 25px; min-width: 25px;\"&gt;题号&lt;/th&gt;' + '&lt;th style=\"width: 60%; min-width: 130px;\"&gt;题目（点击可复制）&lt;/th&gt;' + '&lt;th style=\"min-width: 130px;\"&gt;答案（点击可复制）&lt;/th&gt;' + '&lt;/tr&gt;' + '&lt;/thead&gt;' + '&lt;tfoot style=\"display: none;\"&gt;' + '&lt;tr&gt;' + '&lt;th colspan=\"3\"&gt;答案提示框 已折叠&lt;/th&gt;' + '&lt;/tr&gt;' + '&lt;/tfoot&gt;' + '&lt;tbody&gt;' + '&lt;tr&gt;' + '&lt;td colspan=\"3\" style=\"display: none;\"&gt;&lt;/td&gt;' + '&lt;/tr&gt;' + '&lt;/tbody&gt;' + '&lt;/table&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;' ).appendTo('body').on('click', 'button, td', function() { var len = $(this).prevAll('button').length; if (this.nodeName == 'TD') { $(this).prev().length &amp;&amp; GM_setClipboard($(this).text()); } else if (!$(this).siblings().length) { $(this).parent().text('正在搜索答案...'); setting.num++; } else if (len === 0) { if (setting.loop) { clearInterval(setting.loop); delete setting.loop; len = ['已暂停搜索', '继续答题']; } else { setting.loop = setInterval(findAnswer, setting.time); len = ['正在搜索答案...', '暂停答题']; } setting.div.children('div:eq(0)').html(function() { return $(this).data('html') || len[0]; }).removeData('html'); $(this).html(len[1]); } else if (len == 1) { setting.auto = !setting.auto; $(this).html(setting.auto ? '取消本次自动提交' : '开启本次自动提交'); } else if (len == 2) { parent.location.reload(); } else if (len == 3) { setting.div.find('tbody, tfoot').toggle(); } }).find('table, td, th').css('border', '1px solid').end(); setting.lose = setting.num = 0; setting.data = parent._data = []; setting.over = '&lt;button style=\"margin-right: 10px;\"&gt;跳过此题&lt;/button&gt;'; setting.curs = $('script:contains(courseName)', top.document).text().match(/courseName:\\'(.+?)\\'|$/)[1] || $('h1').text().trim() || '无'; setting.loop = setInterval(findAnswer, setting.time); var tip = ({undefined: '任务点排队中', null: '等待切换中'})[setting.tip]; tip &amp;&amp; setting.div.children('div:eq(0)').data('html', tip).siblings('button:eq(0)').click(); } function findAnswer() { if (setting.num &gt;= $('.TiMu').length) { var arr = setting.lose ? ['共有 &lt;font color=\"red\"&gt;' + setting.lose + '&lt;/font&gt; 道题目待完善（已深色标注）', saveThis] : ['答题已完成', submitThis]; setting.div.children('div:eq(0)').data('html', arr[0]).siblings('button:eq(0)').hide().click(); return setTimeout(arr[1], setting.time); } var $TiMu = $('.TiMu').eq(setting.num), question = filterImg($TiMu.find('.Zy_TItle:eq(0) .clearfix')).replace(/^【.*?】\\s*/, '').replace(/\\s*（\\d+\\.\\d+分）$/, '').replace(/[(]\\s*[)]。$/,'').replace(/（\\s*）。$/,'').replace(/[(]\\s*[)]$/,'').replace(/（\\s*）$/,''), type = $TiMu.find('input[name^=answertype]:eq(0)').val() || '-1'; //setting.div.children('div:eq(0)').text(encodeURIComponent(question)+'正在搜索答案...'); GM_xmlhttpRequest({ method: 'GET', url: 'http://api.xmlm8.com/tp/tk.php?t='+ encodeURIComponent(question), headers: { 'Content-type': 'application/x-www-form-urlencoded' }, timeout: setting.time, onload: function(xhr) { if (!setting.loop) { } else if (xhr.status == 200) { var obj = $.parseJSON(xhr.responseText) || {}; if (obj.code == 1) { setting.div.children('div:eq(0)').text('正在搜索答案...'); var td = '&lt;td style=\"border: 1px solid;', answer = String(obj.answer).replace(/&amp;/g, '&amp;amp;').replace(/&lt;(?!img)/g, '&amp;lt;'); obj.answer = /^http/.test(answer) ? '&lt;img src=\"' + obj.answer + '\"&gt;' : obj.answer; $( '&lt;tr&gt;' + td + ' text-align: center;\"&gt;' + $TiMu.find('.Zy_TItle:eq(0) i').text().trim() + '&lt;/td&gt;' + td + '\" title=\"点击可复制\"&gt;' + (question.match('&lt;img') ? question : question.replace(/&amp;/g, '&amp;amp;').replace(/&lt;/g, '&amp;lt')) + '&lt;/td&gt;' + td + '\" title=\"点击可复制\"&gt;' + (/^http/.test(answer) ? obj.answer : '') + answer + '&lt;/td&gt;' + '&lt;/tr&gt;' ).appendTo(setting.div.find('tbody')).css('background-color', fillAnswer($TiMu.find('ul:eq(0)').find('li'), obj, type) ? '' : 'rgba(0, 150, 136, 0.6)'); setting.data[setting.num++] = { code: obj.code &gt; 0 ? 1 : 0, question: question, option: obj.answer, type: Number(type) }; } else { setting.div.children('div:eq(0)').html(setting.over + obj.answer || setting.over + '服务器繁忙，正在重试...'); } setting.div.children('span').html(obj.msg || ''); } else if (xhr.status == 403) { var html = xhr.responseText.indexOf('{') ? '请求过于频繁，建议稍后再试' : $.parseJSON(xhr.responseText).data; setting.div.children('div:eq(0)').data('html', html).siblings('button:eq(0)').click(); } else { setting.div.children('div:eq(0)').html(setting.over + '服务器异常，正在重试...'); } }, ontimeout: function() { setting.loop &amp;&amp; setting.div.children('div:eq(0)').html(setting.over + '服务器超时，正在重试...'); } }); } function fillAnswer($li, obj, type) { var $input = $li.find(':radio, :checkbox'), str = String(obj.answer).toCDB() || new Date().toString(), data = str.split(/#|\\x01|\\|/), opt = obj.opt || str, state = setting.lose; // $li.find(':radio:checked').prop('checked', false); obj.code &gt; 0 &amp;&amp; $input.each(function(index) { if (this.value == 'true') { data.join().match(/(^|,)(正确|是|对|√|T|ri)(,|$)/) &amp;&amp; this.click(); } else if (this.value == 'false') { data.join().match(/(^|,)(错误|否|错|×|F|wr)(,|$)/) &amp;&amp; this.click(); } else { var tip = filterImg($li.eq(index).find('.after')).toCDB() || new Date().toString(); Boolean($.inArray(tip, data) + 1 || (type == '1' &amp;&amp; str.indexOf(tip) + 1)) == this.checked || this.click(); } }).each(function() { if (!/^A?B?C?D?E?F?G?$/.test(opt)) return false; Boolean(opt.match(this.value)) == this.checked || this.click(); }); if (type.match(/^[013]$/)) { $input.is(':checked') || (setting.none ? ($input[Math.floor(Math.random() * $input.length)] || $()).click() : setting.lose++); } else if (type.match(/^(2|[4-9]|1[08])$/)) { data = String(obj.answer).split(/#|\\x01|\\|/); str = $li.end().find('textarea').each(function(index) { index = (obj.code &gt; 0 &amp;&amp; data[index]) || ''; UE.getEditor(this.name).setContent(index.trim()); }).length; (obj.code &gt; 0 &amp;&amp; data.length == str) || setting.none || setting.lose++; } else { setting.none || setting.lose++; } return state == setting.lose; } function saveThis() { if (!setting.auto) return setTimeout(saveThis, setting.time); setting.div.children('button:lt(3)').hide().eq(1).click(); _self.alert = console.log; $('#tempsave').click(); setting.regl(); } function submitThis() { if (!setting.auto) { } else if (!$('.Btn_blue_1:visible').length) { setting.div.children('button:lt(3)').hide().eq(1).click(); return setting.regl(); } else if ($('#confirmSubWin:visible').length) { var btn = $('#tipContent + * &gt; a').offset() || {top: 0, left: 0}, mouse = document.createEvent('MouseEvents'); btn = [btn.left + Math.ceil(Math.random() * 46), btn.top + Math.ceil(Math.random() * 26)]; mouse.initMouseEvent('click', true, true, document.defaultView, 0, 0, 0, btn[0], btn[1], false, false, false, false, 0, null); _self.event = $.extend(true, {}, mouse); delete _self.event.isTrusted; _self.form1submit(); } else { $('.Btn_blue_1')[0].click(); } setTimeout(submitThis, Math.ceil(setting.time * Math.random()) * 2); } function checkToNext() { var $tip = $(setting.job.join(', '), document).prevAll('.ans-job-icon' + setting.normal); setInterval(function() { $tip.parent(':not(.ans-job-finished)').length || setting.jump &amp;&amp; toNext(); }, setting.time); } function toNext() { var $cur = $('#cur' + $('#chapterIdid').val()), $tip = $('span.currents ~ span'), sel = setting.review ? 'html' : '.blue'; if (!$cur.has(sel).length &amp;&amp; $tip.length) return $tip.eq(0).click(); $tip = $('.roundpointStudent, .roundpoint').parent(); $tip = $tip.slice($tip.index($cur) + 1).not(':has(' + sel + ')'); $tip.not(setting.lock ? ':has(.lock)' : 'html').find('span').eq(0).click(); $tip.length || setting.course &amp;&amp; switchCourse(); } function switchCourse() { GM_xmlhttpRequest({ method: 'GET', url: '/visit/courses/study?isAjax=true&amp;fileId=0&amp;debug=', headers: { 'Referer': location.origin + '/visit/courses', 'X-Requested-With': 'XMLHttpRequest' }, onload: function(xhr) { var list = $('h3 a[target]', xhr.responseText).map(function() { return $(this).attr('href'); }), index = list.map(function(index) { return this.match(top.courseId) &amp;&amp; index; }).filter(function() { return $.isNumeric(this); })[0] + 1 || 0; setting.course = list[index] ? goCourse(list[index]) : 0; } }); } function goCourse(url) { GM_xmlhttpRequest({ method: 'GET', url: url, onload: function(xhr) { $.globalEval('location.href = \"' + $('.articlename a[href]', xhr.responseText).attr('href') + '\";'); } }); } function autoRead() { $('html, body').animate({ scrollTop: $(document).height() - $(window).height() }, Math.round(setting.read) * 1E3, function() { $('.nodeItem.r i').click(); }).one('click', '#top', function(event) { $(event.delegateTarget).stop(); }); } function DisplayURL() { _self.WAY.box.hide(); var $li = $(this).closest('li'); $.get('/visit/goToCourseByFace', { courseId: $li.find('input[name=courseId]').val(), clazzId: $li.find('input[name=classId]').val() }, function(data) { $li.find('[onclick^=openFaceTip]').removeAttr('onclick').attr({ target: '_blank', href: $(data).filter('script:last').text().match(/n\\(\"(.+?)\"/)[1] }); alert('本课程已临时解除面部识别'); }, 'html'); } function getSchoolId() { var school = /^1\\d{10}$/.test(setting.username) ? '' : setting.school; if (!isNaN(school)) return setTimeout(toLogin, setting.time, school); if (school == '账号为手机号可以不修改此参数') return alert('请修改school参数'); $.getJSON('/org/searchUnis?filter=' + encodeURI(school) + '&amp;product=44', function(data) { if (!data.result) return alert('学校查询错误'); var msg = $.grep(data.froms, function(value) { return value.name == school; })[0]; msg ? setTimeout(toLogin, setting.time, msg.schoolid) : alert('学校名称不完整'); }); } function toLogin(fid) { GM_xmlhttpRequest({ method: 'GET', url: '/api/login?name=' + setting.username + '&amp;pwd=' + setting.password + '&amp;schoolid=' + fid + '&amp;verify=0', onload: function(xhr) { var obj = $.parseJSON(xhr.responseText) || {}; obj.result ? location.href = decodeURIComponent($('#ref, #refer_0x001').val()) : alert(obj.errorMsg || 'Error'); } }); } function submitAnswer($job, data) { $job.removeClass('ans-job-finished'); data = data.length ? $(data) : $('.TiMu').map(function() { var title = filterImg($('.Zy_TItle .clearfix', this)); return { question: title.replace(/^【.*?】\\s*/, ''), type: ({单选题: 0, 多选题: 1, 填空题: 2, 判断题: 3})[title.match(/^【(.*?)】|$/)[1]] }; }); data = $.grep(data.map(function(index) { var $TiMu = $('.TiMu').eq(index); if (!($.isPlainObject(this) &amp;&amp; this.type &lt; 4 &amp;&amp; $TiMu.find('.fr').length)) { return false; } else if (this.type == 2) { var $ans = $TiMu.find('.Py_tk, .Py_answer').eq(0); if (!$TiMu.find('.cuo').length &amp;&amp; this.code) { return false; } else if (!$ans.find('.cuo').length) { this.option = $ans.find('.clearfix').map(function() { return $(this).text().trim(); }).get().join('#') || '无'; } else if (this.code) { this.code = -1; } else { return false; } } else if (this.type == 3) { var ans = $TiMu.find('.font20:last').text(); if ($TiMu.find('.cuo').length) { this.option = ({'√': '错误', '×': '正确'})[ans] || '无'; } else if (!this.code) { this.option = ({'√': '正确', '×': '错误'})[ans] || '无'; } else { return false; } } else { var text = $TiMu.find('.Py_answer &gt; span:eq(0)').text(); if ($TiMu.find('.dui').length &amp;&amp; this.code &amp;&amp; !/^A?B?C?D?E?F?G?$/.test(this.option)) { return false; } else if ($TiMu.find('.dui').length || text.match('正确答案')) { text = text.match(/[A-G]/gi) || []; this.option = $.map(text, function(value) { return filterImg($TiMu.find('.fl:contains(' + value + ') + a')); }).join('#') || '无'; this.key = text.join(''); } else if (this.code) { this.code = -1; } else { return false; } } return this; }), function(value) { return value &amp;&amp; value.option != '无'; }); setting.curs = $('script:contains(courseName)', top.document).text().match(/courseName:\\'(.+?)\\'|$/)[1] || $('h1').text().trim() || '无'; data.length &amp;&amp; GM_xmlhttpRequest({ method: 'POST', url: 'http://mooc.forestpolice.org/upload/cx/' + (setting.token || 0) + '/?workRelationId=' + $('#workId').val(), headers: { 'Content-type': 'application/x-www-form-urlencoded' }, data: 'course=' + encodeURIComponent(setting.curs) + '&amp;data=' + encodeURIComponent((Ext.encode || JSON.stringify)(data)) + '&amp;id=' + $('#jobid').val().slice(5) }); $job.addClass('ans-job-finished'); } /* function filterImg(dom) { return $(dom).clone().find('img[src]').replaceWith(function() { return $('&lt;p&gt;&lt;/p&gt;').text('&lt;img src=\"' + $(this).attr('src') + '\"&gt;'); }).end().find('iframe[src]').replaceWith(function() { return $('&lt;p&gt;&lt;/p&gt;').text('&lt;iframe src=\"' + $(this).attr('src') + '\"&gt;&lt;/irame&gt;'); }).end().text().trim(); } */ function filterImg(dom) { return $(dom).clone().find('img[src]').replaceWith(function() { return $('&lt;p&gt;&lt;/p&gt;').text(''); }).end().find('iframe[src]').replaceWith(function() { return $('&lt;p&gt;&lt;/p&gt;').text(''); }).end().text().trim(); } 脚本②超星学习通油猴脚本 // ==UserScript== // @name 超星网课助手(改)(查题可用) // @version 4.5.7 // @namespace coder_tq // @description 自动挂机看尔雅MOOC，支持视频、音频、文档、图书自动完成，章节测验自动答题提交，支持自动切换任务点、挂机阅读时长、自动登录等，解除各类功能限制，开放自定义参数 // @author coder_tq // @match *://*.chaoxing.com/* // @match *://*.edu.cn/* // @match *://*.nbdlib.cn/* // @match *://*.hnsyu.net/* // @connect cx.beaa.cn // @connect cx.icodef.com // @run-at document-end // @grant unsafeWindow // @grant GM_xmlhttpRequest // @grant GM_setValue // @grant GM_getValue // @grant GM_setClipboard // @license MIT // ==/UserScript== // 设置修改后，需要刷新或重新打开网课页面才会生效 var setting = { // 5E3 == 5000，科学记数法，表示毫秒数 time: 5E3 // 默认响应速度为5秒，不建议小于5秒 ,token: '' // token可以增加并发次数，用来打码，采集题库奖励 ,review: 0 // 复习模式，完整挂机视频(音频)时长，支持挂机任务点已完成的视频和音频，默认关闭 ,queue: 1 // 队列模式，开启后任务点逐一完成，关闭则单页面所有任务点同时进行，默认开启 // 1代表开启，0代表关闭 ,video: 1 // 视频支持后台、切换窗口不暂停，支持多视频，默认开启 ,work: 0 // 自动答题功能(章节测验)，作业需要手动开启查询，高准确率，默认开启 ,audio: 1 // 音频自动播放，与视频功能共享vol和rate参数，默认开启 ,book: 1 // 图书阅读任务点，非课程阅读任务点，默认开启 ,docs: 1 // 文档阅读任务点，PPT类任务点自动完成阅读任务，默认开启 // 本区域参数，上方为任务点功能，下方为独立功能 ,jump: 1 // 自动切换任务点、章节、课程(需要配置course参数)，默认开启 ,read: '65' // 挂机课程阅读时间，单位是分钟，'65'代表挂机65分钟，请手动打开阅读页面，默认'65'分钟 ,face: 1 // 解除面部识别(不支持二维码类面部采集)，此功能仅为临时解除，默认开启 ,total: 1 // 显示课程进度的统计数据，在学习进度页面的上方展示，默认开启 // 仅开启video(audio)时，修改此处才会生效 ,line: '公网1' // 视频播放的默认资源线路，此功能适用于系统默认线路无资源，默认'公网1' ,http: '标清' // 视频播放的默认清晰度，无效参数则使用系统默认清晰度，默认'标清' // 本区域参数，上方为video功能独享，下方为audio功能共享 ,vol: '0' // 默认音量的百分数，设定范围：[0,100]，'0'为静音，默认'0' ,rate: '3' // 视频播放默认倍率，参数范围0∪[0.0625,16]，'0'为秒过，默认'1'倍 // 仅开启work时，修改此处才会生效 ,auto: 0 // 答题完成后自动提交，默认关闭 ,none: 0 // 无匹配答案时执行默认操作，关闭后若题目无匹配答案则会暂时保存已作答的题目，默认开启 ,scale: 0 // 富文本编辑器高度自动拉伸，用于文本类题目，答题框根据内容自动调整大小，默认关闭 // 仅开启jump时，修改此处才会生效 ,course: 0 // 当前课程完成后自动切换课程，仅支持按照根目录课程顺序切换，默认开启 ,lock: 1 // 跳过未开放(图标是锁)的章节，即闯关模式或定时发放的任务点，默认开启 // 自动登录功能配置区 ,school: '账号为手机号可以不修改此参数' // 学校/单位/机构码，要求完整有效可查询，例如'清华大学' ,username: '' // 学号/工号/借书证号(邮箱/手机号/账号)，例如'2018010101'，默认'' ,password: '' // 密码，例如'123456'，默认'' // 题库接口配置区 ,tk_num: 0 // 题库接口，默认0 }, _self = unsafeWindow, url = location.pathname, top = _self; setting.tk_num = GM_getValue('tk_num'); setting.tk_num = setting.tk_num == undefined ? 1:setting.tk_num; setting.tk_num = isNaN(setting.tk_num)? 1:setting.tk_num; if (url != '/studyApp/studying' &amp;&amp; top != _self.top) document.domain = location.host.replace(/.+?\\./, ''); try { while (top != _self.top) { top = top.parent.document ? top.parent : _self.top; if (top.location.pathname == '/mycourse/studentstudy') break; } } catch (err) { // console.log(err); top = _self; } var $ = _self.jQuery || top.jQuery, parent = _self == top ? self : _self.parent, Ext = _self.Ext || parent.Ext || {}, UE = _self.UE, vjs = _self.videojs; String.prototype.toCDB = function() { return this.replace(/\\s/g, '').replace(/[\\uff01-\\uff5e]/g, function(str) { return String.fromCharCode(str.charCodeAt(0) - 65248); }).replace(/[“”]/g, '\"').replace(/[‘’]/g, \"'\").replace(/。/g, '.'); }; setting.normal = ''; // ':visible' // setting.time += Math.ceil(setting.time * Math.random()) - setting.time / 2; setting.job = [':not(*)']; setting.video &amp;&amp; setting.job.push('iframe[src*=\"/video/index.html\"]'); setting.work &amp;&amp; setting.job.push('iframe[src*=\"/work/index.html\"]'); setting.audio &amp;&amp; setting.job.push('iframe[src*=\"/audio/index.html\"]'); setting.book &amp;&amp; setting.job.push('iframe[src*=\"/innerbook/index.html\"]'); setting.docs &amp;&amp; setting.job.push('iframe[src*=\"/ppt/index.html\"]', 'iframe[src*=\"/pdf/index.html\"]'); setting.tip = !setting.queue || top != _self &amp;&amp; jobSort($ || Ext.query); if (url == '/mycourse/studentstudy') { _self.checkMobileBrowerLearn = $.noop; var classId = location.search.match(/cla[zs]{2}id=(\\d+)/i)[1] || 0, courseId = _self.courseId || location.search.match(/courseId=(\\d+)/i)[1] || 0; setting.lock || $('#coursetree').on('click', '[onclick*=void], [href*=void]', function() { _self.getTeacherAjax(courseId, classId, $(this).parent().attr('id').slice(3)); }); } else if (url == '/ananas/modules/video/index.html' &amp;&amp; setting.video) { if (setting.review) _self.greenligth = Ext.emptyFn; checkPlayer(_self.supportH5Video()); } else if (url == '/work/doHomeWorkNew' || url == '/api/work' || url == '/work/addStudentWorkNewWeb') { if (!UE) { var len = ($ || Ext.query || Array)('font:contains(未登录)', document).length; setTimeout(len == 1 ? top.location.reload : parent.greenligth, setting.time); } else if (setting.work) { setTimeout(relieveLimit, 0); beforeFind(); } } else if (url == '/ananas/modules/audio/index.html' &amp;&amp; setting.audio) { if (setting.review) _self.greenligth = Ext.emptyFn; _self.videojs = hookAudio; hookAudio.xhr = vjs.xhr; } else if (url == '/ananas/modules/innerbook/index.html' &amp;&amp; setting.book &amp;&amp; setting.tip) { setTimeout(function() { _self.setting ? _self.top.onchangepage(_self.getFrameAttr('end')) : _self.greenligth(); }, setting.time); } else if (url.match(/^\\/ananas\\/modules\\/(ppt|pdf)\\/index\\.html$/) &amp;&amp; setting.docs &amp;&amp; setting.tip) { setTimeout(function() { _self.setting ? _self.finishJob() : _self.greenligth(); }, setting.time); frameElement.setAttribute('download', 1); } else if (url == '/knowledge/cards') { $ &amp;&amp; checkToNext(); } else if (url.match(/^\\/(course|zt)\\/\\d+\\.html$/)) { setTimeout(function() { +setting.read &amp;&amp; _self.sendLogs &amp;&amp; $('.course_section:eq(0) .chapterText').click(); }, setting.time); } else if (url == '/ztnodedetailcontroller/visitnodedetail') { setting.read *= 60 / $('.course_section').length; setting.read &amp;&amp; _self.sendLogs &amp;&amp; autoRead(); } else if (url == '/mycourse/studentcourse') { var gv = location.search.match(/d=\\d+&amp;/g); setting.total &amp;&amp; $('&lt;a&gt;', { href: '/moocAnalysis/chapterStatisticByUser?classI' + gv[1] + 'courseI' + gv[0] + 'userId=' + _self.getCookie('_uid') + '&amp;ut=s', target: '_blank', title: '点击查看章节统计', style: 'margin: 0 25px;', html: '本课程共' + $('.icon').length + '节，剩余' + $('em:not(.openlock)').length + '节未完成' }).appendTo('.zt_logo').parent().width('auto'); } else if (url.match(/^\\/visit\\/(courses|interaction)$/)) { setting.face &amp;&amp; $('.zmodel').on('click', '[onclick^=openFaceTip]', DisplayURL); } else if (location.host.match(/^passport2/)) { setting.username &amp;&amp; getSchoolId(); } else if (location.hostname == 'i.mooc.chaoxing.com') { _self.layui.use('layer', function() { this.layer.open({content: '拖动进度条、倍速播放、秒过会导致不良记录！题库在慢慢补充，搜不到的题目系统会在次日进行自动补充', title: '超星网课助手提示', btn: '我已知悉', offset: 't', closeBtn: 0}); }); } else if (url == '/widget/pcvote/goStudentVotePage') { $(':checked').click(); $('.StudentTimu').each(function(index) { var ans = _self.questionlist[index].answer; $(':radio, :checkbox', this).each(function(num) { ans[num].isanswer &amp;&amp; this.click(); }); $(':text', this).val(function(num) { return $(ans[num].content).text().trim(); }); }); } else if (url == '/work/selectWorkQuestionYiPiYue') { submitAnswer(getIframe().parent(), $.extend(true, [], parent._data)); } function getIframe(tip, win, job) { if (!$) return Ext.get(frameElement || []).parent().child('.ans-job-icon') || Ext.get([]); do { win = win ? win.parent : _self; job = $(win.frameElement).prevAll('.ans-job-icon'); } while (!job.length &amp;&amp; win.parent.frameElement); return tip ? win : job; } function jobSort($) { var fn = $.fn ? [getIframe(1), 'length'] : [self, 'dom'], sel = setting.job.join(', :not(.ans-job-finished) &gt; .ans-job-icon' + setting.normal + ' ~ '); if ($(sel, fn[0].parent.document)[0] == fn[0].frameElement) return true; if (!getIframe()[fn[1]] || getIframe().parent().is('.ans-job-finished')) return null; setInterval(function() { $(sel, fn[0].parent.document)[0] == fn[0].frameElement &amp;&amp; fn[0].location.reload(); }, setting.time); } function checkPlayer(tip) { _self.videojs = hookVideo; hookVideo.xhr = vjs.xhr; Ext.isSogou = Ext.isIos = Ext.isAndroid = false; var data = Ext.decode(_self.config('data')) || {}; delete data.danmaku; data.doublespeed = 1; frameElement.setAttribute('data', Ext.encode(data)); if (tip) return; _self.supportH5Video = function() {return true;}; alert('此浏览器不支持html5播放器，请更换浏览器'); } function hookVideo() { _self.alert = console.log; var config = arguments[1], line = Ext.Array.filter(Ext.Array.map(config.playlines, function(value, index) { return value.label == setting.line &amp;&amp; index; }), function(value) { return Ext.isNumber(value); })[0] || 0, http = Ext.Array.filter(config.sources, function(value) { return value.label == setting.http; })[0]; config.playlines.unshift(config.playlines[line]); config.playlines.splice(line + 1, 1); config.plugins.videoJsResolutionSwitcher.default = http ? http.res : 360; config.plugins.studyControl.enableSwitchWindow = 1; config.plugins.timelineObjects.url = '/richvideo/initdatawithviewer?'; config.plugins.seekBarControl.enableFastForward = 1; if (!setting.queue) delete config.plugins.studyControl; // config.preload = setting.tip ? 'auto' : 'none'; var player = vjs.apply(this, arguments), a = '&lt;a href=\"https://d0.ananas.chaoxing.com/download/' + _self.config('objectid') + '\" target=\"_blank\"&gt;', img = '&lt;img src=\"https://d0.ananas.chaoxing.com/download/e363b256c0e9bc5bd8266bf99dd6d6bb\" style=\"margin: 6px 0 0 6px;\"&gt;'; player.volume(Math.round(setting.vol) / 100 || 0); Ext.get(player.controlBar.addChild('Button').el_).setHTML(a + img + '&lt;/a&gt;').dom.title = '下载视频'; player.on('loadstart', function() { setting.tip &amp;&amp; this.play().catch(Ext.emptyFn); this.playbackRate(setting.rate &gt; 16 || setting.rate &lt; 0.0625 ? 1 : setting.rate); }); player.one(['loadedmetadata', 'firstplay'], function() { setting.two = setting.rate === '0' &amp;&amp; setting.two &lt; 1; setting.two &amp;&amp; config.plugins.seekBarControl.sendLog(this.children_[0], 'ended', Math.floor(this.cache_.duration)); }); player.on('ended', function() { Ext.fly(frameElement).parent().addCls('ans-job-finished'); }); return player; } function hookAudio() { _self.alert = console.log; var config = arguments[1]; config.plugins.studyControl.enableSwitchWindow = 1; config.plugins.seekBarControl.enableFastForward = 1; if (!setting.queue) delete config.plugins.studyControl; var player = vjs.apply(this, arguments), a = '&lt;a href=\"https://d0.ananas.chaoxing.com/download/' + _self.config('objectid') + '\" target=\"_blank\"&gt;', img = '&lt;img src=\"https://d0.ananas.chaoxing.com/download/e363b256c0e9bc5bd8266bf99dd6d6bb\" style=\"margin: 6px 0 0 6px;\"&gt;'; player.volume(Math.round(setting.vol) / 100 || 0); player.playbackRate(setting.rate &gt; 16 || setting.rate &lt; 0.0625 ? 1 : setting.rate); Ext.get(player.controlBar.addChild('Button').el_).setHTML(a + img + '&lt;/a&gt;').dom.title = '下载音频'; player.on('loadeddata', function() { setting.tip &amp;&amp; this.play().catch(Ext.emptyFn); }); player.one('firstplay', function() { setting.rate === '0' &amp;&amp; config.plugins.seekBarControl.sendLog(this.children_[0], 'ended', Math.floor(this.cache_.duration)); }); player.on('ended', function() { Ext.fly(frameElement).parent().addCls('ans-job-finished'); }); return player; } function relieveLimit() { if (setting.scale) _self.UEDITOR_CONFIG.scaleEnabled = false; $.each(UE.instants, function() { var key = this.key; this.ready(function() { this.destroy(); UE.getEditor(key); }); }); } function beforeFind() { setting.regl = parent.greenligth || $.noop; if ($.type(parent._data) == 'array') return setting.regl(); setting.div = $( '&lt;div style=\"border: 2px dashed rgb(0, 85, 68); width: 330px; position: fixed; top: 0; right: 0; z-index: 99999; background-color: rgba(70, 196, 38, 0.6); overflow-x: auto;\"&gt;' + '&lt;span style=\"font-size: medium;\"&gt;&lt;/span&gt;' + '&lt;div style=\"font-size: medium;\"&gt;正在搜索答案...&lt;/div&gt;' + '&lt;button style=\"margin-right: 10px;\"&gt;暂停答题&lt;/button&gt;' + '&lt;button style=\"margin-right: 10px;\"&gt;' + (setting.auto ? '取消本次自动提交' : '开启本次自动提交') + '&lt;/button&gt;' + '&lt;button style=\"margin-right: 10px;\"&gt;重新查询&lt;/button&gt;' + '&lt;button&gt;折叠面板&lt;/button&gt;&lt;br&gt;' + '&lt;div style=\"font-size: medium;\"&gt;当前查题接口:'+ (setting.tk_num%2+1) + '&lt;/div&gt;' + '&lt;button id = \"next_tk\"&gt;切换为下一个查题接口&lt;/button&gt;' + '&lt;div style=\"max-height: 300px; overflow-y: auto;\"&gt;' + '&lt;table border=\"1\" style=\"font-size: 12px;\"&gt;' + '&lt;thead&gt;' + '&lt;tr&gt;' + '&lt;th style=\"width: 25px; min-width: 25px;\"&gt;题号&lt;/th&gt;' + '&lt;th style=\"width: 60%; min-width: 130px;\"&gt;题目（点击可复制）&lt;/th&gt;' + '&lt;th style=\"min-width: 130px;\"&gt;答案（点击可复制）&lt;/th&gt;' + '&lt;/tr&gt;' + '&lt;/thead&gt;' + '&lt;tfoot style=\"display: none;\"&gt;' + '&lt;tr&gt;' + '&lt;th colspan=\"3\"&gt;答案提示框 已折叠&lt;/th&gt;' + '&lt;/tr&gt;' + '&lt;/tfoot&gt;' + '&lt;tbody&gt;' + '&lt;tr&gt;' + '&lt;td colspan=\"3\" style=\"display: none;\"&gt;&lt;/td&gt;' + '&lt;/tr&gt;' + '&lt;/tbody&gt;' + '&lt;/table&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;' ).appendTo('body').on('click', 'button, td', function() { var len = $(this).prevAll('button').length; if (this.nodeName == 'TD') { $(this).prev().length &amp;&amp; GM_setClipboard($(this).text()); } else if (!$(this).siblings().length) { $(this).parent().text('正在搜索答案...'); setting.num++; } else if (len === 0) { if (setting.loop) { clearInterval(setting.loop); delete setting.loop; len = ['已暂停搜索', '继续答题']; } else { setting.loop = setInterval(findAnswer, setting.time); len = ['正在搜索答案...', '暂停答题']; } setting.div.children('div:eq(0)').html(function() { return $(this).data('html') || len[0]; }).removeData('html'); $(this).html(len[1]); } else if (len == 1) { setting.auto = !setting.auto; $(this).html(setting.auto ? '取消本次自动提交' : '开启本次自动提交'); } else if (len == 2) { parent.location.reload(); } else if (len == 3) { setting.div.find('tbody, tfoot').toggle(); } else if (len == 4) { setting.tk_num++; GM_setValue('tk_num',setting.tk_num); setting.tk_num = GM_getValue('tk_num'); console.log(setting.tk_num); parent.location.reload(); } }).find('table, td, th').css('border', '1px solid').end(); setting.lose = setting.num = 0; setting.data = parent._data = []; setting.over = '&lt;button style=\"margin-right: 10px;\"&gt;跳过此题&lt;/button&gt;'; setting.curs = $('script:contains(courseName)', top.document).text().match(/courseName:\\'(.+?)\\'|$/)[1] || $('h1').text().trim() || '无'; setting.loop = setInterval(findAnswer, setting.time); var tip = ({undefined: '任务点排队中', null: '等待切换中'})[setting.tip]; tip &amp;&amp; setting.div.children('div:eq(0)').data('html', tip).siblings('button:eq(0)').click(); } function findAnswer() { if (setting.num &gt;= $('.TiMu').length) { var arr = setting.lose ? ['共有 &lt;font color=\"red\"&gt;' + setting.lose + '&lt;/font&gt; 道题目待完善（已深色标注）', saveThis] : ['答题已完成', submitThis]; setting.div.children('div:eq(0)').data('html', arr[0]).siblings('button:eq(0)').hide().click(); return setTimeout(arr[1], setting.time); } var $TiMu = $('.TiMu').eq(setting.num), question = filterImg($TiMu.find('.Zy_TItle:eq(0) .clearfix')).replace(/^【.*?】\\s*/, '').replace(/\\s*（\\d+\\.\\d+分）$/, '').replace(/[(]\\s*[)]。$/,'').replace(/（\\s*）。$/,'').replace(/[(]\\s*[)]$/,'').replace(/（\\s*）$/,'').replace(/。$/,''), type = $TiMu.find('input[name^=answertype]:eq(0)').val() || '-1'; //setting.div.children('div:eq(0)').text(encodeURIComponent(question)+'正在搜索答案...'); switch(setting.tk_num%2) { case 0:{ GM_xmlhttpRequest({ method: 'POST', url: 'http://cx.icodef.com/wyn-nb', headers: { 'Content-type': 'application/x-www-form-urlencoded', 'Authorization': setting.token, }, data: 'question=' + encodeURIComponent(question) + '&amp;type=' + type + '&amp;id=' + ($('#workLibraryId').val() || $('#oldWorkId').val()), timeout: setting.time, onload: function(xhr) { if (!setting.loop) { } else if (xhr.status == 200) { var obj = $.parseJSON(xhr.responseText) || {}; obj.answer = obj.data; if (obj.code) { setting.div.children('div:eq(0)').text('正在搜索答案...'); var td = '&lt;td style=\"border: 1px solid;', answer = String(obj.answer).replace(/&amp;/g, '&amp;amp;').replace(/&lt;(?!img)/g, '&amp;lt;'); obj.answer = /^http/.test(answer) ? '&lt;img src=\"' + obj.answer + '\"&gt;' : obj.answer; $( '&lt;tr&gt;' + td + ' text-align: center;\"&gt;' + $TiMu.find('.Zy_TItle:eq(0) i').text().trim() + '&lt;/td&gt;' + td + '\" title=\"点击可复制\"&gt;' + (question.match('&lt;img') ? question : question.replace(/&amp;/g, '&amp;amp;').replace(/&lt;/g, '&amp;lt')) + '&lt;/td&gt;' + td + '\" title=\"点击可复制\"&gt;' + (/^http/.test(answer) ? obj.answer : '') + answer + '&lt;/td&gt;' + '&lt;/tr&gt;' ).appendTo(setting.div.find('tbody')).css('background-color', fillAnswer($TiMu.find('ul:eq(0)').find('li'), obj, type) ? '' : 'rgba(0, 150, 136, 0.6)'); setting.data[setting.num++] = { code: obj.code &gt; 0 ? 1 : 0, question: question, option: obj.answer, type: Number(type) }; } else { setting.div.children('div:eq(0)').html(obj.answer || setting.over + '服务器繁忙，正在重试...'); } setting.div.children('span').html(obj.msg || ''); } else if (xhr.status == 403) { var html = xhr.responseText.indexOf('{') ? '请求过于频繁，单击下面的切换题库接口按钮试试吧' : $.parseJSON(xhr.responseText).data; setting.div.children('div:eq(0)').data('html', html).siblings('button:eq(0)').click(); } else { setting.div.children('div:eq(0)').html('题库异常，单击下面的切换题库接口按钮试试吧...'); } }, ontimeout: function() { setting.loop &amp;&amp; setting.div.children('div:eq(0)').html(setting.over + '服务器超时，正在重试...'); } }); }; break; case 1:{ GM_xmlhttpRequest({ method: 'POST', url: 'http://cx.beaa.cn/cx.php', headers: { 'Content-type': 'application/x-www-form-urlencoded', }, data: 'content=' + encodeURIComponent(question.replace(/^&lt;img src=\"/,\"\").replace(/\"&gt;$/,\"\")), timeout: setting.time, onload: function(xhr) { if (!setting.loop) { } else if (xhr.status == 200) { var obj = $.parseJSON(xhr.responseText.replace(/^操作数据失败！/,'')) || {}; if (obj.code) { setting.div.children('div:eq(0)').text('正在搜索答案...'); var td = '&lt;td style=\"border: 1px solid;', answer = S document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Beyond Compare 4解除到期限制的技巧","slug":"Beyond Compare 4解除到期限制的技巧","date":"2020-06-08T14:50:00.000Z","updated":"2020-07-10T06:46:17.181Z","comments":true,"path":"2020/06/08/Beyond Compare 4解除到期限制的技巧/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/08/Beyond%20Compare%204%E8%A7%A3%E9%99%A4%E5%88%B0%E6%9C%9F%E9%99%90%E5%88%B6%E7%9A%84%E6%8A%80%E5%B7%A7/","excerpt":"如果提示 这个授权密钥已被吊销 ，删除 C:\\Users\\Administrator\\AppData\\Roaming\\Scooter Software\\Beyond Compare 4 目录下的文件即可（将Administrator换成自己的用户名） 如果没有输入激活码，且试用30天已到期，可以删除安装目录下 的 BCUnrar.dll 文件，发现又可以使用了，不过依然是试用。也可以删除注册表 \\HKEY_CURRENT_USER\\Software\\ScooterSoftware\\Beyond Compare 4\\CacheId ，也能够继续使用，且不会到期。","text":"如果提示 这个授权密钥已被吊销 ，删除 C:\\Users\\Administrator\\AppData\\Roaming\\Scooter Software\\Beyond Compare 4 目录下的文件即可（将Administrator换成自己的用户名） 如果没有输入激活码，且试用30天已到期，可以删除安装目录下 的 BCUnrar.dll 文件，发现又可以使用了，不过依然是试用。也可以删除注册表 \\HKEY_CURRENT_USER\\Software\\ScooterSoftware\\Beyond Compare 4\\CacheId ，也能够继续使用，且不会到期。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Java 常用资源工具集合","slug":"Java 常用资源工具集合","date":"2020-06-08T06:14:00.000Z","updated":"2020-07-10T06:46:17.294Z","comments":true,"path":"2020/06/08/Java 常用资源工具集合/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/08/Java%20%E5%B8%B8%E7%94%A8%E8%B5%84%E6%BA%90%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/","excerpt":"来源：http://rrd.me/emdDq","text":"来源：http://rrd.me/emdDq 搜索资源网站学习技术过程我们经常需要使用搜索引擎来检索资料，国内常用的也就是某度了。 当然有条件的话，搜索引擎首先还是推荐使用 Google，如果没办法使用，可以使用以下几个作为备用： BingBing 国际版：https://cn.bing.com/ 比某度好用，之前还被停用了几天，最近可以了。 DuckDuckGoDuckDuckGo：https://duckduckgo.com/ 从官网的介绍来看这个搜索引擎不收集用户信息，而且没有广告。 Stack OverflowStack Overflow：https://stackoverflow.com/ 我们如果常用 Google，很多技术问题的答案就在这个网站上，如果你无法使用 Google 可以在这个网站上直接检索就好了。 GitlogsGitlogs：https://www.gitlogs.com/ Gitlogs 是专门针对 GitHub 项目的搜索引擎，我们通过他可以快速找到想要项目。 jiumo search文档搜索引擎 jiumo search 鸠摩搜书：https://www.jiumodiary.com/ 可以用来找一些技术文档手册，很多在百度网盘里。 EbookeEbooke：https://ebookee.org/ Ebookee 是一个基于互联网并提供免费电子图书下载的搜索引擎网站。 Iconfinder图标搜索：https://www.iconfinder.com/ 用来查找 logo 图片。 TinEyeTinEye：https://www.tineye.com 用图片来检索图片，我们可以上传图片或输入图片的 URL 来检索。 SemanticScholarSemanticScholar：https://www.semanticscholar.org/ SemanticScholar 是一个免费学术搜索引擎，其检索结果来自于期刊、学术会议资料或者是学术机构的文献。 LibreStockLibreStock：https://librestock.com/ LibreStock 上可以检索一些优质的高清图片。 CC SearchCC Search：https://ccsearch.creativecommons.org/ CC Search 上搜索到的图片资源都是无版权的，我们可以免费的使用。 PexelsPexels：https://www.pexels.com/ 高质量的图片网站，可以免费使用。 UnsplashUnsplash：https://unsplash.com/ 免费高清素材网站。 The App StoreThe App Store：https://theappstore.org/ The App Store 是一个针对苹果手机、iPad、Mac 设备的应用搜索工具。 工具类图片相关工具TinyPNG：https://tinypng.com/ 免费的在线图片压缩工具，压缩率高，无损画质，直接拖拽使用，很方便。 picdiet：https://www.picdiet.com/zh-cn 独特且强悍的JavaScript 算法，能极速压缩 80% 的图片大小，而不损害其质量。 SmartResize： https://www.smartresize.com/zh-cn 这个工具基于 javascript+HTML5 编写而成的，是一个批量裁剪缩放图片的神器！ 正则表达式相关工具以下两个工具以图形的方式来展示正则表达式，更易于理解： https://regexr.com/ https://jex.im/regulex/#!flags=&amp;re=%5E(a%7Cb)*%3F%24 文件转换转换工具以下资源支持各种格式（PDF、图片、Word）相互转换。 https://smallpdf.com/cn https://convertio.co/zh/ https://www.online-convert.com/ https://www.pdftoword.com/ https://tools.pdf24.org/zh/ https://cn.office-converter.com/ 在线编译器包含前后端（php、java、c等）都可以在线运行测试 https://rextester.com/ https://www.onlinegdb.com/ https://c.runoob.com/ HTML、CSS、JS、设计类的工具JSFiddle: https://jsfiddle.net/ CodePen: https://codepen.io/ Runoob: https://c.runoob.com/front-end/61 JSON 解析器: https://c.runoob.com/front-end/53 在线 PS: http://www.kantu.com/ 表格转换工具: https://tableconvert.com/ 支持的 Markdown、HTML table、CSV 和 Excel 的相互转换。 DesignCap: https://www.designcap.com/ 在线设计海报，内置众多模板及素材。 思维导图工具推荐几款绘图工具： Xmind：https://www.xmind.cn/ 跨平台、跨终端，拥有全功能的思维导图软件。 ProcessOn：https://www.processon.com/ 免费在线作图，实时协作，支持流程图、思维导图、原型图、UML、网络拓扑图、组织结构图等。 MindMaster：https://www.edrawsoft.cn/mindmaster/ 多平台思维导图软件，可用于Windows，Mac和Linux等桌面环境，也可以在线使用或在苹果，安卓等移动端上使用。 MindMeister：https://www.mindmeister.com/zh 在线思维导图工具，已有超过1000万个用户。 百度脑图：http://naotu.baidu.com/ 简洁的在线思维导图工具 Gliffy：https://www.gliffy.com/ 我们可以在 Chrome 浏览器上安装 gliffy 插件。 可以在线创建流程图、UML图、线框图、BPNM、组织架构图等。 文档笔记平台推荐几个常用的国内外云笔记平台，比较常用的应该是印象、有道、石墨，有一些国外的访问速度比较慢，影响体验。 现在用云笔记的人应该蛮多的，可以总结归纳自己的一些知识储备或者相关的业务资料，加上他们自带的跨平台特性，用起来还是很方便的。 印象笔记：https://www.yinxiang.com/ 有道笔记：https://note.youdao.com/ OneNote：https://www.onenote.com/ 幕布：https://mubu.com/ 为知笔记：https://www.wiz.cn/ 石墨文档：https://shimo.im/ Google keep：https://keep.google.com/ Simplenote：https://simplenote.com/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"[转]一个非常实用而且精妙的算法-并查集（java语言实现）","slug":"[转]一个非常实用而且精妙的算法-并查集（java语言实现）","date":"2020-06-08T05:32:00.000Z","updated":"2020-08-27T05:55:24.155Z","comments":true,"path":"2020/06/08/[转]一个非常实用而且精妙的算法-并查集（java语言实现）/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/08/[%E8%BD%AC]%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E5%AE%9E%E7%94%A8%E8%80%8C%E4%B8%94%E7%B2%BE%E5%A6%99%E7%9A%84%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%88java%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%EF%BC%89/","excerpt":"转载：https://baijiahao.baidu.com/s?id=1651803445417553212&amp;wfr=spider&amp;for=pc 在学习数据结构的时候，老师多少会提到并查集，他的应用也是超级广泛。本文首先会通过案例来对并查集有一个介绍。然后给出并查集的java实现。","text":"转载：https://baijiahao.baidu.com/s?id=1651803445417553212&amp;wfr=spider&amp;for=pc 在学习数据结构的时候，老师多少会提到并查集，他的应用也是超级广泛。本文首先会通过案例来对并查集有一个介绍。然后给出并查集的java实现。 一、并查集原理 话说在江湖上有很多门派，这些门派相互争夺武林霸主。毕竟是江湖中人，两个人见面一言不合就开干。但是打归打，总是要判断一下是不是自己人，免得误伤。 于是乎，分了各种各样的门派，比如说张无忌和杨过俩人要打架，就先看看是不是同一门派的，不是的话那就再开干。要是张无忌和杨过觉得俩人合得来，那就合并门派。 而且规定了，每一个门派都有一个掌门人，比如武当派就是张三丰。华山派就是岳不群等等。 现在我们把目光转到并查集上。 （1）张无忌和杨过打架之前，先判断是否是同一门派，这就涉及到了并查集的查找操作。 （2）张无忌和杨过觉得俩人合得来，那就合并门派，这就涉及到了并查集的合并操作。 （3）每一个门派都有一个掌门人，这涉及到了并查集的存储方式。掌门人代表了这个门派的根节点。 现在我们从这个例子的思想开始认识一下并查集。 二、并查集简单实现 并查集主要涉及到两种操作，合并和查找。假设有一个动态集合：S={s1，s2，s3，…..sn}。在这个集合里面每一个元素都是一个江湖人物。比如S1代表了岳不群等等。 我们实现一个并查集的时候首先要考虑的就是存储结构，一般情况下有两种：数组和链表。现在我们使用数组来实现一下。 1、类架构 在上面的类中，我们只是定义了一个雏形，还没有给出一个具体的实现。下面我们针对并查集的查找和合并操作。给出以下具体的实现。 在这里数组s中存储了每一个江湖人的上级。比如说 s[i] 表示该元素 i 的上级领导。 2、构造函数实现 在前文的例子中，我们规定了每一个门派都有一个掌门人。但是在江湖开始的时候，每个人都是自成一派的，也就是每一个江湖人的上级都是他自己。 在这个构造函数里面，首先初始化了一个数组s，然后赋值numElements给count，接下来使用for循环，初始化每一个江湖人的上级都是他自己，在这里使用-1表示。 3、合并操作 Union操作就是将两个不相交的子集合合并成一个大集合。如何去合并呢？其实原理很简单，只需要把一棵子树的根结点指向 另一棵子树即可完成合并。也就是指定其中一个人是另外一个人的上级就好了。 就这一行代码就可以实现合并，但是这个方式虽然简单，但是肯定是存在着很多问题，一会再说。 4、查找操作 Find操作就是查找某个元素所在的集合，返回该集合的代表元素。通俗的理解就是根据张无忌找到其相应门派的掌门人张三丰。 到目前为止，我们可算是把并查集的基本实现都给完成了，但是前文中不是提到了嘛，合并的时候其实是有很多问题，而且查找的时候依然也有很多问题。别着急，想要我们的算法更加的高效，就必须要好好地改进一波。 三、并查集改进 1、出现问题 上面介绍的Union操作很随意：任选一棵子树，将另一棵子树的根指向它即完成了合并。也就是随意指定一个人成为另外一个人的上级。合并操作越来越多的时候，可能会出现一个非常不平衡的情况。 这就是不好的现象，而且我们想要查找节点4的根节点，就需要4–&gt;3–&gt;2–&gt;1一直不停的找，这效率真的很恶心。 1、合并操作改进 合并的时候，判断一下root1和root2谁的子节点多，谁多谁做上级领导。就好比是两个人见面合并，谁的人数，谁做大哥。 2、查找操作改进 在查找的时候，将这条路上的所有节点，全部让掌门人直接管理。这很明显改变了树的高度。 OK，并查集的基本操作就是这样。面试的时候经常会有并查集相关的题目。我总结了一部分。大概十几道题，都是力扣上的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java比较两个List集合的方法","slug":"Java实现比较两个List集合是否相等","date":"2020-06-08T05:27:00.000Z","updated":"2020-07-10T06:46:17.505Z","comments":true,"path":"2020/06/08/Java实现比较两个List集合是否相等/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/08/Java%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAList%E9%9B%86%E5%90%88%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/","excerpt":"","text":"/** * 比较两个List集合是否相等 * &lt;p&gt;注：1. 如果一个List的引用为&lt;code&gt;null&lt;/code&gt;，或者其包含的元素个数为0，那么该List在本逻辑处理中都算作空； * &lt;p&gt;2. 泛型参数E涉及到对象，所以需要确保正确实现了对应对象的&lt;code&gt;equal()&lt;/code&gt;方法。 * @param list1 * @param list2 * @return */ public static &lt;E&gt;boolean isListEqual(List&lt;E&gt; list1, List&lt;E&gt; list2) { // 两个list引用相同（包括两者都为空指针的情况） if (list1 == list2) { return true; } // 两个list都为空（包括空指针、元素个数为0） if ((list1 == null &amp;&amp; list2 != null &amp;&amp; list2.size() == 0) || (list2 == null &amp;&amp; list1 != null &amp;&amp; list1.size() == 0)) { return true; } // 两个list元素个数不相同 if (list1.size() != list2.size()) { return false; } // 两个list元素个数已经相同，再比较两者内容 // 采用这种可以忽略list中的元素的顺序 // 涉及到对象的比较是否相同时，确保实现了equals()方法 if (!list1.containsAll(list2)) { return false; } return true; } 参考参考文章两个List比较内容是否一样和Java判断2个List集合是否相等(不考虑元素的顺序)写的，主要对文章讲到的比较算法的具体实现进行了完善改造。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java比较两个List集合的方法","slug":"Java比较两个List集合的方法","date":"2020-06-08T05:25:00.000Z","updated":"2020-07-10T06:46:17.507Z","comments":true,"path":"2020/06/08/Java比较两个List集合的方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/08/Java%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAList%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.List; import java.util.Set; public class FindNumber { public static void main(String[] args) { // 注意：一定要使用创建对象的格式创建数组 Integer[] a = new Integer[] { 6, 3, 9, 3, 2, 4, 5, 7 }; Integer[] b = new Integer[] { 5, 8, 6, 2, 1, 9 }; List _a = Arrays.asList(a); List _b = Arrays.asList(b); // 创建集合 Collection realA = new ArrayList&lt;Integer&gt;(_a); Collection realB = new ArrayList&lt;Integer&gt;(_b); // 求交集 realA.retainAll(realB); System.out.println(\"交集结果：\" + realA); Set result = new HashSet(); // 求全集 result.addAll(_a); result.addAll(_b); System.out.println(\"全集结果：\" + result); // 求差集：结果 Collection aa = new ArrayList(realA); Collection bb = new ArrayList(result); bb.removeAll(aa); System.out.println(\"最终结果：\" + bb); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"【LeetCode】192周赛-5428. 重新排列数组","slug":"【LeetCode】192周赛-5428. 重新排列数组","date":"2020-06-07T03:16:00.000Z","updated":"2020-07-10T06:46:17.750Z","comments":true,"path":"2020/06/07/【LeetCode】192周赛-5428. 重新排列数组/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/07/%E3%80%90LeetCode%E3%80%91192%E5%91%A8%E8%B5%9B-5428.%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/","excerpt":"题目来自【192场周赛】 题目描述 重新排列数组 题目难度：Easy 给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。 请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。 示例 1： 输入：nums = [2,5,1,3,4,7], n = 3 输出：[2,3,5,4,1,7] 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7] 示例 2： 输入：nums = [1,2,3,4,4,3,2,1], n = 4 输出：[1,4,2,3,3,2,4,1] 示例 3： 输入：nums = [1,1,2,2], n = 2 输出：[1,2,1,2] 提示： 1 &lt;= n &lt;= 500 nums.length == 2n 1 &lt;= nums[i] &lt;= 10^3","text":"题目来自【192场周赛】 题目描述 重新排列数组 题目难度：Easy 给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。 请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。 示例 1： 输入：nums = [2,5,1,3,4,7], n = 3 输出：[2,3,5,4,1,7] 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7] 示例 2： 输入：nums = [1,2,3,4,4,3,2,1], n = 4 输出：[1,4,2,3,3,2,4,1] 示例 3： 输入：nums = [1,1,2,2], n = 2 输出：[1,2,1,2] 提示： 1 &lt;= n &lt;= 500 nums.length == 2n 1 &lt;= nums[i] &lt;= 10^3 题解思路贼简单，直接上代码： class Solution { public int[] shuffle(int[] nums, int n) { int count = (nums.length)/n; // 每轮的元素个数,n轮 int[] res = new int[nums.length]; int index = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0;j &lt;count; j++) { res[index] = nums[i + n * j]; ++index; } } return res; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode】面试题29. 顺时针打印矩阵","slug":"【LeetCode】面试题29. 顺时针打印矩阵","date":"2020-06-05T04:13:00.000Z","updated":"2020-07-10T06:46:17.848Z","comments":true,"path":"2020/06/05/【LeetCode】面试题29. 顺时针打印矩阵/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/05/%E3%80%90LeetCode%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9829.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/","excerpt":"题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制： 0 &lt;= matrix.length &lt;= 100 0 &lt;= matrix[i].length &lt;= 100注意：本题与主站 54 题相同：54. 螺旋矩阵","text":"题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制： 0 &lt;= matrix.length &lt;= 100 0 &lt;= matrix[i].length &lt;= 100注意：本题与主站 54 题相同：54. 螺旋矩阵 题解顺时针方向打印无非就是按着“右下左上”的方向进行遍历并打印，碰到边界就拐弯，然后再缩小边界。 源码有Java、C、C++两种，思路基本差不多。 class Solution { public int[] spiralOrder(int[][] matrix) { if(matrix.length == 0) return new int[0]; int l = 0, r = matrix[0].length - 1, t = 0, b = matrix.length - 1, x = 0; int[] res = new int[(r + 1) * (b + 1)]; while(true) { // left to right. for(int i = l; i &lt;= r; i++) res[x++] = matrix[t][i]; if(++t &gt; b) break; // top to bottom. for(int i = t; i &lt;= b; i++) res[x++] = matrix[i][r]; if(l &gt; --r) break; // right to left. for(int i = r; i &gt;= l; i--) res[x++] = matrix[b][i]; if(t &gt; --b) break; // bottom to top. for(int i = b; i &gt;= t; i--) res[x++] = matrix[i][l]; if(++l &gt; r) break; } return res; } } /** * Note: The returned array must be malloced, assume caller calls free(). */ int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize){ if (matrix == NULL || matrixSize == 0) { *returnSize = 0; return NULL; } *returnSize = matrixSize * matrixColSize[0]; int *res = calloc(*returnSize, sizeof(int)); int i = 0; int urow, rcol, drow, lcol, r, c; urow = -1; lcol = -1; drow = matrixSize; rcol = matrixColSize[0]; while (i &lt; *returnSize) { //right r = urow + 1; for (c = lcol + 1; i &lt; *returnSize &amp;&amp; c &lt; rcol; c++) { res[i] = matrix[r][c]; i++; } urow++; //down c = rcol - 1; for (r = urow + 1; i &lt; *returnSize &amp;&amp; r &lt; drow; r++) { res[i] = matrix[r][c]; i++; } rcol--; //left r = drow - 1; for (c = rcol - 1; i &lt; *returnSize &amp;&amp; c &gt; lcol; c--) { res[i] = matrix[r][c]; i++; } drow--; //up c = lcol + 1; for (r = drow - 1; i &lt; *returnSize &amp;&amp; r &gt; urow; r--) { res[i] = matrix[r][c]; i++; } lcol++; } return res; } class Solution { public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { // 边界情况 auto height = matrix.size(); if (!height) return {}; auto width = matrix[0].size(); if (!width) return {}; // 至少有一个元素 int dx[4]{1, 0, -1, 0}; // 代表 4 个变化方向 int dy[4]{0, 1, 0, -1}; // 同上 int d = 0; // 记录当前方向 int h = 0, w = 0; // 记录当前索引 int cycle = 0; // 记录当前是第几轮 vector&lt;int&gt; ans; for (int i = 0; i != height * width; ++i) { // 到达右边界 if (!d &amp;&amp; w &gt;= width - 1 - cycle) d = ++d % 4; // 到达下边界 if (d == 1 &amp;&amp; h &gt;= height - 1 - cycle) d = ++d % 4; // 到达左边界 if (d == 2 &amp;&amp; w &lt;= cycle) d = ++d % 4; // 到达上边界 if (d == 3 &amp;&amp; h &lt;= cycle + 1) { d = ++d % 4; // 进入下一轮 ++cycle; } ans.push_back(matrix[h][w]); h += dy[d]; w += dx[d]; } return ans; } }; 推荐极力推荐两个我喜欢的算法公众号的文章： 面试题29. 顺时针打印矩阵 顺时针打印矩阵 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"[转]什么是动态规划（Dynamic Programming）？动态规划的意义是什么？","slug":"[转]什么是动态规划（Dynamic Programming）？动态规划的意义是什么？","date":"2020-06-04T04:50:00.000Z","updated":"2020-08-27T05:55:24.158Z","comments":true,"path":"2020/06/04/[转]什么是动态规划（Dynamic Programming）？动态规划的意义是什么？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/04/[%E8%BD%AC]%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88Dynamic%20Programming%EF%BC%89%EF%BC%9F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"什么是动态规划（Dynamic Programming）？动态规划的意义是什么？https://github.com/melodyjerry/GitHub520)","text":"什么是动态规划（Dynamic Programming）？动态规划的意义是什么？https://github.com/melodyjerry/GitHub520) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"提高GitHub的访问速度(DNS实现)","slug":"提高GitHub的访问速度(DNS实现)","date":"2020-06-02T07:32:00.000Z","updated":"2020-07-10T06:46:17.924Z","comments":true,"path":"2020/06/02/提高GitHub的访问速度(DNS实现)/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/02/%E6%8F%90%E9%AB%98GitHub%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6(DNS%E5%AE%9E%E7%8E%B0)/","excerpt":"通过修改Hosts，文件路径C:\\Windows\\System32\\drivers\\etc\\hosts Linux 系统：/etc/hostsAndroid（安卓）系统：/system/etc/hosts 复制、粘贴： # GitHub520 Host Start 185.199.108.154 github.githubassets.com 199.232.68.133 camo.githubusercontent.com 199.232.68.133 github.map.fastly.net 199.232.69.194 github.global.ssl.fastly.net 140.82.112.3 github.com 140.82.114.5 api.github.com 199.232.68.133 raw.githubusercontent.com 199.232.68.133 favicons.githubusercontent.com 199.232.68.133 avatars5.githubusercontent.com 199.232.68.133 avatars4.githubusercontent.com 199.232.68.133 avatars3.githubusercontent.com 199.232.68.133 avatars2.githubusercontent.com 199.232.68.133 avatars1.githubusercontent.com 199.232.68.133 avatars0.githubusercontent.com # GitHub520 Host End 一般是立刻生效。没有的话，手动在 CMD 敲入：ipconfig /flushdns 更多前往GitHub让你“爱”上 GitHub，解决访问时图裂、加载慢的问题。","text":"通过修改Hosts，文件路径C:\\Windows\\System32\\drivers\\etc\\hosts Linux 系统：/etc/hostsAndroid（安卓）系统：/system/etc/hosts 复制、粘贴： # GitHub520 Host Start 185.199.108.154 github.githubassets.com 199.232.68.133 camo.githubusercontent.com 199.232.68.133 github.map.fastly.net 199.232.69.194 github.global.ssl.fastly.net 140.82.112.3 github.com 140.82.114.5 api.github.com 199.232.68.133 raw.githubusercontent.com 199.232.68.133 favicons.githubusercontent.com 199.232.68.133 avatars5.githubusercontent.com 199.232.68.133 avatars4.githubusercontent.com 199.232.68.133 avatars3.githubusercontent.com 199.232.68.133 avatars2.githubusercontent.com 199.232.68.133 avatars1.githubusercontent.com 199.232.68.133 avatars0.githubusercontent.com # GitHub520 Host End 一般是立刻生效。没有的话，手动在 CMD 敲入：ipconfig /flushdns 更多前往GitHub让你“爱”上 GitHub，解决访问时图裂、加载慢的问题。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"Github","slug":"Github","permalink":"https://melodyjerry.github.io/blog/tags/Github/"}]},{"title":"[转]剑指offer第二版总结——基于牛客网","slug":"[转]剑指offer第二版总结——基于牛客网","date":"2020-06-02T07:22:00.000Z","updated":"2020-08-27T05:55:24.260Z","comments":true,"path":"2020/06/02/[转]剑指offer第二版总结——基于牛客网/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/02/[%E8%BD%AC]%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E7%89%9B%E5%AE%A2%E7%BD%91/","excerpt":"","text":"剑指offer第二版总结——基于牛客网1. 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。public class Solution { public boolean Find(int target, int [][] array) { int row = array.length; int col = array[0].length; // 从数组的左下角（或者右上角开始判断） int i = row-1, j = 0; while( i&gt;=0 &amp;&amp; j&lt; col) { if( target == array[i][j]) { return true; } if( target &gt; array[i][j] ){ j++; } else { i--; } } return false; } } 注解：解题的关键在于找到排好序的规则，左下角和右上角的位置数正好处于一个可以通过大小进行判断上下走向。 2. 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。public class Solution { public String replaceSpace(StringBuffer str) { if(str.length() == 0 ) return \"\"; // 找出被替换字符的数目，java可以省略这一步。 int numOfEmpty = 0; for(int i =0; i&lt;str.length(); i++ ) { if( str.charAt(i) == ' ') numOfEmpty++; } // 若是C++可以根据numOfEmpty开辟新空间，而java可以直接使用StringBuffer StringBuffer outStr = new StringBuffer(); for(int i = 0; i&lt;str.length(); i++ ) { if( str.charAt(i) == ' ') outStr.append(\"%20\"); else outStr.append(str.charAt(i)); } return outStr.toString(); } } 3. 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。/** * public class ListNode { * int val; * ListNode next = null; * * ListNode(int val) { * this.val = val; * } * } */ import java.util.Stack; import java.util.ArrayList; public class Solution { public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) { ArrayList&lt;Integer&gt; arrayList= new ArrayList&lt;&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); if(listNode == null) return arrayList; // 遍历链表存入stack中 while( listNode.next != null ) { stack.push(listNode.val); listNode = listNode.next; } stack.push(listNode.val); // 将stack中的数据放入ArrayList中 while( !stack.isEmpty() ) { arrayList.add(stack.pop()); } return arrayList; } } 4. 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。/** * Definition for binary tree * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ public class Solution { public TreeNode reConstructBinaryTree(int [] pre,int [] in) { TreeNode rootNode=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); return rootNode; } private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) { if(startPre&gt;endPre||startIn&gt;endIn)return null; // 新建根节点 TreeNode rootNode=new TreeNode(pre[startPre]); for(int i=startIn;i&lt;=endIn;i++){ // 找到中序中的根节点 if(in[i]==pre[startPre]){ rootNode.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1); rootNode.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn); } } return rootNode; } } 5. 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。import java.util.Stack; public class Solution { Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); // 在一个stack中进 public void push(int node) { stack1.push(node); } // 从stack2中出，若stack2为空，则从stack1中把数据输出到stack2中 public int pop() { if(stack2.isEmpty()) { while(!stack1.isEmpty()) { stack2.push(stack1.pop()); } } return stack2.pop(); } } 注解：先进后出两次为先进先出。 6. 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。import java.util.ArrayList; public class Solution { public int minNumberInRotateArray(int [] array) { if(array.length == 0) return 0; int left = 0; int right = array.length - 1; // 折半查找 while(left &lt; right) { int mid = (left + right) / 2; // 统一与右边比 if(array[mid] &gt; array[right]) { left = mid + 1; } else if(array[mid] &lt; array[right]){ // 存在向下取整的情况 right = mid; } else { // 相等的情况 right--; } } return array[left]; } } 7. 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39public class Solution { public int Fibonacci(int n) { if(n&lt;=0) return 0; if(n&lt;=2)return 1; int preNum =1; int pre2Num =1; int outNum = 0; for(int i = 3; i&lt;=n; i++){ outNum = preNum + pre2Num; pre2Num = preNum; preNum = outNum; } return outNum; } } 8. 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。public class Solution { public int JumpFloor(int target) { if(target&lt;=0) return 0; if(target&lt;=2) return target; int preNum =2; int pre2Num =1; int outNum = 0; for(int i = 3; i&lt;=target; i++){ outNum = preNum + pre2Num; pre2Num = preNum; preNum = outNum; } return outNum; } } 9. 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。public class Solution { public int JumpFloorII(int target) { if(target&lt;=0) return 0; return 1&lt;&lt;(--target); } } 注解：f(n) = f(n-1)+f(n-2)…f(1)+1; 由于f(1)=1，递推可得：f(n)=2^(n-1); 10. 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？public class Solution { public int RectCover(int target) { if(target&lt;=0) return 0; if(target&lt;=2) return target; int preNum =2; int pre2Num =1; int outNum = 0; for(int i = 3; i&lt;=target; i++){ outNum = preNum + pre2Num; pre2Num = preNum; preNum = outNum; } return outNum; } } 注解：这题和青蛙跳没区别。 11. 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。public class Solution { public int NumberOf1(int n) { int temp = 1; int count1 = 0; while(temp!=0) { if( (temp&amp;n)!=0 ) count1++; // 移动1，避免出现负数移动补1的情况 temp = temp &lt;&lt;1; } return count1; } } 12. 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。public class Solution { public double Power(double base, int exponent) { if(exponent==0) return 1; // 由于要考虑正负数，先统一绝对值计算 int absE = Math.abs(exponent); if(exponent&lt;0) { return 1/subPower(base,absE); } else{ return subPower(base,absE); } } public double subPower(double base, int exponent) { if( exponent&gt;1 ){ //折半乘，提高效率 if( exponent%2 != 0) { return base * subPower(base, exponent/2) * subPower(base, exponent/2); } else{ return subPower(base, exponent/2) * subPower(base, exponent/2); } } return base; } } 13. 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。import java.util.LinkedList; import java.util.Queue; public class Solution { public void reOrderArray(int [] array) { Queue&lt;Integer&gt; queue1 = new LinkedList&lt;Integer&gt;(); Queue&lt;Integer&gt; queue2 = new LinkedList&lt;Integer&gt;(); for(int i=0;i&lt;array.length;i++){ if(array[i]%2==1){ queue1.add(array[i]); } else { queue2.add(array[i]); } } for(int i=0;i&lt;array.length;i++){ if(!queue1.isEmpty()) { array[i]=queue1.poll(); } else { array[i]=queue2.poll(); } } } } 14. 输入一个链表，输出该链表中倒数第k个结点。/* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ // 双指针实现 public class Solution { public ListNode FindKthToTail(ListNode head,int k) { if ( head == null || k &lt;= 0) { return null; } ListNode fastHead = head; // 先走k-1步 for(int i=1; i&lt; k; i++) { if(fastHead.next != null) { fastHead = fastHead.next; } else{ return null; } } // 以前走 while(fastHead.next != null){ head = head.next; fastHead = fastHead.next; } return head; } } 15. 输入一个链表，反转链表后，输出新链表的表头。/* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { public ListNode ReverseList(ListNode head) { if ( head == null ) { return null; } // 需要前一个，当前，后一个，三个节点处理转向. ListNode preNode = head; ListNode nextNode = null; //处理首节点 if(head.next != null){ head = head.next; preNode.next = null; } else{ return head; } // 递归处理 while(head.next != null) { nextNode = head.next; head.next = preNode; preNode = head; head = nextNode; } // 尾节点处理 head.next = preNode; return head; } } 16. 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。/* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { public ListNode Merge(ListNode list1,ListNode list2) { if(list1 ==null){ return list2; } if(list2 ==null){ return list1; } ListNode head = new ListNode(0); ListNode indexNode = head; while(list1 != null &amp;&amp; list2 !=null){ if(list1.val &lt;= list2.val){ indexNode.next = list1; list1 = list1.next; } else{ indexNode.next = list2; list2 = list2.next; } indexNode = indexNode.next; } if(list1 == null){ indexNode.next = list2; } else{ indexNode.next = list1; } return head.next; } } 17. 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）/** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public boolean HasSubtree(TreeNode root1,TreeNode root2) { if(root1 == null || root2 == null){ return false; } if( root1.val == root2.val ){ if(sameHasSubtree( root1.left, root2.left) &amp;&amp; sameHasSubtree( root1.right, root2.right)){ return true; } } if( HasSubtree(root1.left,root2) || HasSubtree(root1.right,root2)){ return true; } return false; } public boolean sameHasSubtree(TreeNode root1,TreeNode root2) { if(root2 == null){ return true; } if(root1 == null){ return false; } if( root1.val == root2.val){ if(sameHasSubtree( root1.left, root2.left) &amp;&amp; sameHasSubtree( root1.right, root2.right)){ return true; } } return false; } } 18. 操作给定的二叉树，将其变换为源二叉树的镜像。public class Solution { public void Mirror(TreeNode root) { if(root == null){ return ; } if(root.left != null ){ Mirror(root.left); } if(root.right != null){ Mirror(root.right); } TreeNode temp = root.left; root.left = root.right; root.right = temp; } } 19. 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.import java.util.ArrayList; public class Solution { public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) { if(matrix == null){ return null; } ArrayList&lt;Integer&gt; outList = new ArrayList&lt;&gt;(); int row = matrix.length; int col = matrix[0].length; // 分四个方向讨论遍历，注意截止条件就好。 int left = 0,top = 0,bottom = row - 1,right = col - 1; while(left &lt;= right &amp;&amp; top &lt;= bottom){ for(int i = left;i&lt;=right;i++){ outList.add(matrix[top][i]); } for(int j = top+1;j&lt;=bottom;j++){ outList.add(matrix[j][right]); } if (top != bottom){ for(int t = right-1;t&gt;=left;t--){ outList.add(matrix[bottom][t]); } } if(left != right){ for(int k = bottom-1;k&gt;top;k--){ outList.add(matrix[k][left]); } } top++;left++;right--;bottom--; } return outList; } } 20. 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。import java.util.Stack; public class Solution { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;(); public void push(int node) { stack.push(node); if( minStack.isEmpty() || node &lt; minStack.peek()){ minStack.push(node); } else{ minStack.push(minStack.peek()); // 压自己 } } public void pop() { stack.pop(); minStack.pop(); } public int top() { return stack.peek(); } public int min() { return minStack.peek(); } } 21. 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）import java.util.ArrayList; import java.util.Stack; public class Solution { public boolean IsPopOrder(int [] pushA,int [] popA) { if(pushA.length != popA.length || pushA.length&lt;=0 || popA.length&lt;=0){ return false; } Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(pushA[0]); for (int i = 0,j = 0; i &lt; popA.length; i++) { while (j &lt; popA.length &amp;&amp; stack.peek() != popA[i]) { stack.push(pushA[j++]); } if(stack.peek() != popA[i]){ return false; } stack.pop(); } return true; } } 22. 从上往下打印出二叉树的每个节点，同层节点从左至右打印。import java.util.LinkedList; import java.util.Queue; public class Solution { public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) { Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(root != null){ list.add(root.val); if( root.left != null){ queue.add(root.left); } if( root.right != null){ queue.add(root.right); } root = queue.poll(); } return list; } } 23. 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。public class Solution { public boolean VerifySquenceOfBST(int [] sequence) { if(sequence.length == 0) return false; return IsTreeBST(sequence, 0, sequence.length-1); } public boolean IsTreeBST(int [] sequence,int start,int end ){ if(end &lt;= start) return true; for (int i = start; i &lt; end; i++) { if(sequence[i] &gt; sequence[end]) break; } // 验证后面的是否都大于根值 for (int j = i; j &lt; end; j++) { if(sequence[j] &lt; sequence[end]) return false; } return IsTreeBST(sequence, start, i-1) &amp;&amp; IsTreeBST(sequence, i, end-1); } } 24. 输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)import java.util.ArrayList; public class Solution { public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) { ArrayList&lt;Integer&gt; a1=new ArrayList&lt;Integer&gt;(); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arr=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); path( root, target, arr, a1); return arr; } public void path(TreeNode root, int target, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arr, ArrayList&lt;Integer&gt; a1 ){ if(root==null){ return ; } target -= root.val; a1.add(root.val); if(root.left!=null){ path( root.left, target, arr, a1); } if(root.right!=null){ path( root.right, target, arr, a1); } if(root.left==null &amp;&amp; root.right==null &amp;&amp; target==0){ arr.add(new ArrayList&lt;Integer&gt;(a1)); } a1.remove(a1.size()-1); } } 注解：本题为保证数组长度大的在前也通过，若需要保证，只要加一级的排序就好。 25. 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）public class Solution { public RandomListNode Clone(RandomListNode pHead){ if(pHead == null){ return null; } RandomListNode p=pHead; RandomListNode t=pHead; // next 赋值 while(p!=null){ RandomListNode q=new RandomListNode(p.label); q.next=p.next; p.next=q; p=q.next; } // random 赋值 while(t!=null){ RandomListNode q=t.next; if(t.random!=null) q.random=t.random.next; t=q.next; } // 拆分 RandomListNode s = new RandomListNode(0); RandomListNode s1 = s; while (pHead != null) { RandomListNode q = pHead.next; pHead.next = q.next; s.next = q; s = s.next; pHead = pHead.next; } return s1.next; } } 26. 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。public class Solution { TreeNode head = null; TreeNode realHead = null; public TreeNode Convert(TreeNode pRootOfTree) { if (pRootOfTree == null) return null; Convert(pRootOfTree.left); if (realHead == null) { head = pRootOfTree; realHead = pRootOfTree; } else { head.right = pRootOfTree; pRootOfTree.left = head; head = pRootOfTree; } Convert(pRootOfTree.right); return realHead; } } 27. 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。import java.util.ArrayList; import java.util.Collections; public class Solution { public ArrayList&lt;String&gt; Permutation(String str) { ArrayList&lt;String&gt; res=new ArrayList&lt;String&gt;(); if(str.length()==0||str==null)return res; char[] chars = str.toCharArray(); Permutation(chars, 0, res); // 字典序排序 Collections.sort(res); return res; } public void Permutation(char[] chars, int begin, ArrayList&lt;String&gt; result) { if(chars==null || chars.length==0 || begin&lt;0 || begin&gt;chars.length-1) { return ; } if(begin==chars.length-1){ result.add(new String(chars)); } // 最初自己的排序也是要算上的 for(int i=begin;i&lt;chars.length;i++) { if(i==begin||chars[begin]!=chars[i]) { swap(chars,begin,i); Permutation( chars, begin+1, result); swap(chars,begin,i); } } } public void swap(char[]t,int i,int j) { char c=t[i]; t[i]=t[j]; t[j]=c; } } 注解：这种都是典型的回溯法（1，n-1） 28. 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。import java.util.HashMap; public class Solution { public int MoreThanHalfNum_Solution(int [] array) { HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i&lt;array.length; i++){ if(map.containsKey(array[i])){ map.put(array[i], map.get(array[i]) + 1 ); } else{ map.put(array[i], 1 ); } } for (Integer key : map.keySet()) { if ( map.get(key) &gt; array.length/2){ return key; } } return 0; } } 注解：由于不存在的可能性，故剑指offer中的技巧不能用。 29. 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。import java.util.Collections; import java.util.ArrayList; public class Solution { public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) { ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(input.length &lt; 1 || k &gt; input.length) return res; for(int i =0; i&lt;input.length; i++){ res.add(input[i]); } Collections.sort(res); ArrayList&lt;Integer&gt; out = new ArrayList&lt;Integer&gt;(); for(int i =0; i&lt;k; i++){ out.add(res.get(i)); } return out; } } 注解：这题真扯淡 30. HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)public class Solution { public int FindGreatestSumOfSubArray(int[] array) { if(array == null){ return 0; } int[] arr2 = new int[array.length]; arr2[0] = array[0]; for(int i=1; i&lt; array.length; i++){ // 核心思想 if(arr2[i-1] &lt; 0){ arr2[i] = array[i]; } else{ arr2[i] = arr2[i-1] + array[i]; } } int max = arr2[0]; for(int i=1; i&lt; array.length; i++){ if(arr2[i]&gt;max){ max = arr2[i]; } } return max; } } 31. 求出113的整数中1出现的次数,并算出1001300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。public class Solution { public int NumberOf1Between1AndN_Solution(int n) { int base = 1; int count =0; int round = n; int weight = 0； while(round&gt;0){ weight = round%10; round = round /10; // 按位计算1的数目 count += round * base; if(weight==1){ count += (n % base) + 1; } else if (weight&gt;1) { count += base; } base *= 10; } return count; } } 32. 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; public class Solution { public String PrintMinNumber(int [] numbers) { if(numbers == null || numbers.length == 0) return \"\"; int len = numbers.length; String[] str = new String[len]; StringBuilder sb = new StringBuilder(); // 数字可能越界，转字符串计算 for(int i = 0; i &lt; len; i++){ str[i] = String.valueOf(numbers[i]); } Arrays.sort(str,new Comparator&lt;String&gt;(){ @Override public int compare(String s1, String s2) { String c1 = s1 + s2; String c2 = s2 + s1; return c1.compareTo(c2); } }); for(int i = 0; i &lt; len; i++){ sb.append(str[i]); } return sb.toString(); } } 33. 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。public class Solution { public int GetUglyNumber_Solution(int index) { if( index&lt;=1 ) return index; int[] list = new int[index]; list[0] = 1; int temp2=0,temp3=0,temp5=0; int count = 0; while( count&lt;index-1 ){ while(list[temp2]*2&lt;=list[count]){ temp2++; } while(list[temp3]*3&lt;=list[count]){ temp3++; } while(list[temp5]*5&lt;=list[count]){ temp5++; } list[++count] = Math.min(Math.min(2*list[temp2], 3*list[temp3]) , 5*list[temp5]); } return list[list.length-1]; } } 注解：空间换时间算法 34. 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.import java.util.LinkedHashMap; public class Solution { public static int FirstNotRepeatingChar(String str) { LinkedHashMap &lt;Character, Integer&gt; map = new LinkedHashMap&lt;Character, Integer&gt;(); for(int i=0;i&lt;str.length();i++){ if(map.containsKey(str.charAt(i))){ map.put(str.charAt(i), map.get(str.charAt(i)) + 1 ); } else { map.put(str.charAt(i), 1); } } int i=0; for(;i&lt;str.length();i++){ char c = str.charAt(i); if (map.get(c) == 1) { return i; } } return -1; } } 注解：借助hashmap 35. 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007public class Solution { public static int InversePairs(int [] array) { if(array==null||array.length==0){ return 0; } int[] copy = new int[array.length]; int count = InversePairsCore( array, copy, 0, array.length-1);//数值过大求余 return count; } private static int InversePairsCore( int[] array, int[] copy, int low, int high) { if(low==high){ return 0; } int mid = (low+high)&gt;&gt;1; int leftCount = InversePairsCore( array, copy, low, mid); int rightCount = InversePairsCore( array, copy, mid+1, high); int count = 0; int i=mid; int j=high; int locCopy = high; // 归并排序，保证有序 while(i&gt;=low&amp;&amp;j&gt;mid){ if(array[i]&gt;array[j]){ count += j-mid; // 核心计算逆序对代码 copy[locCopy--] = array[i--]; if(count&gt;=1000000007){ count%=1000000007; } } else{ copy[locCopy--] = array[j--]; } } for(;i&gt;=low;i--) { copy[locCopy--]=array[i]; } for(;j&gt;mid;j--) { copy[locCopy--]=array[j]; } // 复制回去，保证有序 for(int s=low;s&lt;=high;s++) { array[s] = copy[s]; } return (leftCount+rightCount+count)%1000000007; } } 注解：这一题肯定可以简化，懒得改了 36. 输入两个链表，找出它们的第一个公共结点。public class Solution { public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) { if(pHead1==null||pHead2==null){ return null; } if(pHead1==pHead2){ return pHead1; } int len1=0; int len2=0; ListNode curr1=pHead1; ListNode curr2=pHead2; while(curr1!=null){ len1++; curr1=curr1.next; } while(curr2!=null){ len2++; curr2=curr2.next; } curr1=pHead1; curr2=pHead2; if(len1&gt;len2){ int moreLen=len1-len2; while(moreLen!=0){ curr1=curr1.next; moreLen--; } } else{ int moreLen=len2-len1; while(moreLen!=0){ curr2=curr2.next; moreLen--; } } while(curr1!=curr2&amp;&amp;curr1!=null){ curr1=curr1.next; curr2=curr2.next; } return curr1; } } 37. 统计一个数字在排序数组中出现的次数。public class Solution { public int GetNumberOfK(int [] array , int k) { if(array.length&lt;1) return 0; int begin =0; int end = array.length-1; return GetNumberOfK(array , k, begin, end); } public int GetNumberOfK(int[] array,int k, int begin, int end){ if(begin&gt;end) return 0; int mid=(end-begin)/2+begin; if(k&gt;array[mid]) return GetNumberOfK(array,k,mid+1,end); else if(k&lt;array[mid]) return GetNumberOfK(array,k,begin,mid-1); else { return 1+GetNumberOfK(array,k,begin,mid-1)+GetNumberOfK(array,k,mid+1,end); } } } 注解：折半查找提高效率 38. 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。public class Solution { public int TreeDepth(TreeNode root) { if (root == null) { return 0; } return Math.max(TreeDepth(root.left), TreeDepth(root.right)) + 1; } } 39. 输入一棵二叉树，判断该二叉树是否是平衡二叉树。public class Solution { public boolean IsBalanced_Solution(TreeNode root) { if (root == null) { return true; } int left = getTreeDepth(root.left); int right = getTreeDepth(root.right); int diff = Math.abs(left - right); if (diff &gt; 1) return false; return IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right); } public int getTreeDepth(TreeNode root) { if (root == null) return 0; else return Math.max(getTreeDepth(root.left), getTreeDepth(root.right)) + 1; } } 40. 一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。//num1,num2分别为长度为1的数组。传出参数 //将num1[0],num2[0]设置为返回结果 public class Solution { public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) { if (array == null) return ; int binaryVal = array[0]; for(int i=1; i&lt; array.length; i++){ binaryVal ^= array[i]; } // 找到第一个bit不为1的数 int binary1 = 1; while((binary1&amp;binaryVal)==0){ binary1 = binary1&lt;&lt;1; } boolean flag1 = true; boolean flag2 = true; for(int i=0; i&lt; array.length; i++){ if( (binary1 &amp; array[i]) !=0 &amp;&amp; flag1){ num1[0] = array[i]; flag1 = false; } else if( (binary1 &amp; array[i]) !=0){ num1[0] = num1[0] ^array[i]; } else if(flag2){ num2[0] = array[i]; flag2 = false; } else{ num2[0] = num2[0] ^array[i]; } } } } 41. 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!import java.util.ArrayList; public class Solution { public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) { ArrayList&lt;ArrayList&lt;Integer&gt; &gt; list = new ArrayList&lt;ArrayList&lt;Integer&gt; &gt; (); if(sum&lt;=1)return list; // 这里是一个优化，前提单个数为100不行 for(int i=1;i&lt;=sum/2;i++){ ArrayList&lt;Integer&gt; List2=new ArrayList&lt;Integer&gt;(); int count=0; for(int j=i;j&lt;sum;j++){ count+=j; List2.add(j); if(count&gt;sum) break; else if(count==sum){ list.add(List2); break; } } } return list; } } 42. 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。import java.util.ArrayList; public class Solution { public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(array.length&lt;2) return list; int begin = 0; int end = array.length - 1; while(begin&lt;end){ if( (array[begin] + array[end])&lt; sum){ begin++; } else if( (array[begin] + array[end])&gt; sum){ end--; } else{ list.add(array[begin]); list.add(array[end]); break; } } return list; } } 43. 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！public class Solution { public String LeftRotateString(String str,int n) { if(str.length()&lt;0 || n&lt;0 || n&gt;str.length()) return str; char[] chars = str.toCharArray(); for(int i = 0; i&lt;chars.length/2; i++){ char temp = chars[i]; chars[i] = chars[chars.length-1-i]; chars[chars.length-1-i] = temp; } for(int i = 0; i&lt;(chars.length-n)/2; i++){ char temp = chars[i]; chars[i] = chars[chars.length-n-1-i]; chars[chars.length-n-1-i] = temp; } for(int i = chars.length-n; i&lt;(chars.length-n/2); i++){ char temp = chars[i]; chars[i] = chars[chars.length-1-i + chars.length-n]; chars[chars.length-1-i + chars.length-n] = temp; } return new String(chars); } } 注解：不借助辅助空间的算法，需要两次翻转。为了避免混乱，也可以使用前后两指针交换的算法。 44. 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？public class Solution { public String ReverseSentence(String str) { if(str.length()&lt;1 ) return str; char[] chars = str.toCharArray(); // 先翻转 for(int i = 0; i&lt;chars.length/2; i++){ char temp = chars[i]; chars[i] = chars[chars.length-1-i]; chars[chars.length-1-i] = temp; } int end; int begin = 0; for(int i = 0; i&lt;=chars.length-1; i++){ if( chars[i]== ' ' || i==chars.length-1){ end = i - 1; if(i==chars.length-1){ end++; } while(begin&lt;end){ char temp = chars[begin]; chars[begin] = chars[end]; chars[end] = temp; begin++; end--; } begin = i + 1; } } return new String(chars); } } 注解：上一题的一般化 45. LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张_)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。import java.util.Arrays; public class Solution { public boolean isContinuous(int [] numbers) { if(numbers.length &lt;1) return false; Arrays.sort(numbers); //先排序 int zero = 0, i = 0; for(; i &lt; numbers.length &amp;&amp; numbers[i] == 0; i++){ zero ++; //统计0的个数 } for(i = zero; i &lt; numbers.length - 1; i++){ if(numbers[i] == numbers[i+1]) //有对子，则返回false return false; } if( (numbers[numbers.length -1] - numbers[zero]+1) &lt;=5 ) return true; else return false; } } 46. 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋那个小朋友友开始报数。每次喊到m-1的要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!_)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)public class Solution { public int LastRemaining_Solution(int n, int m) { if(n==0||m==0)return -1; int s=0; for(int i=2;i&lt;=n;i++) { s=(s+m)%i; } return s ; } } 注解：每一次都看成一个新的排序f[i-1]，但是下标是从k=m%n开始的。所以上一次的结果f[i]等于(f[i-1]+k)%n。于是有： 递推公式：f[i]=(f[i-1]+k)%n =&gt; f[1]=0，f[i]=(f[i-1]+m)%i;47. 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。public class Solution { public int Sum_Solution(int n) { int sum = n; boolean flag = (n&gt;0)&amp;&amp;((sum +=Sum_Solution(n-1))&gt;0); return sum; } } 注解：利用了逻辑&amp;&amp;的截断功能。 48. 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。public class Solution { public int Add(int num1, int num2) { int num3; int num4; do { num3 = num1 ^ num2; num4 = (num1 &amp; num2) &lt;&lt; 1; num1 = num3; num2 = num4; } while (num4 != 0); return num1; } } 注解：通过位运算 49. 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。public class Solution { public int StrToInt(String str) { if ( str.length() &lt; 1) return 0; char[] a = str.toCharArray(); boolean fuhao = true; int begin = 0; if (a[0] == '-'){ fuhao = false; begin = 1; } else if(a[0] == '+'){ begin = 1; } int sum = 0; for (int i = begin; i &lt; a.length; i++){ if (a[i] &lt; 48 || a[i] &gt; 57) return 0; sum = sum * 10 + a[i] - 48; } return fuhao ? sum : sum * -1; } } 注解：主要符号的判断。字符0的ASCII码是48 50. 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。public boolean duplicate(int numbers[],int length,int [] duplication) { if(length &lt;1 ) return false; for(int i=0;i&lt;length;i++){ while(numbers[i]!=i){ if(numbers[i]==numbers[numbers[i]]){ duplication[0]=numbers[i]; return true; } int temp=numbers[i]; numbers[i]=numbers[temp]; numbers[temp]=temp; } } return false; } 注解：利用数组值与下标的关系 51. 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]*A[i+1]…*A[n-1]。不能使用除法。import java.util.ArrayList; public class Solution { public int[] multiply(int[] A) { if(A.length&lt;1) return A; int[] B = new int[A.length]; B[0] = 1; for(int i=1; i&lt; A.length; i++){ B[i] = B[i-1] * A[i-1]; } int temp = 1; for(int i=A.length-2; i&gt;=0; i--){ temp *= A[i+1]; B[i] = B[i] * temp; } return B; } } 注解：利用前后两次乘，逃离中间乘。 52. 请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配public class Solution { public boolean match(char[] str, char[] pattern) { return matchTwo(str, 0, str.length, pattern, 0, pattern.length); } private boolean matchTwo(char[] str, int i, int length1, char[] pattern, int j, int length2) { if (i == length1 &amp;&amp; j == length2) { return true; } if (i == length1 &amp;&amp; j != length2) { while (j != length2) { if (pattern[j] != '*' &amp;&amp; (j + 1 &gt;= length2 || pattern[j + 1] != '*')) { return false; } j++; } return true; } if (i != length1 &amp;&amp; j == length2) { return false; } if (j + 1 == length2) { if (str[i] == pattern[j] || pattern[j] == '.') return matchTwo(str, i + 1, length1, pattern, j + 1, length2); else { return false; } } if ((str[i] == pattern[j] || pattern[j] == '.') &amp;&amp; pattern[j + 1] != '*') return matchTwo(str, i + 1, length1, pattern, j + 1, length2); if ((str[i] == pattern[j] || pattern[j] == '.') &amp;&amp; pattern[j + 1] == '*') return matchTwo(str, i, length1, pattern, j + 2, length2) || matchTwo(str, i + 1, length1, pattern, j, length2); if (pattern[j + 1] == '*') return matchTwo(str, i, length1, pattern, j + 2, length2); return false; } } 注解：不是我说，让你写一个这种函数还真不好写！！！！ 53. 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。public class Solution { public boolean isNumeric(char[] str) { String s=String.valueOf(str); return s.matches(\"[+-]?[0-9]*(\\\\.[0-9]*)?([eE][+-]?[0-9]+)?\"); } } 54. 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。如果当前字符流没有存在出现一次的字符，返回#字符。import java.util.HashMap; import java.util.ArrayList; public class Solution { HashMap&lt;Character, Integer&gt; map=new HashMap&lt;&gt;(); ArrayList&lt;Character&gt; list=new ArrayList&lt;Character&gt;(); public void Insert(char ch) { if(map.containsKey(ch)){ map.put(ch,map.get(ch)+1); }else{ map.put(ch,1); } list.add(ch); } public char FirstAppearingOnce() { char c='#'; for(char key : list){ if(map.get(key)==1){ c=key; break; } } return c; } } 55. 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。public class Solution { public ListNode EntryNodeOfLoop(ListNode pHead){ if (pHead == null || pHead.next == null || pHead.next.next == null) return null; ListNode slow = pHead.next; ListNode quick = pHead.next.next; // 1 找到是否有环，两个指针 while (slow != quick) { if (slow.next != null &amp;&amp; quick.next.next != null) { slow = slow.next; quick = quick.next.next; } else{ return null; } } // 2 确定环的大小k 但是其大小正好是 slow走的距离。 // 3 先走k步，相遇点为入口。 quick = pHead; while (quick != slow) { quick = quick.next; slow = slow.next; } return slow; } } 56. 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5public class Solution { public ListNode deleteDuplication(ListNode pHead) { ListNode result; ListNode temp = pHead; ListNode index = new ListNode(1); index.next = pHead; result = index; while (temp != null) { if (temp.next != null &amp;&amp; temp.next.val == temp.val) { while (temp.next != null &amp;&amp; temp.next.val == temp.val) { temp = temp.next; } temp = temp.next; index.next = temp; } else { index = index.next; temp = temp.next; } } return result.next; } } 57. 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。public class Solution { public TreeLinkNode GetNext(TreeLinkNode pNode) { if(pNode==null) return null; // 右节点不为空 if(pNode.right!=null) { // 找到右节点的最左节点 pNode=pNode.right; while(pNode.left!=null) { pNode=pNode.left; } return pNode; } // 右节点为空，找到其为父节点的左节点的那个最近的父节点。 while(pNode.next!=null) { if(pNode.next.left==pNode) return pNode.next; pNode=pNode.next; } return null; } } 58. 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。public class Solution { public boolean isSymmetrical(TreeNode pRoot) { if(pRoot==null) return true; return isSymmetrical(pRoot.left,pRoot.right); } public boolean isSymmetrical(TreeNode left, TreeNode right) { if (left == null &amp;&amp; right == null) return true; if (left == null || right == null) return false; if (left.val == right.val) // 左左相比，右右相比，这是最核心的思想了。 return isSymmetrical(left.left, right.right) &amp;&amp; isSymmetrical(left.right, right.left); return false; } } 59. 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。import java.util.ArrayList; import java.util.Queue; import java.util.LinkedList; public class Solution { public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) { ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); if(pRoot==null){ return res; } ArrayList&lt;Integer&gt; list; Queue&lt;TreeNode&gt; queue=new LinkedList&lt;TreeNode&gt;(); int rows=1; queue.add(pRoot); while(!queue.isEmpty()){ list=new ArrayList&lt;&gt;(); int size=queue.size(); for(int i=0;i&lt;size;i++){ TreeNode t=queue.poll(); // 分层考虑 if(rows%2==0){ list.add(0,t.val); // 每次都插入到最前面 }else{ list.add(t.val); } if(t.left!=null){ queue.offer(t.left); } if(t.right!=null){ queue.offer(t.right); } } res.add(list); rows++; } return res; } } 60. 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。public class Solution { ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) { ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = new ArrayList&lt;&gt;(); if(pRoot == null) { return result; } ArrayList&lt;TreeNode&gt; nodes = new ArrayList&lt;&gt;(); nodes.add(pRoot); Print(result, nodes); return result; } public void Print(ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result, ArrayList&lt;TreeNode&gt; nodes) { if(!nodes.isEmpty()) { ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); ArrayList&lt;TreeNode&gt; next = new ArrayList&lt;&gt;(); for(TreeNode t : nodes) { temp.add(t.val); if(t.left != null) { next.add(t.left); } if(t.right != null) { next.add(t.right); } } result.add(temp); Print(result, next); } } } 注解：借助队列会更好做吧 62. 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。public class Solution { int index = 0; TreeNode KthNode(TreeNode root, int k) { if (root != null) { // 中序遍历寻找第k个 TreeNode node = KthNode(root.left, k); if (node != null) return node; index++; if (index == k) return root; node = KthNode(root.right, k); if (node != null) return node; } return null; } } 63. 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。import java.util.ArrayList; import java.util.Collections; public class Solution { ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;(); public void Insert(Integer num) { al.add(num); Collections.sort(al); } public Double GetMedian() { int mid = al.size() / 2; if ((al.size() &amp; 1) == 0) { Integer n1 = al.get(mid); Integer n2 = al.get(mid - 1); double s = (Double.valueOf(n1 + \"\") + Double.valueOf(n2 + \"\")) / 2; return s; } else { double s = Double.valueOf(al.get(mid) + \"\"); return s; } } } 65. 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。public class Solution { // 65 public boolean hasPath(char[] matrix, int rows, int cols, char[] str) { int []flag=new int[matrix.length]; // 可选开始值 for(int i=0;i&lt;rows;i++) { for(int j=0;j&lt;cols;j++) { if(hasPath(matrix,rows,cols,i,j,0,str,flag)) return true; } } return false; } public boolean hasPath(char[]matrix,int rows,int cols,int i,int j,int k,char[]str,int[]flag) { int index=i*cols+j; if(i&lt;0||i&gt;=rows||j&lt;0||j&gt;=cols||flag[index]==1||matrix[index]!=str[k])return false; if(k==str.length-1) return true; flag[index]=1; // 核心遍历 if(hasPath(matrix,rows,cols,i+1,j,k+1,str,flag)||hasPath(matrix,rows,cols,i-1,j,k+1,str,flag)||hasPath(matrix,rows,cols,i,j+1,k+1,str,flag)||hasPath(matrix,rows,cols,i,j-1,k+1,str,flag)) return true; flag[index]=0; return false; } } 66. 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？public class Solution { public int movingCount(int threshold, int rows, int cols) { boolean[] visited=new boolean[rows*cols]; // 与上一题相比，课题初始值只有一个 return movingCountCore(threshold, rows, cols, 0,0,visited); } private int movingCountCore(int threshold, int rows, int cols, int row,int col,boolean[] visited) { if(row&lt;0||row&gt;=rows||col&lt;0||col&gt;=cols) return 0; int i=row*cols+col; if(visited[i]||!checkSum(threshold,row,col)) return 0; visited[i]=true; // 这里保持统一，而在返回推荐控制越界。 return 1+movingCountCore(threshold, rows, cols,row,col+1,visited) +movingCountCore(threshold, rows, cols,row,col-1,visited) +movingCountCore(threshold, rows, cols,row+1,col,visited) +movingCountCore(threshold, rows, cols,row-1,col,visited); } //指定规则 private boolean checkSum(int threshold, int row, int col) { int sum=0; while(row!=0){ sum+=row%10; row=row/10; } while(col!=0){ sum+=col%10; col=col/10; } if(sum&gt;threshold) return false; return true; } } 作者：小张同学_loveZY链接：https://www.jianshu.com/p/62cf4055617d来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode】面试题64. 求1+2+…+n","slug":"【LeetCode】面试题64. 求1+2+…+n","date":"2020-06-02T07:19:00.000Z","updated":"2020-07-10T06:46:17.844Z","comments":true,"path":"2020/06/02/【LeetCode】面试题64. 求1+2+…+n/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/02/%E3%80%90LeetCode%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9864.%20%E6%B1%821+2+%E2%80%A6+n/","excerpt":"来自《剑指Offer（第二版）》 题目描述求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 示例 1： 输入: n = 3 输出: 6 示例 2： 输入: n = 9 输出: 45 限制： 1 &lt;= n &lt;= 10000","text":"来自《剑指Offer（第二版）》 题目描述求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 示例 1： 输入: n = 3 输出: 6 示例 2： 输入: n = 9 输出: 45 限制： 1 &lt;= n &lt;= 10000 题解逻辑(短路)与看完标题，发现这是一道面试题！！！ 看到第一行的“要求不能使用……”，我人傻了，没错，就是人傻了~~ 想用“递归”，但是乘除法不能用、条件判断也不能用🤣🤣🤣 这要怎么做啊？！ 等等，没说不能用运算符哦！！！ 试试看呗~~ 直接写写源码~~ class Solution { // int res = 0; public int sumNums(int n) { // boolean x = n &gt; 1 &amp;&amp; sumNums(n - 1) &gt; 0; boolean x = n &gt; 1 &amp;&amp; (n += sumNums(n - 1)) &gt; 0; // res += n; // return res; return n; } } 思路吗？就直接看源码就懂了！！！ 不懂，那就看多几次！！！ 补充逻辑运算符的短路效应：常见的逻辑运算符有三种，即 “与 &amp;&amp; ”，“或 ∣∣ ”，“非 ! ” ；而其有重要的短路效应，如下所示： if(A &amp;&amp; B) // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true 本题需要实现 “当 n = 1n=1 时终止递归” 的需求，可通过短路效应实现。 n &gt; 1 &amp;&amp; sumNums(n - 1) // 当 n = 1 时 n &gt; 1 不成立 ，此时 “短路” ，终止后续递归 异常捕获这个方法会超时，但是确实是可以。 class Solution { int[] test=new int[]{0}; public int sumNums(int n) { try{ return test[n]; }catch(Exception e){ return n+sumNums(n-1); } } } 移位运算符移位运算符确实可以解，但是好像不是很多人用它写。 class Solution { public int sumNums(int n) { int ans = 0, A = n, B = n + 1; boolean flag; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; flag = ((B &amp; 1) &gt; 0) &amp;&amp; (ans += A) &gt; 0; A &lt;&lt;= 1; B &gt;&gt;= 1; return ans &gt;&gt; 1; } } 我在题解区看到了“你是我见过最变态的题解”，不信就看👇原帖是解过最变态的一道题 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"使用云函数自动完成网易云每日打卡","slug":"使用云函数自动完成网易云每日打卡","date":"2020-06-01T07:19:00.000Z","updated":"2020-07-10T06:46:17.914Z","comments":true,"path":"2020/06/01/使用云函数自动完成网易云每日打卡/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/01/%E4%BD%BF%E7%94%A8%E4%BA%91%E5%87%BD%E6%95%B0%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E7%BD%91%E6%98%93%E4%BA%91%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/","excerpt":"","text":"搜索云函数 新建一个函数 名称随意 环境 PHP 7.2 空白函数 下一步 然后会出现这个界面 把 index.php 里面的内容全部删掉 替换为下面这些代码 记得填写手机号和密码 代码有两个版本，第一个是以前在用的，第二个未测试。 现在两个版本已经有段实践没有去运行测试了，难以保证可行性。（日后有再补新的API） 版本①&lt;?php $localurl = \"http://neteasecloudmusicapi.zhaoboy.com\"; $username = \"手机号\"; $password = \"密码\"; $SCKEY = \"\";//可选 //访问链接 function getcurl($url,$cookies,$headid){ $ch = curl_init(); curl_setopt($ch, CURLOPT_COOKIE, $cookies); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, $headid); $output = curl_exec($ch); curl_close($ch); return $output; } //获取日推歌单 function get_rec_res($cookies){ global $localurl; $url = $localurl.\"/recommend/resource\"; return json_decode(getcurl($url,$cookies,0),true); } //获取歌单中歌曲 function get_song($cookies,$id){ global $localurl; $url = $localurl.\"/playlist/detail?id={$id}\"; return json_decode(getcurl($url,$cookies,0),true); } //打卡歌曲 function daka($cookies,$id){ global $localurl; $url = $localurl.\"/scrobble?id={$id}&amp;time=71&amp;timestamp=\".rand(1, 100000); getcurl($url,$cookies,0); } //签到 function qiandao($cookies){ global $localurl; $urland = $localurl.\"/daily_signin\"; $urlpc = $localurl.\"/daily_signin?type=1\"; getcurl($urland,$cookies,0); getcurl($urlpc,$cookies,0); } //登录 function login($username,$password){ global $localurl; $url = $localurl.\"/login/cellphone?phone={$username}&amp;password={$password}\"; $data = getcurl($url,0,1); if(preg_match_all('/Set-Cookie:(.*);/iU',$data,$str)==0) die($data); $cookies = $str[1][0].\";\".$str[1][1].\";\".$str[1][2].\";\"; return $cookies; } //获取用户id function get_id($cookies){ global $localurl; $url = $localurl.\"/login/status\"; $state = json_decode(getcurl($url,$cookies,0),true); return $state[\"bindings\"][0][\"userId\"]; } //听歌量 function get_listenSongs($cookies){ global $localurl; $userid = get_id($cookies); $url = $localurl.\"/user/detail?uid={$userid}&amp;timestamp=\".rand(1, 100000); $detail = json_decode(getcurl($url,$cookies,0),true); return $detail[\"listenSongs\"]; } function run($username,$password){ global $localurl; global $SCKEY; $cookies = login($username,$password); qiandao($cookies); $songslist = get_rec_res($cookies); for($k=0;$k&lt;(count($songslist[\"recommend\"]));$k++){ $songlist = get_song($cookies,$songslist[\"recommend\"][$k][\"id\"]); for($j=0;$j&lt;(count($songlist[\"privileges\"]));$j++){ daka($cookies,$songlist[\"privileges\"][$j][\"id\"]); if(($j/10)==0){ sleep(1); } if(($j==(count($songlist[\"privileges\"])-1))||$j==300){ echo \"执行 {$j} 首\\n\"; sleep(10); break 1; } } } if($SCKEY){ $number = get_listenSongs($cookies); echo $number; $url = \"https://sc.ftqq.com/\".$SCKEY.\".send?text=\".urlencode($username.\" 当前听歌量 \".$number); getcurl($url,0,0); } } function main_handler($event, $context) { global $username; global $password; run($username,$password); return \" 任务完成 \"; } ?&gt; 版本② &lt;?php $localurl = \"http://wyyapi.aar0n.cn\"; $username = \"你的手机号\"; $password = \"你的密码\"; //访问链接 function getcurl($url,$cookies,$headid){ $ch = curl_init(); curl_setopt($ch, CURLOPT_COOKIE, $cookies); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, $headid); $output = curl_exec($ch); curl_close($ch); return $output; } //获取日推歌单 function get_rec_res($cookies){ global $localurl; $url = $localurl.\"/recommend/resource\"; return json_decode(getcurl($url,$cookies,0),true); } //获取歌单中歌曲 function get_song($cookies,$id){ global $localurl; $url = $localurl.\"/playlist/detail?id={$id}\"; return json_decode(getcurl($url,$cookies,0),true); } //打卡歌曲 function daka($cookies,$id){ global $localurl; $url = $localurl.\"/scrobble?id={$id}&amp;time=71&amp;timestamp=\".rand(1, 100000); getcurl($url,$cookies,0); } //签到 function qiandao($cookies){ global $localurl; $urland = $localurl.\"/daily_signin\"; $urlpc = $localurl.\"/daily_signin?type=1\"; getcurl($urland,$cookies,0); getcurl($urlpc,$cookies,0); } //登录 function login($username,$password){ global $localurl; $url = $localurl.\"/login/cellphone?phone={$username}&amp;password={$password}\"; $data = getcurl($url,0,1); if(preg_match_all('/Set-Cookie:(.*);/iU',$data,$str)==0) die($data); $cookies = $str[1][0].\";\".$str[1][1].\";\".$str[1][2].\";\"; return $cookies; } function run($username,$password){ global $localurl; $cookies = login($username,$password); qiandao($cookies); $songslist = get_rec_res($cookies); for($k=0;$k&lt;(count($songslist[\"recommend\"]));$k++){ $songlist = get_song($cookies,$songslist[\"recommend\"][$k][\"id\"]); for($j=0;$j&lt;(count($songlist[\"privileges\"]));$j++){ daka($cookies,$songlist[\"privileges\"][$j][\"id\"]); if(($j/10)==0){ sleep(1); } if(($j==(count($songlist[\"privileges\"])-1))||$j==300){ echo \"执行 {$j} 首\\n\"; sleep(10); break 1; } } } } function main_handler($event, $context) { global $username; global $password; run($username,$password); return \"ok\"; } ?&gt; 记得修改手机号和密码哦～ 点击编辑 超时时间 改为900 点击保存 找到触发方式 添加触发方式 定时触发 corn 表达式 每天八点自动打卡 0 0 8 */1 * * * 点击保存 这样就可以了 就可以享受每天纯自动打卡了 美滋滋啊 最后你过你对它感兴趣 还可以去研究研究其他的 API他是个开源项目地址：https://binaryify.github.io/NeteaseCloudMusicApi/#/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"【LeetCode】1431. 拥有最多糖果的孩子","slug":"【LeetCode】1431. 拥有最多糖果的孩子","date":"2020-06-01T07:00:00.000Z","updated":"2020-07-10T06:46:17.751Z","comments":true,"path":"2020/06/01/【LeetCode】1431. 拥有最多糖果的孩子/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/06/01/%E3%80%90LeetCode%E3%80%911431.%20%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/","excerpt":"首先祝Jerry生日快乐！ 今天这个打卡题是关于“糖果”的，恰好六一儿童节。 题目描述给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。 对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。 注意，允许有多个孩子同时拥有 最多 的糖果数目。 示例 1： 输入：candies = [2,3,5,1,3], extraCandies = 3 输出：[true,true,true,false,true] 解释： 孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。 孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。 孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。 孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 示例 2： 输入：candies = [4,2,1,1,2], extraCandies = 1 输出：[true,false,false,false,false] 解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。 示例 3： 输入：candies = [12,1,12], extraCandies = 10 输出：[true,false,true] 提示： 2 &lt;= candies.length &lt;= 100 1 &lt;= candies[i] &lt;= 100 1 &lt;= extraCandies &lt;= 50","text":"首先祝Jerry生日快乐！ 今天这个打卡题是关于“糖果”的，恰好六一儿童节。 题目描述给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。 对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。 注意，允许有多个孩子同时拥有 最多 的糖果数目。 示例 1： 输入：candies = [2,3,5,1,3], extraCandies = 3 输出：[true,true,true,false,true] 解释： 孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。 孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。 孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。 孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 示例 2： 输入：candies = [4,2,1,1,2], extraCandies = 1 输出：[true,false,false,false,false] 解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。 示例 3： 输入：candies = [12,1,12], extraCandies = 10 输出：[true,false,true] 提示： 2 &lt;= candies.length &lt;= 100 1 &lt;= candies[i] &lt;= 100 1 &lt;= extraCandies &lt;= 50 题解因为题目有这个关键信息“允许有多个孩子同时拥有 最多 的糖果数目”，这样直接减少了很多麻烦。 题解就“暴力枚举”，两个步骤，两次数组遍历： 找到数组中最大的元素 判断每个元素加上extraCandies能否达到最大值 直接上源码： class Solution { public List&lt;Boolean&gt; kidsWithCandies(int[] candies, int extraCandies) { List&lt;Boolean&gt; ans = new ArrayList&lt;&gt;(); // 定义 max 记录数组的最大值，初始化为 0 int max = 0; for (int c : candies) { max = Math.max(max, c); } // 依次遍历数组，判断元素加上额外糖果大于等于最大值则可以符合条件，否则不可以 for (int c : candies) { ans.add(c + extraCandies &gt;= max); } return ans; } } 提交 题后感想五月已逝，六月努力的💪 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java队列的部分调用方法","slug":"Java队列的部分调用方法","date":"2020-05-31T07:17:00.000Z","updated":"2020-07-10T06:46:17.509Z","comments":true,"path":"2020/05/31/Java队列的部分调用方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/31/Java%E9%98%9F%E5%88%97%E7%9A%84%E9%83%A8%E5%88%86%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"Java队列的部分调用方法 方法 作用 说明 add() 增加一个元素 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove() 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element() 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer() 添加一个元素并返回true 如果队列已满，则返回false poll() 移除并返问队列头部的元素 如果队列为空，则返回null peek() 返回队列头部的元素 如果队列为空，则返回null put() 添加一个元素 如果队列满，则阻塞 take() 移除并返回队列头部的元素 如果队列为空，则阻塞 关于Java队列更多详见：java队列——queue详细分析","text":"Java队列的部分调用方法 方法 作用 说明 add() 增加一个元素 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove() 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element() 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer() 添加一个元素并返回true 如果队列已满，则返回false poll() 移除并返问队列头部的元素 如果队列为空，则返回null peek() 返回队列头部的元素 如果队列为空，则返回null put() 添加一个元素 如果队列满，则阻塞 take() 移除并返回队列头部的元素 如果队列为空，则阻塞 关于Java队列更多详见：java队列——queue详细分析 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"【LeetCode】101. 对称二叉树","slug":"【LeetCode】101. 对称二叉树","date":"2020-05-31T07:17:00.000Z","updated":"2020-07-10T06:46:17.747Z","comments":true,"path":"2020/05/31/【LeetCode】101. 对称二叉树/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/31/%E3%80%90LeetCode%E3%80%91101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"题目描述给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 进阶： 你可以运用递归和迭代两种方法解决这个问题吗？","text":"题目描述给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 进阶： 你可以运用递归和迭代两种方法解决这个问题吗？ 题解思路阅读完题目，脑子里先是想到了栈这种数据结构。 栈的一个特性：先进后出、后进先出。 根据这个特性，很容易地搞定递归实现。 但是迭代地话，用队列更容易理解。 队列的一个特性：先进先出，后进后出。 这题比较容易，直接看代码和注释即可。 递归class Solution { public boolean isSymmetric(TreeNode root) { // 两树都为null，肯定对称 if (root == null) { return true; } // 比较 左子树root.left 与 右子树root.right 这两棵子树是否对称 return compareTree(root.left, root.right); } /* 递归实现 */ private boolean compareTree(TreeNode node1, TreeNode node2) { // 首先比较 node1 与 node2 这两个节点的值是否相等 // 两节点均同时为null时 if (node1 == null &amp;&amp; node2 == null) { return true; } // 最多一个节点为null时，当然还得考虑“值不空但不同”的情况 if (node1 == null || node2 == null || node1.val != node2.val) { // TreeNode.val返回的是该节点的值 return false; } // 再递归比较 node1 的左子树与 node2 的右子树是否对称，node1 的右子树与 node2 的左子树是否对称 return compareTree(node1.left, node2.right) &amp;&amp; compareTree(node1.right, node2.left); } } 迭代class Solution { public boolean isSymmetric(TreeNode root) { // 两树都为null，肯定对称 if (root == null) { return true; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root.left); queue.add(root.right); while (!queue.isEmpty()) { // 每次出队两个节点 node1 和 node2 TreeNode node1 = queue.poll(); TreeNode node2 = queue.poll(); // 首先比较 node1 与 node2 这两个节点的值是否相等 if (node1 == null &amp;&amp; node2 == null) { continue; } // 最多一个节点为null时，当然还得考虑“值不空但不同”的情况 if (node1 == null || node2 == null || node1.val != node2.val) { // TreeNode.val返回的是该节点的值 return false; } // 再将 node1 的左节点与 node2 的右节点一起入队（以便两节点一起出队，进行比较） queue.add(node1.left); queue.add(node2.right); // 再将 node1 的右节点与 node2 的左节点一起入队（以便两节点一起出队，进行比较） queue.add(node1.right); queue.add(node2.left); } return true; } } 复杂度分析无论是递归，还是迭代， 时间复杂度均为：O(n) 空间复杂度均为：O(n) 补充Java 队列的add()方法和offer()方法的区别 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java 队列的add()方法和offer()方法的区别","slug":"Java 队列的add()方法和offer()方法的区别","date":"2020-05-31T06:59:00.000Z","updated":"2020-07-10T06:46:17.459Z","comments":true,"path":"2020/05/31/Java 队列的add()方法和offer()方法的区别/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/31/Java%20%E9%98%9F%E5%88%97%E7%9A%84add()%E6%96%B9%E6%B3%95%E5%92%8Coffer()%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"查阅API文档，找到 add()：增加一个元素。如果队列已满，则抛出一个IIIegaISlabEepeplian异常 Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never throw IllegalStateException or return false. offer()：添加一个元素并返回true。如果队列已满，则返回false Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never return false. 分析 两者都是往队列尾部插入元素 当超出队列界限的时候，add()方法是抛出异常让你处理，而offer()方法是直接返回false Java队列的部分调用方法 方法 作用 说明 add() 增加一个元素 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove() 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element() 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer() 添加一个元素并返回true 如果队列已满，则返回false poll() 移除并返问队列头部的元素 如果队列为空，则返回null peek() 返回队列头部的元素 如果队列为空，则返回null put() 添加一个元素 如果队列满，则阻塞 take() 移除并返回队列头部的元素 如果队列为空，则阻塞 关于Java队列更多详见：java队列——queue详细分析","text":"查阅API文档，找到 add()：增加一个元素。如果队列已满，则抛出一个IIIegaISlabEepeplian异常 Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never throw IllegalStateException or return false. offer()：添加一个元素并返回true。如果队列已满，则返回false Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never return false. 分析 两者都是往队列尾部插入元素 当超出队列界限的时候，add()方法是抛出异常让你处理，而offer()方法是直接返回false Java队列的部分调用方法 方法 作用 说明 add() 增加一个元素 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove() 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element() 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer() 添加一个元素并返回true 如果队列已满，则返回false poll() 移除并返问队列头部的元素 如果队列为空，则返回null peek() 返回队列头部的元素 如果队列为空，则返回null put() 添加一个元素 如果队列满，则阻塞 take() 移除并返回队列头部的元素 如果队列为空，则阻塞 关于Java队列更多详见：java队列——queue详细分析 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"运行IDEA时报错Internal error","slug":"运行IDEA时报错Internal error","date":"2020-05-30T15:17:00.000Z","updated":"2020-07-10T06:46:17.948Z","comments":true,"path":"2020/05/30/运行IDEA时报错Internal error/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/30/%E8%BF%90%E8%A1%8CIDEA%E6%97%B6%E6%8A%A5%E9%94%99Internal%20error/","excerpt":"运行IDEA时，报错Internal error 下面有两种解决办法，优先选择第①种，不行再第②种。我的电脑试了前面两种都不行，所以有了第③种。","text":"运行IDEA时，报错Internal error 下面有两种解决办法，优先选择第①种，不行再第②种。我的电脑试了前面两种都不行，所以有了第③种。 解决①找到intellij的配置目录，windows系统一般是在用户目录下，即C:\\Users\\username\\.IntelliJIdea2019.3，重命名或删除这个文件夹，再次打开intellij时会提示是否加载以前的配置，选择一个较早的版本或者不加载，就能正常打开软件了。 解决② 管理员模式的命令行cmd/PowerShell 输入netsh winsock reset 重启电脑 解决③禁用Hyper-V和Windows 沙盒即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"【LeetCode】198. 打家劫舍","slug":"【LeetCode】198. 打家劫舍","date":"2020-05-29T08:39:00.000Z","updated":"2020-07-10T06:46:17.754Z","comments":true,"path":"2020/05/29/【LeetCode】198. 打家劫舍/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/29/%E3%80%90LeetCode%E3%80%91198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","excerpt":"题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。","text":"题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 题解优化奇偶求和阅读完题目，刚冒出的想法就是“这不就是奇偶数求和吗？”但是第一次提交代码后，提示报错，来看看用例： 输入: [2,1,1,2] 输出 3 预期结果 4 为什么会这样呢？因为不是最优解。 以为是奇偶数求和，但是这个用例中，最大值是下标0、3的求和。 因此必须优化一下，每次奇偶数求和时，除了奇数/偶数下标的求和，还要更新另一边偶数/奇数的求和的值。 多说不好理解，来看看这个对比： indexx 0 1 2 3 nums [2,1,1,2] → 4 优化前： sumEven 0 1 1 3 sumOdd 2 2 3 3 优化后： sumEven 0 2 2 4 sumOdd 2 2 3 3 这一比较，应该就好理解了。 以下为Java代码： class Solution { public int rob(int[] nums) { int sumEven = 0; // 偶数 int sumOdd = 0; // 奇数 for(int i = 0; i &lt; nums.length; i++) { if(i % 2 ==0) { sumEven += nums[i]; // 不是纯粹的偶数和 sumEven = Math.max(sumOdd, sumEven); } else { sumOdd += nums[i]; // 也不是纯粹的奇数和 sumOdd = Math.max(sumOdd, sumEven); } } return Math.max(sumEven, sumOdd); } } 提交后： 动态规划成功解决后，突然想到“能不能用别的办法？比如dp动态规划？” 我试着找了动态规划方程，还真找到了。 动态规划方程：dp[n] = max(dp[n-2] + nums[n], dp[n-1]) 使用上边的用例[2,1,1,2] → 4来验证 n 为数组 nums 的长度 初始： dp[0] = 0 //必须初始化为0 dp[1] = nums[0] = 2 //初始为nums[0] n&gt;=2时： dp[2] = max(dp[0]+nums[1], dp[1]) = max(0+1, 2) = 2 dp[3] = max(dp[1]+nums[2], dp[2]) = max(2+1, 2) = 3 dp[4] = max(dp[2]+nums[3], dp[3]) = max(2+2, 3) = 4 代码： class Solution { public int rob(int[] nums) { int len = nums.length; if(len == 0) return 0; int[] dp = new int[len + 1]; //dp[len] 存储最终结果 dp[0] = 0; //必须初始化为0 dp[1] = nums[0]; //初始为数组的第一个元素 for(int i = 2; i &lt;= len; i++) { //动态规划方程 dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]); } return dp[len]; } } 提交： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode】198. 打家劫舍","slug":"解决Win10开始菜单和搜索框挡重叠的问题","date":"2020-05-29T08:39:00.000Z","updated":"2020-07-10T06:46:17.940Z","comments":true,"path":"2020/05/29/解决Win10开始菜单和搜索框挡重叠的问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/29/%E8%A7%A3%E5%86%B3Win10%E5%BC%80%E5%A7%8B%E8%8F%9C%E5%8D%95%E5%92%8C%E6%90%9C%E7%B4%A2%E6%A1%86%E6%8C%A1%E9%87%8D%E5%8F%A0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。","text":"题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 题解优化奇偶求和阅读完题目，刚冒出的想法就是“这不就是奇偶数求和吗？”但是第一次提交代码后，提示报错，来看看用例： 输入: [2,1,1,2] 输出 3 预期结果 4 为什么会这样呢？因为不是最优解。 以为是奇偶数求和，但是这个用例中，最大值是下标0、3的求和。 因此必须优化一下，每次奇偶数求和时，除了奇数/偶数下标的求和，还要更新另一边偶数/奇数的求和的值。 多说不好理解，来看看这个对比： indexx 0 1 2 3 nums [2,1,1,2] → 4 优化前： sumEven 0 1 1 3 sumOdd 2 2 3 3 优化后： sumEven 0 2 2 4 sumOdd 2 2 3 3 这一比较，应该就好理解了。 以下为Java代码： class Solution { public int rob(int[] nums) { int sumEven = 0; // 偶数 int sumOdd = 0; // 奇数 for(int i = 0; i &lt; nums.length; i++) { if(i % 2 ==0) { sumEven += nums[i]; // 不是纯粹的偶数和 sumEven = Math.max(sumOdd, sumEven); } else { sumOdd += nums[i]; // 也不是纯粹的奇数和 sumOdd = Math.max(sumOdd, sumEven); } } return Math.max(sumEven, sumOdd); } } 提交后： 动态规划成功解决后，突然想到“能不能用别的办法？比如dp动态规划？” 我试着找了动态规划方程，还真找到了。 动态规划方程：dp[n] = max(dp[n-2] + nums[n], dp[n-1]) 使用上边的用例[2,1,1,2] → 4来验证 n 为数组 nums 的长度 初始： dp[0] = 0 //必须初始化为0 dp[1] = nums[0] = 2 //初始为nums[0] n&gt;=2时： dp[2] = max(dp[0]+nums[1], dp[1]) = max(0+1, 2) = 2 dp[3] = max(dp[1]+nums[2], dp[2]) = max(2+1, 2) = 3 dp[4] = max(dp[2]+nums[3], dp[3]) = max(2+2, 3) = 4 代码： class Solution { public int rob(int[] nums) { int len = nums.length; if(len == 0) return 0; int[] dp = new int[len + 1]; //dp[len] 存储最终结果 dp[0] = 0; //必须初始化为0 dp[1] = nums[0]; //初始为数组的第一个元素 for(int i = 2; i &lt;= len; i++) { //动态规划方程 dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]); } return dp[len]; } } 提交： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"自定义返回顶部小火箭","slug":"自定义返回顶部小火箭","date":"2020-05-27T06:52:00.000Z","updated":"2020-07-10T06:46:17.938Z","comments":true,"path":"2020/05/27/自定义返回顶部小火箭/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E5%B0%8F%E7%81%AB%E7%AE%AD/","excerpt":"","text":"&lt;!--自定义返回顶部小火箭--&gt; &lt;style&gt; #back-top { position: fixed; bottom: 10px; right: 5px; z-index: 99; } #back-top span { width: 50px; height: 64px; display: block; background:url(http://images.cnblogs.com/cnblogs_com/seanshao/855033/o_rocket.png) no-repeat center center; } #back-top a{outline:none} &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; $(function() { // hide #back-top first $(\"#back-top\").hide(); // fade in #back-top $(window).scroll(function() { if ($(this).scrollTop() &gt; 500) { $('#back-top').fadeIn(); } else { $('#back-top').fadeOut(); } }); // scroll body to 0px on click $('#back-top a').click(function() { $('body,html').animate({ scrollTop: 0 }, 800); return false; }); }); &lt;/script&gt; &lt;p id=\"back-top\" style=\"display:none\"&gt;&lt;a href=\"#top\"&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"}]},{"title":"[转]在博客页首添加搜索功能","slug":"[转]在博客页首添加搜索功能","date":"2020-05-27T06:47:00.000Z","updated":"2020-08-27T05:55:24.163Z","comments":true,"path":"2020/05/27/[转]在博客页首添加搜索功能/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/27/[%E8%BD%AC]%E5%9C%A8%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%A6%96%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/","excerpt":"原文链接：https://www.cnblogs.com/hardrock/archive/2008/01/26/1054281.html","text":"原文链接：https://www.cnblogs.com/hardrock/archive/2008/01/26/1054281.html 把博客园的搜索设置移植到了页面顶端，这样让博客的搜索功能更加醒目。同时整合了“Adsense for Search” 以及“Add related keyword links”(添加相关关键字链接，起到搜索提示的功能）。下面是我使用的代码： &lt;script language=\"JavaScript\"&gt; function SearchGoogle(key,evt,site) { if(evt.keyCode==13 || evt.keyCode==0 || evt.type =='click') { key.focus(); var keystr = encodeURIComponent(key.value); url = \"http://www.google.com/search?q=\"; url = url+keystr; url += \"&amp;client=pub-7558339387099421&amp;forid=1&amp;ie=UTF-8&amp;oe=UTF-8&amp;safe=active&amp;cof=GALT%3A%23008000%3BGL%3A1%3BDIV%3A%23336699%3BVLC%3A663399%3BAH%3Acenter%3BBGC%3AFFFFFF%3BLBGC%3A336699%3BALC%3A0000FF%3BLC%3A0000FF%3BT%3A000000%3BGFNT%3A0000FF%3BGIMP%3A0000FF%3BFORID%3A1&amp;hl=zh-CN&amp;x=0&amp;y=0&amp;domains=\"+site+\"&amp;sitesearch=\"+site; window.location=url; return false; } } &lt;/script&gt; &lt;table&gt;&lt;tr&gt;&lt;td&gt; &lt;input style=\"WIDTH: 130px\" type=\"text\" name=\"q\" id=\"q\" onkeydown=\"return SearchGoogle(document.getElementById('q'),event,'http://www.cnblogs.com/hardrock/')\"&gt;&amp;nbsp;&lt;input onclick=\"SearchGoogle(document.getElementById('q'),event,'http://www.cnblogs.com/hardrock/')\" type=\"button\" value=\"搜索\" name=\"sa\"&gt; &lt;/td&gt;&lt;td&gt; &lt;script type=\"text/javascript\"&gt;&lt;!-- google_ad_client = \"pub-7558339387099421\"; google_ad_format = \"350x30_sdo\"; google_link_target = 2; google_color_bg = \"ffffff\"; google_color_link = \"black\"; google_encoding = \"UTF-8\"; //--&gt; &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"http://pagead2.googlesyndication.com/pagead/show_ads.js\"&gt; &lt;/script&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"为CSDN博客添加站内搜索栏目","slug":"为CSDN博客添加站内搜索栏目","date":"2020-05-27T06:45:00.000Z","updated":"2020-07-10T06:46:17.910Z","comments":true,"path":"2020/05/27/为CSDN博客添加站内搜索栏目/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/27/%E4%B8%BACSDN%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E6%A0%8F%E7%9B%AE/","excerpt":"栏目代码 &lt;div id=\"panel_Search\"&gt; &lt;img src=\"http://img.blog.csdn.net/20170719024744725?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva3hwOTU0NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"&gt; &lt;form action=\"https://www.google.com/search\" method=\"get\" target=\"_blank\"&gt; &lt;span&gt;&lt;input class=\"blogsearch\" title=\"请输入关键字\" id=\"inputSearch\" type=\"text\" placeholder=\"使用Google搜索本博客\" autofocus name=\"q\"&gt;&lt;/span&gt; &lt;input type=\"hidden\" name=\"hl\" value=\"zh-CN\"&gt; &lt;input type=\"hidden\" name=\"sitesearch\" value=\"blog.csdn.net/kxp9545\"&gt; &lt;input id=\"btnSubmit\" type=\"submit\" value=\"搜索 \"&gt; &lt;/form&gt; &lt;/div&gt;","text":"栏目代码 &lt;div id=\"panel_Search\"&gt; &lt;img src=\"http://img.blog.csdn.net/20170719024744725?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva3hwOTU0NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"&gt; &lt;form action=\"https://www.google.com/search\" method=\"get\" target=\"_blank\"&gt; &lt;span&gt;&lt;input class=\"blogsearch\" title=\"请输入关键字\" id=\"inputSearch\" type=\"text\" placeholder=\"使用Google搜索本博客\" autofocus name=\"q\"&gt;&lt;/span&gt; &lt;input type=\"hidden\" name=\"hl\" value=\"zh-CN\"&gt; &lt;input type=\"hidden\" name=\"sitesearch\" value=\"blog.csdn.net/kxp9545\"&gt; &lt;input id=\"btnSubmit\" type=\"submit\" value=\"搜索 \"&gt; &lt;/form&gt; &lt;/div&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Win10 沉浸式搜索框居中显示","slug":"Win10 沉浸式搜索框居中显示","date":"2020-05-27T06:37:00.000Z","updated":"2020-07-10T06:46:17.744Z","comments":true,"path":"2020/05/27/Win10 沉浸式搜索框居中显示/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/27/Win10%20%E6%B2%89%E6%B5%B8%E5%BC%8F%E6%90%9C%E7%B4%A2%E6%A1%86%E5%B1%85%E4%B8%AD%E6%98%BE%E7%A4%BA/","excerpt":"Windows 10 沉浸式搜索栏居中显示设置，可直接对注册表进行修改从而实现。导入注册表，重启 Windows 资源管理器即可。然后使用 Win + S 快捷键即可看到沉浸式搜索栏已在屏幕中央进行居中显示，复制下方命令，粘贴在记事本中，另存为 修改.reg 后双击运行导入使用。","text":"Windows 10 沉浸式搜索栏居中显示设置，可直接对注册表进行修改从而实现。导入注册表，重启 Windows 资源管理器即可。然后使用 Win + S 快捷键即可看到沉浸式搜索栏已在屏幕中央进行居中显示，复制下方命令，粘贴在记事本中，另存为 修改.reg 后双击运行导入使用。 Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Search] \"ImmersiveSearch\"=dword:00000001 [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Search\\Flighting\\Override] \"ImmersiveSearchFull\"=dword:00000001 \"CenterScreenRoundedCornerRadius\"=dword:00000009 动图操作示范 如果不想用了，可以删除注册表就能恢复Windows10默认搜索样式。 Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Search] \"ImmersiveSearch\"=- [-HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Search\\Flighting\\Override] \"ImmersiveSearchFull\"=dword:00000001 \"CenterScreenRoundedCornerRadius\"=dword:00000009 关于注册表文件的删除语法 要使用 .reg 文件删除注册表项，将 .reg 文件中的 RegistryPath 的前面放一个连字符 （-）。 要使用 .reg 文件删除注册表值，将 .reg 文件中的 DataItemName 的等号后放一个连字符 （-）。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"免费域名注册","slug":"免费域名注册","date":"2020-05-27T06:16:00.000Z","updated":"2020-07-10T06:46:17.912Z","comments":true,"path":"2020/05/27/免费域名注册/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/27/%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C/","excerpt":"Freenom offers a free domain name service for casual users.The Freenom domain name is free for one year and can be renewed manually before expiration.","text":"Freenom offers a free domain name service for casual users.The Freenom domain name is free for one year and can be renewed manually before expiration. 1、访问 freenom 官网，然后在输入框内直接输入想要注册的域名地址，输入完成后点击后面的 检查可用性 ； 2、在列表内选择自己想要的域名后缀，然后点击 Get it now 进行选择，然后待列表右上方出现 check out 直接点击进入确认界面； 3、在已选的域名地址列表后方的下拉菜单内选择 12 Months @ FREE ，有效期 12 个月可免费使用，然后再输入自己的 QQ 邮箱，点击 Verify My Email Address ； 4、下方弹出提示验证邮箱，打开我们的QQ邮箱接收验证邮件，点击邮件内的链接进行验证，在打开的页面内输入个人信息并保存即可完成账户的创建； 5、点击按钮进入登陆界面，输入注册的账户及密码，点击 Login 进行登陆，然后在 Services – My Domains 查看自己注册的域名，已注册域名即在下方显示，点击 Manage Domain 即可进入域名管理； 6、在域名设置界面内，点击 Manage Freenom DNS 进入域名解析设置，Name 处填写 www 后面的 Target 处填写需要解析的 IP 地址即可，再点击 More Records 添加一行，Name 为空 后面的 Target 处再次填写需要解析的 IP 地址，详细的设置可以百度 域名解析设置 进行了解，配置完成后点击 Save Changes 保存，待使用 ping 域名返回服务器正确的 IP 则说明解析成功。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"【LeetCode】287. 寻找重复数","slug":"【LeetCode】287. 寻找重复数","date":"2020-05-26T09:16:00.000Z","updated":"2020-07-10T06:46:17.802Z","comments":true,"path":"2020/05/26/【LeetCode】287. 寻找重复数/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/26/%E3%80%90LeetCode%E3%80%91287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/","excerpt":"题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1: 输入: [1,3,4,2,2] 输出: 2 示例 2: 输入: [3,1,3,4,2] 输出: 3 说明： 不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n^2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。","text":"题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1: 输入: [1,3,4,2,2] 输出: 2 示例 2: 输入: [3,1,3,4,2] 输出: 3 说明： 不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n^2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。 题解本题目限定了元素的取值范围”其数字都在 1 到 n 之间（包括 1 和 n）”。 另外，“说明”里的也特别重要~ 说明： &gt; 不能更改原数组（假设数组是只读的）。 &gt; 只能使用额外的 O(1) 的空间。 &gt; 时间复杂度小于 O(n^2) 。 &gt; 数组中只有一个重复的数字，但它可能不止重复出现一次。 最后解决的思路很简单，就是使用双指针，直接看代码注释即可。 代码class Solution { public int findDuplicate(int[] nums) { // 如果数组就只有两个元素，直接返回即可 if(nums.length &lt;= 2) { return nums[0]; } int q = 0, s = 0; int indexStart = 0; // indexStart用以记录起步位置 // 初始化q、s应该指向[第一个index!=nums[index]的元素],不应该为0 for(int index = 0; index &lt; nums.length; index++) { if(index != nums[index]) { q = index; s = index; indexStart = index; // 保存起步位置 break; } } // 快慢指针从同一位置(index)起步 while(true) { // 快指针q的步长=2 q = nums[nums[q]]; // 慢指针s的步长=1 s = nums[s]; // 两指针相遇,结束第一次循环 if(q == s) { // 慢指针回到初始起步点indexStart s = indexStart; break; } } // 快慢指针继续一起移动,但要修改快指针的步长 // 快慢指针再相遇的元素,即所要的结果 while(true) { // 快指针q的步长=1 q = nums[q]; // 慢指针s的步长=1 s = nums[s]; // 两指针相遇,结束循环 if(q == s) { break; } } return s; } } 提交 题后今天这“每日一题”和《【LeetCode】面试题03. 数组中重复的数字》有些类似。不同的是，今天这题限定了一些特别的条件，比如： 不能更改原数组（假设数组是只读的） 只能使用额外的 O(1) 的空间 *时间复杂度小于 O(n^2) *尤其是对复杂对的要求，这就提高了算法设计的难度。 我想着各种优化方法，很艰难地，最后找到了这种。哇地一声就哭出来了，太难了/(ㄒoㄒ)/~~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"通过css样式实现动态背景","slug":"通过css样式实现动态背景","date":"2020-05-25T09:00:00.000Z","updated":"2020-07-10T06:46:17.951Z","comments":true,"path":"2020/05/25/通过css样式实现动态背景/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/25/%E9%80%9A%E8%BF%87css%E6%A0%B7%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF/","excerpt":"分享一张可以用来做动态背景的gif 通过css样式可实现👇","text":"分享一张可以用来做动态背景的gif 通过css样式可实现👇 &lt;style type = \"text/css\"&gt; @media(prefers - color - scheme: dark) {.js_darkmode__0 { color: rgba(0, 0, 0, 0.9) ! important; background - image: linear - gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(\"https://blog-static.cnblogs.com/files/melodyjerry/%E8%93%9D%E8%89%B2%E7%A2%8E%E7%89%87%E9%A3%9E%E8%88%9E.gif\") ! important; }.js_darkmode__1 { color: rgba(0, 0, 0, 0.9) ! important; }.js_darkmode__bg__0 { background - image: linear - gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(\"https://blog-static.cnblogs.com/files/melodyjerry/%E8%93%9D%E8%89%B2%E7%A2%8E%E7%89%87%E9%A3%9E%E8%88%9E.gif\"), linear - gradient(#fff, #fff) ! important; }.js_darkmode__bg__1 { background - image: -webkit - linear - gradient(left, transparent, rgb(153, 153, 152), transparent) ! important; } } &lt;/style&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://melodyjerry.github.io/blog/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"}]},{"title":"【LeetCode】4. 寻找两个正序数组的中位数","slug":"【LeetCode】4. 寻找两个正序数组的中位数","date":"2020-05-24T08:15:00.000Z","updated":"2020-07-10T06:46:17.755Z","comments":true,"path":"2020/05/24/【LeetCode】4. 寻找两个正序数组的中位数/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/24/%E3%80%90LeetCode%E3%80%914.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"题目描述给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 示例 2: nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5","text":"题目描述给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 示例 2: nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 题解代码class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { // 若仅当nums1为空 if (nums1 == null || nums1.length == 0) { int length = nums2.length; int middle = length / 2; if (length % 2 == 0) { return (nums2[middle] + nums2[middle - 1]) / 2.0; } else { return nums2[middle]; } } // 若仅当nums2为空 if (nums2 == null || nums2.length == 0) { int length = nums1.length; int middle = length / 2; if (length % 2 == 0) { return (nums1[middle] + nums1[middle - 1]) / 2.0; } else { return nums1[middle]; } } int len1 = nums1.length; int len2 = nums2.length; int middle = (len1+len2)/2; int currentIndex = 0; int i1 = 0, i2 = 0; int last = 0, current = 0; while(currentIndex &lt;= middle){ currentIndex++; last = current; /** * 注意越界情况： * 比如， * 1 2 3 4 * 5 6 7 7 8 9 * 当然，数组为空的情况也包含在这里面 */ // i1越界 if(i1 == len1){ current = nums2[i2]; i2++; continue; } // i2越界 if(i2 == len2){ current = nums1[i1]; i1++; continue; } // 正常操作 if(nums1[i1] &lt;= nums2[i2]){ current = nums1[i1]; i1++; } else { current = nums2[i2]; i2++; } } // 分奇偶情况 if((len1+len2) % 2 == 0){ return (last + current) / 2.0; } else { return current; } } } 提交 更多题解详细通俗的思路分析，多解法寻找两个有序数组的中位数 C / C++中位数的小技巧 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Web开发技术&API 接口参考","slug":"Web开发技术&API 接口参考","date":"2020-05-24T07:48:00.000Z","updated":"2020-07-10T06:46:17.703Z","comments":true,"path":"2020/05/24/Web开发技术&API 接口参考/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/24/Web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF&API%20%E6%8E%A5%E5%8F%A3%E5%8F%82%E8%80%83/","excerpt":"Web 开发技术https://developer.mozilla.org/zh-CN/docs/Web Web API 接口参考https://developer.mozilla.org/zh-CN/docs/Web/API","text":"Web 开发技术https://developer.mozilla.org/zh-CN/docs/Web Web API 接口参考https://developer.mozilla.org/zh-CN/docs/Web/API document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://melodyjerry.github.io/blog/tags/Web/"},{"name":"API","slug":"API","permalink":"https://melodyjerry.github.io/blog/tags/API/"}]},{"title":"在VS Code上刷LeetCode","slug":"在VS Code上刷LeetCode","date":"2020-05-24T04:54:00.000Z","updated":"2020-07-10T06:46:17.917Z","comments":true,"path":"2020/05/24/在VS Code上刷LeetCode/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/24/%E5%9C%A8VS%20Code%E4%B8%8A%E5%88%B7LeetCode/","excerpt":"插件说明 该插件需要用户本地拥有Node.js 8+运行环境。读者可以通过在命令行中输入node -v查看。 安装插件之后，可以在 LeetCode 插件的浏览器中找到登录按钮： 登录完成后，浏览器内就会显示出所有问题，并且问题将会按照难度，算法类型，公司进行分类，方便使用者进行针对性训练。 插件同时支持中文及英文版LeetCode，可以通过点击导航栏中的切换按钮（ 图案）进行切换： 右键点击某一个题目并选择 Show Problem 会生成答题文件，接着我们就可以开始刷题了。也可以点击 Preview Problem 先查看一下题目内容： 写完后，可以点击文件最下方的 “Submit” 提交答案，或者“Test”执行测试： 另外，插件还支持题目搜索，存档管理等功能。更多详细的插件使用介绍可以前往GitHub项目主页查看。 参考文章：https://blog.csdn.net/lzuacm/article/details/103375905","text":"插件说明 该插件需要用户本地拥有Node.js 8+运行环境。读者可以通过在命令行中输入node -v查看。 安装插件之后，可以在 LeetCode 插件的浏览器中找到登录按钮： 登录完成后，浏览器内就会显示出所有问题，并且问题将会按照难度，算法类型，公司进行分类，方便使用者进行针对性训练。 插件同时支持中文及英文版LeetCode，可以通过点击导航栏中的切换按钮（ 图案）进行切换： 右键点击某一个题目并选择 Show Problem 会生成答题文件，接着我们就可以开始刷题了。也可以点击 Preview Problem 先查看一下题目内容： 写完后，可以点击文件最下方的 “Submit” 提交答案，或者“Test”执行测试： 另外，插件还支持题目搜索，存档管理等功能。更多详细的插件使用介绍可以前往GitHub项目主页查看。 参考文章：https://blog.csdn.net/lzuacm/article/details/103375905 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"复制文字时自动加版权","slug":"复制文字时自动加版权","date":"2020-05-24T04:42:00.000Z","updated":"2020-07-10T06:46:17.918Z","comments":true,"path":"2020/05/24/复制文字时自动加版权/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/24/%E5%A4%8D%E5%88%B6%E6%96%87%E5%AD%97%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8A%A0%E7%89%88%E6%9D%83/","excerpt":"复制正文文字时自动加版权 在知乎复制的文本为什么会自带一些版权声明，这个功能是如何实现的? 知乎上复制回答，剪贴板里自动加上版权出处的技术js如何实现？ 在知乎复制的文本为什么会自带一些版权声明，这个功能是如何实现的?","text":"复制正文文字时自动加版权 在知乎复制的文本为什么会自带一些版权声明，这个功能是如何实现的? 知乎上复制回答，剪贴板里自动加上版权出处的技术js如何实现？ 在知乎复制的文本为什么会自带一些版权声明，这个功能是如何实现的? document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"}]},{"title":"Linux安装Docker","slug":"Linux安装Docker","date":"2020-05-24T03:51:00.000Z","updated":"2020-07-10T06:46:17.558Z","comments":true,"path":"2020/05/24/Linux安装Docker/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/24/Linux%E5%AE%89%E8%A3%85Docker/","excerpt":"介绍 来自百度百科的介绍 Docker的三大核心概念：镜像、容器、仓库 镜像：类似虚拟机的镜像、用俗话说就是安装文件。 容器：类似一个轻量级的沙箱，容器是从镜像创建应用运行实例，可以将其启动、开始、停止、删除、而这些容器都是相互隔离、互不可见的。 仓库：类似代码仓库，是Docker集中存放镜像文件的场所。 是收费软件？就目前来讲，docker有两个版本Docker CE和Docker EE，CE是社区版的免费软件，EE是企业版的收费软件。 安装使用脚本来安装 查询内核 ![Y2PztK.png](https://s1.ax1x.com/2020/05/17/Y2PztK.png) 2. 使用root用户登录linux系统后，将yum包更新到最新： 关于root模式，见[Linux root 模式](https://www.cnblogs.com/melodyjerry/p/12904792.html) ```$ yum update 执行docker安装脚本(因curl命令需要一个网址，网址被禁止发布，此处不能列出) ```sh get-docker.sh 启动docker进程 systemctl start docker 验证docker是否安装成功：docker run hello-world 删除使用yum命令 然后将docker的安装目录删除 ```rm -rf /var/lib/docker 就可以了。 参考阅读菜鸟教程-CentOS Docker 安装","text":"介绍 来自百度百科的介绍 Docker的三大核心概念：镜像、容器、仓库 镜像：类似虚拟机的镜像、用俗话说就是安装文件。 容器：类似一个轻量级的沙箱，容器是从镜像创建应用运行实例，可以将其启动、开始、停止、删除、而这些容器都是相互隔离、互不可见的。 仓库：类似代码仓库，是Docker集中存放镜像文件的场所。 是收费软件？就目前来讲，docker有两个版本Docker CE和Docker EE，CE是社区版的免费软件，EE是企业版的收费软件。 安装使用脚本来安装 查询内核 ![Y2PztK.png](https://s1.ax1x.com/2020/05/17/Y2PztK.png) 2. 使用root用户登录linux系统后，将yum包更新到最新： 关于root模式，见[Linux root 模式](https://www.cnblogs.com/melodyjerry/p/12904792.html) ```$ yum update 执行docker安装脚本(因curl命令需要一个网址，网址被禁止发布，此处不能列出) ```sh get-docker.sh 启动docker进程 systemctl start docker 验证docker是否安装成功：docker run hello-world 删除使用yum命令 然后将docker的安装目录删除 ```rm -rf /var/lib/docker 就可以了。 参考阅读菜鸟教程-CentOS Docker 安装 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"【LeetCode】面试题03. 数组中重复的数字","slug":"【LeetCode】面试题03. 数组中重复的数字","date":"2020-05-23T14:37:00.000Z","updated":"2020-07-10T06:46:17.804Z","comments":true,"path":"2020/05/23/【LeetCode】面试题03. 数组中重复的数字/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/23/%E3%80%90LeetCode%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9803.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"题目来源《剑指 Offer（第 2 版）》 题目描述找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制： 2 &lt;= n &lt;= 100000","text":"题目来源《剑指 Offer（第 2 版）》 题目描述找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 题解思路题目中有2句很重要的话“在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内”、“任意一个重复的数字”，前者限定了元素的取值范围；而后者要求只要找到了重复数字就可以直接return了。 本题的关键是“重复”！！！ 既然是“重复”，那第一会想到什么？Set 集合！ Set集合有个重要的特性：不能存储相同的元素。 利用Set集合就很好解决了，操作步骤如下： 初始化一个set 遍历数组 将元素加入到set中，并判断是否加入成功 若成功了，就继续遍历 若失败了，说明该元素已经再该集合中- 直接break，并return该元素的值 若没有重复元素，就return -1 关于Set集合见Java集合-Set（含转载） 代码class Solution { public int findRepeatNumber(int[] nums) { Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int num : nums){ /* 若添加失败，说明该元素已经在集合中，因此该元素是重复元素 */ if(!set.add(num)){ return num; } } // 若没有重复元素，直接返回-1 return -1; } } 提交 拓展评论里第一条是👇，可以当作这次拓展内容补充补充。 class Solution: def findRepeatNumber(self, nums: List[int]) -&gt; int: def count(start,end): c,i=0,0 while i&lt;len(nums): if start&lt;=nums[i]&lt;=end: c+=1 i+=1 return c left,right = 0,len(nums)-1 if right&lt;1:return -1 while left+1&lt;right: mid = (left+right)//2 if count(left,mid)&gt;mid-left+1: right = mid else: left = mid if count(nums[left],nums[left])&gt;1:return nums[left] if count(nums[right],nums[right])&gt;1:return nums[right] return -1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java集合-Set（含转载）","slug":"Java集合-Set（含转载）","date":"2020-05-23T12:43:00.000Z","updated":"2020-07-10T06:46:17.613Z","comments":true,"path":"2020/05/23/Java集合-Set（含转载）/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/23/Java%E9%9B%86%E5%90%88-Set%EF%BC%88%E5%90%AB%E8%BD%AC%E8%BD%BD%EF%BC%89/","excerpt":"Set概述set集合不能存储相同的元素 同时因为其是一个抽象的接口：所以不能直接实例化一个set对象。 Set s = new Set() ：× 该接口主要继承于Collections接口，所以具有Collection的一些常见的方法。 常见用法 Sr.No. Method Description 1 add( ) 向集合中添加元素 2 clear( ) 去掉集合中所有的元素 3 contains( ) 判断集合中是否包含某一个元素 4 isEmpty( ) 判断集合是否为空 5 iterator( ) 主要用于递归集合，返回一个Iterator()对象 6 remove( ) 从集合中去掉特定的对象 7 size( ) 返回集合的大小 Set接口最长用的两大实现： HashSet TreeSet","text":"Set概述set集合不能存储相同的元素 同时因为其是一个抽象的接口：所以不能直接实例化一个set对象。 Set s = new Set() ：× 该接口主要继承于Collections接口，所以具有Collection的一些常见的方法。 常见用法 Sr.No. Method Description 1 add( ) 向集合中添加元素 2 clear( ) 去掉集合中所有的元素 3 contains( ) 判断集合中是否包含某一个元素 4 isEmpty( ) 判断集合是否为空 5 iterator( ) 主要用于递归集合，返回一个Iterator()对象 6 remove( ) 从集合中去掉特定的对象 7 size( ) 返回集合的大小 Set接口最长用的两大实现： HashSet TreeSet HashSet类（散列存放）Java.util.HashSet类实现了Java.util.Set接口。 它不允许出现重复元素； 不保证和政集合中元素的顺序 允许包含值为null的元素，但最多只能有一个null元素。 import java.util.Date; import java.util.HashSet; import java.util.Iterator; public class TestHashSet { public static void main(String [] args) { HashSet h=new HashSet(); h.add(\"1st\"); h.add(\"2nd\"); h.add(new Integer(3)); h.add(new Double(4.0)); h.add(\"2nd\"); //重复元素，未被添加 h.add(new Integer(3)); //重复元素，未被添加 h.add(new Date()); System.out.println(\"开始：size=\"+h.size()); Iterator it=h.iterator(); while(it.hasNext()) { Object o=it.next(); System.out.println(o); } h.remove(\"2nd\"); System.out.println(\"移除元素后：size=\"+h.size()); System.out.println(h); } } TreeSet（有序存放） TreeSet描述的是Set的一种变体 ———— 可以实现排序等功能的集合，它在讲对象元素添加到集合中时会自动按照某种比较规则将其插入到有序的对象序列中，并保证该集合元素组成的读uixiangxulie时刻按照“升序”排列。 import java.util.TreeSet; import java.util.Iterator; public class TestTreeSet { public static void main(String [] args) { TreeSet ts=new TreeSet(); ts.add(\"orange\"); ts.add(\"apple\"); ts.add(\"banana\"); ts.add(\"grape\"); Iterator it=ts.iterator(); while(it.hasNext()) { String fruit=(String)it.next(); System.out.println(fruit); } } } Java中三种Set类型用法、性能大比拼 - 云+社区 - 腾讯云 转载内容转载学习一份关于Java Set集合的基础笔记，一下内容来自~ 作者：贾博岩链接：https://www.jianshu.com/p/b48c47a42916来源：简书 Set上一篇，我们介绍Java中的List集合。本篇，让我们继续学习，来了解下Set集合； Set继承于Collection接口，是一个不允许出现重复元素，并且无序的集合，主要有HashSet和TreeSet两大实现类。 在判断重复元素的时候，Set集合会调用hashCode()和equal()方法来实现。 HashSet是哈希表结构，主要利用HashMap的key来存储元素，计算插入元素的hashCode来获取元素在集合中的位置； TreeSet是红黑树结构，每一个元素都是树中的一个节点，插入的元素都会进行排序； Set集合框架结构： Set常用方法与List接口一样，Set接口也提供了集合操作的基本方法。 但与List不同的是，Set还提供了equals(Object o)和hashCode()，供其子类重写，以实现对集合中插入重复元素的处理； public interface Set&lt;E&gt; extends Collection&lt;E&gt; { A:添加功能 boolean add(E e); boolean addAll(Collection&lt;? extends E&gt; c); B:删除功能 boolean remove(Object o); boolean removeAll(Collection&lt;?&gt; c); void clear(); C:长度功能 int size(); D:判断功能 boolean isEmpty(); boolean contains(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); E:获取Set集合的迭代器： Iterator&lt;E&gt; iterator(); F:把集合转换成数组 Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); //判断元素是否重复，为子类提高重写方法 boolean equals(Object o); int hashCode(); } HashSetHashSet实现Set接口，底层由HashMap(后面讲解)来实现，为哈希表结构，新增元素相当于HashMap的key，value默认为一个固定的Object。在我看来，HashSet相当于一个阉割版的HashMap; 当有元素插入的时候，会计算元素的hashCode值，将元素插入到哈希表对应的位置中来； 它继承于AbstractSet，实现了Set, Cloneable, Serializable接口。 (1)HashSet继承AbstractSet类，获得了Set接口大部分的实现，减少了实现此接口所需的工作，实际上是又继承了AbstractCollection类； (2)HashSet实现了Set接口，获取Set接口的方法，可以自定义具体实现，也可以继承AbstractSet类中的实现； (3)HashSet实现Cloneable，得到了clone()方法，可以实现克隆功能； (4)HashSet实现Serializable，表示可以被序列化，通过序列化去传输，典型的应用就是hessian协议。 具有如下特点： 不允许出现重复因素； 允许插入Null值； 元素无序（添加顺序和遍历顺序不一致）； 线程不安全，若2个线程同时操作HashSet，必须通过代码实现同步； HashSet基本操作HashSet底层由HashMap实现，插入的元素被当做是HashMap的key，根据hashCode值来确定集合中的位置，由于Set集合中并没有角标的概念，所以并没有像List一样提供get（）方法。当获取HashSet中某个元素时，只能通过遍历集合的方式进行equals()比较来实现； public class HashSetTest { public static void main(String[] agrs){ //创建HashSet集合： Set&lt;String&gt; hashSet = new HashSet&lt;String&gt;(); System.out.println(\"HashSet初始容量大小：\"+hashSet.size()); //元素添加： hashSet.add(\"my\"); hashSet.add(\"name\"); hashSet.add(\"is\"); hashSet.add(\"jiaboyan\"); hashSet.add(\",\"); hashSet.add(\"hello\"); hashSet.add(\"world\"); hashSet.add(\"!\"); System.out.println(\"HashSet容量大小：\"+hashSet.size()); //迭代器遍历： Iterator&lt;String&gt; iterator = hashSet.iterator(); while (iterator.hasNext()){ String str = iterator.next(); System.out.println(str); } //增强for循环 for(String str:hashSet){ if(\"jiaboyan\".equals(str)){ System.out.println(\"你就是我想要的元素:\"+str); } System.out.println(str); } //元素删除： hashSet.remove(\"jiaboyan\"); System.out.println(\"HashSet元素大小：\" + hashSet.size()); hashSet.clear(); System.out.println(\"HashSet元素大小：\" + hashSet.size()); //集合判断： boolean isEmpty = hashSet.isEmpty(); System.out.println(\"HashSet是否为空：\" + isEmpty); boolean isContains = hashSet.contains(\"hello\"); System.out.println(\"HashSet是否为空：\" + isContains); } } HashSet元素添加分析Set集合不允许添加重复元素，那么到底是个怎么情况呢？ 来看一个简单的例子： public class HashSetTest { public static void main(String[] agrs){ //hashCode() 和 equals()测试： hashCodeAndEquals(); } public static void hashCodeAndEquals(){ //第一个 Set集合： Set&lt;String&gt; set1 = new HashSet&lt;String&gt;(); String str1 = new String(\"jiaboyan\"); String str2 = new String(\"jiaboyan\"); set1.add(str1); set1.add(str2); System.out.println(\"长度：\"+set1.size()+\",内容为：\"+set1); //第二个 Set集合： Set&lt;App&gt; set2 = new HashSet&lt;App&gt;(); App app1 = new App(); app1.setName(\"jiaboyan\"); App app2 = new App(); app2.setName(\"jiaboyan\"); set2.add(app1); set2.add(app2); System.out.println(\"长度：\"+set2.size()+\",内容为：\"+set2); //第三个 Set集合： Set&lt;App&gt; set3 = new HashSet&lt;App&gt;(); App app3 = new App(); app3.setName(\"jiaboyan\"); set3.add(app3); set3.add(app3); System.out.println(\"长度：\"+set3.size()+\",内容为：\"+set3); } } 测试结果： 长度：1,内容为：[jiaboyan] 长度：2,内容为：[com.jiaboyan.collection.App@efb78af, com.jiaboyan.collection.App@5f3306ad] 长度：1,内容为：[com.jiaboyan.collection.App@1fb030d8] 可以看到，第一个Set集合中最终只有一个元素；第二个Set集合保留了2个元素；第三个集合也只有1个元素； 究竟是什么原因呢？ 让我们来看看HashSet的add(E e)方法： public boolean add(E e) { return map.put(e, PRESENT)==null; } 在底层HashSet调用了HashMap的put(K key, V value)方法: public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); return null; } 通过查看以上的源码，我们可以了解到：实际的逻辑都是在HashMap的put()方法中。 int hash = hash(key) 对传入的key计算hash值； int i = indexFor(hash, table.length) 对hash值进行转换，转换成数组的index(HashMap中底层存储使用了Entry&lt;K,V&gt;[]数组)； for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) 判断对应index下是否存在元素； 如果存在，则if(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))判断； 如果不存在，则addEntry(hash, key, value, i)直接添加； 简单概括如下： 在向HashMap中添加元素时，先判断key的hashCode值是否相同，如果相同，则调用equals()、==进行判断，若相同则覆盖原有元素；如果不同，则直接向Map中添加元素； 反过来，我们在看下上面的例子： 在第一个Set集合中，我们new了两个String对象，赋了相同的值。当传入到HashMap中时，key均为“jiaboyan”，所以hash和i的值都相同。进行if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))判断，由于String对象重写了equals()方法，所以在((k = e.key) == key || key.equals(k))判断时，返回了true，所以第二次的插入并不会增加Set集合的长度； 第二个Set集合中，也是new了两个对象，但没有重写equals()方法（底层调用的Object的equals()，也就是==判断），所以会增加2个元素； 第三个Set集合中，只new了一个对象，调用的两次add方法都添加的这个新new的对象，所以也只是保留了1个元素； TreeSet从名字上可以看出，此集合的实现和树结构有关。与HashSet集合类似，TreeSet也是基于Map来实现，具体实现TreeMap(后面讲解)，其底层结构为红黑树（特殊的二叉查找树）； 与HashSet不同的是，TreeSet具有排序功能，分为自然排序(123456)和自定义排序两类，默认是自然排序；在程序中，我们可以按照任意顺序将元素插入到集合中，等到遍历时TreeSet会按照一定顺序输出–倒序或者升序； 它继承AbstractSet，实现NavigableSet, Cloneable, Serializable接口。 （1）与HashSet同理，TreeSet继承AbstractSet类，获得了Set集合基础实现操作； （2）TreeSet实现NavigableSet接口，而NavigableSet又扩展了SortedSet接口。这两个接口主要定义了搜索元素的能力，例如给定某个元素，查找该集合中比给定元素大于、小于、等于的元素集合，或者比给定元素大于、小于、等于的元素个数；简单地说，实现NavigableSet接口使得TreeSet具备了元素搜索功能； （3）TreeSet实现Cloneable接口，意味着它也可以被克隆； （4）TreeSet实现了Serializable接口，可以被序列化，可以使用hessian协议来传输； 具有如下特点： 对插入的元素进行排序，是一个有序的集合（主要与HashSet的区别）; 底层使用红黑树结构，而不是哈希表结构； 允许插入Null值； 不允许插入重复元素； 线程不安全； TreeSet基本操作public class TreeSetTest { public static void main(String[] agrs){ TreeSet&lt;String&gt; treeSet = new TreeSet&lt;String&gt;(); System.out.println(\"TreeSet初始化容量大小：\"+treeSet.size()); //元素添加： treeSet.add(\"my\"); treeSet.add(\"name\"); treeSet.add(\"jiaboyan\"); treeSet.add(\"hello\"); treeSet.add(\"world\"); treeSet.add(\"1\"); treeSet.add(\"2\"); treeSet.add(\"3\"); System.out.println(\"TreeSet容量大小：\" + treeSet.size()); System.out.println(\"TreeSet元素顺序为：\" + treeSet.toString()); //增加for循环遍历： for(String str:treeSet){ System.out.println(\"遍历元素：\"+str); } //迭代器遍历：升序 Iterator&lt;String&gt; iteratorAesc = treeSet.iterator(); while(iteratorAesc.hasNext()){ String str = iteratorAesc.next(); System.out.println(\"遍历元素升序：\"+str); } //迭代器遍历：降序 Iterator&lt;String&gt; iteratorDesc = treeSet.descendingIterator(); while(iteratorDesc.hasNext()){ String str = iteratorDesc.next(); System.out.println(\"遍历元素降序：\"+str); } //元素获取:实现NavigableSet接口 String firstEle = treeSet.first();//获取TreeSet头节点： System.out.println(\"TreeSet头节点为：\" + firstEle); // 获取指定元素之前的所有元素集合：(不包含指定元素) SortedSet&lt;String&gt; headSet = treeSet.headSet(\"jiaboyan\"); System.out.println(\"jiaboyan节点之前的元素为：\"+headSet.toString()); //获取给定元素之间的集合：（包含头，不包含尾） SortedSet subSet = treeSet.subSet(\"1\",\"world\"); System.out.println(\"1--jiaboan之间节点元素为：\"+subSet.toString()); //集合判断： boolean isEmpty = treeSet.isEmpty(); System.out.println(\"TreeSet是否为空：\"+isEmpty); boolean isContain = treeSet.contains(\"who\"); System.out.println(\"TreeSet是否包含who元素：\"+isContain); //元素删除： boolean jiaboyanRemove = treeSet.remove(\"jiaboyan\"); System.out.println(\"jiaboyan元素是否被删除\"+jiaboyanRemove); //集合中不存在的元素，删除返回false boolean whoRemove = treeSet.remove(\"who\"); System.out.println(\"who元素是否被删除\"+whoRemove); //删除并返回第一个元素：如果set集合不存在元素，则返回null String pollFirst = treeSet.pollFirst(); System.out.println(\"删除的第一个元素：\"+pollFirst); //删除并返回最后一个元素：如果set集合不存在元素，则返回null String pollLast = treeSet.pollLast(); System.out.println(\"删除的最后一个元素：\"+pollLast); treeSet.clear();//清空集合: } } TreeSet元素排序在前面的章节，我们讲到了TreeSet是一个有序集合，可以对集合元素排序，其中分为自然排序和自定义排序，那么这两种方式如何实现呢？ 首先，我们通过JDK提供的对象来展示，我们使用String、Integer： public class TreeSetTest { public static void main(String[] agrs){ naturalSort(); } //自然排序顺序：升序 public static void naturalSort(){ TreeSet&lt;String&gt; treeSetString = new TreeSet&lt;String&gt;(); treeSetString.add(\"a\"); treeSetString.add(\"z\"); treeSetString.add(\"d\"); treeSetString.add(\"b\"); System.out.println(\"字母顺序：\" + treeSetString.toString()); TreeSet&lt;Integer&gt; treeSetInteger = new TreeSet&lt;Integer&gt;(); treeSetInteger.add(1); treeSetInteger.add(24); treeSetInteger.add(23); treeSetInteger.add(6); System.out.println(treeSetInteger.toString()); System.out.println(\"数字顺序：\" + treeSetString.toString()); } } 测试结果： 字母顺序：[a, b, d, z] 数字顺序：[1, 6, 23, 24] 接下来，我们自定义对象，看能否实现： public class App{ private String name; private Integer age; public App(){} public App(String name,Integer age){ this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public static void main(String[] args ){ System.out.println( \"Hello World!\" ); } } public class TreeSetTest { public static void main(String[] agrs){ customSort(); } //自定义排序顺序：升序 public static void customSort(){ TreeSet&lt;App&gt; treeSet = new TreeSet&lt;App&gt;(); //排序对象： App app1 = new App(\"hello\",10); App app2 = new App(\"world\",20); App app3 = new App(\"my\",15); App app4 = new App(\"name\",25); //添加到集合： treeSet.add(app1); treeSet.add(app2); treeSet.add(app3); treeSet.add(app4); System.out.println(\"TreeSet集合顺序为：\"+treeSet); } } 测试结果： 抛出异常：提示App不能转换为Comparable对象： Exception in thread \"main\" java.lang.ClassCastException: com.jiaboyan.collection.App cannot be cast to java.lang.Comparable 为什么会报错呢？ compare(key, key); // type (and possibly null) check final int compare(Object k1, Object k2) { return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2); } 通过查看源码发现，在TreeSet调用add方法时，会调用到底层TreeMap的put方法，在put方法中会调用到compare(key, key)方法，进行key大小的比较； 在比较的时候，会将传入的key进行类型强转，所以当我们自定义的App类进行比较的时候，自然就会抛出异常，因为App类并没有实现Comparable接口； 将App实现Comparable接口，在做比较: public class App implements Comparable&lt;App&gt;{ private String name; private Integer age; public App(){} public App(String name,Integer age){ this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } //自定义比较：先比较name的长度，在比较age的大小； public int compareTo(App app) { //比较name的长度： int num = this.name.length() - app.name.length(); //如果name长度一样，则比较年龄的大小： return num == 0 ? this.age - app.age : num; } @Override public String toString() { return \"App{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试结果如下： TreeSet集合顺序为：[App{name='my', age=15}, App{name='name', age=25}, App{name='hello', age=10}, App{name='world', age=20}] 此外，还有另一种方式，那就是实现Comparetor接口，并重写compare方法； //自定义App类的比较器： public class AppComparator implements Comparator&lt;App&gt; { //比较方法：先比较年龄，年龄若相同在比较名字长度； public int compare(App app1, App app2) { int num = app1.getAge() - app2.getAge(); return num == 0 ? app1.getName().length() - app2.getName().length() : num; } } 此时，App不用在实现Comparerable接口了，单纯的定义一个类即可； public class App{ private String name; private Integer age; public App(){} public App(String name,Integer age){ this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public static void main(String[] args ){ System.out.println( \"Hello World!\" ); } } public class TreeSetTest { public static void main(String[] agrs){ customSort(); } //自定义比较器：升序 public static void customComparatorSort(){ TreeSet&lt;App&gt; treeSet = new TreeSet&lt;App&gt;(new AppComparator()); //排序对象： App app1 = new App(\"hello\",10); App app2 = new App(\"world\",20); App app3 = new App(\"my\",15); App app4 = new App(\"name\",25); //添加到集合： treeSet.add(app1); treeSet.add(app2); treeSet.add(app3); treeSet.add(app4); System.out.println(\"TreeSet集合顺序为：\"+treeSet); } } 测试结果： TreeSet集合顺序为：[App{name='hello', age=10}, App{name='my', age=15}, App{name='world', age=20}, App{name='name', age=25}] 最后，在说下关于compareTo()、compare()方法： 结果返回大于0时，方法前面的值大于方法中的值； 结果返回等于0时，方法前面的值等于方法中的值； 结果返回小于0时，方法前面的值小于方法中的值； 集合排序方法 @Test public void testFor() { String orderId1 = \"2321837281372913\"; String userId1 = \"20180701001\"; String orderId2 = \"2321837281372914\"; String userId2 = \"20180701002\"; String orderId3 = \"2321837281372912\"; String userId3 = \"20180701003\"; String orderId4 = \"2321837281372918\"; String userId4 = \"20180701005\"; String orderId5 = \"2321837281372918\"; String userId5 = \"20180701004\"; Order order = new Order(); order.setUserId(userId1); order.setOrderId(orderId1); Order order1 = new Order(); order1.setOrderId(orderId2); order1.setUserId(userId2); Order order2 = new Order(); order2.setOrderId(orderId3); order2.setUserId(userId3); Order order3 = new Order(); order3.setOrderId(orderId4); order3.setUserId(userId4); Order order4 = new Order(); order4.setOrderId(orderId5); order4.setUserId(userId5); List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); orderList.add(order); orderList.add(order1); orderList.add(order2); orderList.add(order3); orderList.add(order4); //1.jdk8 lambda排序，带参数类型 // orderList.sort(( Order ord1, Order ord2) -&gt; ord2.getOrderId().compareTo(ord1.getOrderId())); //2.jdk8 lambda排序，不带参数类型 // orderList.sort(( ord1, ord2) -&gt; ord2.getOrderId().compareTo(ord1.getOrderId())); //3.jdk8 升序排序，Comparator提供的静态方法 Collections.sort(orderList, Comparator.comparing(Order::getOrderId)); //4.jdk8 降序排序，Comparator提供的静态方法 // Collections.sort(orderList, Comparator.comparing(Order::getOrderId).reversed()); //5.jdk8 组合排序，Comparator提供的静态方法，先按orderId排序，orderId相同的按userId排序 // Collections.sort(orderList, Comparator.comparing(Order::getOrderId).reversed().thenComparing(Order::getUserId)); orderList.stream().forEach(str -&gt; System.out.println(str.getOrderId()+\"/\" + str.getUserId())); } 作者：贾博岩链接：https://www.jianshu.com/p/b48c47a42916来源：简书 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"【LeetCode】680. 验证回文字符串 Ⅱ","slug":"【LeetCode】680. 验证回文字符串 Ⅱ","date":"2020-05-21T02:42:00.000Z","updated":"2020-07-10T06:46:17.805Z","comments":true,"path":"2020/05/21/【LeetCode】680. 验证回文字符串 Ⅱ/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/21/%E3%80%90LeetCode%E3%80%91680.%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%20%E2%85%A1/","excerpt":"题目描述给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: “aba”输出: True 示例 2: 输入: “abca”输出: True解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。","text":"题目描述给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: “aba”输出: True 示例 2: 输入: “abca”输出: True解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 题解思路我们先来看看最简单的情况，也就是不删除字符的情况，然后再递进看看删除情况。 不删除字符的情况 先考虑如果不允许删除字符，如何判断一个字符串是否是回文串？双指针！！！定义左右指针left、right，初始时分别指向字符串的第一个字符和最后一个字符。每次判断左右指针指向的字符是否相同，如果不相同，则不是回文串；如果相同，则将左右指针都往中间移动一位，直到左右指针相遇，则字符串是回文串。 删除1个字符的情况 在前面不删除的情况下，发现在找到不相等的元素时，[0, left) 和 (right, len(s) - 1] 这两部分已经判断过是回文，因此不用再次判断。 剩下的只需要再判断 [left, right] 区间中的字符串，即删除 left 或者 right 指向的元素，剩余的区间 (left, right] 或者 [left, right) 是否为回文串。 若 (left, right] 或者 [left, right) 为回文串，则说明删除了一个字符可以构成回文串。 注意的是：若删除过一次，则不是回文串。 如果左右指针从两端同时向中间走，那么： 第一步： a b c a | | left right 第二步： a b c a | | left right 第一步，左右指针遇到的元素相等，继续向中间走；第二步，左右指针遇到的元素不等，则必须进行处理：我们必须删除其中的一个字符，然后再判断 剩余的所有字符 是否是回文串。 删除 b： a c a 或者 删除 c： a b a 即判断 aca 或者 aba 是否为回文字符串。 看看官方给出的实例，辅助理解： 代码class Solution { int del = 0; // 记录删除节点的次数 public boolean validPalindrome(String s) { int left = 0, right = s.length()-1; // left左指针 right右指针 while(left &lt; right){ if(s.charAt(left) == s.charAt(right)){ left++; right--; }else{ // 不相等的话，若没有删除字符，则删除左边或右边的字符再判断 // 若删除过一次，则不是回文串 if(del == 0){ del++; return validPalindrome(s.substring(left, right)) || validPalindrome(s.substring(left+1, right+1)); } return false; } } return true; /* if(left &gt; right) return true; */ } } 复杂度分析时间复杂度：O(n)。其中 n 是字符串的长度。判断整个字符串是否是回文字符串的时间复杂度是 O(n)，遇到不同字符时，判断两个子串是否是回文字符串的时间复杂度也都是 O(n)。空间复杂度：O(1)。只需要维护有限的常量空间。 提交 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Linux root 模式","slug":"Linux root 模式","date":"2020-05-17T04:34:00.000Z","updated":"2020-07-10T06:46:17.617Z","comments":true,"path":"2020/05/17/Linux root 模式/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/17/Linux%20root%20%E6%A8%A1%E5%BC%8F/","excerpt":"第一种方式：sudo（暂时的） 输入sudo，然后显示可以输入的命令 sudo-b：在后台执行指令-h：帮助-H：将HOME环境变量设为新身份的HOME环境变量-k：结束密码的有效期限，即下次再执行sudo时需要输入密码-l：列出目前用户可执行与无法执行的指令-p：改变询问密码的提示符号-s：执行指定的shell-u&lt;用户&gt;：以指定的用户作为新的身份-v：延长密码有效期限5分钟-V ：显示版本信息 这里我们输入sudo -i，再输入你的用户密码，就会进入root模式了。 但是这个方法持续的时间只有五分钟，想要延长时间可以用sudo -v再延长五分钟。 第二种方法：root（非暂时的） 输入sudo passwd root（注意passwd的拼写），再输入用户密码，接下来会让你设置root密码，并再次确认。 接下来输入su，再输入刚刚设置的root密码就可以进入root了。 之后想要退出输入exit即可。","text":"第一种方式：sudo（暂时的） 输入sudo，然后显示可以输入的命令 sudo-b：在后台执行指令-h：帮助-H：将HOME环境变量设为新身份的HOME环境变量-k：结束密码的有效期限，即下次再执行sudo时需要输入密码-l：列出目前用户可执行与无法执行的指令-p：改变询问密码的提示符号-s：执行指定的shell-u&lt;用户&gt;：以指定的用户作为新的身份-v：延长密码有效期限5分钟-V ：显示版本信息 这里我们输入sudo -i，再输入你的用户密码，就会进入root模式了。 但是这个方法持续的时间只有五分钟，想要延长时间可以用sudo -v再延长五分钟。 第二种方法：root（非暂时的） 输入sudo passwd root（注意passwd的拼写），再输入用户密码，接下来会让你设置root密码，并再次确认。 接下来输入su，再输入刚刚设置的root密码就可以进入root了。 之后想要退出输入exit即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"Ubuntu使用yum","slug":"Ubuntu使用yum","date":"2020-05-17T04:32:00.000Z","updated":"2020-07-10T06:46:17.701Z","comments":true,"path":"2020/05/17/Ubuntu使用yum/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/17/Ubuntu%E4%BD%BF%E7%94%A8yum/","excerpt":"yum介绍详细转见yum 命令讲解","text":"yum介绍详细转见yum 命令讲解 安装 首先打开终端（Ctrl+Alt+T），进入root模式 jerry是用户名，也就是你自己起的名字。@是分割的符号jerry-VirtualBox是主机名，也就是你所使用的机器的名称是当前目录，”“表示根目录$是提示符，当进入root时，会变成# 第一种方式：sudo（暂时的） 输入sudo，然后显示可以输入的命令 sudo-b：在后台执行指令-h：帮助-H：将HOME环境变量设为新身份的HOME环境变量-k：结束密码的有效期限，即下次再执行sudo时需要输入密码-l：列出目前用户可执行与无法执行的指令-p：改变询问密码的提示符号-s：执行指定的shell-u&lt;用户&gt;：以指定的用户作为新的身份-v：延长密码有效期限5分钟-V ：显示版本信息 这里我们输入sudo -i，再输入你的用户密码，就会进入root模式了。 但是这个方法持续的时间只有五分钟，想要延长时间可以用sudo -v再延长五分钟。 第二种方法：root（非暂时的） 输入sudo passwd root（注意passwd的拼写），再输入用户密码，接下来会让你设置root密码，并再次确认。 接下来输入su，再输入刚刚设置的root密码就可以进入root了。 之后想要退出输入exit即可。 检测是否安装了build-essential程序包 ![Y2Vg6U.png](https://s1.ax1x.com/2020/05/17/Y2Vg6U.png) &gt; 如果提示下面这个，就是没进入root模式 &gt; ![Y2AWgU.png](https://s1.ax1x.com/2020/05/17/Y2AWgU.png) 3. 安装yum ```apt-get install yum 安装成功 使用yum的命令形式一般是如下：yum [options] [command] [package ...] 添加 yum 仓库 首先要进入到”/etc/yum.repos.d/“目录中（因为该目录存放着yum仓库的配置文件） 使用vim编辑器创建一个名为docker.repo的新配置文件（命令 vim /etc/yum.repos.d/docker.repo 文件名称可随意，但后缀必须为repo），逐项写入下面加粗的配置参数并保存退出（不写中文注释）。[rhel-media] yum仓库唯一标识符，避免与其他仓库冲突。name=linuxprobe yum仓库的名称描述，易于识别仓库用处。。baseurl=file:///media/cdrom 提供方式包括FTP（ftp://..）、HTTP（http://..）、本地（file:///..）enabled=1 设置此源是否可用，1为可用，0为禁用。gpgcheck=1 设置此源是否校验文件，1为校验，0为不校验。gpgkey=file:///media/cdrom/RPM-GPG-KEY-redhat-release 若为校验请指定公钥文件地址。 在原文的基础上略修改。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}]},{"title":"【LeetCode】560. 和为K的子数组","slug":"【LeetCode】560. 和为K的子数组","date":"2020-05-15T02:53:00.000Z","updated":"2020-07-10T06:46:17.803Z","comments":true,"path":"2020/05/15/【LeetCode】560. 和为K的子数组/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/15/%E3%80%90LeetCode%E3%80%91560.%20%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","excerpt":"题目描述给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。","text":"题目描述给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 思路看到这题，我唯一能想到的解决方法就是暴力法（或枚举法）。 定下两个下表start、end，使用两次for循环，外层关于end并依次从0开始向后移动，内层关于start并从end开始向前移动。因为题目中要求的是“连续的子数组”，因此就直接构造了[start,end]的数组，并对其求和sum。只要sum值等于k值，那我们用计数count记录。最后函数返回count即可。 方法很简单，这样分析的话，不需要用到什么额外的空间，所以空间复杂度为O(1)；时间复杂度方面，由于使用两次for循环对数组进行遍历为O(n^2)，再加上求和时间为O(1)，因此总体的时间复杂度为O(n^2)。 代码class Solution { //注意题中说的是“连续的子数组” public int subarraySum(int[] nums, int k) { int count = 0; // 计算[start,end]构成的子数组的和sum for(int end = 0; end &lt; nums.length; end++) { int sum = 0; for (int start = end; start &gt;= 0; start--) { sum += nums[start]; if(sum == k) count++; } } return count; } /* 时间复杂度：O(n^2)，n为数组的长度；两层循环O(n^2)+求和时间为O(1) 空间复杂度：O(1)，无需其他存储空间的使用 */ } 执行 题后心得刚看到这题的时候，注意到难度为“中等”，我想肯定不止有这种方法，而且这种方法过于简单，肯定有更高效的、更有技术含量的算法。于是，去看了他人的算法，发现使用了哈希表。可是，我还不会哈希表啊接下来这段时间，得找时间把哈希表这块学一点。 接下来的话特别有意思、深刻：提交后，我也顺便看了一下评论，有意思的是，我发现了“老马”。 当然，是假的！！！ 精选题解 暴力解法、前缀和、前缀和哈希表优化 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode】136. 只出现一次的数字","slug":"【LeetCode】136. 只出现一次的数字","date":"2020-05-14T02:59:00.000Z","updated":"2020-07-10T06:46:17.749Z","comments":true,"path":"2020/05/14/【LeetCode】136. 只出现一次的数字/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/14/%E3%80%90LeetCode%E3%80%91136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"看到今天的“每日一题”，第一时间发现用位运算很简单、快速。 题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1 示例 2: 输入: [4,1,2,1,2]输出: 4","text":"看到今天的“每日一题”，第一时间发现用位运算很简单、快速。 题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1 示例 2: 输入: [4,1,2,1,2]输出: 4 题解思路位运算首先，来看个例子，比如：a^b假设，a、b的值分别是15、2，a 的值是15，转换成二进制为 1111，b 的值是2，转换成二进制为 0010，这下可以根据异或的运算规律，可以得出其结果为 1101，即13。 &nbsp;&nbsp;&nbsp;&nbsp; 1 1 1 1⊕&nbsp; 0 0 1 0————————————&nbsp;&nbsp;&nbsp;&nbsp; 1 1 0 1 继续看看，我们可以来看看⊕的运算性质： a⊕0 = a a⊕a = 0 a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b 继续看这道题，输入的数组一定是奇数个，现在我假设一共有 2m+1 个元素，其中，m对元素是成对出现的，唯一1个元素就是将被输出的结果。 接下来可以根据这个假设，列出这个表达式，(a1⊕a2⊕⋯⊕am)⊕(a1⊕a2⊕⋯⊕am)⊕am+1⇨ (a1​⊕a1​)⊕(a2​⊕a2​)⊕⋯⊕(am​⊕am​)⊕am+1​⇨ 0⊕0⊕⋯⊕0⊕am+1​⇨ am+1​ 下面的代码就是采用按位异或操作符来完成的。 哈希表成功提交后，我看了其他其他题解，大部分都是使用异或运算来完成。但是，还有一些是使用哈希表来完成的。对哦，为什么我不用 Hash 表呢？因为我还不会 Hash 表啊hhh好吧，不会归不会，但也得学学。 这里就直接小本本上记录两个使用Hash来实现的算法： 利用 Hash 表，Time: O(n)，Space: O(n) 解决方案：哈希集（HashSet） 代码 使用位运算来完成。 class Solution { public int singleNumber(int[] nums) { // (a1​⊕a1​)⊕(a2​⊕a2​)⊕⋯⊕(am​⊕am​)⊕am+1​ // ⇨ 0⊕0⊕⋯⊕0⊕am+1​=am+1​ // 结合三个性质： // 1、a⊕0 = a // 2、a⊕a = 0 // 3、a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b int key = 0; for(int num : nums){ // 比如：a^b=13 // a 的值是15，转换成二进制为1111， // b 的值是2，转换成二进制为0010， // 根据异或的运算规律，可以得出其结果为1101，即13 key ^= num; } return key; } } 复杂度分析 时间复杂度：O(n)，其中 n 是数组长度。因为只需要对数组遍历一次即可 空间复杂度：O(1) 执行 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode】102. 二叉树的层序遍历","slug":"【LeetCode】102. 二叉树的层序遍历","date":"2020-05-13T04:37:00.000Z","updated":"2020-07-10T06:46:17.746Z","comments":true,"path":"2020/05/13/【LeetCode】102. 二叉树的层序遍历/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/13/%E3%80%90LeetCode%E3%80%91102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"题目描述给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ]","text":"题目描述给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ] 题解我想用栈来实现，但是发现有些问题。日后再补充。现在，干脆就直接学习学习他人的优秀算法，顺便记录一下感想。 该算法题解来自~微信公众号：看图学算法链接：https://mp.weixin.qq.com/s/oI_pmqvaA9AFQUPxKX13vw 用广度优先BFS处理是很直观的，可以想象成是一把刀横着切割了每一层，但是深度优先遍历就不那么直观了。 我们开下脑洞，把这个二叉树的样子调整一下，摆成一个田字形的样子。田字形的每一层就对应一个list。 按照深度优先DFS的处理顺序，会先访问节点1，再访问节点2，接着是节点3。之后是第二列的4和5，最后是第三列的6。每次递归的时候都需要带一个index(表示当前的层数)，也就对应那个田字格子中的第几行，如果当前行对应的list不存在，就加入一个空list进去。 动态演示如下： 代码import java.util.*; class Solution { void dfs(int index,TreeNode root, List&lt;List&lt;Integer&gt;&gt; res) { //每次递归的时候都需要带一个index(表示当前的层数) //如果当前行对应的list不存在，就加入一个空list进去。 //假设res是[ [1],[2,3] ]， index是3，就再插入一个空list放到res中 if(res.size()&lt;index) { res.add(new ArrayList&lt;Integer&gt;()); } //将当前节点的值加入到res中，index代表当前层，假设index是3，节点值是99 //res是[ [1],[2,3] [4] ]，加入后res就变为 [ [1],[2,3] [4,99] ] res.get(index-1).add(root.val); //递归的处理左子树，右子树，同时将层数index+1 if(root.left!=null) { dfs(index+1, root.left, res); } if(root.right!=null) { dfs(index+1, root.right, res); } } public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { if(root==null) { return new ArrayList&lt;List&lt;Integer&gt;&gt;(); } //用来存放最终结果 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); dfs(1,root,res); return res; } } 时间复杂度:O(N)空间复杂度:O(h)，h是树的高度** 心得体会首先，我绝对不会想到用list，因为我对集合一是不敏感，二是基础知识掌握不多。第二点是，灵活性的不足，即使我想不到list，但是我也没想过“我们开下脑洞，把这个二叉树的样子调整一下，摆成一个田字形的样子”🤣先前写算法基本都是用C来写，偶尔用C++。有的题目用C写起来轻松，但是有的却用Java轻松。很必要的一点，就是学会使用两种及以上的语言来写算法。 其他题解 【精选】递归和迭代 官方题解 二叉树层次遍历 图片来源：微信公众号“看图学算法”学习笔记，待补充… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"一些常用的 Emoji 符号（可直接复制）","slug":"一些常用的 Emoji 符号（可直接复制）","date":"2020-05-13T04:34:00.000Z","updated":"2020-07-10T06:46:17.846Z","comments":true,"path":"2020/05/13/一些常用的 Emoji 符号（可直接复制）/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/13/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%20Emoji%20%E7%AC%A6%E5%8F%B7%EF%BC%88%E5%8F%AF%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%EF%BC%89/","excerpt":"","text":"其他方法https://blog.csdn.net/u014636245/article/details/82945997 表情类😀 😁 😂 🤣 😃 😄 😅 😆 😉 😊 😋 😎 😍 😘 😗 😙 😚 ☺️ 🙂 🤗 🤩 🤔 🤨 😐 😑 😶 🙄 😏 😣 😥 😮 🤐 😯 😪 😫 😴 😌 😛 😜 😝 🤤 😒 😓 😔 😕 🙃 🤑 😲 ☹️ 🙁 😖 😞 😟 😤 😢 😭 😦 😧 😨 😩 🤯 😬 😰 😱 😳 🤪 😵 😡 😠 🤬 😷 🤒 🤕 🤢 🤮 🤧 😇 🤠 🤡 🤥 🤫 🤭 🧐 🤓 😈 👿 👹 👺 💀 👻 👽 🤖 💩 😺 😸 😹 😻 😼 😽 🙀 😿 😾 手势类🤲 👐 🙌 👏 🤝 👍 👎 👊 ✊ 🤛 🤜 🤞 ✌️ 🤟 🤘 👌 👈 👉 👆 👇 ☝️ ✋ 🤚 🖐 🖖 👋 🤙 💪🖕 ✍️ 🙏 人物👶 👧 🧒 👦 👩 🧑 👨 👵 🧓 👴 👲 👳‍♀️ 👳‍♂️ 🧕 🧔 👱‍♂️ 👱‍♀️ 👮‍♀️ 👮‍♂️ 👷‍♀️ 👷‍♂️ 💂‍♀️ 💂‍♂️ 🕵️‍♀️ 🕵️‍♂️ 👩‍⚕️ 👨‍⚕️ 👩‍🌾 👨‍🌾 👩‍🍳 👨‍🍳 👩‍🎓 👨‍🎓 👩‍🎤 👨‍🎤 👩‍🏫 👨‍🏫 👩‍🏭 👨‍🏭 👩‍💻 👨‍💻 👩‍💼 👨‍💼 👩‍🔧 👨‍🔧 👩‍🔬 👨‍🔬 👩‍🎨 👨‍🎨 👩‍🚒 👨‍🚒 👩‍✈️ 👨‍✈️ 👩‍🚀 👨‍🚀 👩‍⚖️ 👨‍⚖️ 👰 🤵 👸 🤴 🤶 🎅 🧙‍♀️ 🧙‍♂️ 🧝‍♀️ 🧝‍♂️ 🧛‍♀️ 🧛‍♂️ 🧟‍♀️ 🧟‍♂️ 🧞‍♀️ 🧞‍♂️ 🧜‍♀️ 🧜‍♂️ 🧚‍♀️ 🧚‍♂️ 👼 🤰 🤱 🙇‍♀️ 🙇‍♂️ 💁‍♀️ 💁‍♂️ 🙅‍♀️ 🙅‍♂️ 🙆‍♀️ 🙆‍♂️ 🙋‍♀️ 🙋‍♂️ 🤦‍♀️ 🤦‍♂️ 🤷‍♀️ 🤷‍♂️ 🙎‍♀️ 🙎‍♂️ 🙍‍♀️ 🙍‍♂️ 💇‍♀️ 💇‍♂️ 💆‍♀️ 💆‍♂️ 🧖‍♀️ 🧖‍♂️ 💅 🤳 💃 🕺 👯‍♀️ 👯‍♂️ 🕴 🚶‍♀️ 🚶‍♂️ 🏃‍♀️ 🏃‍♂️ 👫 👭 👬 💑 👩‍❤️‍👩 👨‍❤️‍👨 💏 👩‍❤️‍💋‍👩 👨‍❤️‍💋‍👨 👪 👨‍👩‍👧 👨‍👩‍👧‍👦 👨‍👩‍👦‍👦 👨‍👩‍👧‍👧 👩‍👩‍👦 👩‍👩‍👧 👩‍👩‍👧‍👦 👩‍👩‍👦‍👦 👩‍👩‍👧‍👧 👨‍👨‍👦 👨‍👨‍👧 👨‍👨‍👧‍👦 👨‍👨‍👦‍👦 👨‍👨‍👧‍👧 👩‍👦 👩‍👧 👩‍👧‍👦 👩‍👦‍👦 👩‍👧‍👧 👨‍👦 👨‍👧 👨‍👧‍👦 👨‍👦‍👦 👨‍👧‍👧 动植物 自然🐶 🐱 🐭 🐹 🐰 🦊 🦝 🐻 🐼 🦘 🦡 🐨 🐯 🦁 🐮 🐷 🐽 🐸 🐵 🙈 🙉 🙊 🐒 🐔 🐧 🐦 🐤 🐣 🐥 🦆 🦢 🦅 🦉 🦚 🦜 🦇 🐺 🐗 🐴 🦄 🐝 🐛 🦋 🐌 🐚 🐞 🐜 🦗 🕷 🕸 🦂 🦟 🦠 🐢 🐍 🦎 🦖 🦕 🐙 🦑 🦐 🦀 🐡 🐠 🐟 🐬 🐳 🐋 🦈 🐊 🐅 🐆 🦓 🦍 🐘 🦏 🦛 🐪 🐫 🦙 🦒 🐃 🐂 🐄 🐎 🐖 🐏 🐑 🐐 🦌 🐕 🐩 🐈 🐓 🦃 🕊 🐇 🐁 🐀 🐿 🦔 🐾 🐉 🐲 🌵 🎄 🌲 🌳 🌴 🌱 🌿 ☘️ 🍀 🎍 🎋 🍃 🍂 🍁 🍄 🌾 💐 🌷 🌹 🥀 🌺 🌸 🌼 🌻 🌞 🌝 🌛 🌜 🌚 🌕 🌖 🌗 🌘 🌑 🌒 🌓 🌔 🌙 🌎 🌍 🌏 💫 ⭐️ 🌟 ✨ ⚡️ ☄️ 💥 🔥 🌪 🌈 ☀️ 🌤 ⛅️ 🌥 ☁️ 🌦 🌧 ⛈ 🌩 🌨 ❄️ ☃️ ⛄️ 🌬 💨 💧 💦 ☔️ ☂️ 🌊 🌫 十二生肖🐁🐂🐅🐇🐉🐍🐎🐐🐒🐓🐕🐖 水果 食物🍏 🍎 🍐 🍊 🍋 🍌 🍉 🍇 🍓 🍈 🍒 🍑 🍍 🥭 🥥 🥝 🍅 🍆 🥑 🥦 🥒 🥬 🌶 🌽 🥕 🥔 🍠 🥐 🍞 🥖 🥨 🥯 🧀 🥚 🍳 🥞 🥓 🥩 🍗 🍖 🌭 🍔 🍟 🍕 🥪 🥙 🌮 🌯 🥗 🥘 🥫 🍝 🍜 🍲 🍛 🍣 🍱 🥟 🍤 🍙 🍚 🍘 🍥 🥮 🥠 🍢 🍡 🍧 🍨 🍦 🥧 🍰 🎂 🍮 🍭 🍬 🍫 🍿 🧂 🍩 🍪 🌰 🥜 🍯 🥛 🍼 ☕️ 🍵 🥤 🍶 🍺 🍻 🥂 🍷 🥃 🍸 🍹 🍾 🥄 🍴 🍽 🥣 🥡 🥢 运动 娱乐⚽️ 🏀 🏈 ⚾️ 🥎 🏐 🏉 🎾 🥏 🎱 🏓 🏸 🥅 🏒 🏑 🥍 🏏 ⛳️ 🏹 🎣 🥊 🥋 🎽 ⛸ 🥌 🛷 🛹 🎿 ⛷ 🏂 🏋️‍♀️ 🏋🏻‍♀️ 🏋🏼‍♀️ 🏋🏽‍♀️ 🏋🏾‍♀️ 🏋🏿‍♀️ 🏋️‍♂️ 🏋🏻‍♂️ 🏋🏼‍♂️ 🏋🏽‍♂️ 🏋🏾‍♂️ 🏋🏿‍♂️ 🤼‍♀️ 🤼‍♂️ 🤸‍♀️ 🤸🏻‍♀️ 🤸🏼‍♀️ 🤸🏽‍♀️ 🤸🏾‍♀️ 🤸🏿‍♀️ 🤸‍♂️ 🤸🏻‍♂️ 🤸🏼‍♂️ 🤸🏽‍♂️ 🤸🏾‍♂️ 🤸🏿‍♂️ ⛹️‍♀️ ⛹🏻‍♀️ ⛹🏼‍♀️ ⛹🏽‍♀️ ⛹🏾‍♀️ ⛹🏿‍♀️ ⛹️‍♂️ ⛹🏻‍♂️ ⛹🏼‍♂️ ⛹🏽‍♂️ ⛹🏾‍♂️ ⛹🏿‍♂️ 🤺 🤾‍♀️ 🤾🏻‍♀️ 🤾🏼‍♀️ 🤾🏾‍♀️ 🤾🏾‍♀️ 🤾🏿‍♀️ 🤾‍♂️ 🤾🏻‍♂️ 🤾🏼‍♂️ 🤾🏽‍♂️ 🤾🏾‍♂️ 🤾🏿‍♂️ 🏌️‍♀️ 🏌🏻‍♀️ 🏌🏼‍♀️ 🏌🏽‍♀️ 🏌🏾‍♀️ 🏌🏿‍♀️ 🏌️‍♂️ 🏌🏻‍♂️ 🏌🏼‍♂️ 🏌🏽‍♂️ 🏌🏾‍♂️ 🏌🏿‍♂️ 🏇 🏇🏻 🏇🏼 🏇🏽 🏇🏾 🏇🏿 🧘‍♀️ 🧘🏻‍♀️ 🧘🏼‍♀️ 🧘🏽‍♀️ 🧘🏾‍♀️ 🧘🏿‍♀️ 🧘‍♂️ 🧘🏻‍♂️ 🧘🏼‍♂️ 🧘🏽‍♂️ 🧘🏾‍♂️ 🧘🏿‍♂️ 🏄‍♀️ 🏄🏻‍♀️ 🏄🏼‍♀️ 🏄🏽‍♀️ 🏄🏾‍♀️ 🏄🏿‍♀️ 🏄‍♂️ 🏄🏻‍♂️ 🏄🏼‍♂️ 🏄🏽‍♂️ 🏄🏾‍♂️ 🏄🏿‍♂️ 🏊‍♀️ 🏊🏻‍♀️ 🏊🏼‍♀️ 🏊🏽‍♀️ 🏊🏾‍♀️ 🏊🏿‍♀️ 🏊‍♂️ 🏊🏻‍♂️ 🏊🏼‍♂️ 🏊🏽‍♂️ 🏊🏾‍♂️ 🏊🏿‍♂️ 🤽‍♀️ 🤽🏻‍♀️ 🤽🏼‍♀️ 🤽🏽‍♀️ 🤽🏾‍♀️ 🤽🏿‍♀️ 🤽‍♂️ 🤽🏻‍♂️ 🤽🏼‍♂️ 🤽🏽‍♂️ 🤽🏾‍♂️ 🤽🏿‍♂️ 🚣‍♀️ 🚣🏻‍♀️ 🚣🏼‍♀️ 🚣🏽‍♀️ 🚣🏾‍♀️ 🚣🏿‍♀️ 🚣‍♂️ 🚣🏻‍♂️ 🚣🏼‍♂️ 🚣🏽‍♂️ 🚣🏾‍♂️ 🚣🏿‍♂️ 🧗‍♀️ 🧗🏻‍♀️ 🧗🏼‍♀️ 🧗🏽‍♀️ 🧗🏾‍♀️ 🧗🏿‍♀️ 🧗‍♂️ 🧗🏻‍♂️ 🧗🏼‍♂️ 🧗🏽‍♂️ 🧗🏾‍♂️ 🧗🏿‍♂️ 🚵‍♀️ 🚵🏻‍♀️ 🚵🏼‍♀️ 🚵🏽‍♀️ 🚵🏾‍♀️ 🚵🏿‍♀️ 🚵‍♂️ 🚵🏻‍♂️ 🚵🏼‍♂️ 🚵🏽‍♂️ 🚵🏾‍♂️ 🚵🏿‍♂️ 🚴‍♀️ 🚴🏻‍♀️ 🚴🏼‍♀️ 🚴🏽‍♀️ 🚴🏾‍♀️ 🚴🏿‍♀️ 🚴‍♂️ 🚴🏻‍♂️ 🚴🏼‍♂️ 🚴🏽‍♂️ 🚴🏾‍♂️ 🚴🏿‍♂️ 🏆 🥇 🥈 🥉 🏅 🎖 🏵 🎗 🎫 🎟 🎪 🤹‍♀️ 🤹🏻‍♀️ 🤹🏼‍♀️ 🤹🏽‍♀️ 🤹🏾‍♀️ 🤹🏿‍♀️ 🤹‍♂️ 🤹🏻‍♂️ 🤹🏼‍♂️ 🤹🏽‍♂️ 🤹🏾‍♂️ 🤹🏿‍♂️ 🎭 🎨 🎬 🎤 🎧 🎼 🎹 🥁 🎷 🎺 🎸 🎻 🎲 🧩 ♟ 🎯 🎳 🎮 🎰 交通 旅行🚗 🚕 🚙 🚌 🚎 🏎 🚓 🚑 🚒 🚐 🚚 🚛 🚜 🛴 🚲 🛵 🏍 🚨 🚔 🚍 🚘 🚖 🚡 🚠 🚟 🚃 🚋 🚞 🚝 🚄 🚅 🚈 🚂 🚆 🚇 🚊 🚉 ✈️ 🛫 🛬 🛩 💺 🛰 🚀 🛸 🚁 🛶 ⛵️ 🚤 🛥 🛳 ⛴ 🚢 ⚓️ ⛽️ 🚧 🚦 🚥 🚏 🗺 🗿 🗽 🗼 🏰 🏯 🏟 🎡 🎢 🎠 ⛲️ ⛱ 🏖 🏝 🏜 🌋 ⛰ 🏔 🗻 🏕 ⛺️ 🏠 🏡 🏘 🏚 🏗 🏭 🏢 🏬 🏣 🏤 🏥 🏦 🏨 🏪 🏫 🏩 💒 🏛 ⛪️ 🕌 🕍 🕋 ⛩ 🛤 🛣 🗾 🎑 🏞 🌅 🌄 🌠 🎇 🎆 🌇 🌆 🏙 🌃 🌌 🌉 🌁 物体⌚️ 📱 📲 💻 ⌨️ 🖥 🖨 🖱 🖲 🕹 🗜 💽 💾 💿 📀 📼 📷 📸 📹 🎥 📽 🎞 📞 ☎️ 📟 📠 📺 📻 🎙 🎚 🎛 ⏱ ⏲ ⏰ 🕰 ⌛️ ⏳ 📡 🔋 🔌 💡 🔦 🕯 🗑 🛢 💸 💵 💴 💶 💷 💰 💳 🧾 💎 ⚖️ 🔧 🔨 ⚒ 🛠 ⛏ 🔩 ⚙️ ⛓ 🔫 💣 🔪 🗡 ⚔️ 🛡 🚬 ⚰️ ⚱️ 🏺 标志❤️ 🧡 💛 💚 💙 💜 🖤 💔 ❣️ 💕 💞 💓 💗 💖 💘 💝 💟 ☮️ ✝️ ☪️ 🕉 ☸️ ✡️ 🔯 🕎 ☯️ ☦️ 🛐 ⛎ ♈️ ♉️ ♊️ ♋️ ♌️ ♍️ ♎️ ♏️ ♐️ ♑️ ♒️ ♓️ 🆔 ⚛️ 🉑 ☢️ ☣️ 📴 📳 🈶 🈚️ 🈸 🈺 🈷️ ✴️ 🆚 💮 🉐 ㊙️ ㊗️ 🈴 🈵 🈹 🈲 🅰️ 🅱️ 🆎 🆑 🅾️ 🆘 ❌ ⭕️ 🛑 ⛔️ 📛 🚫 💯 💢 ♨️ 🚷 🚯 🚳 🚱 🔞 📵 🚭 ❗️ ❕ ❓ ❔ ‼️ ⁉️ 🔅 🔆 〽️ ⚠️ 🚸 🔱 ⚜️ 🔰 ♻️ ✅ 🈯️ 💹 ❇️ ✳️ ❎ 🌐 💠 Ⓜ️ 🌀 💤 🏧 🚾 ♿️ 🅿️ 🈳 🈂️ 🛂 🛃 🛄 🛅 🚹 🚺 🚼 🚻 🚮 🎦 📶 🈁 🔣 ℹ️ 🔤 🔡 🔠 🆖 🆗 🆙 🆒 🆕 🆓 0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣ 🔟 🔢 #️⃣ *️⃣ ⏏️ ▶️ ⏸ ⏯ ⏹ ⏺ ⏭ ⏮ ⏩ ⏪ ⏫ ⏬ ◀️ 🔼 🔽 ➡️ ⬅️ ⬆️ ⬇️ ↗️ ↘️ ↙️ ↖️ ↕️ ↔️ ↪️ ↩️ ⤴️ ⤵️ 🔀 🔁 🔂 🔄 🔃 🎵 🎶 ➕ ➖ ➗ ✖️ ♾ 💲 💱 ™️ ©️ ®️ 〰️ ➰ ➿ 🔚 🔙 🔛 🔝 🔜 ✔️ ☑️ 🔘 ⚪️ ⚫️ 🔴 🔵 🔺 🔻 🔸 🔹 🔶 🔷 🔳 🔲 ▪️ ▫️ ◾️ ◽️ ◼️ ◻️ ⬛️ ⬜️ 🔈 🔇 🔉 🔊 🔔 🔕 📣 📢 👁‍🗨 💬 💭 🗯 ♠️ ♣️ ♥️ ♦️ 🃏 🎴 🀄️ 🕐 🕑 🕒 🕓 🕔 🕕 🕖 🕗 🕘 🕙 🕚 🕛 🕜 🕝 🕞 🕟 🕠 🕡 🕢 🕣 🕤 🕥 🕦 🕧 ⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝 来源：https://www.cnblogs.com/cckui/p/11046826.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"Java中List集合的常用方法","slug":"Java中List集合的常用方法","date":"2020-05-13T02:15:00.000Z","updated":"2020-07-10T06:46:17.503Z","comments":true,"path":"2020/05/13/Java中List集合的常用方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/13/Java%E4%B8%ADList%E9%9B%86%E5%90%88%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"ListList接口是继承Collection接口，所以Collection集合中有的方法，List集合也继承过来。 常用方法： void add(int index, E element) 在指定位置插入元素，后面的元素都往后移一个元素。 boolean addAll(int index, Collection&lt;? extends E&gt; c) 在指定的位置中插入c集合全部的元素，如果集合发生改变，则返回true，否则返回false。 意思就是当插入的集合c没有元素，那么就返回false，如果集合c有元素，插入成功，那么就返回true。 E get(int index) 返回list集合中指定索引位置的元素 int indexOf(Object o) 返回list集合中第一次出现o对象的索引位置，如果list集合中没有o对象，那么就返回-1 ListIterator listIterator() 返回此列表元素的列表迭代器（按适当顺序）。 ListIterator listIterator(int index) 从指定位置开始，返回此列表元素的列表迭代器（按适当顺序）。 和上面那个迭代器不同的就是多了一个参数，就是能控制迭代器开始的位置。 E remove(int index) 删除指定索引的对象 E set(int index, E element) 在索引为index位置的元素更改为element元素 List subList(int fromIndex, int toIndex) 返回从索引fromIndex到toIndex的元素集合，包左不包右 void add(int index, E element)在指定位置插入元素，后面的元素都往后移一个元素。 boolean addAll(int index, Collection&lt;? extends E&gt; c)在指定的位置中插入c集合全部的元素，如果集合发生改变，则返回true，否则返回false。 意思就是当插入的集合c没有元素，那么就返回false，如果集合c有元素，插入成功，那么就返回true。 E get(int index)返回list集合中指定索引位置的元素 int indexOf(Object o)返回list集合中第一次出现o对象的索引位置，如果list集合中没有o对象，那么就返回-1 ListIterator&lt; E &gt; listIterator()返回此列表元素的列表迭代器（按适当顺序）。 listIterator和iterator的区别是什么呢？下面这篇博客比较详细的分析，可以参考。 https://blog.csdn.net/longshengguoji/article/details/41551491 这里大概讲一下他们的区别： 当只需要遍历集合时，两个迭代器的功能都是一样。 但是listIterator迭代器只能用于List和他的实现子类，iterator迭代器可以用于所有的集合使用。 所不同的就是listIterator迭代器的功能会比iterator迭代器的功能要多。 listIterator迭代器可以在遍历集合时添加、修改和删除，而iterator迭代器在遍历集合时只有删除。 ListIterator&lt; E &gt; listIterator(int index)从指定位置开始，返回此列表元素的列表迭代器（按适当顺序）。 和上面那个迭代器不同的就是多了一个参数，就是能控制迭代器开始的位置。 E remove(int index)删除指定索引的对象 E set(int index, E element)在索引为index位置的元素更改为element元素 List subList(int fromIndex, int toIndex)返回从索引fromIndex到toIndex的元素集合，包左不包右 更多Java集合List详解 学习笔记，待补充… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java集合小抄","slug":"Java的Collection集合的常用方法","date":"2020-05-13T02:05:00.000Z","updated":"2020-07-10T06:46:17.506Z","comments":true,"path":"2020/05/13/Java的Collection集合的常用方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/13/Java%E7%9A%84Collection%E9%9B%86%E5%90%88%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"常用方法 boolean add(E e) 添加元素到Collection集合中。 boolean addAll(Collection&lt;? extends E&gt; c) 将指定c中的所有元素都添加到此Collection集合中。 void clear() 移除此collection集合中的所有元素 boolean contains(Object o) 检查Collection集合中是否包含o对象，如果包含则返回true，否则返回false。 boolean containsAll(Collection&lt;?&gt; c) 检查Collection集合中是否包含c的全部对象，全部包含则返回true，否则返回false。 boolean equals(Object o) 比较此collection集合与指定对象是否相等，是比较的是里面元素是否相等，而不是比较地址是否相等。 在Object类中，equals()方法底层就是“==”，也就是说就是比较地址是否相等，但是继承后，大多数的类都重写了该方法。由于Collection是接口，不能直接new对象，所以只能new一个它的子类。 int hashCode() 返回此Collection集合的哈希码值。 boolean isEmpty() 检查Collection集合是否包含有元素，如果没有包含元素，则返回true，否则返回false。 此方法与contains方法的区别是，此方法是判断集合是否包含有元素，就是说，如果一个元素都没有的话就返回true，如果有一个或者以上就返回false。contains的方法是判断集合中是否包含特定的元素，如果包含特定的元素就返回true，如果没有包含特定元素就返回false。 Iterator iterator() 返回在此collection集合的元素上进行迭代的迭代器 注意：迭代过程中不能用集合里的添加. 删除等方法修改集合，不然会报错。如果想在迭代过程中还想操作集合，那么只能用迭代器类里面的方法。 boolean remove(Object o) 从collection集合中删除指定的元素，如果集合中有这个元素，并且删除成功，那么就返回true，否则返回false。 boolean removeAll(Collection&lt;?&gt; c) 从集合中删除c集合中所有的元素 boolean retainAll(Collection&lt;?&gt; c) 集合中仅保留c集合中的所有元素 int size() 返回集合中元素个数 Object[] toArray() 返回包含此collection集合中所有元素的数组 boolean add(E e)添加元素到Collection集合中。 boolean addAll(Collection&lt;? extends E&gt; c)将指定c中的所有元素都添加到此Collection集合中。 void clear()移除此collection集合中的所有元素 boolean contains(Object o)检查Collection集合中是否包含o对象，如果包含则返回true，否则返回false。 boolean containsAll(Collection&lt;?&gt; c)检查Collection集合中是否包含c的全部对象，全部包含则返回true，否则返回false。 boolean equals(Object o)比较此collection集合与指定对象是否相等，是比较的是里面元素是否相等，而不是比较地址是否相等。 在Object类中，equals()方法底层就是“==”，也就是说就是比较地址是否相等，但是继承后，大多数的类都重写了该方法。 由于Collection是接口，不能直接new对象，所以只能new一个它的子类。 下面这个是Object类的equals()方法，底层就是用”==”。 下面我们来看Collection的一个实现类Vector。 Vector是继承了AbstractList 所以它的equals方法是调用了父类的方法 我们再跟进去看看。真的是重写的equals方法 int hashCode()返回此Collection集合的哈希码值。 boolean isEmpty()检查Collection集合是否包含有元素，如果没有包含元素，则返回true，否则返回false。 此方法与contains方法的区别是，此方法是判断集合是否包含有元素，就是说，如果一个元素都没有的话就返回true，如果有一个或者以上就返回false。 contains的方法是判断集合中是否包含特定的元素，如果包含特定的元素就返回true，如果没有包含特定元素就返回false。 Iterator iterator()返回在此collection集合的元素上进行迭代的迭代器 注意：迭代过程中不能用集合里的添加、删除等方法修改集合，不然会报错。 如果想在迭代过程中还想操作集合，那么只能用迭代器类里面的方法。 boolean remove(Object o)从collection集合中删除指定的元素，如果集合中有这个元素，并且删除成功，那么就返回true，否则返回false。 boolean removeAll(Collection&lt;?&gt; c)从集合中删除c集合中所有的元素 boolean retainAll(Collection&lt;?&gt; c)集合中仅保留c集合中的所有元素 int size()返回集合中元素个数 Object[] toArray()返回包含此collection集合中所有元素的数组 学习笔记，待补充… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"Java集合小抄","slug":"Java集合小抄","date":"2020-05-13T01:42:00.000Z","updated":"2020-07-10T06:46:17.616Z","comments":true,"path":"2020/05/13/Java集合小抄/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/13/Java%E9%9B%86%E5%90%88%E5%B0%8F%E6%8A%84/","excerpt":"Java 集合 Java集合类是我们在工作中运用最多的、最频繁的类。相比于数组(Array)来说，集合类的长度可变，更加适合于现代开发需求； Java集合就像一个容器，可以存储任何类型的数据，也可以结合泛型来存储具体的类型对象。 在程序运行时，Java集合可以动态的进行扩展(动态增容)，随着元素的增加而扩大。在Java中，集合类通常存在于java.util包中。 Java集合主要由2大体系构成，分别是 Collection 体系 Map 体系 其中Collection和Map分别是2大体系中的顶层接口。","text":"Java 集合 Java集合类是我们在工作中运用最多的、最频繁的类。相比于数组(Array)来说，集合类的长度可变，更加适合于现代开发需求； Java集合就像一个容器，可以存储任何类型的数据，也可以结合泛型来存储具体的类型对象。 在程序运行时，Java集合可以动态的进行扩展(动态增容)，随着元素的增加而扩大。在Java中，集合类通常存在于java.util包中。 Java集合主要由2大体系构成，分别是 Collection 体系 Map 体系 其中Collection和Map分别是2大体系中的顶层接口。 CollectionCollection主要有三个子接口，分别为 List(列表) Set(集) Queue(队列)。 其中，List、Queue中的元素有序可重复，而Set中的元素无序不可重复。 ListList中主要有两个实现类： ArrayList LinkedList SetSet中则是有实现类: HashSet Queue而Queue是主要以数组和链表两种形式存在。 Queue是在JDK1.5后才出现的新集合 MapMap同属于java.util包中，是集合的一部分，但与Collection是相互独立的，没有任何关系。Map中都是以key-value的形式存在，其中key必须唯一主要有三个实现类： HashMap HashTable TreeMap 学习笔记，待补充… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"【LeetCode】155. 最小栈","slug":"【LeetCode】155. 最小栈","date":"2020-05-12T12:32:00.000Z","updated":"2020-07-10T06:46:17.752Z","comments":true,"path":"2020/05/12/【LeetCode】155. 最小栈/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/12/%E3%80%90LeetCode%E3%80%91155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/","excerpt":"题目描述设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例: 输入： [“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”][[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; 返回 -3.minStack.pop();minStack.top(); –&gt; 返回 0.minStack.getMin(); –&gt; 返回 -2. 提示： pop、top 和 getMin 操作总是在 非空栈 上调用。","text":"题目描述设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例: 输入： [“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”][[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; 返回 -3.minStack.pop();minStack.top(); –&gt; 返回 0.minStack.getMin(); –&gt; 返回 -2. 提示： pop、top 和 getMin 操作总是在 非空栈 上调用。 题解思路使用额外的栈（同步辅助栈）来完成。 由于栈有后进先出的特点。假设元素a入栈时，栈里有元素 b、c、d，那么只要 a 在栈中，b、c、d 就一定会在栈中，因为在 a 被出栈前，b、c、d 不会被出栈。 我们使用同步辅助栈来依次存储新元素在入栈时当前整个栈的最小值。当元素a入栈时，将当前整个栈的最小值min入栈到同步辅助栈中存储起来。 如果知道栈顶元素是a，那就可以直接知道此时原栈的最小值min了。 同步辅助栈与原栈的同步关系入栈 当原栈为空，新元素a入栈时，将新元素a拷贝一份，并入栈到辅助栈当中。 当原栈非空，新元素k入栈时，取出辅助栈的栈顶元素min_top，与k比较，将min{k, min_top}入栈到辅助栈中去。 出栈 原栈有元素出栈，辅助栈同时将栈顶元素弹出。 在任意一个时刻，原栈内元素的最小值就存储在辅助栈的栈顶中。 代码#define MAXSIZE 1600 typedef struct { // 只用一个(数组模拟的)栈来同时模拟原栈、同步辅助栈并存 // 原栈：偶数，0,2,4...... // 辅助栈：奇数，1,3,5...... int top; int *data; } MinStack; /** initialize your data structure here. */ MinStack* minStackCreate() { MinStack *obj=(MinStack *)malloc(sizeof(MinStack)); obj-&gt;data=(int *)malloc(MAXSIZE*sizeof(int)); obj-&gt;top=-1; return obj; } void minStackPush(MinStack* obj, int x) { if(obj-&gt;top == MAXSIZE-1){ // 栈满了，不做任何操作 } else if(obj-&gt;top == -1){ // 原栈 obj-&gt;top++; obj-&gt;data[obj-&gt;top] = x; // 辅助栈 obj-&gt;top++; obj-&gt;data[obj-&gt;top] = x; } else { // 当原栈非空，新元素k入栈时，取出辅助栈的栈顶元素min_top，与k比较，将`min{k, min_top}`入栈到辅助栈中去 int tmp = obj-&gt;data[obj-&gt;top]; // 原栈 obj-&gt;top++; obj-&gt;data[obj-&gt;top] = x; // 辅助栈 if(tmp &lt; x){ obj-&gt;top++; obj-&gt;data[obj-&gt;top] = tmp; } else { obj-&gt;top++; obj-&gt;data[obj-&gt;top] = x; } } } void minStackPop(MinStack* obj) { if(obj-&gt;top != -1){ // 原栈 obj-&gt;top--; // 辅助栈 obj-&gt;top--; } } int minStackTop(MinStack* obj) { if(obj-&gt;top == -1){ return; // 返回空（void） } return obj-&gt;data[obj-&gt;top-1]; // 必须减1，减1才是原栈的栈顶 } int minStackGetMin(MinStack* obj) { // 在任意一个时刻，原栈内元素的最小值就存储在辅助栈的栈顶中 return obj-&gt;data[obj-&gt;top]; } void minStackFree(MinStack* obj) { free(obj-&gt;data); obj-&gt;data = NULL; free(obj); obj = NULL; } 提交 优秀、精明的题解 【精选】使用辅助栈（同步和不同步) 详细通俗的思路分析，多解法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C语言中几种return的区分","slug":"C语言中几种return的区分","date":"2020-05-12T11:55:00.000Z","updated":"2020-07-10T06:46:17.187Z","comments":true,"path":"2020/05/12/C语言中几种return的区分/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/12/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%A0%E7%A7%8Dreturn%E7%9A%84%E5%8C%BA%E5%88%86/","excerpt":"return 0; 一般0代表的是正常结束 return -1; -1代表非正常结束 return ; void 返回是空，void返回值可以什么也不写，可以写return； return NULL; 如果数据类型是指针类型，那我们一般成功的时候返回相应的地址，失败的时候返回NULL 关于NULL，我这就简单记成 描述地址时用NULL‘清零’，描述数据时 用 0 清零.","text":"return 0; 一般0代表的是正常结束 return -1; -1代表非正常结束 return ; void 返回是空，void返回值可以什么也不写，可以写return； return NULL; 如果数据类型是指针类型，那我们一般成功的时候返回相应的地址，失败的时候返回NULL 关于NULL，我这就简单记成 描述地址时用NULL‘清零’，描述数据时 用 0 清零. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Stack，一个后进先出的集合容器","slug":"Stack，一个后进先出的集合容器","date":"2020-05-12T09:32:00.000Z","updated":"2020-07-10T06:46:17.702Z","comments":true,"path":"2020/05/12/Stack，一个后进先出的集合容器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/12/Stack%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%90%8E%E8%BF%9B%E5%85%88%E5%87%BA%E7%9A%84%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/","excerpt":"今天刷LC的每日一题时，需要使用到“栈”这种数据结构。就顺便复习了有关“栈”的知识。本文就用C来复习(预习)“Stack”。 特点Stack，本身就具有数据结构中栈的一般特性：后进先出。 定义Stack#include&lt;stack&gt; stack&lt;typename&gt; name; 栈中元素的访问 top() 只能访问其栈顶元素 通过top()来获取（或遍历） 常用的调用函数 push()：入栈 pop()：出栈（弹出栈顶元素） top：获取栈顶元素 empty()：判空，返回值是Bool类型，true为空，false为非空 size()：返回stack内元素的个数","text":"今天刷LC的每日一题时，需要使用到“栈”这种数据结构。就顺便复习了有关“栈”的知识。本文就用C来复习(预习)“Stack”。 特点Stack，本身就具有数据结构中栈的一般特性：后进先出。 定义Stack#include&lt;stack&gt; stack&lt;typename&gt; name; 栈中元素的访问 top() 只能访问其栈顶元素 通过top()来获取（或遍历） 常用的调用函数 push()：入栈 pop()：出栈（弹出栈顶元素） top：获取栈顶元素 empty()：判空，返回值是Bool类型，true为空，false为非空 size()：返回stack内元素的个数 DEMO#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct node { int data; struct node *next; }Node ,*PNode; typedef struct stack { PNode pTop; PNode pBot; }Stack, *PStack; void init(PStack pS) { pS-&gt;pTop = pS-&gt;pBot = (PNode)malloc(sizeof(Node)); pS-&gt;pBot-&gt;next = NULL; } void push(PStack pS, int val) { PNode pNew = (PNode)malloc(sizeof(Node)); pNew-&gt;data = val; pNew-&gt;next = pS-&gt;pTop; pS-&gt;pTop = pNew; } void traverse(PStack pS) { PNode p = pS-&gt;pTop; while (p != pS-&gt;pBot) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\"); } void pop(PStack pS) { if (pS-&gt;pTop != NULL) { if (pS-&gt;pTop == pS-&gt;pBot) { printf(\"已到栈底\\n\"); return; } PNode p = pS-&gt;pTop; pS-&gt;pTop = p-&gt;next; free(p); p = NULL; } } void clean(PStack pS) { PNode q = NULL; while (pS-&gt;pTop != pS-&gt;pBot){ q = pS-&gt;pTop-&gt;next; free(pS-&gt;pTop); pS-&gt;pTop = q; } } int main(void) { Stack s; init(&amp;s); push(&amp;s, 5); push(&amp;s, 4); push(&amp;s, 3); push(&amp;s, 2); push(&amp;s, 1); traverse(&amp;s); pop(&amp;s); traverse(&amp;s); clean(&amp;s); pop(&amp;s); traverse(&amp;s); system(\"pause\"); return 0; } 相关文章 stack的常见用法 java集合容器之Stack 数据结构之栈（C语言版） Java 栈 stack方法总结 Java Stack 类 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"[转]学习B站动态转发抽奖脚本","slug":"[转]学习B站动态转发抽奖脚本","date":"2020-05-11T05:23:00.000Z","updated":"2020-08-27T05:55:24.160Z","comments":true,"path":"2020/05/11/[转]学习B站动态转发抽奖脚本/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/11/[%E8%BD%AC]%E5%AD%A6%E4%B9%A0B%E7%AB%99%E5%8A%A8%E6%80%81%E8%BD%AC%E5%8F%91%E6%8A%BD%E5%A5%96%E8%84%9A%E6%9C%AC/","excerpt":"作者博客原文链接：https://www.hackinn.com/index.php/archives/112/","text":"作者博客原文链接：https://www.hackinn.com/index.php/archives/112/ #!/usr/bin/env python # -*- encoding: utf-8 -*- \"\"\" Bilibili动态转发抽奖脚本 V1.1 Bilibili:鸟云厂商 Mon site Internet:https://www.hackinn.com 更新内容：1.增加了对画册类型动态的支持。 \"\"\" import os import urllib2 import json import sqlite3 import random import webbrowser import re import time from urlparse import * def GetMiddleStr(content,startStr,endStr): startIndex = content.index(startStr) if startIndex&gt;=0: startIndex += len(startStr) endIndex = content.index(endStr) return content[startIndex:endIndex] def GetUsers(): global Bilibili_Key GetTotalRepost() Tmp_count = 0 Bilibili_Key = 0 DynamicAPI = \"https://api.live.bilibili.com/dynamic_repost/v1/dynamic_repost/view_repost?dynamic_id=\"+ Dynamic_id + \"&amp;offset=\" conn = sqlite3.connect('Bilibili_TMP.db') c = conn.cursor() while Tmp_count&lt;Total_count: Tmp_DynamicAPI = DynamicAPI + str(Tmp_count) try: BiliJson = json.loads(GetMiddleStr(urllib2.urlopen(Tmp_DynamicAPI).read(),\"comments\\\":\",\",\\\"total\")) for BiliJson_dict in BiliJson: Bilibili_UID = str(BiliJson_dict['uid']) Bilibili_Uname = BiliJson_dict['uname'] Bilibili_Comment = BiliJson_dict['comment'] Bilibili_Sql = \"INSERT or REPLACE into Bilibili (UID,Uname,Comment,ID) VALUES (\" + Bilibili_UID + \", '\" + Bilibili_Uname + \"', '\" + Bilibili_Comment + \"', \" + str(Bilibili_Key) + \")\" c.execute(Bilibili_Sql) conn.commit() Bilibili_Key = Bilibili_Key + 1 except: break Tmp_count = Tmp_count + 20 else: Tmp_count = 0 conn.close() def GetTotalRepost(): global Total_count global UP_UID DynamicAPI = \"https://api.vc.bilibili.com/dynamic_svr/v1/dynamic_svr/get_dynamic_detail?dynamic_id=\" + Dynamic_id BiliJson = json.loads(urllib2.urlopen(DynamicAPI).read()) Total_count = BiliJson['data']['card']['desc']['repost'] UP_UID = BiliJson['data']['card']['desc']['user_profile']['info']['uid'] def GetLuckyDog(): Bilibili_Doge = random.randint(0,Bilibili_Key) conn = sqlite3.connect('Bilibili_TMP.db') c = conn.cursor() cursor = c.execute(\"SELECT UID from Bilibili where ID=\" + str(Bilibili_Doge)) res = cursor.fetchall() suc = True if len(res) &gt; 0 : suc = True cursor.close() conn.close() conn2 = sqlite3.connect('Bilibili_TMP.db') c2 = conn2.cursor() info_cursor = c2.execute(\"SELECT UID,Uname,Comment from Bilibili where ID=\" + str(Bilibili_Doge)) for row in info_cursor: print \"用户ID:\", row[0] print \"用户名:\", row[1] print \"转发详情：\", row[2], \"\\n\" bilibili_open = raw_input(TellTime() + \"是否打开网页给获奖用户发送私信：（Y/N）\"); if bilibili_open == \"Y\": webbrowser.open(\"https://message.bilibili.com/#/whisper/mid\" + str(row[0])) elif bilibili_open == \"y\": webbrowser.open(\"https://message.bilibili.com/#/whisper/mid\" + str(row[0])) elif bilibili_open == \"Yes\": webbrowser.open(\"https://message.bilibili.com/#/whisper/mid\" + str(row[0])) elif bilibili_open == \"yes\": webbrowser.open(\"https://message.bilibili.com/#/whisper/mid\" + str(row[0])) elif bilibili_open == \"是\": webbrowser.open(\"https://message.bilibili.com/#/whisper/mid\" + str(row[0])) elif bilibili_open == \"是的\": webbrowser.open(\"https://message.bilibili.com/#/whisper/mid\" + str(row[0])) conn2.close() else: suc = False cursor.close() conn.close() GetLuckyDog() def DeleteDatabase(): DB_path = os.getcwd() + os.sep + \"Bilibili_TMP.db\" try: os.remove(DB_path) print TellTime() + \"正在清理缓存...\" except: print TellTime() + \"正在清理缓存...\" def CreateDatabase(): conn = sqlite3.connect('Bilibili_TMP.db') c = conn.cursor() c.execute('''CREATE TABLE Bilibili (UID INT PRIMARY KEY NOT NULL, Uname TEXT NOT NULL, Comment TEXT NOT NULL, ID INT NOT NULL);''') conn.commit() conn.close() def GetDynamicid(): s = raw_input(\"请粘贴您获取到的网址：\") nums = re.findall(r'\\d+', s) try: bilibili_domain = urlparse(s)[1] if bilibili_domain == \"t.bilibili.com\": print TellTime() + \"为纯文本类型动态\" return str(nums[0]) elif bilibili_domain == \"h.bilibili.com\": bilibili_docid = \"https://api.vc.bilibili.com/link_draw/v2/doc/dynamic_id?doc_id=\" + str(nums[0]) Dynamic_id = GetMiddleStr(urllib2.urlopen(bilibili_docid).read(),\"dynamic_id\\\":\\\"\",\"\\\"}}\") print TellTime() + \"为画册类型动态\" return str(Dynamic_id) except: print TellTime() + \"您输入的网址有误！\" exit() def TellTime(): localtime = \"[\" + str(time.strftime('%H:%M:%S',time.localtime(time.time()))) + \"]\" return localtime if __name__ == '__main__': DeleteDatabase() print \"+------------------------------------------------------------+\" print \"|在电脑端登录Bilibli,点击进入个人主页,再点击动态,进入动态页面|\" print \"|点击对应的动态内容，将获取到的网址复制，并粘贴在下方： |\" print \"+------------------------------------------------------------+\\n\" Dynamic_id = str(GetDynamicid()) TellTime() print TellTime() + \"获取动态成功，ID为：\" + Dynamic_id print TellTime() + \"正在获取转发数据中......\" CreateDatabase() GetUsers() print TellTime() + \"获取数据成功！\" print TellTime() + \"中奖用户信息：\\n\" GetLuckyDog() DeleteDatabase() document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"【LeetCode】236. 二叉树的最近公共祖先","slug":"【LeetCode】236. 二叉树的最近公共祖先","date":"2020-05-10T02:30:00.000Z","updated":"2020-07-10T06:46:17.800Z","comments":true,"path":"2020/05/10/【LeetCode】236. 二叉树的最近公共祖先/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/10/%E3%80%90LeetCode%E3%80%91236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","excerpt":"题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。","text":"题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 代码/** * 时间复杂度：O(n) 每个节点最多就遍历一次 * 空间复杂度：O(n) 用到栈空间 */ class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) return null; if(p == root || q == root) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left == null &amp;&amp; right == null) // 根节点为空，公共祖先便为空 return null; else if(left != null &amp;&amp; right != null) // 左右两边各一个节点，那root一定是p、q的公共祖先 return root; else if(left == null) // 左子树为空，那就只用看右子树的根 return right; else if(right == null) // 右子树为空，那就只用看左子树的根 return left; // 因为函数的返回值是TreeNode，最后一定要return return null; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"最长递增子序列（LIS）","slug":"最长递增子序列（LIS）","date":"2020-05-09T13:57:00.000Z","updated":"2020-07-10T06:46:17.931Z","comments":true,"path":"2020/05/09/最长递增子序列（LIS）/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/09/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LIS%EF%BC%89/","excerpt":"","text":"代码/** * @Classname LIS * @Description 最长递增子序列（LIS） * @Date 2020/5/9 下午 9:09 * @Created by jerry */ public class LIS { public static int LIS(int[] nums) { if(nums.length &lt;= 1){ return nums.length; } //最大长度 int max = 1; //dp[i]表示第i长的子序列，最后的元素 int[] dp = new int[nums.length + 1]; dp[1] = nums[0]; for(int i = 1;i &lt; nums.length;i++){ //如果当前元素比最大的那个子串的最后一个元素还要大 //那就直接长度加一，新子串的最后一个元素为当前元素 if(nums[i] &gt; dp[max]){ dp[++max] = nums[i]; }else if(nums[i] &lt; dp[max]){ //如果当前元素比最大的那个子串的最后一个元素要小 //那就要更新dp数组，保证每一个子串都是最优解 for(int j = 1 ;j &lt;= max; j++){ //因为是递增，所以是&lt;=,在将等于的时候直接终止循环 if(nums[i] &lt;= dp[j]){ dp[j] = nums[i]; break; } } } } for (int i = 1; i &lt;= max; i++) { System.out.print(dp[i] + \" \"); } System.out.println(); return max; } public static void main(String[] args) { int[] nums = new int[]{10,9,2,5,3,7,101,18}; System.out.println(LIS(nums)); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode】69. x 的平方根","slug":"【LeetCode】69. x 的平方根","date":"2020-05-09T12:51:00.000Z","updated":"2020-07-10T06:46:17.808Z","comments":true,"path":"2020/05/09/【LeetCode】69. x 的平方根/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/09/%E3%80%90LeetCode%E3%80%9169.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/","excerpt":"","text":"这是今天”每日一题”的题目，等级是简单。不过，确实耐人寻味。最简单的方法就是采用JAVA的Math类库的方法 但是这样做，还有什么意义呢，是吧？ # 题目描述 实现 `int sqrt(int x)` 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: &gt; 输入: 4 &gt; 输出: 2 示例 2: &gt; 输入: 8 &gt; 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 &lt;!--more--&gt; # 题解 采用&lt;font color='red' size='6'&gt;“二分法”&lt;/font&gt;的思想可以很容易的完成。 其思想简单的来说，就像是玩“猜数字”的游戏，猜小了就往大的猜，猜大了就往小的猜，随着猜的次数增加，范围越来越小，离结果也就越来越近了。 那么，这里也一样的。 我们不妨可以采用这个公式来做 $$\\sqrt{k} ≦ \\frac{k}{2}$$ 我们这样子看，假设一个很大的数k，k的开方肯定不会超过它的一半，越是很大的数越是如此。 但是我们回来这个公式，看看这个公式的边界，边界是4。 0、1、2、3、4、5这样的数的开方，我们都一清二楚，所以我们要考虑的是从4开始的数字，那就完全可以忽略那些小细节了。 注意的是，**在取中位数mid的时候，应该向右取。**如果向左取得话，会陷入死循环中。 # 代码 class Solution { public int mySqrt(int x) { if(x == 0) return 0; long left = 1; long right = x / 2; while (left &lt; right){ long mid = (left + right + 1) &gt;&gt;&gt; 1; // 向右取中位数 long mid_square = mid * mid; if(mid_square &gt; x) right = mid - 1; else left = mid; } return (int)left; }} # 更多题解 官方：https://leetcode-cn.com/problems/sqrtx/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"最长公共子序列（LCS）","slug":"最长公共子序列（LCS）","date":"2020-05-09T12:51:00.000Z","updated":"2020-07-10T06:46:17.926Z","comments":true,"path":"2020/05/09/最长公共子序列（LCS）/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/09/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LCS%EF%BC%89/","excerpt":"","text":"代码#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; using namespace std; const int MAX = 100; const int m = 7, n = 6; int C[MAX][MAX]; // C[i][j]：Xi和Yj的LCS长度 int X[m] = {'A', 'B', 'C', 'B', 'D', 'A', 'B'}, Y[n] = {'B', 'D', 'C', 'A', 'B', 'A'}; void LCS(int X[], int Y[], int m, int n){ int i, j; char B[MAX][MAX]; // B[i][j]：C[i][j]取得最大值的标志 for (i = 1; i &lt;= m; i++) C[i][0] = 0; for (i = 1; i &lt;= n; i++) C[0][i] = 0; for (i = 1; i &lt;= m; i++){ for (j = 1; j &lt;= n; j++){ if (X[i] == Y[j]){ C[i][j] = C[i - 1][j - 1] + 1; B[i][j] = 'lu'; } else if (C[i-1][j] &gt;= C[i][j-1]){ C[i][j] = C[i - 1][j]; B[i][j] = 'u'; } else { C[i][j] = C[i][j - 1]; B[i][j] = 'l'; } } } printf(\"\\nC[i][j]\\n\"); for (i = 1; i &lt;= m; i++){ printf(\"%d\\t\", i); for (j = 1; j &lt;= n; j++){ printf(\"%d\\t\", C[i][j]); } printf(\"\\n\"); } printf(\"\\nB[j][j]\\n\"); for (i = 1; i &lt;= m; i++){ printf(\"%d\\t\", i); for (j = 1; j &lt;= n; j++){ printf(\"%c\\t\", B[i][j]); } printf(\"\\n\"); } } int main () { LCS(X, Y, m, n); return 0; system(\"pause\"); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"博客园写随笔时用数学公式","slug":"Java中有三种移位运算符","date":"2020-05-09T10:00:00.000Z","updated":"2020-07-10T06:46:17.460Z","comments":true,"path":"2020/05/09/Java中有三种移位运算符/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/09/Java%E4%B8%AD%E6%9C%89%E4%B8%89%E7%A7%8D%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"插入公式在开启后你就可以使用LATEX格式的公式了 行内公式使用如下格式书写，公式使用$包裹： 二元一次方程的判别式：$\\Delta=b^2-4ac$ 编译结果为：二元一次方程的判别式：$\\Delta=b^2-4ac$ 陈列(独立)公式使用如下格式书写，公式使用$$包裹： 二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 编译结果为：二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 相关阅读 https://www.cnblogs.com/linxd/p/4955530.html https://www.cnblogs.com/q735613050/p/7253073.html https://www.cnblogs.com/zhuxiaoxi/p/8320683.html","text":"插入公式在开启后你就可以使用LATEX格式的公式了 行内公式使用如下格式书写，公式使用$包裹： 二元一次方程的判别式：$\\Delta=b^2-4ac$ 编译结果为：二元一次方程的判别式：$\\Delta=b^2-4ac$ 陈列(独立)公式使用如下格式书写，公式使用$$包裹： 二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 编译结果为：二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 相关阅读 https://www.cnblogs.com/linxd/p/4955530.html https://www.cnblogs.com/q735613050/p/7253073.html https://www.cnblogs.com/zhuxiaoxi/p/8320683.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"【LeetCode】69. x 的平方根","slug":"博客园写随笔时用数学公式","date":"2020-05-09T10:00:00.000Z","updated":"2020-07-10T06:46:17.916Z","comments":true,"path":"2020/05/09/博客园写随笔时用数学公式/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/05/09/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E5%86%99%E9%9A%8F%E7%AC%94%E6%97%B6%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","excerpt":"插入公式在开启后你就可以使用LATEX格式的公式了 行内公式使用如下格式书写，公式使用$包裹： 二元一次方程的判别式：$\\Delta=b^2-4ac$ 编译结果为：二元一次方程的判别式：$\\Delta=b^2-4ac$ 陈列(独立)公式使用如下格式书写，公式使用$$包裹： 二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 编译结果为：二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 相关阅读 https://www.cnblogs.com/linxd/p/4955530.html https://www.cnblogs.com/q735613050/p/7253073.html https://www.cnblogs.com/zhuxiaoxi/p/8320683.html","text":"插入公式在开启后你就可以使用LATEX格式的公式了 行内公式使用如下格式书写，公式使用$包裹： 二元一次方程的判别式：$\\Delta=b^2-4ac$ 编译结果为：二元一次方程的判别式：$\\Delta=b^2-4ac$ 陈列(独立)公式使用如下格式书写，公式使用$$包裹： 二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 编译结果为：二元一次方程的判别式：$$\\Delta=b^2-4ac$$ 相关阅读 https://www.cnblogs.com/linxd/p/4955530.html https://www.cnblogs.com/q735613050/p/7253073.html https://www.cnblogs.com/zhuxiaoxi/p/8320683.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"正式开通博客园","slug":"正式开通博客园","date":"2020-04-23T14:40:27.000Z","updated":"2020-04-23T11:40:36.814Z","comments":true,"path":"2020/04/23/正式开通博客园/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/23/%E6%AD%A3%E5%BC%8F%E5%BC%80%E9%80%9A%E5%8D%9A%E5%AE%A2%E5%9B%AD/","excerpt":"现在正式开通【博客园】：https://www.cnblogs.com/melodyjerry/","text":"现在正式开通【博客园】：https://www.cnblogs.com/melodyjerry/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"实现博客内容折叠","slug":"实现博客内容折叠","date":"2020-04-23T13:00:00.000Z","updated":"2020-09-18T04:43:03.200Z","comments":true,"path":"2020/04/23/实现博客内容折叠/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/23/%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E6%8A%98%E5%8F%A0/","excerpt":"点击查看Hexo NexT主题美化2.0浏览器控制台个性化输出Hexo 优化与加速本站主题已整理开源Hexo NexT主题之自定义标签页Hexo NexT主题移动端样式适配Hexo NexT接入Google AdSense广告NexT主题之LeanCloud切换国际版Hexo NexT主题之代码块Mac Panel特效Hexo-abbrlink生成唯一文章链接","text":"点击查看Hexo NexT主题美化2.0浏览器控制台个性化输出Hexo 优化与加速本站主题已整理开源Hexo NexT主题之自定义标签页Hexo NexT主题移动端样式适配Hexo NexT接入Google AdSense广告NexT主题之LeanCloud切换国际版Hexo NexT主题之代码块Mac Panel特效Hexo-abbrlink生成唯一文章链接 &lt;details open=\"\"&gt; &lt;summary&gt;点击查看&lt;/summary&gt; &lt;ul class=\"popular-posts\"&gt; &lt;li class=\"popular-posts-item\"&gt; &lt;div class=\"popular-posts-title\"&gt; &lt;a href=\"https://www.liaofuzhan.com/posts/2114475547.html\" rel=\"bookmark\" data-pjax-state=\"\"&gt;Hexo NexT主题美化2.0&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=\"popular-posts-item\"&gt; &lt;div class=\"popular-posts-title\"&gt; &lt;a href=\"https://www.liaofuzhan.com/posts/3274212224.html\" rel=\"bookmark\" data-pjax-state=\"\"&gt;浏览器控制台个性化输出&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=\"popular-posts-item\"&gt; &lt;div class=\"popular-posts-title\"&gt; &lt;a href=\"https://www.liaofuzhan.com/posts/1599400735.html\" rel=\"bookmark\" data-pjax-state=\"\"&gt;Hexo 优化与加速&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/details&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Fiddler抓包工具","slug":"Fiddler抓包工具总结","date":"2020-04-23T11:38:39.421Z","updated":"2020-04-23T11:40:36.716Z","comments":true,"path":"2020/04/23/Fiddler抓包工具总结/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/23/Fiddler%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/","excerpt":"Fiddler抓包工具总结 https://www.cnblogs.com/yyhh/p/5140852.html","text":"Fiddler抓包工具总结 https://www.cnblogs.com/yyhh/p/5140852.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"MVC：开发模式","slug":"MVC：开发模式","date":"2020-04-23T11:38:39.409Z","updated":"2020-04-23T11:40:36.767Z","comments":true,"path":"2020/04/23/MVC：开发模式/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/23/MVC%EF%BC%9A%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/","excerpt":"MVC：开发模式一、jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 二、MVC M Model，模型。JavaBean 完成具体的业务操作，如：查询数据库，封装对象 V View，视图。JSP 展示数据 C Controller，控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 三、优缺点优点 耦合性低，方便维护，可以利于分工协作 重用性高 生命周期成本低 部署快 可维护性高 有软件工程化管理 缺点 使得项目架构变得复杂，对开发人员要求高 不适合小型，中等规模的应用程序 增加系统结构和实现的复杂性 视图与控制器间的过于紧密的连接 视图对模型数据的低效率访问 一般高级的界面工具或构造器不支持模式 扩展阅读 [CSDN] MVC模式简介 [菜鸟教程] MVC 模式 [百度百科] MVC框架","text":"MVC：开发模式一、jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 二、MVC M Model，模型。JavaBean 完成具体的业务操作，如：查询数据库，封装对象 V View，视图。JSP 展示数据 C Controller，控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 三、优缺点优点 耦合性低，方便维护，可以利于分工协作 重用性高 生命周期成本低 部署快 可维护性高 有软件工程化管理 缺点 使得项目架构变得复杂，对开发人员要求高 不适合小型，中等规模的应用程序 增加系统结构和实现的复杂性 视图与控制器间的过于紧密的连接 视图对模型数据的低效率访问 一般高级的界面工具或构造器不支持模式 扩展阅读 [CSDN] MVC模式简介 [菜鸟教程] MVC 模式 [百度百科] MVC框架 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"MVC","slug":"MVC","permalink":"https://melodyjerry.github.io/blog/tags/MVC/"}]},{"title":"将博客搬至CSDN","slug":"将博客搬至CSDN","date":"2020-04-23T01:04:00.000Z","updated":"2020-04-23T11:40:36.811Z","comments":true,"path":"2020/04/23/将博客搬至CSDN/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/23/%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%87%B3CSDN/","excerpt":"现将本博客中，截止到2020-4-23 09点04分的所有博客拷贝到CSDN。 CSDN博客链接：https://blog.csdn.net/weixin_43438052","text":"现将本博客中，截止到2020-4-23 09点04分的所有博客拷贝到CSDN。 CSDN博客链接：https://blog.csdn.net/weixin_43438052 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"“点击查看”隐藏式按钮html实现","slug":"“点击查看”隐藏式按钮html实现","date":"2020-04-22T15:00:00.000Z","updated":"2020-04-23T11:40:36.795Z","comments":true,"path":"2020/04/22/“点击查看”隐藏式按钮html实现/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/22/%E2%80%9C%E7%82%B9%E5%87%BB%E6%9F%A5%E7%9C%8B%E2%80%9D%E9%9A%90%E8%97%8F%E5%BC%8F%E6%8C%89%E9%92%AEhtml%E5%AE%9E%E7%8E%B0/","excerpt":"点击查看Hexo NexT主题美化2.0浏览器控制台个性化输出Hexo 优化与加速本站主题已整理开源Hexo NexT主题之自定义标签页Hexo NexT主题移动端样式适配Hexo NexT接入Google AdSense广告NexT主题之LeanCloud切换国际版Hexo NexT主题之代码块Mac Panel特效Hexo-abbrlink生成唯一文章链接","text":"点击查看Hexo NexT主题美化2.0浏览器控制台个性化输出Hexo 优化与加速本站主题已整理开源Hexo NexT主题之自定义标签页Hexo NexT主题移动端样式适配Hexo NexT接入Google AdSense广告NexT主题之LeanCloud切换国际版Hexo NexT主题之代码块Mac Panel特效Hexo-abbrlink生成唯一文章链接 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"一款炫丽的网页播放器插件","slug":"一款炫丽的网页播放器插件","date":"2020-04-22T14:00:00.000Z","updated":"2020-09-18T04:43:03.048Z","comments":true,"path":"2020/04/22/一款炫丽的网页播放器插件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/22/%E4%B8%80%E6%AC%BE%E7%82%AB%E4%B8%BD%E7%9A%84%E7%BD%91%E9%A1%B5%E6%92%AD%E6%94%BE%E5%99%A8%E6%8F%92%E4%BB%B6/","excerpt":"一款炫丽的网页播放器插件网上看到一款挺不错的基于 HTML 5 实现的播放器插件，支持多平台音乐解析、精准 LRC 歌词、智能记忆、视频播放等多种功能。目前免费使用，只需注册即可 DIY。作者表明自己是个初！中！生！，在 2016 年用业余时间写的（网传是抄袭、暴力破解他人作品），目前每天的访问量 10W+，用的人还是挺多的，本站点也进行了集成，可在左下角体验效果。 2020 年 04 月 01 日更新：本站已弃用绚丽彩虹，推荐 明月浩空 转载链接：https://www.liaofuzhan.com/posts/2636059693.html","text":"一款炫丽的网页播放器插件网上看到一款挺不错的基于 HTML 5 实现的播放器插件，支持多平台音乐解析、精准 LRC 歌词、智能记忆、视频播放等多种功能。目前免费使用，只需注册即可 DIY。作者表明自己是个初！中！生！，在 2016 年用业余时间写的（网传是抄袭、暴力破解他人作品），目前每天的访问量 10W+，用的人还是挺多的，本站点也进行了集成，可在左下角体验效果。 2020 年 04 月 01 日更新：本站已弃用绚丽彩虹，推荐 明月浩空 转载链接：https://www.liaofuzhan.com/posts/2636059693.html 绚丽彩虹播放器 相关的功能介绍可参考： 绚丽彩虹播放器http://www.badapple.top/ 之前用的是 APlayer 这款播放器，其吸盘模式能放在网页左下角，外链需自己逐个添加。由于本站要过滤 HTTP 链接，想要的外链不好找，而且在 IE 11 （博主的破旧电脑） 里 JS 一大堆报错。。部分非主流浏览器（谁会用呢 -.-!）兼容还有点问题。 PS：NexT 5.1.4 在 Pisces 这个 scheme 下，左侧栏 sidebar 在 IE 11 里会不显示。（本站已修复） 基于这些原因（主要是找到了更好的~），所以将 Aplayer 进行了替换，步骤也很简单： 在 next/layout/_layout.swig 的 body 体内部，新增如下代码： 复制&lt;!-- badApplePlayer --&gt; {% if theme.badApplePlayer.enable %} &lt;!-- Your XlchPlayerKey --&gt; &lt;script&gt;XlchKey=\"{{theme.badApplePlayer.XlchKey}}\";&lt;/script&gt; &lt;!-- font-awesome 4.2.0 --&gt; &lt;link href=\"https://lib.baomitu.com/font-awesome/4.2.0/css/font-awesome.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt; &lt;!-- JQuery-mousewheel 3.1.9 --&gt; &lt;script src=\"https://lib.baomitu.com/jquery-mousewheel/3.1.9/jquery.mousewheel.min.js\"&gt;&lt;/script&gt; &lt;!-- Scrollbar --&gt; &lt;script src=\"https://static.https.badapple.top/BadApplePlayer/js/scrollbar.js\"&gt;&lt;/script&gt; &lt;!-- BadApplePlayer --&gt; &lt;script src=\"https://static.https.badapple.top/BadApplePlayer/Player.js\"&gt;&lt;/script&gt; {% endif %} 其还需要依赖 jquery ，我在做其它功能时已经引入，这里就不需要了，如果你加了以上代码没效果，那么再补充： 复制&lt;script src=\"https://lib.baomitu.com/jquery/2.2.4/jquery.min.js\"&gt;&lt;/script&gt; 以上链接均可换成 http 的，按需修改即可。 在主题配置文件 _config.yml 中，添加配置： 复制# http://www.badapple.top badApplePlayer: enable: true XlchKey: your_key # 播放器Key XlchKey 为你自己的播放器 Key，官网完成注册，添加播放器后即可生成。你也可使用我的 BZ9DLOyFjh 来测试下。 调整播放器在移动端大小（可选）。需要在 head 标签内添加以下代码，比如我是在 next/layout/_layout.swig 的 head 内加的： 复制{% if theme.badApplePlayer.enable %} &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=0.9, maximum-scale=0.9\" /&gt; {% endif %} hexo 三连即可看到效果。附上视频教程地址： 绚丽彩虹播放器 [BadApplePlayer] 播放器教程 V20170122 https://www.bilibili.com/video/av8153459 按照教程就可以添加网易云这些第三方平台的歌单啦！ 明月浩空音乐播放器由于绚丽彩虹经常宕机，在网上找替换方案的同时，翻到了明月浩空 的网站。细品了这位大佬诸多文章后，才发现他才是播放器的原作者，只能说盗版行为太昌盛，真假难辨…明月浩空音乐播放器已经商用，功能很强大，如今开放了免费注册功能，大家不妨体验一下 明月浩空音乐播放器https://player.lmih.cn/ PS：其实也是基于 APlayer 的定制版本，又绕回来了。。😝 宅音乐播放器另外一款，看了下代码，插件是修改于明月浩空免费版，体验了下，bug 挺多，毕竟是阉割版，不过它可以添加多个播放器和歌单，而明月浩空则需要付费才可以。体验地址： 宅音乐播放器https://player.ilt.me/ 作者还分享了源代码和安装教程： 宅音乐播放器源代码https://github.com/lzx8589561/zhai-music 底层使用 PHP 所写，前端为 LayUI 框架，数据库用的 MySQL 写在最后之前搭建的几款 JAVA 后端框架，可以用来 DIY 一个自己的播放器，彻底重写，有兴趣的朋友可以尝试一下。 相关文章点击查看Hexo NexT主题美化2.0浏览器控制台个性化输出Hexo 优化与加速本站主题已整理开源Hexo NexT主题之自定义标签页Hexo NexT主题移动端样式适配Hexo NexT接入Google AdSense广告NexT主题之LeanCloud切换国际版Hexo NexT主题之代码块Mac Panel特效Hexo-abbrlink生成唯一文章链接 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"浏览器截长图的方法","slug":"浏览器截长图方法","date":"2020-04-09T14:00:00.000Z","updated":"2020-04-23T11:40:36.814Z","comments":true,"path":"2020/04/09/浏览器截长图方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%AA%E9%95%BF%E5%9B%BE%E6%96%B9%E6%B3%95/","excerpt":"Chrome -&gt; F12 -&gt; Ctrl+Shift+P -&gt; Capture full size screenshot Firefox -&gt; F12 -&gt; 右上角”…“ -&gt; 设置 -&gt; 可选的工具箱按钮 -&gt; 截取整个页面 -&gt; 右上角“相机”按钮","text":"Chrome -&gt; F12 -&gt; Ctrl+Shift+P -&gt; Capture full size screenshot Firefox -&gt; F12 -&gt; 右上角”…“ -&gt; 设置 -&gt; 可选的工具箱按钮 -&gt; 截取整个页面 -&gt; 右上角“相机”按钮 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"win10快速在当前文件夹打开cmd","slug":"win10快速在当前文件夹打开cmd","date":"2020-04-08T09:43:23.000Z","updated":"2020-04-23T11:40:36.792Z","comments":true,"path":"2020/04/08/win10快速在当前文件夹打开cmd/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/08/win10%E5%BF%AB%E9%80%9F%E5%9C%A8%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E5%A4%B9%E6%89%93%E5%BC%80cmd/","excerpt":"一般有两种简单、直接的方法： 在路径栏输入cmd，回车 即可在当前位置打开命令窗口 按住Shift键+鼠标右键，可见在“在此处打开cmd”","text":"一般有两种简单、直接的方法： 在路径栏输入cmd，回车 即可在当前位置打开命令窗口 按住Shift键+鼠标右键，可见在“在此处打开cmd” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"将idea工程打包成jar文件的全步骤","slug":"将idea工程打包成jar文件的全步骤","date":"2020-04-08T06:43:23.000Z","updated":"2020-04-23T11:40:36.810Z","comments":true,"path":"2020/04/08/将idea工程打包成jar文件的全步骤/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/08/%E5%B0%86idea%E5%B7%A5%E7%A8%8B%E6%89%93%E5%8C%85%E6%88%90jar%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E6%AD%A5%E9%AA%A4/","excerpt":"前言 近日在工作中遇到了一个问题，需要把本地的java文件打成jar包，传到云服务器上运行。于是学习了一下如何在intellijidea中将java工程打成jar包。","text":"前言 近日在工作中遇到了一个问题，需要把本地的java文件打成jar包，传到云服务器上运行。于是学习了一下如何在intellijidea中将java工程打成jar包。 步骤如下： 1、File-&gt;PorjectStructure 2、在ProjectSetings中选择Artifects。 点击+号选择jar文件中的Empty选项 Artifacts –&gt; + –&gt; JAR –&gt; From modules with dependencies… 参见文末 3、在Name选项中修改jar文件的名字。 然后点击下方的CreatManifest按钮，点击ok(应该默认是当前工程) 4、点击Main Class右侧的文件夹图标，选择当前工程的入口类，即主函数所在类，点击ok Main Class是你这个项目(\\脚本*)的主方法,就是要运行的类,选一个* 5、在右侧的AvailableElements一栏中双击编译后的资源文件，将其打入左侧jar包 6、点击Build选项中的BuildArtifacts 点击Build选项。这里Build选项是第一次构建jar，Rebuild是修改后重新构建jar，clean是删除jar。 7、在这里我们可以看见生成的jar包 8、 进入jar包所在目录，在地址栏中输入cmd按回车，进入命令行 9、执行如图命令即可运行jar文件 如果是选择 Artifacts –&gt; + –&gt; JAR –&gt; From modules with dependencies… 的话 Main Class是你这个项目(\\脚本*)的主方法,就是要运行的类,选一个* 如下图,设置 META-INF/MANIFEST.MF !!!!!切记,不能用默认的(起码我用默认的是不成功的)!!!!! 选中你这个项目的根目录,一定要放在根目录下 设置完是这样子的,关于 JAR files from libraries的两个选项: 选中第一个的话,打完包后是一个jar包 选中第二个的话,打完包后是一个jar包,外带你项目所用的jar包,个人推荐第二个 设置完后就可以点OK了 这个页面, Build on make打上勾,其他的不一样也没事 最后一步, Build Artifacts… –&gt; XXX.jar –&gt; Build 复制这里的路径去找jar包就行 参考资料： https://blog.csdn.net/weixin_42089175/article/details/89113271 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"JAVA","slug":"JAVA","permalink":"https://melodyjerry.github.io/blog/tags/JAVA/"}]},{"title":"virtualbox安装ubuntu16 LTS及其配置","slug":"virtualbox安装ubuntu16-LTS及其配置","date":"2020-04-07T11:00:00.000Z","updated":"2020-04-23T11:40:36.791Z","comments":true,"path":"2020/04/07/virtualbox安装ubuntu16-LTS及其配置/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/04/07/virtualbox%E5%AE%89%E8%A3%85ubuntu16-LTS%E5%8F%8A%E5%85%B6%E9%85%8D%E7%BD%AE/","excerpt":"virtualbox安装ubuntu16 LTS及其配置 https://www.cnblogs.com/luengmingbiao/p/10859905.html","text":"virtualbox安装ubuntu16 LTS及其配置 https://www.cnblogs.com/luengmingbiao/p/10859905.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"}],"author":{"name":"buildings","url":"https://www.cnblogs.com/luengmingbiao/"}},{"title":"Java-生成验证码并保存到硬盘","slug":"Java-生成验证码并保存到硬盘","date":"2020-03-31T11:00:00.000Z","updated":"2020-04-23T11:40:36.764Z","comments":true,"path":"2020/03/31/Java-生成验证码并保存到硬盘/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/31/Java-%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%E5%B9%B6%E4%BF%9D%E5%AD%98%E5%88%B0%E7%A1%AC%E7%9B%98/","excerpt":"做课设时候，选择是做“图书借阅管理系统”。 在写登陆界面时候，想把前段时间学的web中生成验证码的知识用上。 于是，就写了这个。 分为两个文件：&lt;CheckCode.java&gt; 和 &lt;CheckCodeRead.java&gt; ，前者是生成，后者是读取，均可以在控制台打印验证码值 checkValue 。","text":"做课设时候，选择是做“图书借阅管理系统”。 在写登陆界面时候，想把前段时间学的web中生成验证码的知识用上。 于是，就写了这个。 分为两个文件：&lt;CheckCode.java&gt; 和 &lt;CheckCodeRead.java&gt; ，前者是生成，后者是读取，均可以在控制台打印验证码值 checkValue 。 CheckCodepackage view; import javax.imageio.ImageIO; import java.awt.*; import java.awt.image.BufferedImage; import java.io.*; import java.util.Random; /** * @Classname CheckCode * @Description TODO * @Date 2020/3/31 下午 5:13 * @Created by jerry */ public class CheckCode { public void creatCheck() { char[] chs = new char[4]; int width = 100; int height = 50; //1.创建一对象，在内存中图片(验证码图片对象) BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2.美化图片 //2.1 填充背景色 Graphics g = image.getGraphics();//画笔对象 g.setColor(Color.PINK);//设置画笔颜色 g.fillRect(0,0,width,height); //2.2画边框 g.setColor(Color.BLUE); g.drawRect(0,0,width - 1,height - 1); String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789\"; //生成随机角标 Random ran = new Random(); StringBuilder sb = new StringBuilder(); // StringBuilder：一个可变的字符序列 for (int i = 1; i &lt;= 4; i++) { int index = ran.nextInt(str.length()); //获取字符 char ch = str.charAt(index);//随机字符 sb.append(ch); chs[i-1] = ch; //2.3写验证码 g.drawString(ch+\"\",width/5*i,height/2); } String checkCode_session = sb.toString(); /* //将验证码存入session request.getSession().setAttribute(\"checkCode_session\",checkCode_session);*/ //2.4画干扰线 g.setColor(Color.GREEN); //随机生成坐标点 for (int i = 0; i &lt; 10; i++) { int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1,y1,x2,y2); } //3.将图片、验证码值写入硬盘 // ImageIO.write(image,\"jpg\",response.getOutputStream()); try { String encoding=\"GBK\"; ImageIO.write(image, \"png\",new File(\"F:\\\\MyJava\\\\LibrarySystem\\\\v0.0\\\\src\\\\image\\\\check.png\")); File file = new File(\"F:\\\\MyJava\\\\LibrarySystem\\\\v0.0\\\\src\\\\image\\\\check.txt\"); Writer out = new OutputStreamWriter(new FileOutputStream(file),encoding); out.write(checkCode_session); // 将验证码值写入check.txt文件里 out.close(); // 关闭输出流，回收资源 System.out.println(checkCode_session); } catch (IOException e) { e.printStackTrace(); } } public static void main(String[] args) { new CheckCode().creatCheck(); } } CheckCodeReadpackage view; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.InputStreamReader; /** * @Classname CheckCodeCreate * @Description TODO * @Date 2020/3/31 下午 5:51 * @Created by jerry */ public class CheckCodeRead { /** * 功能：Java读取txt文件的内容 * 步骤：1：先获得文件句柄 * 2：获得文件句柄当做是输入一个字节码流，需要对这个输入流进行读取 * 3：读取到输入流后，需要读取生成字节流 * 4：一行一行的输出。readline()。 * 备注：需要考虑的是异常情况 * @param filePath */ public static void readTxtFile(String filePath){ try { String encoding=\"GBK\"; File file=new File(filePath); if(file.isFile() &amp;&amp; file.exists()){ //判断文件是否存在 InputStreamReader read = new InputStreamReader( new FileInputStream(file),encoding);//考虑到编码格式 BufferedReader bufferedReader = new BufferedReader(read); String lineTxt = null; while((lineTxt = bufferedReader.readLine()) != null){ System.out.println(lineTxt); } read.close(); }else{ System.out.println(\"找不到指定的文件\"); } } catch (Exception e) { System.out.println(\"读取文件内容出错\"); e.printStackTrace(); } } public CheckCodeRead() { String filePath = \"F:\\\\MyJava\\\\LibrarySystem\\\\v0.0\\\\src\\\\image\\\\check.txt\"; // \"res/\"; readTxtFile(filePath); } public static void main(String argv[]){ new CheckCodeRead(); } } 效果验证码图片 check.png 👇 控制台输出 👇 check.txt 保存 验证码值 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java.sql的接口PreparedStatement使用","slug":"Java.sql的接口PreparedStatement使用","date":"2020-03-28T10:51:11.000Z","updated":"2020-04-23T11:40:36.765Z","comments":true,"path":"2020/03/28/Java.sql的接口PreparedStatement使用/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/28/Java.sql%E7%9A%84%E6%8E%A5%E5%8F%A3PreparedStatement%E4%BD%BF%E7%94%A8/","excerpt":"","text":"package utils; import java.sql.*; /** * @Classname JdbcUtils * @Description JDBC的工具类。(尽量用单例模式) * @Created by melodyjerry */ public class JdbcUtil { private static final String driverName = \"com.mysql.jdbc.Driver\"; // 数据库连接路径 private static final String URL = \"jdbc:mysql://localhost:3306/librarysystem?\" //127.0.0.1 + \"useUnicode = true &amp; serverTimezone = GMT\" // MySQL在高版本需要指明是否进行SSL连接 + \"&amp; characterEncoding = utf8 &amp; useSSL = false\"; private static final String userName = \"root\"; private static final String userPassword = \"root\"; private static Connection dbConn = null; private static Statement stmt; private static JdbcUtil utils = null; // 预编译语句 private static PreparedStatement pstmt = null; /** * 不是线程安全的 * 如果有并发访问实例化的时候会出现线程安全的问题 * 解决办法加同步锁synchronized */ public synchronized static JdbcUtil getJdbcUtil() { if (utils == null) { utils = new JdbcUtil(); return utils; } return utils; } /** * 静态代码块 * 将加载驱动、连接数据库放入静态块中 */ static { if (dbConn == null) { try { // 使用Class.forName()方式来加载数据库的驱动类 // Class.forName()是Java提供的一种基于反射的方式，直接根据类的全限定名（包+类） Class.forName(driverName); System.out.println(\"加载驱动成功！\"); }catch(Exception e){ e.printStackTrace(); System.out.println(\"加载驱动失败！\"); } try{ dbConn= DriverManager.getConnection(URL,userName,userPassword); System.out.println(\"连接数据库成功！\"); }catch(Exception e) { e.printStackTrace(); System.out.print(\"SQL Server连接失败！\"); } } } /** * 对外提供一个方法来获取数据库连接 * @return dbConn * @throws Exception */ public static Connection getConn() throws Exception { return dbConn; } /** * 创建语句对象 * @return stmt * @throws Exception */ public static Statement getStmt() throws Exception { if(stmt == null) { try { if(dbConn == null) { dbConn = getConn(); } stmt = dbConn.createStatement(); } catch (Exception e) { e.printStackTrace(); } } return stmt; } /** * 预编译语句对象 * PreparedStatement对象可以防止sql注入，而Statement不能防止sql注入 * @param sql * @return * @throws Exception */ public static PreparedStatement getPstmt(String sql) throws Exception { if(pstmt == null) { try { pstmt = dbConn.prepareStatement(sql); } catch (SQLException e) { e.printStackTrace(); } } return pstmt; } /** * 关闭数据库连接 * @param dbConn * @throws Exception */ public void closeConn(Connection dbConn) throws Exception { try { if(dbConn != null) dbConn.close(); } catch (SQLException e) { e.printStackTrace(); System.out.print(\"MySQL数据库关闭失败！\"); } } /** * 测试数据库连接、sql操作 * @param args */ public static void main(String[] args) { // 创建实例来测试连接 JdbcUtil jdbcUtil = new JdbcUtil(); try { getConn(); // jdbcUtil.getConn(); // 基于数据库连接Connection对象，创建SQL语句执行句柄，Statement对象 // prepareStatement对象，就是用来基于底层的Connection代表的数据库连接 // 允许我们通过java程序，通过prepareStatement对象，向MySQL数据库发送SQL语句 // 从而实现通过发送的SQL语句来执行增删改查等逻辑 // 第一个，SQL语句中，值所在的地方，都用问号（?）代表 String sql = \"select * from admin where adminName = ? and adminPassword = ?;\"; pstmt = dbConn.prepareStatement(sql); // 第二个，必须调用PreparedStatement的setX()系列方法，对指定的占位符设置实际的值 pstmt.setString(1,\"admin\"); pstmt.setString(2,\"admin\"); // Statement.executeQuery()方法，用来执行select语句 // Statement.executeUpdate()方法，就可以用来执行insert、update、delete语句 // executeUpdate()方法，返回类型是个int值，也就是SQL语句影响的行数 // 第三个，执行SQL语句时，直接使用executeQuery()即可，不用传入任何参数 ResultSet rs = pstmt.executeQuery(); // int rsn = pstmt.executeUpdate(); // System.out.println(\"SQL语句影响了【\" + rsn + \"】行。\"); while(rs.next()){ //打印的就是总记录数。把检索结果看成只有一跳记录一个字段的表 System.out.println(rs.getString(3)+\"\\t\"); } } catch (SQLException e) { e.printStackTrace(); System.out.println(\"sql语句操作失败！\"+e.toString()); } catch (Exception e) { e.printStackTrace(); System.out.println(\"存在异常！\"+e.toString()); }finally { try { // 最后一定要记得在finally代码块中，尽快在执行完SQL语句之后，就释放数据库连接 if (pstmt != null){ pstmt.close(); } if (dbConn !=null){ dbConn.close(); } }catch (Exception e){ e.printStackTrace(); } } } } 参考资料： PreparedStatement用法详解 对PreparedStatement、Statement的一点总结 java中PreparedStatement和Statement详细讲解 prepareStatement的用法和解释 PreparedStatement接口，prepareStatement方法 PreparedStatement的用法 Java.sql的接口PreparedStatement使用 怎么得到PreparedStatement查询条数的结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"https://melodyjerry.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"全能终端神器——MobaXterm","slug":"全能终端神器MobaXterm","date":"2020-03-25T03:17:00.000Z","updated":"2020-04-23T11:40:36.797Z","comments":true,"path":"2020/03/25/全能终端神器MobaXterm/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/25/%E5%85%A8%E8%83%BD%E7%BB%88%E7%AB%AF%E7%A5%9E%E5%99%A8MobaXterm/","excerpt":"现今软件市场上有很多终端工具，比如：secureCRT、Putty、telnet，等等。secureCRT其实也是一款很强大的终端工具，良许也使用过它很长时间，但是，它毕竟是收费软件，在公司里不允许使用。而且在良许自己的电脑里一量输入大写，整个界面就乱了（原因未知，未深究），这是直接导致良许放弃它的原因。 而Putty，它非常小巧，而且免费，在我们公司大量使用。但是良许不喜欢它的原因是它真的不好用，不支持标签，开多个会话的话就需要开多个窗口，窗口切换也很不方便，因此良许就使用了一两个月后就放弃它了。 当然还有其它终端工具，比如XShell，由于没用过就不敢乱评价了。 本文要隆重推出一款集万千于一身的全能型终端神器——MobaXterm！这款神器是我师傅介绍给我的，在我第一次使用它的时候，就深深爱上它了，真的是相见恨晚，从此一发不不可收拾，自己电脑，公司电脑全部都安上了这款神器。 先说说这款神器的优点： 功能十分强大，支持SSH，FTP，串口，VNC，X server等功能； 支持标签，切换也十分方便； 众多快捷键，操作方便； 有丰富的插件，可以进一步增强功能； 虽然有收费版，但免费版已经可以让我们装逼装上天…… 当然优点、功能远不止这些，更多闪光点期待读者去发掘！ 废话这么多，下面进入教学阶段。","text":"现今软件市场上有很多终端工具，比如：secureCRT、Putty、telnet，等等。secureCRT其实也是一款很强大的终端工具，良许也使用过它很长时间，但是，它毕竟是收费软件，在公司里不允许使用。而且在良许自己的电脑里一量输入大写，整个界面就乱了（原因未知，未深究），这是直接导致良许放弃它的原因。 而Putty，它非常小巧，而且免费，在我们公司大量使用。但是良许不喜欢它的原因是它真的不好用，不支持标签，开多个会话的话就需要开多个窗口，窗口切换也很不方便，因此良许就使用了一两个月后就放弃它了。 当然还有其它终端工具，比如XShell，由于没用过就不敢乱评价了。 本文要隆重推出一款集万千于一身的全能型终端神器——MobaXterm！这款神器是我师傅介绍给我的，在我第一次使用它的时候，就深深爱上它了，真的是相见恨晚，从此一发不不可收拾，自己电脑，公司电脑全部都安上了这款神器。 先说说这款神器的优点： 功能十分强大，支持SSH，FTP，串口，VNC，X server等功能； 支持标签，切换也十分方便； 众多快捷键，操作方便； 有丰富的插件，可以进一步增强功能； 虽然有收费版，但免费版已经可以让我们装逼装上天…… 当然优点、功能远不止这些，更多闪光点期待读者去发掘！ 废话这么多，下面进入教学阶段。 1. 软件的安装 直接去官网下载，有免费版下载。当然你要是够土豪买收费版良许也不介意。免费版不仅提供了安装版，还提供了免安装的绿色版，我们甚至可以将它拷到U盘，在家里有公司所有配置都一样。 2. 创建SSH session 安装完毕之后界面长这个样。 当然你们刚安装完成是不会有任何session的。下面来创建第一个SSH session。 点击菜单栏 「sessions」 –&gt; 「new session」，即可弹出 「session setting」 对话框。由上面那一大串的连接方式我们就可以知道Moba的强大之处。 我们点选第一个SSH图标，并填入相关信息，就可以完成session创建了。 点击确定后，输入密码就可以连接上虚拟机了。而且边上虚拟机之后，它会自动通过FTP也连接到虚拟机，直接拖拽就可以进行文件复制了。 3. 快速连接session 创建一个session之后，就可以在左侧的session标签里留下它的信息，下次需要连接的时候直接双击即可。 4. 创建串口session 下面介绍串口session的创建。 如同第2步，在「session setting」 对话框里选择serial，再选好串口号及波特率，点击OK就完成连接了。 同样session会保存在左侧的session标签页里，方便下次连接。 5. 几个有用的设置 5.1 隐藏菜单栏下的那排按钮 菜单栏下的那排按钮感觉有点鸡肋，全部可以从菜单栏里找到，而且使用频率也不是非常高。况且，大部分屏幕是长方形的，上下空间有限，左右还比较富余一些，因此去掉它可以省下很大空间。 在菜单栏点击 「view」 –&gt; 「show menu bar」，即可隐藏此排按钮。 5.2 右键粘贴 在Moba及很多终端工具里，都有这样的功能：鼠标左键划选复制文件，右键粘贴文本。但在Moba中右键粘贴功能默认不打开，我们可以手动打开。 在菜单栏点击 「settings」 –&gt; 「Configuration」，在弹出的对话框中选择 「terminal」，再将 「paste using right-click」 打上对勾即可。 5.3 关闭自动弹出SFTP Moba在连接上远程电脑之后，将自动打开左侧的SFTP侧边栏。有时我们并不需要SFTP，同时主窗口是黑色的，SFTP又是白色的，显得有点刺眼，因此可以将自动弹出SFTP功能关闭掉。 在菜单栏点击 「settings」 –&gt; 「Configuration」，在弹出的对话框中选择 「SSH」，再将 「automaticall switch to SSH-browser tab after login」 前面的对勾去掉即可。 6. 小结 本文介绍了三种连接方式：SSH，FTP，serial，以及三个有用的设置。当然Moba的功能远不止这些，但这三种连接方式是最基本，最常用的，因此先拿出来讲。在后续的博文中，将进一步介绍Moba的高级用法，敬请期待！ 本文章转载自知乎 [良许Linux] 本文仅供学习使用 原文链接：https://zhuanlan.zhihu.com/p/56341917 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}],"author":{"name":"良许Linux","url":"https://zhuanlan.zhihu.com/p/56341917"}},{"title":"VS Code配置C/C++环境","slug":"VS Code 配置C、C++环境","date":"2020-03-21T03:17:00.000Z","updated":"2020-04-23T11:40:36.778Z","comments":true,"path":"2020/03/21/VS Code 配置C、C++环境/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/21/VS%20Code%20%E9%85%8D%E7%BD%AEC%E3%80%81C++%E7%8E%AF%E5%A2%83/","excerpt":"","text":"1、安装 VS Code官网下载安装包直接安装即可 https://code.visualstudio.com/ 2、VS Code 插件 C/C++ 彩虹括号 汉化 Include Autocorrelete 3、安装mingw-w64在mingw-w64官网下载64位的mingw-w64离线包 https://sourceforge.net/projects/mingw-w64/files/?source=navbar 根据系统选择合适的安装包进行下载（win10_64位选择如图标签） 可以直接下载文件压缩包(我是下载文件压缩包直接解压就可以用了) 4、配置计算机环境变量PATH我的bin目录是：C:\\mingw64\\bin 把它加到环境变量中的PATH里去 5、重启电脑、检验安装重启电脑后，打开CMD，输入gcc -v查看是否安装正确 输入gcc -v的最后一行输出。版本要和你自己下的对应，例如64位要有x86_64和seh 6、VS Code 配置运行环境打开vscode，选择或新建一个空文件夹目录打开作为项目目录。点击“文件”按钮，再点击“新建文件夹”按钮，并重命名为”.vscode”。在该文件夹内，在点击“新建文件”按钮，建launch.json，settings.json，tasks.json三个.json文件。 launch.json{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"(gdb) Launch\", \"preLaunchTask\": \"build\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${fileDirname}/${fileBasenameNoExtension}.exe\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": true, \"MIMode\": \"gdb\", \"miDebuggerPath\": \"C:/Program Files/mingw-w64/x86_64-8.1.0-release-posix-sjlj-rt_v6-rev0/mingw64/bin/gdb.exe\", // 这里修改GDB路径为安装的mingw64的bin下的gdb.exe路径 \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true, } ] }] } tasks.json{ \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"build\", \"type\": \"shell\", \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"presentation\": { \"echo\": true, \"reveal\": \"always\", \"focus\": false, \"panel\": \"shared\" }, \"windows\": { \"command\": \"g++\", \"args\": [ \"-ggdb\", \"\\\"${file}\\\"\", \"--std=c++11\", \"-o\", \"\\\"${fileDirname}\\\\${fileBasenameNoExtension}.exe\\\"\", \"-finput-charset=UTF-8\",//输入编译器文本编码 默认为UTF-8 \"-fexec-charset=GBK\"//编译器输出文本编码 自行选择 ] } } ] } settings.json// Configuring tasks.json for C/C++ debugging // author: huihut // repo: https://gist.github.com/huihut/887d3c28db92617bd5148c20a5ff112a // Available variables which can be used inside of strings. // ${workspaceRoot}: the root folder of the team // ${file}: the current opened file // ${fileBasename}: the current opened file's basename // ${fileDirname}: the current opened file's dirname // ${fileExtname}: the current opened file's extension // ${cwd}: the current working directory of the spawned process { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"build\", \"type\": \"shell\", \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"presentation\": { \"echo\": true, \"reveal\": \"always\", \"focus\": false, \"panel\": \"shared\" }, \"windows\": { \"command\": \"g++\", \"args\": [ \"-ggdb\", \"\\\"${file}\\\"\", \"--std=c++11\", \"-o\", \"\\\"${fileDirname}\\\\${fileBasenameNoExtension}.exe\\\"\" ] } } ], \"files.autoSave\": \"afterDelay\", \"[c]\": { }, \"files.encoding\": \"utf8\", \"files.autoGuessEncoding\": true, \"explorer.confirmDragAndDrop\": false, \"workbench.colorTheme\": \"Visual Studio Dark\", \"team.showWelcomeMessage\": false } 工作区设置（可选）{ \"C_Cpp.errorSquiggles\": \"Disabled\", \"files.associations\": { \"stdlib.h\": \"c\", \"time.h\": \"c\" } } 7、运行测试代码新建一个文件，run试试 #include &lt;iostream&gt; int main() { std::cout &lt;&lt; \"Hello World!\\n\"; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://melodyjerry.github.io/blog/tags/C-C/"}]},{"title":"蓝桥杯-模拟正整数序列的数量","slug":"蓝桥杯-模拟正整数序列的数量","date":"2020-03-15T06:41:11.000Z","updated":"2020-04-23T11:40:36.819Z","comments":true,"path":"2020/03/15/蓝桥杯-模拟正整数序列的数量/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/15/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%A8%A1%E6%8B%9F%E6%AD%A3%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E9%87%8F/","excerpt":"问题描述 小明想知道，满足以下条件的正整数序列的数量： 1. 第一项为 n； 2. 第二项不超过 n； 3. 从第三项开始，每一项小于前两项的差的绝对值。 请计算，对于给定的 n，有多少种满足条件的序列。","text":"问题描述 小明想知道，满足以下条件的正整数序列的数量： 1. 第一项为 n； 2. 第二项不超过 n； 3. 从第三项开始，每一项小于前两项的差的绝对值。 请计算，对于给定的 n，有多少种满足条件的序列。 输入格式 输入一行包含一个整数 n。 输出格式 输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。 样例输入4 样例输出7 样例说明 以下是满足条件的序列： 4 1 4 1 1 4 1 2 4 2 4 2 1 4 3 4 4 评测用例规模与约定 对于 20% 的评测用例，1 &lt;= n &lt;= 5； 对于 50% 的评测用例，1 &lt;= n &lt;= 10； 对于 80% 的评测用例，1 &lt;= n &lt;= 100； 对于所有评测用例，1 &lt;= n &lt;= 1000。 代码实现import java.util.Scanner; public class Demo8序列 { public static int n=0,count=0; public static int [] []map ; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n =sc.nextInt(); sc.close(); map = new int [n+1][n+1]; for (int i = 1; i &lt;=n; i++) { map[i][i]=1; map[i][0]=1; map[0][i]=1; } for (int i = 1; i &lt;=n; i++) { count+=f(n,i); count%=10000; // System.out.println(count); } System.out.println(count); // System.out.println(f(4,2)); } public static int f(int x,int y){ if(map[x][y]!=0){ return map[x][y]; } for (int i = Math.abs(x-y)-1; i&gt;=0; i--) { map[x][y]+=f(y,i); } map[x][y]%=10000; map[y][x]=map[x][y]; return map[x][y]; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"蓝桥杯-模拟组织晚会","slug":"蓝桥杯-模拟组织晚会","date":"2020-03-15T06:33:11.000Z","updated":"2020-04-23T11:40:36.820Z","comments":true,"path":"2020/03/15/蓝桥杯-模拟组织晚会/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/15/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%A8%A1%E6%8B%9F%E7%BB%84%E7%BB%87%E6%99%9A%E4%BC%9A/","excerpt":"问题描述 小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。 这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。 小明发现，观众对于晚上的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。 小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。","text":"问题描述 小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。 这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。 小明发现，观众对于晚上的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。 小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。 输入格式 输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。 第二行包含 n 个整数，依次为每个节目的好看值。 输出格式 输出一行包含 m 个整数，为选出的节目的好看值。 样例输入5 33 1 2 5 4 样例输出3 5 4 样例说明 选择了第1, 4, 5个节目。 评测用例规模与约定对于 30% 的评测用例，1 &lt;= n &lt;= 20； 对于 60% 的评测用例，1 &lt;= n &lt;= 100； 对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。 代码实现import java.util.ArrayList; import java.util.Arrays; import java.util.Scanner; public class Demo10选节目 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int[] num = new int[n]; int[] order = new int[n]; for (int i = 0; i &lt; n; i++) { num[i] = sc.nextInt(); order[i] = num[i]; } sc.close(); Arrays.sort(order); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for (int i = n - m; i &lt; n; i++) { list.add(order[i]); } StringBuilder sb = new StringBuilder(\"\"); for (int i : num) { if (list.contains(i)) { sb.append(i + \" \"); } } System.out.println(sb); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"蓝桥杯-模拟带九9的数的个数","slug":"蓝桥杯-模拟带九9的数的个数","date":"2020-03-15T06:21:11.000Z","updated":"2020-04-23T11:40:36.818Z","comments":true,"path":"2020/03/15/蓝桥杯-模拟带九9的数的个数/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/15/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%A8%A1%E6%8B%9F%E5%B8%A6%E4%B9%9D9%E7%9A%84%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0/","excerpt":"问题描述 在1至2019中，有多少个数的数位中包含数字9？ 注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算只是算一个数。","text":"问题描述 在1至2019中，有多少个数的数位中包含数字9？ 注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算只是算一个数。 答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 ​ 答案：544 代码实现/** * @Classname Main * @Description 模拟带九9的数的个数 * @Date 2020/3/15 下午 2:21 * @Created by jerry */ public class Main { public static void main(String[] args) { int count=0; A: for (int i = 1; i &lt;=2019; i++) { int a=i; while(a!=0){ int b = a%10; if(b==9){ count++; continue A; } a/=10; } } System.out.println(count); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"蓝桥杯-求一个数的约数个数","slug":"蓝桥杯-求一个数的约数个数","date":"2020-03-15T06:11:11.000Z","updated":"2020-04-23T11:40:36.819Z","comments":true,"path":"2020/03/15/蓝桥杯-求一个数的约数个数/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/15/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0/","excerpt":"问题描述 1200000有多少个约数（只计算正约数）。","text":"问题描述 1200000有多少个约数（只计算正约数）。 答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 答案：96 代码实现import java.io.*; import java.util.*; public class Main{ public static void main(String [] args){ Scanner s=new Scanner(System.in); String sc=s.nextLine(); int num=Integer.valueOf(sc); String ss=s.nextLine(); String []sss=ss.split(\" \"); for(int i=0;i&lt;num;i++){ System.out.println(yueshu(Integer.valueOf(sss[i]))); } } static int yueshu(int a){ int num=0; for(int i=1;i&lt;=Math.sqrt(a);i++){ if(a%i==0){ if(i!=Math.sqrt(a)) num=num+2; else num=num+1; } } return num; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"生成n位的所有二进制数","slug":"生成n位的所有二进制数","date":"2020-03-12T04:14:11.000Z","updated":"2020-04-23T11:40:36.815Z","comments":true,"path":"2020/03/12/生成n位的所有二进制数/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/12/%E7%94%9F%E6%88%90n%E4%BD%8D%E7%9A%84%E6%89%80%E6%9C%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/","excerpt":"需求要求输入位数n，生成所有情况的二进制数并存进数组","text":"需求要求输入位数n，生成所有情况的二进制数并存进数组 实现import java.util.ArrayList; import java.util.List; /** * @Classname BinaryList * @Description 输入位数n，生成所有情况的二进制数并存进数组 * @Date 2020/3/12 上午 11:54 * @Created by MelodyJerry */ public class BinaryList { public static void main(String[] args){ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int n = 4; //二进制位数 int i = 1; for(int j = n; j &gt; 0; j--){ i = i * 2; //对应位权 } for(i = i-1 ; i &gt;= 0; i--){ //System.out.println(i); String bin = Integer.toBinaryString(i); while(bin.length() &lt; n){ bin = \"0\"+bin; } //System.out.println(bin); list.add(bin); } for(String entry : list){ System.out.println(entry); } } } 需求用户输入一个整数，程序输出该数的二进制 实现package org.pcl; import java.util.Scanner; /** * 用户输入一个整数，程序输出该数的二进制 * * @version 1.0 2014-05-05 * @author yifan */ public class OutBinary { public static void main(String[] args) { Scanner scan = new Scanner(System.in); System.out.println(\"请输入一个整数:\"); int number = scan.nextInt(); int tmp = 1&lt;&lt;31; //用于计算的临时变量 System.out.println(); for(int i=0; i&lt;Integer.SIZE-1; i++) { //System.out.print(number &amp;(tmp&gt;&gt;&gt;=1)); System.out.print( (number &amp;(tmp&gt;&gt;&gt;=1))&gt;0? 1:0); } System.out.println(); if(scan != null) { scan.close(); } } } 该实现代码由CSDN博主「yfstdio」提供原文链接：https://blog.csdn.net/yfstdio/article/details/25079563 需求二、八、十六进制输出 实现一、未使用移位运算 public static void main(String[] args) { int a = -17; System.out.println(\"二进制输出\"+Integer.toBinaryString(a)); System.out.println(\"八进制输出\"+Integer.toOctalString(a)); System.out.printf(\"八进制输出\"+\"%010o\\n\",a); //按10位十六进制输出，向右靠齐，左边用0补齐 System.out.printf(\"十六进制输出\"+\"%010x\\n\",a); //按10位八进制输出，向右靠齐，左边用0补齐 System.out.println(\"十六进制输出\"+Integer.toHexString(a)); System.out.println(); int b = 17; System.out.println(\"二进制输出\"+Integer.toBinaryString(b)); System.out.println(\"八进制输出\"+Integer.toOctalString(b)); System.out.printf(\"八进制输出\"+\"%010o\\n\",b); System.out.printf(\"十六进制输出\"+\"%010x\\n\",b); System.out.println(\"十六进制输出\"+Integer.toHexString(b)); } /* 运行结果： 二进制输出11111111111111111111111111101111 八进制输出37777777757 八进制输出37777777757 十六进制输出00ffffffef 十六进制输出ffffffef 二进制输出10001 八进制输出21 八进制输出0000000021 十六进制输出0000000011 十六进制输出11 */ 二、使用移位运算 public static void main(String[] args) { int a = -5; System.out.println(a); System.out.println(\"二进制输出\"+Integer.toBinaryString(a)); System.out.println(a+\"&lt;&lt;2\"+\"=\"+(a&lt;&lt;2)); System.out.println(\"二进制输出\"+Integer.toBinaryString(a&lt;&lt;2)); System.out.println(a+\"&gt;&gt;2\"+\"=\"+(a&gt;&gt;2)); System.out.println(\"二进制输出\"+Integer.toBinaryString(a&gt;&gt;2)); System.out.println(\"无符号右移\"+a+\"&gt;&gt;&gt;2\"+\"=\"+(a&gt;&gt;&gt;2)); System.out.println(\"二进制输出\"+Integer.toBinaryString(a&gt;&gt;&gt;2)); System.out.println(); int b = 5; System.out.println(b); System.out.println(\"二进制输出\"+Integer.toBinaryString(b)); System.out.println(b+\"&lt;&lt;2\"+\"=\"+(b&lt;&lt;2)); System.out.println(\"二进制输出\"+Integer.toBinaryString(b&lt;&lt;2)); System.out.println(b+\"&gt;&gt;2\"+\"=\"+(b&gt;&gt;2)); System.out.println(\"二进制输出\"+Integer.toBinaryString(b&gt;&gt;2)); System.out.println(\"无符号右移\"+b+\"&gt;&gt;&gt;2\"+\"=\"+(b&gt;&gt;&gt;2)); System.out.println(\"二进制输出\"+Integer.toBinaryString(b&gt;&gt;&gt;2)); } /* 运行结果： -5 二进制输出11111111111111111111111111111011 -5&lt;&lt;2=-20 二进制输出11111111111111111111111111101100 -5&gt;&gt;2=-2 二进制输出11111111111111111111111111111110 无符号右移-5&gt;&gt;&gt;2=1073741822 二进制输出111111111111111111111111111110 5 二进制输出101 5&lt;&lt;2=20 二进制输出10100 5&gt;&gt;2=1 二进制输出1 无符号右移5&gt;&gt;&gt;2=1 二进制输出1 */ 左移运算符&lt;&lt; 1、a&lt;&lt;n 将a的二进制数据左移b位，右边移空的部分补0 可以理解为数字a= a2^n（移了n位）。5&lt;&lt;2 –&gt;52^2=20 -5&lt;&lt;2^2=-20 2、a&gt;&gt;n 将a的二进制数据右移b位，如果最高位是0，则左边移空的部分补0，如果最高位是1，则左边移空的部分补1 可以理解为数字a= a/2^n（移了n位），向下取整。5&gt;&gt;2 —&gt; 5/2^2=1; 3、-5&gt;&gt;2 –&gt; -5/2^2=-2 (向下取整) a&gt;&gt;&gt;n 不管最高位是0或1，左边移空部分都补0 正数可以按右移计算，负数没有捷径。 本实现代码由 CSDN博主「qq_36503510」提供原文链接：https://blog.csdn.net/qq_36503510/article/details/83957214 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"和一个人聊天很舒服是什么感觉？","slug":"和一个人聊天很舒服是什么感觉？","date":"2020-03-02T11:58:00.000Z","updated":"2020-03-02T12:35:48.202Z","comments":true,"path":"2020/03/02/和一个人聊天很舒服是什么感觉？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/03/02/%E5%92%8C%E4%B8%80%E4%B8%AA%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%BE%88%E8%88%92%E6%9C%8D%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%9F%E8%A7%89%EF%BC%9F/","excerpt":"说来这文案是有问题的。和一个人聊天很舒服是什么感觉？ 当然是很舒服啊。 我也是不知道当时为什么会这么写。 不过，确实很开心 ——2020.3.2","text":"说来这文案是有问题的。和一个人聊天很舒服是什么感觉？ 当然是很舒服啊。 我也是不知道当时为什么会这么写。 不过，确实很开心 ——2020.3.2 运气 彩 蛋 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"一熟悉的陌生人","slug":"一熟悉的陌生人","date":"2020-02-29T11:26:11.000Z","updated":"2020-03-02T12:35:48.192Z","comments":true,"path":"2020/02/29/一熟悉的陌生人/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/29/%E4%B8%80%E7%86%9F%E6%82%89%E7%9A%84%E9%99%8C%E7%94%9F%E4%BA%BA/","excerpt":"昨晚 和一个女孩在聊天，聊到了很多。聊着聊着，聊到了一些事情让我联想到一些经历。 后来，和她说了一些奇怪的话。想哭，早早结束了一日的聊天，自己静了静。 一觉醒来，却收到了她的另一大段话。看完的那刻，我觉得这是个好女孩。很可爱的女孩。 对她，我不知道如何去定位她。彼此都说了一些奇怪但又是奇妙的话。 硬要是用一个词来形容，我只能想到“熟悉的陌生人”。 陌生是此前从未有过任何交流，熟悉是原来都知道对方还有着很多相似的地方。 这么些天来，对她，心跳有过那么几次起伏跌落。 有那么几个时候觉得她是我想找的那个人，但可能是吧也可能不是…… 于我，生活和情感，是我目前觉得最难的两个了吧。——2020.2.29随笔 选自聊天记录的其中一张","text":"昨晚 和一个女孩在聊天，聊到了很多。聊着聊着，聊到了一些事情让我联想到一些经历。 后来，和她说了一些奇怪的话。想哭，早早结束了一日的聊天，自己静了静。 一觉醒来，却收到了她的另一大段话。看完的那刻，我觉得这是个好女孩。很可爱的女孩。 对她，我不知道如何去定位她。彼此都说了一些奇怪但又是奇妙的话。 硬要是用一个词来形容，我只能想到“熟悉的陌生人”。 陌生是此前从未有过任何交流，熟悉是原来都知道对方还有着很多相似的地方。 这么些天来，对她，心跳有过那么几次起伏跌落。 有那么几个时候觉得她是我想找的那个人，但可能是吧也可能不是…… 于我，生活和情感，是我目前觉得最难的两个了吧。——2020.2.29随笔 选自聊天记录的其中一张 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"HTTP案例：文件下载","slug":"HTTP案例：文件下载","date":"2020-02-24T14:10:12.000Z","updated":"2020-04-23T11:40:36.738Z","comments":true,"path":"2020/02/24/HTTP案例：文件下载/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/24/HTTP%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/","excerpt":"结束HTTP的学习后，记录一份案例学习的笔记。 需求 页面显示超链接 点击超链接后弹出下载提示框 完成图片文件下载","text":"结束HTTP的学习后，记录一份案例学习的笔记。 需求 页面显示超链接 点击超链接后弹出下载提示框 完成图片文件下载 分析 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示。如果不能解析，则弹出下载提示框。不不满足需求。 任何资源都必须弹出下载提示框。 使用响应头设置资源的打开方式： content-disposition:attachment;filename=xxx 步骤一、定义页面，编辑超链接href属性，并指向Servlet，传递资源名称filename 二、定义Servlet 获取文件名称 使用字节输入流加载文件进内存 指定response的响应头： content-disposition:attachment;filename=xxx 将数据写出到response输出流 代码 web下New一个download.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;文件下载&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"/day15/img/1.jpg\"&gt;图片1&lt;/a&gt; &lt;hr&gt; &lt;a href=\"/day15/downloadServlet?filename=1.jpg\"&gt;图片1&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 包cn.itcast.web.download下New一个DownloadServlet.java package cn.itcast.web.download; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.FileInputStream; import java.io.IOException; /** * @Classname DownloadServlet * @Description 文件下载 * @Date 2020/2/24 下午 5:37 * @Created by jerry */ @WebServlet(\"/downloadServlet\") public class DownloadServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求参数，即文件名称 String filename = request.getParameter(\"filename\"); //2.使用字节输入流加载进内存 //2-1.找到文件的服务器路径 ServletContext servletContext = this.getServletContext(); String realPath = servletContext.getRealPath(\"/img/\" + filename);//服务器路径 //2-2.用字节输入流关联 FileInputStream fileInputStream = new FileInputStream(realPath); //3.设置response的响应头 //3-1.设置响应头类型：content-type String minetype = servletContext.getMimeType(filename); response.setHeader(\"content-type\", minetype); //3-2.设置响应头打开方式：content-disposition response.setHeader(\"content-disposition\",\"attachment;filename=\"+filename); //4.将输入流写到输出流中 ServletOutputStream servletOutputStream = response.getOutputStream(); byte[] buff = new byte[1024 * 8]; //作为缓冲区 int lenght = 0; //读取 while ((lenght = fileInputStream.read(buff)) != -1){ //写入 servletOutputStream.write(buff, 0, lenght); } servletOutputStream.close(); //可以不关闭输出流 fileInputStream.close(); //建议关闭输出流，释放资源 } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 演示 思考/分析 中文文件问题 解决思路 获取客户端使用的浏览器版本信息 根据不同的版本信息，设置filename的编码方式不同 详细见 【视频】 ，里面有详解。 ****** 与本笔记相关的资源： 链接: https://pan.baidu.com/s/1q_B3k1LzQwxlslEOdpeDWQ 提取码: dx5u document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"HTTP中的ServletContext对象","slug":"HTTP中的ServletContext对象","date":"2020-02-24T09:08:11.000Z","updated":"2020-04-23T11:40:36.737Z","comments":true,"path":"2020/02/24/HTTP中的ServletContext对象/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/24/HTTP%E4%B8%AD%E7%9A%84ServletContext%E5%AF%B9%E8%B1%A1/","excerpt":"ServletContext对象 ServletContext对象范围：所有用户所有请求的数据 谨慎使用。所有用户可以操控它，不太安全；而且，它的生命周期长：服务器始到终，存储的数据多了，会造成内存的压力。 概念 代表整个web应用，可以和程序的容器（服务器）来通信（交互数据） 获取 通过request对象获取 调用request.getServletContext(); 通过HttpServlet获取 调用this.getServletContext(); 注意：2个调用方法获取到的ServletContext都是一样的。因此，更多的时候会使用this.getServletContext(); 功能 获取mine类型 域对象：共享数据 获取文件的真实路径(服务器路径)","text":"ServletContext对象 ServletContext对象范围：所有用户所有请求的数据 谨慎使用。所有用户可以操控它，不太安全；而且，它的生命周期长：服务器始到终，存储的数据多了，会造成内存的压力。 概念 代表整个web应用，可以和程序的容器（服务器）来通信（交互数据） 获取 通过request对象获取 调用request.getServletContext(); 通过HttpServlet获取 调用this.getServletContext(); 注意：2个调用方法获取到的ServletContext都是一样的。因此，更多的时候会使用this.getServletContext(); 功能 获取mine类型 域对象：共享数据 获取文件的真实路径(服务器路径) Demopackage cn.itcast.web.servletcontext; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/servletContextDemo1\") public class ServletContextDemo1 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext对象获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext(); */ //1. 通过request对象获取 ServletContext context1 = request.getServletContext(); //2. 通过HttpServlet获取 ServletContext context2 = this.getServletContext(); System.out.println(context1); System.out.println(context2); System.out.println(context1 == context2);//true } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 控制台输出👇 1.获取mine类型 格式：大类型/小类型 比如，text/html 、 image/jpeg 等等 mine类型 在互联网通信过程中定义的一种文件数据类型 调用方法 String getMimeType(String file) Demopackage cn.itcast.web.servletcontext; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/servletContextDemo2\") public class ServletContextDemo2 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext功能： 1. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) 2. 域对象：共享数据 3. 获取文件的真实(服务器)路径 */ //2. 通过HttpServlet获取 ServletContext context = this.getServletContext(); //3. 定义文件名称 String filename = \"a.jpg\";//image/jpeg //4.获取MIME类型 String mimeType = context.getMimeType(filename); System.out.println(mimeType); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 2.域对象 共享数据 ServletContext对象范围：所有用户所有请求的数据 调用方法 设置数据 setAttribute(String name,Object value) 获取数据 getAttribute(String name) removeAttribute(String name) DemoServletContextDemo3.java package cn.itcast.web.servletcontext; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/servletContextDemo3\") public class ServletContextDemo3 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext功能： 1. 获取MIME类型： 2. 域对象：共享数据 3. 获取文件的真实(服务器)路径 */ //2. 通过HttpServlet获取 ServletContext context = this.getServletContext(); //设置数据 context.setAttribute(\"msg\",\"haha\"); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } ServletContextDemo4.java package cn.itcast.web.servletcontext; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/servletContextDemo4\") public class ServletContextDemo4 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext功能： 1. 获取MIME类型： 2. 域对象：共享数据 3. 获取文件的真实(服务器)路径 */ //2. 通过HttpServlet获取 ServletContext context = this.getServletContext(); //获取数据 Object msg = context.getAttribute(\"msg\"); System.out.println(msg); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 3.获取文件的真实路径(服务器路径) 调用方法 String getRealPath(String path) Demopackage cn.itcast.web.servletcontext; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.File; import java.io.IOException; @WebServlet(\"/servletContextDemo5\") public class ServletContextDemo5 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* ServletContext功能： 1. 获取MIME类型： 2. 域对象：共享数据 3. 获取文件的真实(服务器)路径 */ // 通过HttpServlet获取 ServletContext context = this.getServletContext(); // 获取文件的服务器路径 String b = context.getRealPath(\"/b.txt\");//工作空间(IDEA)web目录下资源访问 System.out.println(b); // File file = new File(realPath); String c = context.getRealPath(\"/WEB-INF/c.txt\");//工作空间(IDEA)WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(\"/WEB-INF/classes/a.txt\");//工作空间(IDEA)src目录下的资源访问 System.out.println(a); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 项目空间、工作空间的区别：视频 进度条【04:52】 注意： 将来配置文件/资源文件的放置的路径不一样，要会写路径的字符串写法。 src目录的资源路径可以使用ClassLoader（类加载器，不能获取web目录的路径） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"热部署-IDEA实现不用重启Tomcat服务便可自动更新","slug":"热部署-IDEA实现不用重启Tomcat服务便可自动更新","date":"2020-02-24T06:36:53.000Z","updated":"2020-04-23T11:40:36.816Z","comments":true,"path":"2020/02/24/热部署-IDEA实现不用重启Tomcat服务便可自动更新/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/24/%E7%83%AD%E9%83%A8%E7%BD%B2-IDEA%E5%AE%9E%E7%8E%B0%E4%B8%8D%E7%94%A8%E9%87%8D%E5%90%AFTomcat%E6%9C%8D%E5%8A%A1%E4%BE%BF%E5%8F%AF%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/","excerpt":"Tomcat的热部署👇 一、配置Tomcat的Deployment处的“+”的Artifacts是war exploded形式： _:war exploded 作用：展开部署(相当于将资源文件进行展开后进行部署)_:war 作用：发布模式,这是先打成war包,再部署 二、修改Run/Debug Configurations On ‘Update’ Action：update class and resources On frame deactivation：update class and resources 三、浏览器F12，勾选上disable cache 四、以上都不行，那就到Plugins安装JRebel插件","text":"Tomcat的热部署👇 一、配置Tomcat的Deployment处的“+”的Artifacts是war exploded形式： _:war exploded 作用：展开部署(相当于将资源文件进行展开后进行部署)_:war 作用：发布模式,这是先打成war包,再部署 二、修改Run/Debug Configurations On ‘Update’ Action：update class and resources On frame deactivation：update class and resources 三、浏览器F12，勾选上disable cache 四、以上都不行，那就到Plugins安装JRebel插件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"IDEA设置方法参数列表类型自动提示","slug":"IDEA设置方法参数列表类型自动提示","date":"2020-02-23T14:36:53.000Z","updated":"2020-04-23T11:40:36.758Z","comments":true,"path":"2020/02/23/IDEA设置方法参数列表类型自动提示/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/23/IDEA%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA/","excerpt":"期望有这样的参数列表提示👇 File-Settings打开设置(或者ctrl +Alt+S)👇","text":"期望有这样的参数列表提示👇 File-Settings打开设置(或者ctrl +Alt+S)👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"Druid的配置及连接","slug":"Druid的配置及连接","date":"2020-02-23T09:36:53.000Z","updated":"2020-08-27T05:55:24.098Z","comments":true,"path":"2020/02/23/Druid的配置及连接/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/23/Druid%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%BF%9E%E6%8E%A5/","excerpt":"Druid介绍DRUID是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池(据说是目前最好的连接池,不知道速度有没有BoneCP快)。","text":"Druid介绍DRUID是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池(据说是目前最好的连接池,不知道速度有没有BoneCP快)。 配置参数和其它连接池一样DRUID的DataSource类为：com.alibaba.druid.pool.DruidDataSource，基本配置参数如下： 配置 缺省值 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-“ + System.identityHashCode(this) jdbcUrl 连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1) Destroy线程会检测连接的间隔时间2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 更多参考：http://www.cnblogs.com/wuyun-blog/p/5679073.html 使用 配置文件:application.properties DataSource连接参数 url=jdbc:mysql://localhost:3306/dbtest?autoReconnect=true&amp;useSSL=true driverClassName=com.mysql.jdbc.Driver username=root password=mysql filters=stat maxActive=20 initialSize=1 maxWait=60000 minIdle=10 maxIdle=15 validationQuery=SELECT 'x' testWhileIdle=true testOnBorrow=false testOnReturn=false timeBetweenEvictionRunsMillis=600000 minEvictableIdleTimeMillis=300000 maxOpenPreparedStatements=20 removeAbandoned=true removeAbandonedTimeout=1800 logAbandoned=true 最主要的是前四行 jdbc.driverClassName=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://127.0.0.1:3306/dbtest jdbc.username=root jdbc.password=mysql 连接private static DruidDataSource ds = null; static { // 初始化连接池 try{ ResourceBundle res = ResourceBundle.getBundle(\"jdbc\"); ds = new DruidDataSource(); ds.setUrl(res.getString(\"url\")); ds.setDriverClassName(res.getString(\"driverClassName\")); ds.setUsername(res.getString(\"username\")); ds.setPassword(res.getString(\"password\")); ds.setFilters(res.getString(\"filters\")); ds.setMaxActive(Integer.parseInt(res.getString(\"maxActive\"))); ds.setInitialSize(Integer.parseInt(res.getString(\"initialSize\"))); ds.setMaxWait(Integer.parseInt(res.getString(\"maxWait\"))); ds.setMinIdle(Integer.parseInt(res.getString(\"minIdle\"))); //ds.setMaxIdle(Integer.parseInt(res.getString(\"maxIdle\"))); ds.setValidationQuery(res.getString(\"validationQuery\")); ds.setTestWhileIdle(Boolean.parseBoolean(res.getString(\"testWhileIdle\"))); ds.setTestOnBorrow(Boolean.parseBoolean(res.getString(\"testOnBorrow\"))); ds.setTestOnReturn(Boolean.parseBoolean(res.getString(\"testOnReturn\"))); ds.setTimeBetweenEvictionRunsMillis(Long.parseLong(res.getString(\"timeBetweenEvictionRunsMillis\"))); ds.setMinEvictableIdleTimeMillis(Long.parseLong(res.getString(\"minEvictableIdleTimeMillis\"))); //ds.setValidationQuery(res.getString(\"validationQuery\")); } catch (SQLException e) { log.error(\"ERROR_001_com.hq.db.Db_初始化连接池失败_line52\"+e.getMessage()); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Druid","slug":"Druid","permalink":"https://melodyjerry.github.io/blog/tags/Druid/"}]},{"title":"BeanUtils的基本使用","slug":"BeanUtils的基本使用","date":"2020-02-23T08:36:53.000Z","updated":"2020-04-23T11:40:36.736Z","comments":true,"path":"2020/02/23/BeanUtils的基本使用/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/23/BeanUtils%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"在《HTTP案例学习：用户登录》的学习中，使用到BeanUtils。 案例中只涉及到封装username、password两个对象，但是实际上的用户登录界面，有十几个数据对象需要封装。 按原来的方式，是非常麻烦的。期望能够一次把所有参数获取到，并且通过一个方法，一次把所有数据封装成一个对象。 BeanUtils，一个工具类，简化数据封装 这里专门挑出来，做一份简单的笔记。 配合【教学视频】、【BeanUtils工具类常用方法】 食用更佳。","text":"在《HTTP案例学习：用户登录》的学习中，使用到BeanUtils。 案例中只涉及到封装username、password两个对象，但是实际上的用户登录界面，有十几个数据对象需要封装。 按原来的方式，是非常麻烦的。期望能够一次把所有参数获取到，并且通过一个方法，一次把所有数据封装成一个对象。 BeanUtils，一个工具类，简化数据封装 这里专门挑出来，做一份简单的笔记。 配合【教学视频】、【BeanUtils工具类常用方法】 食用更佳。 我们将原来写的代码， //2.获取请求参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); 使用BeanUtils工具类进行封装， //2.获取所有请求参数 Map&lt;String, String[]&gt; map = req.getParameterMap(); //3.创建User对象 User loginUser = new User(); //3-2.使用BeanUtils封装 try { BeanUtils.populate(loginUser,map); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } 会发现只用简单几行代码就完成了封装，而不用和之前一样分别对每个数据进行封装。 BeanUtils 工具类，简化数据封装 用于封装JavaBean的 JavaBean：标准(简单)的Java类 概念 JavaBean 成员变量 属性：setter和getter方法截取后的产物 例如：getUsername() –&gt; Username–&gt; username（大多数下，名字一样） JavaBean 标准的Java类 一般放在domain等package下 功能 封装数据 要求 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共setter和getter方法 属性 setter和getter方法截取后的产物 例如：getUsername() –&gt; Username–&gt; username（大多数下，名字一样） 调用方法 setProperty() 设置属性值 getProperty() 获取属性值 populate(Object obj, Map map) 将map集合的键值对信息，封装到对应的JavaBean对象中 Demo配合 《HTTP案例学习：用户登录》 ，现在New一个BeanUtils.java package cn.itcast.test; import cn.itcast.domain.User; import org.apache.commons.beanutils.BeanUtils; import org.junit.Test; import java.lang.reflect.InvocationTargetException; public class BeanUtilsTest { @Test public void test(){ User user = new User(); try { BeanUtils.setProperty(user,\"username\",\"zhangsan\"); System.out.println(user); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } 控制台输出： 扩展后来看的一篇博客 【BeanUtils工具类常用方法】，觉得写的很不错，一起记录在这里。 相关资料【教学视频】：https://www.bilibili.com/video/av70420291?p=143 【BeanUtils工具类常用方法】：https://blog.csdn.net/wzc1991520/article/details/80176679 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"html中form表单的action路径的写法","slug":"html中form表单的action路径的写法","date":"2020-02-23T07:36:53.000Z","updated":"2020-04-23T11:40:36.782Z","comments":true,"path":"2020/02/23/html中form表单的action路径的写法/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/23/html%E4%B8%ADform%E8%A1%A8%E5%8D%95%E7%9A%84action%E8%B7%AF%E5%BE%84%E7%9A%84%E5%86%99%E6%B3%95/","excerpt":"在 《HTTP案例学习：用户登录》 中提及到html中form表单的action路径的写法 是 虚拟目录+Servlet的资源路径 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/day14_test/loginServlet\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码:&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 先记住，日后还会涉及到的。","text":"在 《HTTP案例学习：用户登录》 中提及到html中form表单的action路径的写法 是 虚拟目录+Servlet的资源路径 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/day14_test/loginServlet\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码:&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 先记住，日后还会涉及到的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"}]},{"title":"IDEA添加jar包的三种方式(小结)","slug":"IDEA中单元测试@Test使用","date":"2020-02-23T04:36:53.000Z","updated":"2020-04-23T11:40:36.755Z","comments":true,"path":"2020/02/23/IDEA中单元测试@Test使用/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/23/IDEA%E4%B8%AD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95@Test%E4%BD%BF%E7%94%A8/","excerpt":"相关文章： https://blog.csdn.net/QQljh123456/article/details/81583786","text":"相关文章： https://blog.csdn.net/QQljh123456/article/details/81583786 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"HTTP响应信息数据-Response","slug":"HTTP响应信息数据-Response","date":"2020-02-22T13:15:01.000Z","updated":"2020-04-23T11:40:36.752Z","comments":true,"path":"2020/02/22/HTTP响应信息数据-Response/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/22/HTTP%E5%93%8D%E5%BA%94%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE-Response/","excerpt":"接着前面两篇博文 《HTTP：超文本传输协议》 、 《HTTP请求信息数据 - Request》 的学习。 现在记录关于 HTTP响应信息数据-Response 的笔记。 响应信息数据 格式 Servlet类中service()方法的参数ServletResponse Response在一次响应结束后，自动被销毁，其输出流也会自动被关闭。 字符串数据，比如： HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt;","text":"接着前面两篇博文 《HTTP：超文本传输协议》 、 《HTTP请求信息数据 - Request》 的学习。 现在记录关于 HTTP响应信息数据-Response 的笔记。 响应信息数据 格式 Servlet类中service()方法的参数ServletResponse Response在一次响应结束后，自动被销毁，其输出流也会自动被关闭。 字符串数据，比如： HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; 响应行 格式：协议/版本 响应状态码 状态码描述 响应状态码 服务器告诉客户端浏览器本次请求和响应的一个状态。 特点 状态码都是3位数字 分类 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx状态码 2xx：成功。代表： 200 3xx：重定向。代表： 302：重定向 304：访问缓存 4xx：客户端错误。代表： 403：错误是一种在网站访问过程中，常见的错误提示，表示资源不可用。服务器理解客户的请求，但拒绝处理它，通常由于服务器上文件或目录的权限设置导致的WEB访问错误。 404：请求路径没有对应的资源 405：请求方式没有对应的doXxx方法 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头 格式：响应头名称 ：值 常见的响应头 Content-Type Content-disposition Content-Type 服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition 服务器告诉客户端以什么格式打开响应体数据 其值： in-line：默认值，在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体。涉及文件下载等功能。 响应空行 就是一个空行（空白行） 作用：分割响应头和响应体 响应体 传输的数据 文件、HTML网页源码等等。比如， &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; 案例1：重定向 重定向：资源跳转的方式 步骤 ResponseDemo1.java package cn.itcast.web.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * 重定向 */ @WebServlet(\"/responseDemo1\") public class ResponseDemo1 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo1........\"); //访问/responseDemo1，会自动跳转到/responseDemo2资源 /* //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(\"location\",\"/day15/responseDemo2\");*/ //演示，不能使用request对象来共享数据 request.setAttribute(\"msg\",\"response\"); //动态获取虚拟目录 String contextPath = request.getContextPath(); //简单的重定向方法 response.sendRedirect(contextPath+\"/responseDemo2\"); //response.sendRedirect(\"http://www.itcast.cn\"); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } ResponseDemo2.java package cn.itcast.web.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/responseDemo2\") public class ResponseDemo2 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo2222222........\"); //演示，不能使用request对象来共享数据 Object msg = request.getAttribute(\"msg\"); System.out.println(msg); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 演示： 特点 重定向的特点：redirect 地址栏发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。不能使用request对象来共享数据 转发的特点：forward 转发地址栏路径不变 转发只能访问当前服务器下的资源 转发是一次请求，可以使用request对象来共享数据 forward 和 redirect 区别 路径写法分类 相对路径 绝对路径 相对路径 通过相对路径不可以确定唯一资源 如：./index.html 不以/开头，以.开头路径 规则 找到当前资源和目标资源之间的相对位置关系 ./：当前目录 ../：后退一级目录 绝对路径(JSP时推荐使用) 通过绝对路径可以确定唯一资源 如：http://localhost/day15/responseDemo2 中 /day15/responseDemo2 以/开头的路径 JSP时推荐使用 规则 判断定义的路径是给谁用的？判断请求将来从哪儿发出 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) 建议动态获取虚拟目录：request.getContextPath() 重定向是客户端浏览器进行的 &lt;a&gt;、 &lt;form&gt;等要重定向… 给服务器使用：不需要加虚拟目录 比如：转发时的路径request.getRequestDispatcher(\"/responseDemo2\").forward(request,response); 案例2：服务器输出字符数据到浏览器步骤 获取字符输出流 输出数据 演示 ResponseDemo4.java package cn.itcast.web.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @WebServlet(\"/responseDemo4\") public class ResponseDemo4 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取流对象之前，设置流的默认编码：ISO-8859-1 设置为：GBK // response.setCharacterEncoding(\"utf-8\"); //告诉浏览器，服务器发送的消息体数据的编码。建议浏览器使用该编码解码 //response.setHeader(\"content-type\",\"text/html;charset=utf-8\"); //简单的形式，设置编码 response.setContentType(\"text/html;charset=utf-8\"); //1.获取字符输出流 PrintWriter pw = response.getWriter(); //2.输出数据 pw.write(\"&lt;h1&gt;hello response&lt;/h1&gt;\"); pw.write(\"&lt;br&gt;你好啊啊啊 response\"); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 演示 注意乱码问题(编解码问题) PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 设置该流的默认编码 告诉浏览器响应体使用的编码 简单的形式，设置编码，是在获取流之前设置 response.setContentType(\"text/html;charset=utf-8\"); Demo上面ResponseDemo4.java文件中 //获取流对象之前，设置流的默认编码：ISO-8859-1 设置为：GBK // response.setCharacterEncoding(\"utf-8\"); //告诉浏览器，服务器发送的消息体数据的编码。建议浏览器使用该编码解码 //response.setHeader(\"content-type\",\"text/html;charset=utf-8\"); //简单的形式，设置编码 response.setContentType(\"text/html;charset=utf-8\"); 案例3：服务器输出字节数据到浏览器步骤 获取字符输出流 输出数据 演示 ResponseDemo5.java package cn.itcast.web.servlet; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/responseDemo5\") public class ResponseDemo5 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\"text/html;charset=utf-8\"); //1.获取字节输出流 ServletOutputStream sos = response.getOutputStream(); //2.输出数据 sos.write(\"你好\".getBytes(\"utf-8\")); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 演示 案例4：验证码 本质：图片 目的：防止恶意表单注册 步骤 创建一对象，在内存中代表一个图片（验证码图片对象） 美化图片 将图片输出到页面展示 演示 New一个CheckCode.java package cn.itcast.web.servlet; import javax.imageio.ImageIO; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.awt.image.BufferedImage; import java.io.IOException; /** * @Classname CheckCode * @Description TODO * @Date 2020/2/23 下午 10:20 * @Created by jerry */ @WebServlet(\"/checkCodeServlet\") public class CheckCode extends HttpServlet { @Override protected void doPost(HttpServletRequest requeste, HttpServletResponse response) throws ServletException, IOException { int width = 100; int height = 50; //1.创建一对象，在内存中代表一个图片（验证码图片对象） BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2. 美化图片 //3.将图片输出到页面展示 ImageIO.write(image, \"jpg\", response.getOutputStream()); } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 没有美化前 美化图片 package cn.itcast.web.servlet; import javax.imageio.ImageIO; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.awt.*; import java.awt.image.BufferedImage; import java.io.IOException; import java.util.Random; /** * 验证码 */ @WebServlet(\"/checkCodeServlet\") public class CheckCode extends HttpServlet { @Override protected void doPost(HttpServletRequest requeste, HttpServletResponse response) throws ServletException, IOException { int width = 100; int height = 50; //1.创建一对象，在内存中代表一个图片（验证码图片对象） BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2. 美化图片 //2-1.填充背景色 Graphics g = image.getGraphics(); //画笔对象，可画/填充 g.setColor(Color.pink); //设置画笔颜色 g.fillRect(0,0,width,height); //g.fill3DRect(0, 0, width, height, true); //2-2.画边框 g.setColor(Color.BLUE); g.drawRect(0, 0, width-1, height-1); //2-3.随机字符（全部） String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789\"; //生产随机角标 Random ran = new Random(); //2-3.写验证码 for (int i = 1; i &lt;= 4; i++) { int index = ran.nextInt(str.length()); //获取字符 char ch = str.charAt(index); //随机字符 //写入字符 g.drawString(ch+\"\", width/5*i , height/2); } /*g.drawString(\"a\", 20, 25); g.drawString(\"2\", 33, 15); g.drawString(\"4\", 72, 35); g.drawString(\"g\", 80, 20);*/ //2-4.画出干扰线 g.setColor(Color.green); //随机生成坐标点 for (int i = 0; i &lt; 10; i++) { int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1, y1, x2, y2); } //3.将图片输出到页面展示 ImageIO.write(image, \"jpg\", response.getOutputStream()); } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 美化后 在页面中配合注册表单等使用验证码 点击超链接或图片后，直接加载随机验证码 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;验证码&lt;/title&gt; &lt;script&gt; /**分析： * 点击超链接/图片，需要换一张 * 1.给超链接/图片绑定单击事件 * 2.重新设置图片的src属性值 */ window.onload = function () { //1.获取图片对象 var img = document.getElementById(\"checkCode\"); var a = document.getElementById(\"change\"); //2.绑定单击事件 img.onclick = function () { //获取时间戳 var date = new Date().getTime(); //毫秒值 //利用时间戳，浏览器访问就一定不会去访问缓存了。每一时刻的链接都是不一样的。 img.src = \"/day15/checkCodeServlet?\" + date; } a.onlick = function () { var date = new Date().getTime(); a.href = \"/day15/checkCodeServlet?\" + date; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=\"checkCode\" src=\"/day15/checkCodeServlet\" /&gt;&lt;br&gt; &lt;a id=\"change\" href=\"\"&gt;看不清，换一张？&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 演示 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"创建@Test测试Druid连接池时的问题","slug":"创建@Test测试Druid连接池时的问题","date":"2020-02-22T12:55:12.000Z","updated":"2020-04-23T11:40:36.798Z","comments":true,"path":"2020/02/22/创建@Test测试Druid连接池时的问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/22/%E5%88%9B%E5%BB%BA@Test%E6%B5%8B%E8%AF%95Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"记录学习 《HTTP案例学习：用户登录》 时候遇到的一些问题","text":"记录学习 《HTTP案例学习：用户登录》 时候遇到的一些问题 IDEA run之后，控制台输出一堆问题： 二月 23, 2020 1:30:34 下午 com.alibaba.druid.pool.DruidDataSource error 严重: init datasource error com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server. 二月 23, 2020 1:30:34 下午 com.alibaba.druid.pool.DruidDataSource error 严重: dataSource init error 二月 23, 2020 1:30:34 下午 com.alibaba.druid.pool.DruidDataSource info 信息: {dataSource-1} inited 我估计是MySQL版本的问题，因为从我开始学习MySQL来安装的是8.0，学习期间就遇到很多问题，不过都能逐一解决。 但是这次我果断直接降级到5.7。 不过，降级后还是被提示错误 二月 23, 2020 2:41:58 下午 com.alibaba.druid.pool.DruidDataSource info 信息: {dataSource-1} inited 二月 23, 2020 2:41:58 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions 信息: Loading XML bean definitions from class path resource [org/springframework/jdbc/support/sql-error-codes.xml] 二月 23, 2020 2:41:58 下午 org.springframework.jdbc.support.SQLErrorCodesFactory &lt;init&gt; 信息: SQLErrorCodes loaded: [DB2, Derby, H2, HSQL, Informix, MS-SQL, MySQL, Oracle, PostgreSQL, Sybase, Hana] ...................................... org.springframework.dao.EmptyResultDataAccessException: Incorrect result size: expected 1, actual 0 at org.springframework.dao.support.DataAccessUtils.requiredSingleResult(DataAccessUtils.java:74) at org.springframework.jdbc.core.JdbcTemplate.queryForObject(JdbcTemplate.java:777) at cn.itcast.Dao.UserDao.login(UserDao.java:25) at cn.itcast.test.UserDaoTest.testLogin(UserDaoTest.java:23) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Process finished with exit code -1 分析了信息: SQLErrorCodes loaded: [DB2, Derby, H2, HSQL, Informix, MS-SQL, MySQL, Oracle, PostgreSQL, Sybase, Hana]， 信息是提示sql语句错了。 仔细检查一下sql语句，单纯的去 cmd 中用自己的sql语句执行一下检查问题。 果然是sql语句的问题。 剩下的错误提示，是数据库的字段的问题。 //正确 loginuser.setUsername(\"superbaby\"); //错误，字段少了个y loginuser.setUsername(\"superbab\"); 再次run，这次得到如期的结果。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Druid","slug":"Druid","permalink":"https://melodyjerry.github.io/blog/tags/Druid/"}]},{"title":"HTTP案例学习：用户登录&验证码","slug":"HTTP案例学习：用户登录&验证码","date":"2020-02-22T12:44:12.000Z","updated":"2020-04-23T11:40:36.753Z","comments":true,"path":"2020/02/22/HTTP案例学习：用户登录&验证码/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/22/HTTP%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95&%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"本笔记包括两个案例，分别是用户登录、验证码。","text":"本笔记包括两个案例，分别是用户登录、验证码。 案例：用户登录接着 《HTTP：超文本传输协议》 、 《HTTP请求信息数据 - Request》 的学习，现在记录一份案例学习。 用户需求 编写 login.html 登录页面，并且有 username &amp; password 两个输入框 使用 Druid 数据库连接池技术，操作 MySQL，day14数据库中user表 使用 JdbcTemplate 技术封装 JDBC 登录成功跳转到 SuccessServlet 展示：登录成功！用户名,欢迎您 登录失败跳转到 FailServlet 展示：登录失败，用户名或密码错误 分析 步骤 创建项目，导入html页面，配置文件，jar包 创建数据库环境 创建包cn.itcast.domain,创建类User 创建包cn.itcast.util,编写工具类JDBCUtils 创建包cn.itcast.dao,创建类UserDao,提供login方法 编写cn.itcast.web.servlet.LoginServlet类 编写FailServlet和SuccessServlet类 BeanUtils工具类，简化数据封装 一、创建项目，导入html页面，配置文件，jar包 新建Module web文件夹下创建login.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/day14_test/loginServlet\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码:&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 这里的login.html中form表单的action路径的写法：虚拟目录+Servlet的资源路径是虚拟目录+Servlet的资源路径 关于 《html中form表单的action路径的写法》 将Druid配置文件druid.properties导入到src文件下 driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql:///day14 username=root password=root initialSize=5 maxActive=10 maxWait=3000 导入jar包到Web的WEB-INF文件中 在项目的web文件夹下创建文件夹WEB-INF，将lib文件夹粘贴进去 并把jar包加入到工作空间里 二、创建数据库环境 打开Navicat，创建数据库和数据表 CREATE DATABASE day14; USE day14; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL ); 插入一条记录 三、创建包cn.itcast.domain,创建类User 右键项目的src文件，New一个包cn.itcast.domain 在包下，New一个User.java package cn.itcast.domain; /** * 用户的实体类 */ public class User { private int id; private String username; private String password; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } 四、创建包cn.itcast.util,编写工具类JDBCUtils New一个包cn.itcast.util New一个JDBCUtils.java package cn.itcast.util; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.ConnectionEvent; import javax.sql.DataSource; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; /** * JDBC的工具类 使用Durid连接池 */ public class JDBCUtils { private static DataSource ds; static { try { //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\"); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static DataSource getDataSource(){ return ds; } /** * 获取连接池Connection对象 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } } 五、创建包cn.itcast.dao,创建类UserDao,提供login方法 New一个包cn.itcast.dao New一个UserDao.java package cn.itcast.Dao; import cn.itcast.domain.User; import cn.itcast.util.JDBCUtils; import com.alibaba.druid.util.JdbcUtils; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; /** * 操作数据库中User表的类 */ public class UserDao { // 声明JDBCTemplate对象公用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return User包含用户全部数据；没有查询到，返回null */ public User login(User loginUser) { try { //1.编写SQL String sql = \"select * from user where username = ? and password = ?\"; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; } catch (DataAccessException e) { e.printStackTrace(); // 记录日志，后期写入文件里，不会总在控制台打印 return null; } } } 测试一下UserDao New一个包cn.itcast.test，New一个UserDaoTest.java package cn.itcast.test; import cn.itcast.Dao.UserDao; import cn.itcast.domain.User; import org.junit.Test; /** * @Classname UserDaoTest * @Description TODO * @Date 2020/2/23 下午 1:00 * @Created by jerry */ public class UserDaoTest { @Test public void testLogin(){ User loginuser = new User(); loginuser.setUsername(\"superbaby\"); loginuser.setPassword(\"123\"); UserDao dao = new UserDao(); User user = dao.login(loginuser); System.out.println(user); } } run后，控制台输出 这个@Test部分，遇到了一些问题，就顺便记录在《创建@Test测试Druid连接池时的问题》 里面。 六、编写cn.itcast.web.servlet.LoginServlet类 New一个包cn.itcast.web.servlet New一个LoginServlet.java package cn.itcast.web.servlet; import cn.itcast.Dao.UserDao; import cn.itcast.domain.User; import cn.itcast.test.UserDaoTest; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/loginServlet\") public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.设置编码 req.setCharacterEncoding(\"utf-8\"); //2.获取请求参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(\"username\"); loginUser.setPassword(\"password\"); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //真正获取到的user //5.判断user if(user == null){ //登录失败 req.getRequestDispatcher(\"/failServlet\").forward(req,resp); //转发 }else{ //登录成功 //存储数据 req.setAttribute(\"user\",user); //转发 req.getRequestDispatcher(\"/successServlet\").forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } 七、编写FailServlet和SuccessServlet类 New一个FailServlet.java package cn.itcast.web.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * @Classname failServlet * @Description TODO * @Date 2020/2/23 下午 3:38 * @Created by jerry */ @WebServlet(\"/failServlet\") public class FailServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //给页面写一句话 //设置页面编码 response.setContentType(\"text/html;charset=utf-8\"); //输出 response.getWriter().write(\"登录失败，用户名或密码错误\"); } } New一个SuccessServlet.java package cn.itcast.web.servlet; import cn.itcast.domain.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * @Classname successServlet * @Description TODO * @Date 2020/2/23 下午 3:38 * @Created by jerry */ @WebServlet(\"/successServlet\") public class SuccessServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取request域中共享的user对象 User user = (User) request.getAttribute(\"user\"); if(user != null){ //给页面写一句话 //设置页面编码 response.setContentType(\"text/html;charset=utf-8\"); //输出 response.getWriter().write(\"登录失败，用户名或密码错误\"); } } } 八、测试浏览器访问：http://localhost/day14_test/login.html 九、BeanUtils工具类，简化数据封装 在LoginServlet.java中使用BeanUtils工具类 package cn.itcast.web.servlet; import cn.itcast.Dao.UserDao; import cn.itcast.domain.User; import cn.itcast.test.UserDaoTest; import org.apache.commons.beanutils.BeanUtils; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.util.Map; @WebServlet(\"/loginServlet\") public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.设置编码 req.setCharacterEncoding(\"utf-8\"); /*//2.获取请求参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password);*/ //2.获取所有请求参数 Map&lt;String, String[]&gt; map = req.getParameterMap(); //3.创建User对象 User loginUser = new User(); //3-2.使用BeanUtils封装 try { BeanUtils.populate(loginUser,map); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //真正获取到的user //5.判断user if(user == null){ //登录失败 req.getRequestDispatcher(\"/failServlet\").forward(req,resp); //转发 }else{ //登录成功 //存储数据 req.setAttribute(\"user\",user); //转发 req.getRequestDispatcher(\"/successServlet\").forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } 关于BeanUtils的更多使用，看下一篇笔记《BeanUtils的基本使用》 。 与本笔记相关的资源： 链接: https://pan.baidu.com/s/1pV1ArOotLcoH9mKYABEm5g 提取码: w9h8 案例：验证码接着 《JSP&amp;Cookie&amp;Session技术》 的学习， 现在记录一份案例的学习。 用户需求 访问带有验证码的登录页面login.jsp 用户输入用户名，密码以及验证码， 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 如果验证码输入有误，跳转登录页面，提示：验证码错误 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 分析 设置request编码 获取参数 获取生成的验证码 将用户信息封装到User对象 判断程序生成的验证码和用户输入的验证码是否一致。从session中获取程序生成的验证码 一致：再判断用户名和密码是否正确 正确： 1.登陆成功 2.存储数据到session中 3.跳转（重定向）到success.jsp 不正确： 1.给提示信息：用户名或密码错误 2.跳转（转发）到登录页面 不一致： 1.给用户提示信息：验证码错误 2.存储提示信息到request 3.跳转（转发）到登录页面 login.jsp显示错误信息，从request域中获取 CodeCheckCodeServlet.javapackage cn.itcast.servlet; import javax.imageio.ImageIO; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.awt.*; import java.awt.image.BufferedImage; import java.io.IOException; import java.util.Random; @WebServlet(\"/checkCodeServlet\") public class CheckCodeServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { int width = 100; int height = 50; //1.创建一对象，在内存中图片(验证码图片对象) BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2.美化图片 //2.1 填充背景色 Graphics g = image.getGraphics();//画笔对象 g.setColor(Color.PINK);//设置画笔颜色 g.fillRect(0,0,width,height); //2.2画边框 g.setColor(Color.BLUE); g.drawRect(0,0,width - 1,height - 1); String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789\"; //生成随机角标 Random ran = new Random(); StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt;= 4; i++) { int index = ran.nextInt(str.length()); //获取字符 char ch = str.charAt(index);//随机字符 sb.append(ch); //2.3写验证码 g.drawString(ch+\"\",width/5*i,height/2); } String checkCode_session = sb.toString(); //将验证码存入session request.getSession().setAttribute(\"checkCode_session\",checkCode_session); //2.4画干扰线 g.setColor(Color.GREEN); //随机生成坐标点 for (int i = 0; i &lt; 10; i++) { int x1 = ran.nextInt(width); int x2 = ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1,y1,x2,y2); } //3.将图片输出到页面展示 ImageIO.write(image,\"jpg\",response.getOutputStream()); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } login.jsp&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;!--点击刷新验证码--&gt; &lt;script&gt; window.onload = function(){ document.getElementById(\"img\").onclick = function(){ this.src=\"/day16/checkCodeServlet?time=\"+new Date().getTime(); } } &lt;/script&gt; &lt;style&gt; div{ color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/day16/loginServlet\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"checkCode\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;img id=\"img\" src=\"/day16/checkCodeServlet\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;input type=\"submit\" value=\"登录\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;div&gt;&lt;%=request.getAttribute(\"cc_error\") == null ? \"\" : request.getAttribute(\"cc_error\")%&gt;&lt;/div&gt; &lt;div&gt;&lt;%=request.getAttribute(\"login_error\") == null ? \"\" : request.getAttribute(\"login_error\") %&gt;&lt;/div&gt; &lt;!-- 等同于 EL表达式。有信息就打印输出，没有就显示空字符串。 ${requestScope.cc_error} ${requestScope.login.error} --&gt; &lt;/body&gt; &lt;/html&gt; LoginServlet.javapackage cn.itcast.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; @WebServlet(\"/loginServlet\") public class LoginServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.设置request编码 request.setCharacterEncoding(\"utf-8\"); //2.获取参数 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); String checkCode = request.getParameter(\"checkCode\"); //3.先获取生成的验证码 HttpSession session = request.getSession(); String checkCode_session = (String) session.getAttribute(\"checkCode_session\"); //删除session中存储的验证码 session.removeAttribute(\"checkCode_session\"); //3.先判断验证码是否正确 if(checkCode_session!= null &amp;&amp; checkCode_session.equalsIgnoreCase(checkCode)){ //忽略大小写比较 //验证码正确 //判断用户名和密码是否一致 if(\"zhangsan\".equals(username) &amp;&amp; \"123\".equals(password)){//需要调用UserDao查询数据库 //登录成功 //存储信息，用户信息 session.setAttribute(\"user\",username); //重定向到success.jsp response.sendRedirect(request.getContextPath()+\"/success.jsp\"); }else{ //登录失败 //存储提示信息到request request.setAttribute(\"login_error\",\"用户名或密码错误\"); //转发到登录页面 request.getRequestDispatcher(\"/login.jsp\").forward(request,response); } }else{ //验证码不一致 //存储提示信息到request request.setAttribute(\"cc_error\",\"验证码错误\"); //转发到登录页面 request.getRequestDispatcher(\"/login.jsp\").forward(request,response); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } success.jsp&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;成功登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%=request.getSession().getAttribute(\"user\")%&gt;,欢迎您&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; Demo 视频详解 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"2020.2.22随笔","slug":"2020.2.22随笔","date":"2020-02-22T09:36:53.000Z","updated":"2020-03-02T12:35:48.151Z","comments":true,"path":"2020/02/22/2020.2.22随笔/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/22/2020.2.22%E9%9A%8F%E7%AC%94/","excerpt":"好久好久，没能有人和我聊着久，聊的这么嗨了。就当做这两天的随笔吧。晚安🌙 ——2020.2.22","text":"好久好久，没能有人和我聊着久，聊的这么嗨了。就当做这两天的随笔吧。晚安🌙 ——2020.2.22 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"HTTP请求信息数据-Request","slug":"HTTP请求信息数据-Request","date":"2020-02-21T12:25:00.000Z","updated":"2020-04-23T11:40:36.757Z","comments":true,"path":"2020/02/21/HTTP请求信息数据-Request/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/21/HTTP%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE-Request/","excerpt":"接着上篇博文 《HTTP：超文本传输协议》 的学习。 现在，来学习两个对象：Request &amp; Response。 request对象和response对象的原理 request和response对象是由服务器创建的。接着我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 其基本原理，如下图👇 request对象继承体系结构ServletRequest – interface，接口 ↓|继承 HttpServletRequest – interface，接口 ↓|实现 org.apache.catalina.connector.RequestFacade – 类，Tomcat编写的 Tomcat 是用纯Java语言编写的 request功能 基础功能 获取请求消息数据 其他功能： 1.获取请求参数通用方式 2.请求转发 3.共享数据 4.获取ServletContext 获取请求消息数据 获取请求行数据 获取请求头数据 获取请求体数据","text":"接着上篇博文 《HTTP：超文本传输协议》 的学习。 现在，来学习两个对象：Request &amp; Response。 request对象和response对象的原理 request和response对象是由服务器创建的。接着我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 其基本原理，如下图👇 request对象继承体系结构ServletRequest – interface，接口 ↓|继承 HttpServletRequest – interface，接口 ↓|实现 org.apache.catalina.connector.RequestFacade – 类，Tomcat编写的 Tomcat 是用纯Java语言编写的 request功能 基础功能 获取请求消息数据 其他功能： 1.获取请求参数通用方式 2.请求转发 3.共享数据 4.获取ServletContext 获取请求消息数据 获取请求行数据 获取请求头数据 获取请求体数据 获取请求消息数据的字符串格式 👇 POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan 一.获取请求行数据GET /day14/demo1?name=zhangsan HTTP/1.1 调用方法（★★重点掌握）： 获取请求方式：GET String getMethod() ★★获取虚拟目录：/day14 String getContextPath() 获取Servlet路径：/demo1 String getServletPath() 获取get方式请求参数：name=zhangsan String getQueryString() 不用这个，以后会用更高级的方式 多个参数之间用&amp;连接 ★★获取请求URI：/day14/demo1 String getRequestURI()：/day14/demo1 StringBuffer getRequestURL()：http://localhost/day14/demo1 URL：统一资源定位符 ： http://localhost/day14/demo1 其地位相当于”中华人民共和国” URI：统一资源标识符，其表示范围更大 ：/day14/demo1 其地位相当于”共和国” 获取协议及版本：HTTP/1.1 String getProtocol() 该方法在Interface ServletRequest中 获取客户机的IP地址： String getRemoteAddr() 该方法在Interface ServletRequest中 示例新建RequestDemo1.java，输入代码👇 可以在新建时候选择创建Servlet，IDEA自动生成相应模板。 import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * 演示Request对象获取请求行数据 */ @WebServlet(\"/RequestDemo1\") public class RequestDemo1 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：/Servlet * String getContextPath() 3. 获取Servlet路径: /requestDemo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (*)获取请求URI：/Servlet/requestDemo1 * String getRequestURI(): /day14/requestDemo1 * StringBuffer getRequestURL() :http://localhost/Servlet/requestDemo1 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() */ //1. 获取请求方式 ：GET String method = request.getMethod(); System.out.println(method); //2.(*)获取虚拟目录：/day14 String contextPath = request.getContextPath(); System.out.println(contextPath); //3. 获取Servlet路径: /demo1 String servletPath = request.getServletPath(); System.out.println(servletPath); //4. 获取get方式请求参数：name=zhangsan String queryString = request.getQueryString(); System.out.println(queryString); //5.(*)获取请求URI：/day14/demo1 String requestURI = request.getRequestURI(); StringBuffer requestURL = request.getRequestURL(); System.out.println(requestURI); System.out.println(requestURL); //6. 获取协议及版本：HTTP/1.1 String protocol = request.getProtocol(); System.out.println(protocol); //7. 获取客户机的IP地址： String remoteAddr = request.getRemoteAddr(); System.out.println(remoteAddr); } } 演示👇 浏览器访问：http://localhost/Servlet/RequestDemo1?name=zhangsan IDEA控制台输出： 二.获取请求头数据Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 调用方法（★★重点掌握）： ★★String getHeader(String name) 通过请求头的名称获取请求头的值 参数不分大小写，只要单词拼写的对即可 Enumeration&lt;String&gt; getHeaderNames() 获取所有的请求头名称 封装成 Enumeration&lt;String&gt; 注意：从JDK1.0开始，该接口的功能由Iterator（迭代器）接口 复制。此外，Iterator还添加了一个可选的删除操作，并且有较短的方法名称。新的实现应该考虑使用迭代器优选于枚举。——JDK 8 文档 示例一、调用Enumeration&lt;String&gt; getHeaderNames()，演示获取所有请求头数据 新建一个Servlet，名为RequestDemo2.java import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.Enumeration; @WebServlet(\"/RequestDemo2\") public class RequestDemo2 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 演示获取请求头数据 // 1.获取所有请求头数据 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); // 2.遍历 while(headerNames.hasMoreElements()){ String name = headerNames.nextElement(); // 根据名称获取请求头的值 String value = request.getHeader(name); System.out.println(name + \"--\" + value); } } } 浏览器访问：http://localhost/Servlet/RequestDemo2 IDEA控制台输出： 二、调用String getHeader(String name)，user-agent、referer 新建一个Servlet，名为RequestDemo3.java import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/RequestDemo3\") public class RequestDemo3 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 演示获取请求头数据：user-agent(客户端版本) // 获取请求头数据：user-agent String agent = request.getHeader(\"user-agent\"); // 判断agent的浏览器版本，可以解决浏览器兼容问题 if(agent.contains(\"Chrome\")) { // 谷歌浏览器 System.out.println(\"谷歌来了。。。\"); } else if (agent.contains(\"Firefox\")) { // 火狐浏览器 System.out.println(\"火狐来了。。。\"); } } } 浏览器访问：http://localhost/Servlet/RequestDemo3 IDEA控制台输出： 注意： 获取请求头数据：user-agent(客户端版本) 判断agent的浏览器版本，可以解决浏览器兼容问题 新建一个Servlet，名为RequestDemo4.java import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/RequestDemo4\") public class RequestDemo4 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 演示请求头数据：referer String referer = request.getHeader(\"referer\"); System.out.println(referer); // http://localhost/Servlet/login.html //防盗链 if(referer != null) { if(referer.contains(\"/Servlet\")) { // 正常访问 System.out.println(\"播放电影。。。\"); /* 等同于，只不过不再是输出到控制台，而是直接打印在页面上 response.setContentType(\"text/html;charset=utf-8\"); response.getWriter.writer(\"播放电影。。。\") */ } else { // 盗链 System.out.println(\"想看电影吗？来优酷吧。。。\"); /* 等同于，只不过不再是输出到控制台，而是直接打印在页面上 response.setContentType(\"text/html;charset=utf-8\"); response.getWriter.writer(\"想看电影吗？来优酷吧。。。\") */ } } } } 新建一个html文件，名为login.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/Servlet/Demo3\" method=\"get\"&gt; &lt;input name=\"username\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;!--加入超链接--&gt; &lt;a href=\"http://localhost/Servlet/RequestDemo4\"&gt;RequestDemo3&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 演示👉获取请求头数据：referer 关于获取referer来防盗链，观看 视频（进度条【10:56】） 三.获取请求体数据username=zhangsan 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 步骤： 获取流对象 获取字符输入流：文字等字符数据 获取字节输入流：上传图片、文件等字节数据 再从流对象中获取数据 调用方法： BufferedReader getReader() 获取字符输入流，只能操作字符数据 返回值是BufferedReader，高效的、带有缓冲区的 该方法在Interface ServletRequest中 ServletInputStream getInputStream() 获取字节输入流，可以操作所有类型数据 但是获取字符时不方便，更推荐用第一个调用方法 返回值是ServletInputStream，继承了InputStream。 涉及到文件上传等知识 该方法在Interface ServletRequest中 示例 新建html文件，名为regist.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/Servlet/RequestDemo5\" method=\"post\"&gt; &lt;input type=\"text\" placeholder=\"请输入用户名\" name=\"username\"&gt;&lt;br&gt; &lt;input type=\"text\" placeholder=\"请输入密码\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 新建一个Servlet，名为RequestDemo5.java import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; @WebServlet(\"/RequestDemo5\") public class RequestDemo5 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取请求消息体--请求参数 //1.获取字符流 BufferedReader br = request.getReader(); //2.读取数据 String line = null; while((line = br.readLine()) != null){ System.out.println(line); } br.close(); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } } 浏览器访问：http://localhost/Servlet/regist.html 控制台输出： 注意：多个参数之间用&amp;连接。 其他功能 获取请求参数通用方式 请求转发 共享数据 一、获取请求参数通用方式 不论GET还是POST请求方式都可以使用下列方法来获取请求参数 上述即，doGet() 和 doPost() 的方法体代码完全一样 因此，为了简化，只需要选择在doPost() 的方法体中写代码，之后在doGet() 中调用 this.doPost(request,response); 调用方法： String getParameter(String name) 根据参数名称获取参数值： username=zs&amp;password=123 String[] getParameterValues(String name) 根据参数名称获取参数值的数组：hobby=xuexi&amp;hobby=game 将键值对，按一个键来封装不同的值并封装成一个数组 多用于复选框 Enumeration&lt;String&gt; getParameterNames() 获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap() 获取所有参数的Map集合 示例 新建regist2.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/Servlet/RequestDemo6\" method=\"post\"&gt; &lt;input type=\"text\" placeholder=\"请输入用户名\" name=\"username\"&gt;&lt;br&gt; &lt;input type=\"text\" placeholder=\"请输入密码\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"checkbox\" name=\"hobby\" value=\"game\"&gt;游戏 &lt;input type=\"checkbox\" name=\"hobby\" value=\"study\"&gt;学习 &lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 新建RequestDemo6.java import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; import java.util.Enumeration; import java.util.Map; import java.util.Set; @WebServlet(\"/RequestDemo6\") public class RequestDemo6 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //post 获取请求参数 //根据参数名称获取参数值 String username = request.getParameter(\"username\"); /* System.out.println(\"post\"); System.out.println(username);*/ //根据参数名称获取参数值的数组 String[] hobbies = request.getParameterValues(\"hobby\"); /*for (String hobby : hobbies) { System.out.println(hobby); }*/ //获取所有请求的参数名称 Enumeration&lt;String&gt; parameterNames = request.getParameterNames(); /*while(parameterNames.hasMoreElements()){ String name = parameterNames.nextElement(); System.out.println(name); String value = request.getParameter(name); System.out.println(value); System.out.println(\"----------------\"); }*/ // 获取所有参数的map集合 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); //遍历 Set&lt;String&gt; keyset = parameterMap.keySet(); for (String name : keyset) { //获取键获取值 String[] values = parameterMap.get(name); System.out.println(name); for (String value : values) { System.out.println(value); } System.out.println(\"-----------------\"); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //get 获取请求参数 /* //根据参数名称获取参数值 String username = request.getParameter(\"username\"); System.out.println(\"get\"); System.out.println(username);*/ this.doPost(request,response); } } 浏览器访问：http://localhost/Servlet/regist2.html 控制台输出： 中文乱码问题 GET方式：tomcat 8 已经将 GET方式乱码问题解决了 POST方式：会乱码 解决：在获取参数前，设置request的编码request.setCharacterEncoding(\"utf-8\"); 。对应着html页面的编码。 二、请求转发 一种在服务器内部的资源跳转方式 特点 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中 转发就是一次请求。像上图的AServlet和BServlet两种资源使用的是同一次请求。 步骤 通过request对象获取请求转发器对象 RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发 forward(ServletRequest request, ServletResponse response) 示例 新建RequestDemo8.java import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/RequestDemo8\") public class RequestDemo8 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"Demo8888被访问了。。。\"); //转发到Demo9资源 /* RequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/RequestDemo9\"); requestDispatcher.forward(request,response); // 一般不这么写，直接写成： request.getRequestDispatcher(\"/RequestDemo9\").forward(request,response); */ //存储数据到request域中 request.setAttribute(\"msg\",\"hello\"); request.getRequestDispatcher(\"/RequestDemo9\").forward(request,response); //没法跳转到外部资源，比如下面这个是不行的 //request.getRequestDispatcher(\"http://www.itcast.cn\").forward(request,response); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 新建RequestDemo9.java import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/RequestDemo9\") public class RequestDemo9 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取数据 Object msg = request.getAttribute(\"msg\"); System.out.println(msg); System.out.println(\"Demo9999也被访问了。。。\"); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 浏览器访问：http://localhost/Servlet/RequestDemo8 控制台输出： 三、共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 调用方法： void setAttribute(String name,Object obj) 存储数据 Object getAttitude(String n ame) 通过键获取值 void removeAttribute(String name) 通过键移除键值对 👉视频 的【03:15】，详细说到 如何共享数据。 示例示例放在 __ 请求转发 的示例 __ 中。 详细见代码文件中的两个注释： RequestDemo8的【// 存储数据到request域中】 RequestDemo9的【// 获取数据】 四、获取ServletContext调用方法： ServletContext getServletContext() 示例 新建RequestDemo10.java import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/RequestDemo10\") public class RequestDemo10 extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ServletContext servletContext = request.getServletContext(); System.out.println(servletContext); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 浏览器访问：http://localhost/Servlet/RequestDemo10 控制台输出： 下篇博客 《HTTP响应信息数据 - Response》 中，详细学习响应信息数据 - Response。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"HTTP：超文本传输协议","slug":"HTTP：超文本传输协议","date":"2020-02-21T10:25:00.000Z","updated":"2020-04-23T11:40:36.753Z","comments":true,"path":"2020/02/21/HTTP：超文本传输协议/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/21/HTTP%EF%BC%9A%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/","excerpt":"概念 HTTP == Hyper Text Transfer Protocol 超文本传输协议 传输协议：定义了客户端和服务器端通信时，发送数据的格式。 特点 基于TCP/IP的高级协议 默认端口号:80 基于请求/响应模型的：一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 网页中每一个文件都是一次单独的请求，几张图片，就是几次请求。如下图所示。","text":"概念 HTTP == Hyper Text Transfer Protocol 超文本传输协议 传输协议：定义了客户端和服务器端通信时，发送数据的格式。 特点 基于TCP/IP的高级协议 默认端口号:80 基于请求/响应模型的：一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 网页中每一个文件都是一次单独的请求，几张图片，就是几次请求。如下图所示。 历史版本http 0.9 只有一个命令GET 没有HEADER等描述数据的信息 服务器发送完毕，就关闭TCP连接 每一次请求响应都会建立新的连接 http 1.0 增加了很多命令，如status code和header 多字符集支持、多部分发送、权限、缓存等 http 1.1 持久连接：keep-alive 复用连接（较http1.0的每一次请求响应都会建立新的连接。好处：节约了连接的资源，提升了传输的速度。） 提高性能的关键是低延迟而不是高带宽。 较http1.0，对缓存的支持更好 推送：主动发送js、css推送到浏览器。 二进制流：可以并行发送数据。 http 2.0 所有数据以二进制传输 同一个连接里面发送多个请求不再需要按顺序来 头消息压缩以及推送等提高效率的功能 所有的请求共用一个连接，可以更有效的使用tcp连接，通过带宽来提升http性能 可以减少服务链接的压力，内存减少了，链接吞吐量大了 解决浏览器连接数有限的问题 资源合并减少请求的优化手段在http2.0来说是没有效果的 请求信息数据 格式 Servlet类中service()方法的参数ServletRequest 字符串格式，比如： POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan 以下关于 请求信息数据格式 的内容有缺省，详细见下一篇博客 《HTTP请求信息数据 - Request》 中。 请求行 格式：请求方式 请求url 请求协议/版本 请求方式 HTTP协议有7种请求协议，常用的有GET、POST两种 GET 请求参数在请求行中，在url后 请求的url长度有限制的 不太安全（参数跟在url之后） 浏览器控制台显示👇 POST 请求参数在请求体中 请求的url长度没有限制的 相对安全（参数在请求体中） 浏览器控制台显示👇 请求url 假设为 /login.html 请求协议/版本 HTTP/1.1 请求头 客户端浏览器告诉服务器一些信息 格式：请求头名称 : 请求头值 若有多个，则一行一个。 常见的请求头 Host User-Agent Referer Host 请求的主机地址 User-Agent 浏览器告诉服务器，我访问你时候使用的浏览器版本信息 作用：可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer 比如上面几张图片的Referer是 http://localhost/login.html 告诉服务器，我（当前请求）从哪里来？ 作用：防盗链、统计工作 举个例子：我的网站想播放《战狼2》电影👇 Connection keep-alive http1.1，表示该链接可以被复用 请求空行 就是一个空行（空白行） 作用：分割POST请求的请求头和请求体 请求体/请求正文 封装POST请求信息的请求参数 下一篇博客 《HTTP请求信息数据 - Request》 中，详细学习了 请求信息数据 - Request。 响应信息数据 格式 Servlet类中service()方法的参数ServletResponse 字符串数据，比如： HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; 响应行 格式：协议/版本 响应状态码 状态码描述 响应状态码 服务器告诉客户端浏览器本次请求和响应的一个状态。 特点 状态码都是3位数字 分类 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx状态码 2xx：成功。代表： 200 3xx：重定向。代表： 302：重定向 304：访问缓存 4xx：客户端错误。代表： 403：错误是一种在网站访问过程中，常见的错误提示，表示资源不可用。服务器理解客户的请求，但拒绝处理它，通常由于服务器上文件或目录的权限设置导致的WEB访问错误。 404：请求路径没有对应的资源 405：请求方式没有对应的doXxx方法 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头 格式：响应头名称 ：值 常见的响应头 Content-Type Content-disposition Content-Type 服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition 服务器告诉客户端以什么格式打开响应体数据 其值： in-line：默认值，在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体。涉及文件下载等功能。 响应空行 就是一个空行（空白行） 作用：分割响应头和响应体 响应体 传输的数据 文件、HTML网页源码等等。比如， &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; 下下篇博客 《HTTP响应信息数据 - Response》 中，详细学习响应信息数据 - Response。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"}]},{"title":"hexo s浏览博客时，提示4000端口问题","slug":"hexo s浏览博客时，提示4000端口问题","date":"2020-02-21T10:17:00.000Z","updated":"2020-04-23T11:40:36.789Z","comments":true,"path":"2020/02/21/hexo s浏览博客时，提示4000端口问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/21/hexo%20s%E6%B5%8F%E8%A7%88%E5%8D%9A%E5%AE%A2%E6%97%B6%EF%BC%8C%E6%8F%90%E7%A4%BA4000%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98/","excerpt":"记录一次使用Hexo来，第一次遇到的问题。 讲真我也不知道为什么我的4000端口会被占用，我只是如常一样地使用Hexo而已。 问题hexo s浏览博客时，提示4000端口问题。代码提示如下： $ hexo server FATAL Port 4000 has been used. Try other port instead. FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/do Error: listen EADDRINUSE 0.0.0.0:4000 at Object.exports._errnoException (util.js:1026:11) at exports._exceptionWithHostPort (util.js:1049:20) at Server._listen2 (net.js:1257:14) at listen (net.js:1293:10) at net.js:1403:9 at _combinedTickCallback (internal/process/next_tick.js:77:11) at process._tickCallback (internal/process/next_tick.js:98:9) FATAL listen EADDRINUSE 0.0.0.0:4000 Error: listen EADDRINUSE 0.0.0.0:4000 at Object.exports._errnoException (util.js:1026:11) at exports._exceptionWithHostPort (util.js:1049:20) at Server._listen2 (net.js:1257:14) at listen (net.js:1293:10) at net.js:1403:9 at _combinedTickCallback (internal/process/next_tick.js:77:11) at process._tickCallback (internal/process/next_tick.js:98:9) 解决可以在站点下的文件_config.yml内加上如下代码更改hexo-server运行时的端口号： server: port: 40401 compress: true header: true 其中40401可以换成想要运行的端口号。","text":"记录一次使用Hexo来，第一次遇到的问题。 讲真我也不知道为什么我的4000端口会被占用，我只是如常一样地使用Hexo而已。 问题hexo s浏览博客时，提示4000端口问题。代码提示如下： $ hexo server FATAL Port 4000 has been used. Try other port instead. FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/do Error: listen EADDRINUSE 0.0.0.0:4000 at Object.exports._errnoException (util.js:1026:11) at exports._exceptionWithHostPort (util.js:1049:20) at Server._listen2 (net.js:1257:14) at listen (net.js:1293:10) at net.js:1403:9 at _combinedTickCallback (internal/process/next_tick.js:77:11) at process._tickCallback (internal/process/next_tick.js:98:9) FATAL listen EADDRINUSE 0.0.0.0:4000 Error: listen EADDRINUSE 0.0.0.0:4000 at Object.exports._errnoException (util.js:1026:11) at exports._exceptionWithHostPort (util.js:1049:20) at Server._listen2 (net.js:1257:14) at listen (net.js:1293:10) at net.js:1403:9 at _combinedTickCallback (internal/process/next_tick.js:77:11) at process._tickCallback (internal/process/next_tick.js:98:9) 解决可以在站点下的文件_config.yml内加上如下代码更改hexo-server运行时的端口号： server: port: 40401 compress: true header: true 其中40401可以换成想要运行的端口号。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"将本地文件传到阿里云服务器","slug":"将本地文件传到阿里云服务器","date":"2020-02-21T05:47:34.000Z","updated":"2020-04-23T11:40:36.803Z","comments":true,"path":"2020/02/21/将本地文件传到阿里云服务器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/21/%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%BC%A0%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"问题怎么将本地文件传到阿里云服务器里面？ 解决 第一种：在阿里云服务器里建一个FTP服务商，在本地用FTP客户端上传文件 第二种：进阿里云服务器远程界面的时候，把本地磁盘带进去，然后进服务器里直接从本地磁盘里把文件复制到服务器里 第三种：QQ安装到阿里云服务器里，用QQ对传 第四种：把本地文件上传到邮箱里 ，然后进阿里云服务器里打开您的邮箱，进去下载文件即可 链接：https://www.w3cschool.cn/intellij_idea_doc/","text":"问题怎么将本地文件传到阿里云服务器里面？ 解决 第一种：在阿里云服务器里建一个FTP服务商，在本地用FTP客户端上传文件 第二种：进阿里云服务器远程界面的时候，把本地磁盘带进去，然后进服务器里直接从本地磁盘里把文件复制到服务器里 第三种：QQ安装到阿里云服务器里，用QQ对传 第四种：把本地文件上传到邮箱里 ，然后进阿里云服务器里打开您的邮箱，进去下载文件即可 链接：https://www.w3cschool.cn/intellij_idea_doc/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"云服务器","slug":"云服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"Servlet 体系结构","slug":"Servlet 体系结构","date":"2020-02-20T12:23:11.000Z","updated":"2020-04-23T11:40:36.768Z","comments":true,"path":"2020/02/20/Servlet 体系结构/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/Servlet%20%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"我们在写一个class 并 implement Servlet时，需要重写Servlet中的5个方法，但是大多时候都只用到 service 方法。 虽然中用到service方法，但其余的4个方法还得重写。 那我们能不能编写一个class，去继承或实现 Servlet 后，只用定义一个 service 方法就可以了。其他方法想有就有，不想有就没有？ 这时候我们就要聊聊 Servlet 体系结构了。 Servlet 体系结构Servlet – interface，接口 ↓|实现 GenericServlet – 实现类，抽象类 ↓|继承 HttpServlet – 实现类，抽象类 做项目时，创建Servlet时候，推荐使用第三种方式：👉继承HttpServlet👉定义类继承HttpServlet👉 复写doGet/doPost方法","text":"我们在写一个class 并 implement Servlet时，需要重写Servlet中的5个方法，但是大多时候都只用到 service 方法。 虽然中用到service方法，但其余的4个方法还得重写。 那我们能不能编写一个class，去继承或实现 Servlet 后，只用定义一个 service 方法就可以了。其他方法想有就有，不想有就没有？ 这时候我们就要聊聊 Servlet 体系结构了。 Servlet 体系结构Servlet – interface，接口 ↓|实现 GenericServlet – 实现类，抽象类 ↓|继承 HttpServlet – 实现类，抽象类 做项目时，创建Servlet时候，推荐使用第三种方式：👉继承HttpServlet👉定义类继承HttpServlet👉 复写doGet/doPost方法 GenericServlet 将 Servlet 接口中的其他方法做了默认空实现，只将 service() 方法作为抽象 将来定义 Servlet 类时候，可以继承 GenericServlet，实现 service() 方法即可 其余四种方法， 若有需要，手动重写即可。 @WebServlet(\"/demo2\") public class ServletDemo2 extends GenericServlet { @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"demo2....\"); } } HttpServlet 该抽象类是对 HTTP协议 的封装和描述，可以简化某些操作 HTTP协议 有 7种 请求方式。现在，我们假设只是用最常用的两种请求方式GET和POST这两种请求方式。 service()方法中 最先要干 的其中2件事👇 将来不管怎么样，都得做这么一件事：“先判断请求方式👉判断完后，要通过不同的请求方式，做出不同的代码逻辑“。 那么，这个过程是非常麻烦的。 同时，这个过程也是所有 service() 都该做的一个过程。 所以这个时候，官方针对这个过程，专门提供了一个class HttpServlet。 HttpServlet 已经帮程序员做好了这个过程，写好了相应的代码，就如上图的红色字体部分。集程序员不再需要去判断请求方式了。 HttpServlet 内部定义了 doGet(){} 和 doPost(){} 这两个方法。并且在判断请求方式的 if 中调用了这两个方法。 这就是其基本的定义原理。就如下图👇 若将来想要屏蔽这种GET或POST请求方式的处理逻辑：我们可以继承 HttpServlet，并且去重写 doGet(){} 和 doPost(){}这两个方法。 因为将来都是调用 service()方法 ，并且 service()会做一个方法分发：你是get就调用 doGet() ，你是post就调用 doPost() 。 做项目时，创建Servlet时候，推荐使用第三种方式：👉继承HttpServlet👉定义类继承HttpServlet👉 复写doGet/doPost方法 步骤 定义 class 继承 HttpServlet 重写doGet() 和 doPost() 两个方法 /* ServletDemo3.java */ import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * @Classname ServletDemo3 * @Description TODO * @Date 2020/2/20 下午 10:54 * @Created by jerry */ @WebServlet(\"demo3\") public class ServletDemo3 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doGet......\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"doPost......\"); } } 注意 通过浏览器直接请求，是GET方式 现在掌握的知识，只能通过表单，完成POST方式 简单案例 新建login.html文件 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/demo3\" method=\"post\"&gt; &lt;input name=\"username\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 重启服务，访问页面 将 method=\"post\" 改为 method=\"get\" 再访问页面 注意： 使用get方式后，请求的参数会跟在url后。 后续阅读相关文章1、GenericServlet和HttpServlet 2、GenericServlet 、Servlet和httpServler他们之间的关系 3、GenericServlet和HttpServlet有什么区别？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"https://melodyjerry.github.io/blog/tags/Servlet/"}]},{"title":"IDEA官方文档","slug":"IntelliJ IDEA官方文档","date":"2020-02-20T11:47:34.000Z","updated":"2020-04-23T11:40:36.762Z","comments":true,"path":"2020/02/20/IntelliJ IDEA官方文档/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/IntelliJ%20IDEA%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/","excerpt":"一份 W3C school 提供的 《IntelliJ IDEA官方文档》 链接：https://www.w3cschool.cn/intellij_idea_doc/","text":"一份 W3C school 提供的 《IntelliJ IDEA官方文档》 链接：https://www.w3cschool.cn/intellij_idea_doc/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"愿有情人终成眷属，执手前走共度一生","slug":"愿有情人终成眷属，执手前走共度一生","date":"2020-02-20T10:47:34.000Z","updated":"2020-03-02T12:35:48.206Z","comments":true,"path":"2020/02/20/愿有情人终成眷属，执手前走共度一生/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/%E6%84%BF%E6%9C%89%E6%83%85%E4%BA%BA%E7%BB%88%E6%88%90%E7%9C%B7%E5%B1%9E%EF%BC%8C%E6%89%A7%E6%89%8B%E5%89%8D%E8%B5%B0%E5%85%B1%E5%BA%A6%E4%B8%80%E7%94%9F/","excerpt":"浏览博客 网易云热评墙 时，看见两段很感触的网易云音乐热评。截了两张图，就当做今天的随笔。 “愿有情人终成眷属”，这话我想在后边加上一句，“执手前走共度一生”。——2020.02.20随笔","text":"浏览博客 网易云热评墙 时，看见两段很感触的网易云音乐热评。截了两张图，就当做今天的随笔。 “愿有情人终成眷属”，这话我想在后边加上一句，“执手前走共度一生”。——2020.02.20随笔 图片[1]链接：https://www.7ooooo.cn/490/.html 图片[2]链接：https://www.7ooooo.cn/523/.html 关注我们：请关注一下我们的微信公众号（xielihaia）版权声明：版权归 网易云热评墙 所有！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"IDEA与Tomcat的其他相关配置","slug":"IDEA与Tomcat的其他相关配置","date":"2020-02-20T09:42:00.000Z","updated":"2020-04-23T11:40:36.756Z","comments":true,"path":"2020/02/20/IDEA与Tomcat的其他相关配置/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/IDEA%E4%B8%8ETomcat%E7%9A%84%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","excerpt":"IDEA会为每一个Tomcat部署的项目单独建立一份配置文件 查看控制台的log Using CATALINA_BASE: \"C:\\Users\\丶Melody\\.IntelliJIdea2019.1\\system\\tomcat\\_test\" 工作空间项目 和 Tomcat部署的Web项目 Tomcat真正访问的是“Tomcat部署的Web项目” “Tomcat部署的Teb项目”对应着“工作空间项目” 的Web目录下的所有资源 IDEA工作台中，项目的src对应着WEB-INF目录 WEB-INF目录下的资源不能被浏览器直接访问。日后可以利用其他技术访问到。 断点调试：使用”小虫子”启动 dubug 启动 视频讲解【00:28】1.IDEA会为每一个Tomcat部署的项目单独建立一份配置文件 【03:15】2.工作空间项目 和 Tomcat部署的Web项目 【09:04】3.断点调试：使用”小虫子”启动 dubug 启动","text":"IDEA会为每一个Tomcat部署的项目单独建立一份配置文件 查看控制台的log Using CATALINA_BASE: \"C:\\Users\\丶Melody\\.IntelliJIdea2019.1\\system\\tomcat\\_test\" 工作空间项目 和 Tomcat部署的Web项目 Tomcat真正访问的是“Tomcat部署的Web项目” “Tomcat部署的Teb项目”对应着“工作空间项目” 的Web目录下的所有资源 IDEA工作台中，项目的src对应着WEB-INF目录 WEB-INF目录下的资源不能被浏览器直接访问。日后可以利用其他技术访问到。 断点调试：使用”小虫子”启动 dubug 启动 视频讲解【00:28】1.IDEA会为每一个Tomcat部署的项目单独建立一份配置文件 【03:15】2.工作空间项目 和 Tomcat部署的Web项目 【09:04】3.断点调试：使用”小虫子”启动 dubug 启动 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"Servlet：运行在服务器端的小程序","slug":"Servlet：运行在服务器端的小程序","date":"2020-02-20T07:19:00.000Z","updated":"2020-04-23T11:40:36.772Z","comments":true,"path":"2020/02/20/Servlet：运行在服务器端的小程序/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/Servlet%EF%BC%9A%E8%BF%90%E8%A1%8C%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/","excerpt":"Servlet： server applet 概念：运行在服务器端的小程序 Servlet就是一个接口，定义了Java类被浏览器访问到（Tomcat识别）的规则（我是跳转内容）↩。 将来我们自定义一个类，实现Servlet接口，复写（重写Override）方法。 快速理解","text":"Servlet： server applet 概念：运行在服务器端的小程序 Servlet就是一个接口，定义了Java类被浏览器访问到（Tomcat识别）的规则（我是跳转内容）↩。 将来我们自定义一个类，实现Servlet接口，复写（重写Override）方法。 快速理解 快速入门 创建JavaEE项目 定义一个类，实现Servlet接口 /* ServletDemo1.java */ package cn.itcast.web.servlet; import javax.servlet.*; import java.io.IOException; public class ServletDemo1 implements Servlet { //TODO } ​ 实现接口中的抽象方法 /* ServletDemo1.java */ package cn.itcast.web.servlet; import javax.servlet.*; import java.io.IOException; public class ServletDemo1 implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } // 提供服务的方法 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"Hello Servlet\"); } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } 配置Servlet，在web.xml的&lt;web-app&gt;&lt;/web-app&gt;中添加： &lt;!--配置Servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; servlet-mapping是做一个映射，servlet-name对应servlet-class，url-pattern是资源路径（/开头） &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;，中的cn.itcast.web.servlet.ServletDemo1是全类名，这里涉及到反射。日后补充。 启动服务，看看结果 浏览器中是空白的， 但是IDEA控制台中显示“Hello Servlet” 每刷新一次页面，控制台就多一句“Hello Servlet”。 执行原理 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。 如果有，则在找到对应的&lt;servlet-class&gt;全类名（涉及到反射） tomcat会将字节码文件加载进内存，并且创建其对象 调用其方法 为什么能调用方法？ 因为实现了【规则】（点击我跳转）。实现规则，实现Servlet接口，实现了接口中的方法。 ServletDemo可以调试、运行，看看每个方法的执行次数。 import javax.servlet.*; import java.io.IOException; /** * Servlet的方法 */ public class ServletDemo1 implements Servlet { /** * 初始化的方法 * 在Servlet被创建时，执行，且只执行一次。 * @param servletConfig * @throws ServletException */ @Override public void init(ServletConfig servletConfig) throws ServletException { System.out.println(\"init...\"); } /** * 获取ServletConfig对象 * ServletConfig：Servlet的配置对象 * @return */ @Override public ServletConfig getServletConfig() { return null; } /** * 提供服务的方法 * 每一次Servlet被访问时，执行。可执行多次。 * @param servletRequest * @param servletResponse * @throws ServletException * @throws IOException */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"service...\"); } /** * 获取Servlet的一些信息（版本、作者……） * @return */ @Override public String getServletInfo() { return null; } /** * 销毁的方法 * 在服务器正常关闭时，执行。只执行一次。 * 非正关闭时，destroy方法不会执行。 */ @Override public void destroy() { System.out.println(\"destroy...\"); } } Servlet中的生命周期方法1.被创建：执行init方法，只执行一次 Servlet什么时候被创建？ 默认情况下，第一次被访问时，被创建。 在服务器启动时，被创建。 可以配置执行Servlet的创建时机，在&lt;servlet&gt;&lt;/servlet&gt;标签中配置&lt;load-on-startup&gt;整数值&lt;/load-on-startup&gt; 1.第一次被访问时，创建 负整数 2.在服务器启动时，创建 0或正整数(一般0~10) /** * 初始化的方法 * 在Servlet被创建时，执行，且只执行一次。 * @param servletConfig * @throws ServletException */ @Override public void init(ServletConfig servletConfig) throws ServletException { System.out.println(\"init...\"); // 定义局部变量，这样不存在多线程的安全问题 int number = 3; } Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的。 多个用户同时访问时，可能存在线程安全问题。 解决：尽量不要在Servlet中定义成员变量（定义局部变量就不存在安全问题了）。即使定义了成员变量，也不要对修改值。 2.提供服务：执行service方法，可执行多次 每次访问Servlet时，Service方法都会被调用一次。 /** * 提供服务的方法 * 每一次Servlet被访问时，执行。可执行多次。 * @param servletRequest * @param servletResponse * @throws ServletException * @throws IOException */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"service...\"); } 3.被销毁：执行destroy方法，只执行一次 Servlet被销毁时执行。服务器关闭时，Servlet被销毁 只有服务器正常关闭时，才会执行destroy方法。 destroy方法在Servlet被销毁之前执行，一般用于释放资源 /** * 销毁的方法 * 在服务器正常关闭时，执行。只执行一次。 * 非正关闭时，destroy方法不会执行。 */ @Override public void destroy() { System.out.println(\"destroy...\"); } Servlet 3.0 官方提供新的标准 Servlet 3.0 从 Java EE 6 开始支持 Servlet 3.0 好处 支持注解配置。可以不需要web.xml了 步骤 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 定义一个类，实现Servlet接口 复写方法 在类上使用@WebServlet注解，进行配置 @WebServlet(\"资源路径\") 比如：@WebServlet(urlPatterns = \"/demo2\") 或 @WebServlet(value = \"/demo2\") 或 @WebServlet(\"/demo2\") 访问：http://localhost:8080/Servlet3/demo2 @WebServlet注解 @WebServlet中有个很特殊的属性value 一般表示最重要的属性，就用value表示。 特性：如果只有一个属性，value可以省略不写。 除去value，最重要的属性是urlPatterns @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface WebServlet { String name() default \"\"; //相当于&lt;Servlet-name&gt; String[] value() default {}; //代表urlPatterns()属性配置 String[] urlPatterns() default {}; //相当于&lt;url-pattern&gt; int loadOnStartup() default -1; //相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default {}; boolean asyncSupported() default false; String smallIcon() default \"\"; String largeIcon() default \"\"; String description() default \"\"; String displayName() default \"\"; } Servlet 体系结构跳转到我得下一篇博文👉 [Servlet 体系结构](https://melodyjerry.gitee.io/blog/2020/02/20/Servlet 体系结构/) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"},{"name":"Servlet","slug":"Servlet","permalink":"https://melodyjerry.github.io/blog/tags/Servlet/"}]},{"title":"Tomcat简单修改虚拟目录实现访问多个项目","slug":"Tomcat简单修改虚拟目录实现访问多个项目","date":"2020-02-20T06:55:00.000Z","updated":"2020-04-23T11:40:36.769Z","comments":true,"path":"2020/02/20/Tomcat简单修改虚拟目录实现访问多个项目/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/20/Tomcat%E7%AE%80%E5%8D%95%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%8E%B0%E8%AE%BF%E9%97%AE%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/","excerpt":"可以通过 修改Application Contest（虚拟目录） 实现访问多个项目 修改项目名称作为对应的虚拟目录， 重启服务后，浏览器访问时， http://localhost:8080/项目a/资源5 例如：http://localhost:55555/ServletDemo/demo1.html","text":"可以通过 修改Application Contest（虚拟目录） 实现访问多个项目 修改项目名称作为对应的虚拟目录， 重启服务后，浏览器访问时， http://localhost:8080/项目a/资源5 例如：http://localhost:55555/ServletDemo/demo1.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"IDEA启动Tomcat报错","slug":"IDEA启动Tomcat报错","date":"2020-02-19T12:02:09.000Z","updated":"2020-04-23T11:40:36.759Z","comments":true,"path":"2020/02/19/IDEA启动Tomcat报错/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/IDEA%E5%90%AF%E5%8A%A8Tomcat%E6%8A%A5%E9%94%99/","excerpt":"问题 IDEA run的时候报错： Error running 'Tomcat 8.5.51': Address loaclhost:1099 is already in use","text":"问题 IDEA run的时候报错： Error running 'Tomcat 8.5.51': Address loaclhost:1099 is already in use 分析控制台提示1099端口已经被占用。 解决解决方法要么是杀死端口号1099对应的进程，要么就是修改IDEA中Tomcat的端口号。 建议优先选择杀死对应进程。 方法一 根据端口号查找对应的PID，可以通过在cmd中输入命令， netstat -ano | findstr 1099 找到该进程的进程号为7256 输入命令，杀死进程 tskill 7256 或 taskkill -f -pid 7256 方法二同方法一，知道进程的PID后，直接去进程管理器，直接右键结束进程。 方法三针对方法一、二均无效时，只能在IDEA中修改端口： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"IDEA 常用快捷键列表","slug":"IDEA输出打印System.out.println()的快捷键","date":"2020-02-19T09:02:00.000Z","updated":"2020-04-23T11:40:36.760Z","comments":true,"path":"2020/02/19/IDEA输出打印System.out.println()的快捷键/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/IDEA%E8%BE%93%E5%87%BA%E6%89%93%E5%8D%B0System.out.println()%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"IDEA输出打印System.out.println()的快捷键在eclipse中习惯了使用syso，开始用idea很不习惯。 在idea中直接输入sout，自动出现提示，不像eclipse中那样还要alt+/，这算是idea的一个优点了。 sout 看图： 按Tab或Enter都可以出现","text":"IDEA输出打印System.out.println()的快捷键在eclipse中习惯了使用syso，开始用idea很不习惯。 在idea中直接输入sout，自动出现提示，不像eclipse中那样还要alt+/，这算是idea的一个优点了。 sout 看图： 按Tab或Enter都可以出现 十大Intellij IDEA快捷键 for System.out、main快捷键 1 智能提示 Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。 最后要说一点，Intellij能够智能感知spring、hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。 2 重构 Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。 切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。 3 代码生成这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。 另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。 4 编辑编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+&lt;/&gt;折叠代码就不多说了。 关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。 5 查找打开类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。 类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。 要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。 Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。 6 其他辅助以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有： Ø 命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 Ø 新建：Alt+Insert可以新建类、方法等任何东西。 Ø 格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 Ø 切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 Ø 单元测试：Ctrl+Alt+T创建单元测试用例。 Ø 运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 Ø 调试：F7/F8/F9分别对应Step into，Step over，Continue。 此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。 7 最终榜单这榜单阵容太豪华了，后几名都是如此有用，毫不示弱。 Ø Top #10切来切去：Ctrl+Tab Ø Top #9选你所想：Ctrl+W Ø Top #8代码生成：Template/Postfix +Tab Ø Top #7发号施令：Ctrl+Shift+A Ø Top #6无处藏身：Shift+Shift Ø Top #5自动完成：Ctrl+Shift+Enter Ø Top #4创造万物：Alt+Insert 太难割舍，前三名并列吧！ Ø Top #1智能补全：Ctrl+Shift+Space Ø Top #1自我修复：Alt+Enter Ø Top #1重构一切：Ctrl+Shift+Alt+T ————————版权声明：本文为CSDN博主「Jenrey」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/jenrey/article/details/79961825 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"IDEA 常用快捷键列表","slug":"IDEA常用快捷键列表","date":"2020-02-19T09:00:00.000Z","updated":"2020-04-23T11:40:36.761Z","comments":true,"path":"2020/02/19/IDEA常用快捷键列表/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%88%97%E8%A1%A8/","excerpt":"IDEA 常用快捷键列表","text":"IDEA 常用快捷键列表 ——- IDEA中窗口最大化—-&gt;Windows 上： Ctrl+Shift+F12 ——– ctrl+z撤回代码 ——- ctrl+shift+z恢复撤回代码 ——- ctrl + Alt + V (返回属性变量) ——- shift+ctrl+u (大小写的切换) ——- Ctrl+Alt+L，格式化代码 ——- Ctrl+D 将当前行复制到下一行 ——- Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch 也可抛错误 ——- 快捷方式一（光标移到该代码行，Alt+Enter），可以异常外抛出，也可以try-catch： ——- Ctrl+Shift+Space，自动补全代码（提示） ——- Ctrl+O，重写方法 ——- Ctrl+I，实现方法 ——- ctrl + shift + enter 句末加； ——- 连安两下 shift 查找文件 ——- CtrL +shift +r 全局搜索： ——- ctrl +r 替换当前页的单词 ——- 代码格式化： shfit + G (自定义) //ctrl +alt +L —— 直接查看和进入接口实现类的快捷键 ： Ctrl+Alt+鼠标左键 —– 单机两下放大窗户： —– alt+capslk(大小写切换)+鼠标左键 或者：ALT + 鼠标左键 列编辑模式 ————- ctrl+shift+enter不只是用来行尾加分号的； idea进阶快捷键： 1 查看接口的实现类：Ctrl+Alt+B： 2：查看一个类中有什么方法：Alt+7 或 点左侧边栏Structure 2 返回上/下个光标地方:Alt+Ctrl+箭头(向左) 和 Alt+ Ctrl+箭头(向右)—（全键盘） 3： 查看Java方法调用树(被调/主调)：Ctrl+Alt+H 4 :查看类继承关系图：Ctrl+Alt+U 5:查看当前类的继承树：Ctrl+H 6: 查看定义的变量在哪里被调用：Ctrl+Alt+F7 7:查看一个类中有什么方法：Alt+7 或 点左侧边栏Structure 8:列编辑：alt +左键 9:自动生成not null判断语句 自动生成not null这种if判断，在IDEA里有很多种办法，其中一种办法你可能没想到。 upload successful 当我们使用rabbitTemplate. 后，直接输入notnull并回车，IDEA就好自动生成if判断了。 upload successful 编辑Ctrl+Shift + Enter，语句完成\" ！\"，否定完成，输入表达式时按 “！”键Ctrl+E，最近的文件Ctrl+Shift+E，最近更改的文件Shift+Click，可以关闭文件Ctrl+[ OR ]，可以跑到大括号的开头与结尾Ctrl+F12，可以显示当前文件的结构Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择Ctrl+N，可以快速打开类Ctrl+Shift+N，可以快速打开文件Alt+Q，可以看到当前方法的声明Ctrl+P，可以显示参数信息Ctrl+Shift+Insert，可以选择剪贴板内容并插入Alt+Insert，可以生成构造器/Getter/Setter等Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catchCtrl+Enter，导入包，自动修正Ctrl+Alt+L，格式化代码Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作Ctrl+Alt+O，优化导入的类和包Ctrl+R，替换文本Ctrl+F，查找文本Ctrl+Shift+Space，自动补全代码Ctrl+空格，代码提示（与系统输入法快捷键冲突）Ctrl+Shift+Alt+N，查找类中的方法或变量★Alt+Enter，快速修复错误提示、导入包、自动修正代码、解决出现的问题、生成返回值…… 详细见 最特殊的快捷键 Alt + Enter 介绍 Alt+Shift+C，最近的更改Alt+Shift+Up/Down，上/下移一行Shift+F6，重构 – 重命名Ctrl+X，删除行Ctrl+D，复制行Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）Ctrl+J，自动代码（例如：serr）Ctrl+Alt+J，用动态模板环绕Ctrl+H，显示类结构图（类的继承层次）Ctrl+Q，显示注释文档Alt+F1，查找代码所在位置Alt+1，快速打开或隐藏工程面板Ctrl+Alt+left/right，返回至上次浏览的位置Alt+left/right，切换代码视图Alt+Up/Down，在方法间快速移动定位Ctrl+Shift+Up/Down，向上/下移动语句F2 或 Shift+F2，高亮错误或警告快速定位Tab，代码标签输入完成后，按 Tab，生成代码Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失Alt+F3，逐个往下查找相同文本，并高亮显示Ctrl+Up/Down，光标中转到第一行或最后一行下Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）Ctrl+Alt+B，跳转到方法实现处Ctrl+Shift+Backspace，跳转到上次编辑的地方Ctrl+O，重写方法Ctrl+Alt+Space，类名自动完成Ctrl+Alt+Up/Down，快速跳转搜索结果Ctrl+Shift+J，整合两行Alt+F8，计算变量值Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本Ctrl+Alt+Shift+V，简单粘贴Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口F12，把焦点从编辑器移到最近使用的工具窗口Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器Ctrl+W，可以选择单词继而语句继而行继而函数Ctrl+Shift+W，取消选择光标所在词Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置Ctrl+I，实现方法Ctrl+Shift+U，大小写转化Ctrl+Y，删除当前行 Shift+Enter，向下插入新行psvm/sout，main/System.out.println();Ctrl+J，查看更多Ctrl+Shift+F，全局查找Ctrl+F，查找Shift+F3，向上查找F3，向下查找Ctrl+Shift+S，高级搜索Ctrl+U，转到父类Ctrl+Alt+S，打开设置对话框Alt+Shift+Inert，开启/关闭列选择模式Ctrl+Alt+Shift+S，打开当前项目/模块属性Ctrl+G，定位行Alt+Home，跳转到导航栏Ctrl+Enter，上插一行Ctrl+Backspace，按单词删除Ctrl+\"+/-\"，当前方法展开、折叠Ctrl+Shift+\"+/-\"，全部展开、折叠 调试、编译Ctrl+F2，停止Alt+Shift+F9，选择 DebugAlt+Shift+F10，选择 RunCtrl+Shift+F9，编译Ctrl+Shift+F10，运行Ctrl+Shift+F8，查看断点F8，步过F7，步入Shift+F7，智能步入Shift+F8，步出Alt+Shift+F8，强制步过Alt+Shift+F7，强制步入Alt+F9，运行至光标处Ctrl+Alt+F9，强制运行至光标处F9，恢复程序Alt+F10，定位到断点Ctrl+F8，切换行断点Ctrl+F9，生成项目Alt+1，项目Alt+2，收藏Alt+6，TODOAlt+7，结构Ctrl+Shift+C，复制路径Ctrl+Alt+Shift+C，复制引用，必须选择类名Ctrl+Alt+Y，同步Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）Shift+F12，还原默认布局Ctrl+Shift+F12，隐藏/恢复所有窗口Ctrl+F4，关闭Ctrl+Shift+F4，关闭活动选项卡Ctrl+Tab，转到下一个拆分器Ctrl+Shift+Tab，转到上一个拆分器 重构Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除Ctrl+Alt+N，内联 查找Ctrl+F，查找Ctrl+R，替换F3，查找下一个Shift+F3，查找上一个Ctrl+Shift+F，在路径中查找Ctrl+Shift+R，在路径中替换Ctrl+Shift+S，搜索结构Ctrl+Shift+M，替换结构Alt+F7，查找用法Ctrl+Alt+F7，显示用法Ctrl+F7，在文件中查找用法Ctrl+Shift+F7，在文件中高亮显示用法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"Tomcat启动时中文乱码的问题","slug":"Tomcat启动时中文乱码的问题","date":"2020-02-19T08:01:00.000Z","updated":"2020-04-23T11:40:36.767Z","comments":true,"path":"2020/02/19/Tomcat启动时中文乱码的问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/Tomcat%E5%90%AF%E5%8A%A8%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"问题Tomcat启动时中文乱码的问题 解决方法修改conf文件夹下的logging.properties文件 第47行代码： java.util.logging.ConsoleHandler.encoding = UTF-8 改为 java.util.logging.ConsoleHandler.encoding = GBK","text":"问题Tomcat启动时中文乱码的问题 解决方法修改conf文件夹下的logging.properties文件 第47行代码： java.util.logging.ConsoleHandler.encoding = UTF-8 改为 java.util.logging.ConsoleHandler.encoding = GBK 扩展如果IDEA中使用Tomcat也乱码，可以额为参考此方法。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"Tomcat：Web服务器软件","slug":"Tomcat：服务器软件","date":"2020-02-19T07:25:00.000Z","updated":"2020-04-23T11:40:36.770Z","comments":true,"path":"2020/02/19/Tomcat：服务器软件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/19/Tomcat%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AF%E4%BB%B6/","excerpt":"Tomcat：web服务器软件 Tomcat 是用纯Java语言编写的 安装下载 https://tomcat.apache.org/download-80.cgi 免安装，解压压缩包即可。 注意：安装目录建议不要有中文和空格 目录结构 启动 Windows：运行./bin/startup.bat Linux：运行./bin/startup.sh","text":"Tomcat：web服务器软件 Tomcat 是用纯Java语言编写的 安装下载 https://tomcat.apache.org/download-80.cgi 免安装，解压压缩包即可。 注意：安装目录建议不要有中文和空格 目录结构 启动 Windows：运行./bin/startup.bat Linux：运行./bin/startup.sh 可能遇到的问题中文乱码详细见博文 【Tomcat启动时中文乱码的问题】 黑窗口一闪而过 原因： 没有正确配置JAVA_HOME环境变量 解决方案：正确配置JAVA_HOME环境变量 启动报错暴力 找到占用的端口号，并且找到对应的进程，杀死该进程 cmd&gt;netstat -ano &gt; 查看进程id（PID）&gt;任务管理器（查看-选择列-PID）&gt;结束进程（对应PID） 温柔 修改自身的端口号 ./conf/server.xml `&lt;Connector port=”8888” protocol=”HTTP/1.1” connectionTimeout=\"20000\" redirectPort=\"8445\" /&gt;` 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 好处：在访问时，就不用输入端口号 该方式可实现单机多Tomcat并存 访问浏览器输入： 访问自己：http://localhost:8080 访问别人：http://别人的ip:8080 查看IP地址 cmd&gt;$ ipconfig &gt;IPv4地址 关闭 针对服务器本身，推荐使用“正常关闭” 但是后期是配合IDEA使用Tomcat 正常关闭 有两种方式： 手动运行./bin/shutdown.bat 在Tomcat窗口，按Ctrl+C 强制关闭 点击Tomcat窗口右上角的X 部署/配置项目的方式 有三种方式： 直接将项目放到webapps目录下即可 配置conf/server.xml文件 在conf\\Catalina\\localhost创建任意名称的xml文件 虚拟目录浏览器通过http://localhost:8080访问，需要访问到某一个项目时，需要在其随后加上/目录或路径（称作虚拟目录） 直接将项目放到webapps目录下即可 /项目(文件夹)名”：项目的访问路径，也称虚拟目录 简化部署 第一种方式还有一种简化部署的形式 将项目打成一个war包，再将war包放置到webapps目录下 war 包会自动解压缩 若删除项目，删除对应war包即可。自动会删除对应生产的项目文件夹。 配置conf/server.xml文件 在&lt;Host&gt;标签体中配置 &lt;Context docBase=\"D:\\hello\" path=\"/hehe\" /&gt; docBase：项目存放的路径 path：虚拟目录 缺点：需要修改配置文件，不太安全 在conf\\Catalina\\localhost创建任意名称的xml文件 在文件中编写 &lt;Context docBase=\"D:\\hello\" /&gt; 虚拟目录：xml文件的名称。比如localhost:8080/xml文件/index.html 热部署方式：删除或修改文件名后，不需要重启服务。 部署项目的类型 静态项目 动态项目 静态项目 只能存放静态资源 HTML、CSS、JavaScript、图片、音频、视频、文本等等 动态项目 不仅可存放静态资源，还有动态资源 目录结构(Java动态项目)项目根目录 ﹂-WEB-INF目录 ﹂web.xml：web项目的核心配置文件 ﹂classes目录：放置字节码文件的目录 ﹂lib目录：放置依赖的jar包 比如： IDEA中配合使用Tomcat集成到IDEA中 新建Web项目 运行项目 注意： 默认war打包部署 / ：默认虚拟目录设置当前项目为根目录 其他配置 重新部署项目时，不再重启Tomcat服务器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"}]},{"title":"Github提速","slug":"Github提速","date":"2020-02-18T09:00:00.000Z","updated":"2020-04-23T11:40:36.737Z","comments":true,"path":"2020/02/18/Github提速/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/18/Github%E6%8F%90%E9%80%9F/","excerpt":"经常要clone github中的一些项目，无奈如果不爬梯子的话速度实在是龟速，经常1k/s，于是献上改Hosts大法。 第一步：打开http://codeload.github.com.ipaddress.com/#ipinfo 找到你浏览器上实际显示的IP地址， 例图 ： 第二步：按win+r唤起运行框，输入cmd，然后再依次ping一下上面的地址 第三步：打开你C:\\Windows\\System32\\drivers\\etc\\hosts文件，在文件末尾追加如下一行即可 140.82.113.9 http://codeload.github.com","text":"经常要clone github中的一些项目，无奈如果不爬梯子的话速度实在是龟速，经常1k/s，于是献上改Hosts大法。 第一步：打开http://codeload.github.com.ipaddress.com/#ipinfo 找到你浏览器上实际显示的IP地址， 例图 ： 第二步：按win+r唤起运行框，输入cmd，然后再依次ping一下上面的地址 第三步：打开你C:\\Windows\\System32\\drivers\\etc\\hosts文件，在文件末尾追加如下一行即可 140.82.113.9 http://codeload.github.com 另外以下这些github hosts，可能对你所在地区来说不是最优版本，最优hosts的选择可以参考上面三个步骤 # GitHub Start 192.30.253.112 github.com 192.30.253.119 gist.github.com 151.101.100.133 assets-cdn.github.com 151.101.100.133 raw.githubusercontent.com 151.101.100.133 gist.githubusercontent.com 151.101.100.133 cloud.githubusercontent.com 151.101.100.133 camo.githubusercontent.com 151.101.100.133 avatars0.githubusercontent.com 151.101.100.133 avatars1.githubusercontent.com 151.101.100.133 avatars2.githubusercontent.com 151.101.100.133 avatars3.githubusercontent.com 151.101.100.133 avatars4.githubusercontent.com 151.101.100.133 avatars5.githubusercontent.com 151.101.100.133 avatars6.githubusercontent.com 151.101.100.133 avatars7.githubusercontent.com 151.101.100.133 avatars8.githubusercontent.com # GitHub End document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Github","slug":"Github","permalink":"https://melodyjerry.github.io/blog/tags/Github/"}]},{"title":"JavaScript：让页面元素动起来","slug":"JavaScript：让页面元素动起来","date":"2020-02-18T01:01:00.000Z","updated":"2020-04-23T11:40:36.763Z","comments":true,"path":"2020/02/18/JavaScript：让页面元素动起来/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/18/JavaScript%EF%BC%9A%E8%AE%A9%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%8A%A8%E8%B5%B7%E6%9D%A5/","excerpt":"概念一门客户端脚本语言 特点 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎 脚本语言：不需要编译，直接就可以被浏览器解析执行了 功能 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。","text":"概念一门客户端脚本语言 特点 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎 脚本语言：不需要编译，直接就可以被浏览器解析执行了 功能 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。 发展史 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C– ，后来更名为：ScriptEase 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript 1996年，微软抄袭JavaScript开发出JScript语言 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。 JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)ECMAScript：客户端脚本语言的标准基本语法与html结合方式内部JS 定义&lt;script&gt;，标签体内容就是js代码 外部JS 定义&lt;script&gt;，通过src属性引入外部的js文件 注意 &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。 &lt;script&gt;可以定义多个。 注释 单行注释：// 注释内容 多行注释：/* 注释内容 */ 数据类型详细见 JavaScript 数据类型 原始数据类型(基本数据类型) number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型) string：字符串。 字符串 “abc” “a” ‘abc’ boolean：布尔。 true和false null：一个对象为空的占位符 undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined Undefined 与 Null 的区别 Undefined 与 Null 的值相等，但类型不相等： typeof undefined // undefined typeof null // object null === undefined // false null == undefined // true 引用数据类型 对象（object） 数组（array） 变量 变量：一小块存储数据的内存空间 Java语言是强类型语言，而JavaScript是弱类型语言。 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。 语法var 变量名 = 初始化值; typeof运算符 获取变量的类型 注：null运算后得到的是object 更多见 《JavaScript中typeof知多少？》 运算符 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换。 其他类型转number： string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字） boolean转number：true转为1，false转为0 算数运算符算术运算符对数值（文字或变量）执行算术运算。 运算符 描述 + 加法 - 减法 * 乘法 ** 幂（将第一个操作数提升到第二个操作数的幂。ES2016） / 除法 % 系数（返回除法的余数） ++ 递增 – 递减 赋值运算符赋值运算符向 JavaScript 变量赋值。 运算符 特殊说明 例子 等同于 = x = y x = y += x += y x = x + y -= x -= y x = x - y *= x *= y x = x * y /= x /= y x = x / y %= 把余数赋值给变量 x %= y x = x % y &lt;&lt;= x &lt;&lt;= y x = x &lt;&lt; y &gt;&gt;= x &gt;&gt;= y x = x &gt;&gt; y &gt;&gt;&gt;= x &gt;&gt;&gt;= y x = x &gt;&gt;&gt; y &amp;= x &amp;= y x = x &amp; y ^= x ^= y x = x ^ y |= x |= y x = x | y **= x **= y x = x ** y 提示：****=** 运算符属于 ECMAScript 2016 proposal (ES7) 的实验部分。它的跨浏览器表现并不稳定。请勿使用。 比较运算符比较运算符在逻辑语句中使用，以判定变量或值是否相等。 我们给定 x = 5，下表中解释了比较运算符： 运算符 描述 比较 返回 == 等于 x == 8 false x == 5 true x == “5” true === 值相等并且类型相等 x === 5 true x === “5” false != 不相等 x != 8 true !== 值不相等或类型不相等 x !== 5 false x !== “5” true x !== 8 true &gt; 大于 x &gt; 8 false &lt; 小于 x &lt; 8 true &gt;= 大于或等于 x &gt;= 8 false &lt;= 小于或等于 x &lt;= 8 true 比较方式 类型相同：直接比较 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。 类型不同：先进行类型转换，再比较 ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false 逻辑运算符逻辑运算符用于判定变量或值之间的逻辑。 我们给定 x = 6 且 y = 3，下表解释了逻辑运算符： 运算符 描述 例子 &amp;&amp; 与 (x &lt; 10 &amp;&amp; y &gt; 1) 为 true || 或 (x == 5 || y == 5) 为 false ! 非 !(x == y) 为 true 其他类型转boolean： number：0或NaN为假，其他为真 string：除了空字符串(“”)，其他都是true null&amp;undefined：都是false 对象：所有对象都为true 条件（三元）运算符语法： 变量名=(表达式)? 值1:值2; 判断表达式的值，如果是true则取值1，如果是false则取值2； 示例： var voteable = (age &lt; 18) ? \"太年轻\":\"足够成熟\"; 字符串运算符+ 运算符也可用于对字符串进行相加（concatenate，级联）。+= 赋值运算符也可用于相加（级联）字符串： 实例：给定 text1 = “Good “, text2 = “Morning”, 及 text3 = “”, 下面的表格解释了字符串运算符的使用： 运算符 例子 text1 text2 text3或text1 + text3 = text1 + text2 “Good “ “Morning” “Good Morning” += text1 += text2 “Hello” “Kitty！” “Hello Kitty!” 字符串+数字=字符串 相加两个数字，将返回和。但对一个数字和一个字符串相加将返回一个字符串。 类型运算符 运算符 描述 typeof 返回变量的类型。 instanceof 返回 true，如果对象是对象类型的实例。 typeof 运算符您可以使用 typeof 运算符来确定 JavaScript 变量的数据类型。 typeof \"Bill\" // 返回 \"string\" typeof 3.14 // 返回 \"number\" typeof NaN // 返回 \"number\" typeof false // 返回 \"boolean\" typeof [1,2,3,4] // 返回 \"object\" typeof {name:'Bill', age:62} // 返回 \"object\" typeof new Date() // 返回 \"object\" typeof function () {} // 返回 \"function\" typeof myCar // 返回 \"undefined\" * typeof null // 返回 \"object\" 请注意： NaN 的数据类型是数值 数组的数据类型是对象 日期的数据类型是对象 null 的数据类型是对象 未定义变量的数据类型是 undefined 尚未赋值的变量的数据类型也是 undefined 无法使用 typeof 去判断 JavaScript 对象是否是数组（或日期）。 typeof 的数据类型： typeof 运算符不是变量。它属于运算符。运算符（比如 + - * /）没有数据类型。 但是，typeof 始终会返回字符串（包含运算数的类型）。 另外涉及到Number() 转换数值，String() 转换字符串，Boolean() 转换布尔值。 位运算符位运算符处理 32 位数。 该运算中的任何数值运算数都会被转换为 32 位的数。结果会被转换回 JavaScript 数。 运算符 描述 例子 等同于 结果 十进制 &amp; 与 (and) 5 &amp; 1 0101 &amp; 0001 0001 1 | 或 (or) 5 | 1 0101 | 0001 0101 5 ~ 非 (not) ~ 5 ~0101 1010 10 ^ 异或 (xor) 5 ^ 1 0101 ^ 0001 0100 4 &lt;&lt; 零填充左位移 5 &lt;&lt; 1 0101 &lt;&lt; 1 1010 10 &gt;&gt; 有符号右位移 5 &gt;&gt; 1 0101 &gt;&gt; 1 0010 2 &gt;&gt;&gt; 零填充右位移 5 &gt;&gt;&gt; 1 0101 &gt;&gt;&gt; 1 0010 2 上例使用 4 位无符号的例子。但是 JavaScript 使用 32 位有符号数。因此，在 JavaScript 中，~ 5 不会返回 10，而是返回 -6。~00000000000000000000000000000101 将返回 11111111111111111111111111111010。 JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数。执行按位操作后，结果将转换回 64 位 JavaScript 数。 运算符优先级值 值 运算符 描述 实例 20 ( ) 表达式分组 (3 + 4) 19 . 成员 person.name 19 [] 成员 person[“name”] 19 () 函数调用 myFunction() 19 new 创建 new Date() 17 ++ 后缀递增 i++ 17 – 后缀递减 i– 16 ++ 前缀递增 ++i 16 – 前缀递减 –i 16 ! 逻辑否 !(x==y) 16 typeof 类型 typeof x 15 ** 求幂 (ES7) 10 ** 2 14 * 乘 10 * 5 14 / 除 10 / 5 14 % 模数除法 10 % 5 13 + 加 10 + 5 13 - 减 10 - 5 12 &lt;&lt; 左位移 x &lt;&lt; 2 12 &gt;&gt; 右位移 x &gt;&gt; 2 12 &gt;&gt;&gt; 右位移（无符号） x &gt;&gt;&gt; 2 11 &lt; 小于 x &lt; y 11 &lt;= 小于或等于 x &lt;= y 11 &gt; 大于 x &gt; y 11 &gt;= 大于或等于 x &gt;= y 11 in 对象中的属性 “PI” in Math 11 instanceof 对象的实例 instanceof Array 10 == 相等 x == y 10 === 严格相等 x === y 10 != 不相等 x != y 10 !== 严格不相等 x !== y 9 &amp; 按位与 x &amp; y 8 ^ 按位 XOR x ^ y 7 | 按位或 x | y 6 &amp;&amp; 逻辑与 x &amp;&amp; y 5 || 逻辑否 x || y 4 ? : 条件 ? “Yes” : “No” 3 = 赋值 x = y 3 += 赋值 x += y 3 -= 赋值 x -= y 3 *= 赋值 x *= y 3 %= 赋值 x %= y 3 &lt;&lt;= 赋值 x &lt;&lt;= y 3 &gt;&gt;= 赋值 x &gt;&gt;= y 3 &gt;&gt;&gt;= 赋值 x &gt;&gt;&gt;= y 3 &amp;= 赋值 x &amp;= y 3 ^= 赋值 x ^= y 3 |= 赋值 x |= y 2 yield 暂停函数 yield x 1 , 逗号 7 , 8 注意：淡红色指示实验性或建议性的技术（ECMASScript 2016 或 ES7） 提示：括号中的表达式会在值在表达式的其余部分中被使用之前进行完全计算。 流程控制语句 if...else... switch: 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7) switch(变量): case 值: 在JS中,switch语句可以接受任意的原始数据类型 while for JS特殊语法 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议) 变量的定义使用var关键字，也可以不使用 用： 定义的变量是局部变量 不用：定义的变量是全局变量(不建议) 练习：99乘法表&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;99乘法表&lt;/title&gt; &lt;style&gt; td{ border: 1px solid; } &lt;/style&gt; &lt;script&gt; document.write(\"&lt;table align='center'&gt;\"); //1.完成基本的for循环嵌套，展示乘法表 for (var i = 1; i &lt;= 9 ; i++) { document.write(\"&lt;tr&gt;\"); for (var j = 1; j &lt;=i ; j++) { document.write(\"&lt;td&gt;\"); //输出 1 * 1 = 1 document.write(i + \" * \" + j + \" = \" + ( i*j) +\"&amp;nbsp;&amp;nbsp;&amp;nbsp;\"); document.write(\"&lt;/td&gt;\"); } /*//输出换行 document.write(\"&lt;br&gt;\");*/ document.write(\"&lt;/tr&gt;\"); } //2.完成表格嵌套 document.write(\"&lt;/table&gt;\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 基本对象Function：函数(方法)对象创建格式 function 方法名称(形式参数列表){ 方法体 } var 方法名 = function(形式参数列表){ 方法体 } 建议不用 var fun = new Function(形式参数列表,方法体); //忘掉吧 方法属性 length：代表形参的个数 特点 方法定义是，形参的类型不用写,返回值类型也不写。 方法是一个对象，如果定义名称相同的方法，会覆盖 在JS中，方法的调用只与方法的名称有关，和参数列表无关 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数 调用方法名称(实际参数列表); &lt;!-- 比如： var x = myFunction(4, 3); // 调用函数，返回值被赋值给 x --&gt; 函数中的代码将在其他代码调用该函数时执行： 当事件发生时（当用户点击按钮时） 当 JavaScript 代码调用时 自动的（自调用） 返回当 JavaScript 到达 return 语句，函数将停止执行。如果函数被某条语句调用，JavaScript 将在调用语句之后“返回”执行代码。函数通常会计算出返回值。这个返回值会返回给调用者： function myFunction(a, b) { return a * b; // 函数返回 a 和 b 的乘积 } Array：数组对象创建格式 var arr = new Array(元素列表); var arr = new Array(默认长度); var arr = [元素列表]; 方法 join(参数)：将数组中的元素按照指定的分隔符拼接为字符串 push()：向数组的末尾添加一个或更多元素，并返回新的长度 属性 lengh:数组的长度 特点1. JS中，数组元素的类型可变的。 2. JS中，数组长度可变的。Boolean：布尔布尔值只有两个值：true 或 false。 实例 var x = true; var y = false; 布尔值经常用在条件测试中。 Date：日期对象创建格式var date = new Date(); 方法 toLocaleString()：返回当前date对象对应的时间本地字符串格式 getTime()：获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差 Math：数学对象创建特点 Math对象不用创建，直接使用。 格式：Math.方法名(); 方法 random():返回 0 ~ 1 之间的随机数。 含0不含1 ceil(x)：对数进行上舍入 floor(x)：对数进行下舍入 round(x)：把数四舍五入为最接近的整数 属性 PI Number：数值JavaScript 只有一种数值类型。 写数值时用不用小数点均可： 实例 var x1 = 34.00; // 带小数点 var x2 = 34; // 不带小数点 超大或超小的数值可以用科学计数法来写： 实例 var y = 123e5; // 12300000 var z = 123e-5; // 0.00123 String：字符串字符串（或文本字符串）是一串字符（比如 “Bill Gates”）。 字符串被引号包围。您可使用单引号或双引号： 实例 var carName = \"Porsche 911\"; // 使用双引号 var carName = 'Porsche 911'; // 使用单引号 您可以在字符串内使用引号，只要这些引号与包围字符串的引号不匹配： 实例 var answer = \"It's alright\"; // 双引号内的单引号 var answer = \"He is called 'Bill'\"; // 双引号内的单引号 var answer = 'He is called \"Bill\"'; // 单引号内的双引号 RegExp：正则表达式对象正则表达式：定义字符串的组成规则。 单个字符:[]如： [a] [ab] [a-zA-Z0-9_] 特殊符号代表特殊含义的单个字符： \\d:单个数字字符 [0-9] \\w:单个单词字符 [a-zA-Z0-9_] 量词符号： ?：表示出现0次或1次 *：表示出现0次或多次 +：表示出现1次或多次 {m,n}:表示 m&lt;= 数量 &lt;= n m如果缺省：{,n}：最多n次n 如果缺省：{m,}：最少m次 开始结束符号 ^:开始 $:结束 正则对象创建有两种创建形式： var reg = new RegExp(\"正则表达式\"); var reg = /正则表达式/; 方法 test(参数):验证指定的字符串是否符合正则定义的规范 Global：全局对象特点 全局对象 这个Global中封装的方法不需要对象就可以直接调用：方法名(); 方法 encodeURI()：url编码 decodeURI()：url解码 encodeURIComponent()：url编码,编码的字符更多 decodeURIComponent()：url解码 parseInt()：将字符串转为数字 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number isNaN()：判断一个值是否是NaN NaN六亲不认，连自己都不认。NaN参与的==比较，全部都是false eval()：讲 JavaScript 字符串，并把它作为脚本代码来执行。 URL编码 传智播客 = %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2 BOM概念 Browser Object Model 浏览器对象模型 将浏览器的各个组成部分封装成对象。 浏览器对象模型（Browser Object Model (BOM)）不存在浏览器对象模型（BOM）的官方标准。 现代的浏览器已经（几乎）实现了 JavaScript 交互相同的方法和属性，因此它经常作为 BOM 的方法和属性被提到。 该部分笔记不全，详细见 JavaScript Window - 浏览器对象模型 组成 Window：窗口对象 Navigator：浏览器对象 Screen：显示器屏幕对象 History：历史记录对象 Location：地址栏对象 Navigator 浏览器对象 Navigator 对象获取一些浏览器的信息. 属性 appName 返回浏览器的名称。 相关文档 https://www.w3school.com.cn/jsref/dom_obj_navigator.asp Screen 屏幕对象 Screen 对象包含有关客户端显示屏幕的信息。 属性 width: 返回屏幕的宽度 height: 返回屏幕的高度 相关文档 https://www.w3school.com.cn/jsref/dom_obj_screen.asp Location 地址栏对象 Location 对象包含有关当前 URL 的信息。 创建(获取) window.location location 方法 reload(): 重新加载当前文档,刷新操作. 属性 href: 设置或返回完整的url. Demo&lt;body&gt; &lt;input id=\"btn\" type=\"button\" value=\"跳转\"&gt; &lt;script type=\"text/javascript\"&gt; // 获取input标签 var btn = document.getElementById(\"btn\"); // 设置事件 btn.onclick = function (){ location.href = \"https://www.baidu.com\"; } &lt;/script&gt; &lt;/body&gt; 相关文档 https://www.w3school.com.cn/jsref/dom_obj_location.asp History 对象 History 对象包含用户（在浏览器窗口中）访问过的 URL。 创建(获取) window.history history 方法 back() 加载 history 列表中的前一个 URL。 forward() 加载 history 列表中的下一个 URL。 go(参数)加载 history 列表中的某个具体页面。 参数：正数：前进几个历史记录负数：后退几个历史记录 属性 length: 返回当前窗口历史列表中的url数量. Window 窗口对象 Window 对象表示浏览器中打开的窗口。 方法 与弹出框有关的方法 alert(): 显示带有一段消息和一个确认按钮的警告框. confirm(): 显示带有一段消息,以及确认和取消两个按钮的对话框. 若点击确定,该方法返回true, 点击取消,返回false. 如果用户点击确定按钮，则方法返回true 如果用户点击取消按钮，则方法返回false prompt(): 显示可提示用户输入的对话框. 返回值为用户输入的内容. 与打开关闭有关的方法 close():关闭浏览器窗口。谁调用我 ，我关谁 open(arg1, arg2, arg3, arg4): 打开一个新的浏览器窗口，返回新的Window对象 注意: 这4个参数都是可选的, arg1 传入url, arg3传入窗口的特征(设置宽高等) window.open(\"https://www.baidu.com\",\"\",\"width=100,height=100\"); 与定时器有关的方法 setTimeout(code,millisec): 在指定的毫秒数后调用函数或计算表达式。 参数： js代码或者方法对象 毫秒值 返回值：唯一标识，用于取消定时器 clearTimeout(id_of_settimeout): 取消由 setTimeout() 方法设置的 timeout。传入某个定时器的id用来取消指定的定时器. setInterval(code,millisec): 按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval(id_of_settimeout): 取消由 setInterval() 设置的 timeout。 属性 获取其他BOM对象 History location Navigator Screen 获取DOM对象 document 特点 Window对象不需要创建可以直接使用： window.方法名() window引用可以省略：方法名(); DOM简单学习：为了满足案例要求 功能：控制html文档的内容 获取页面标签(元素)对象：Element* `document.getElementById(\"id值\")`:通过元素的id获取元素对象 操作Element对象： 修改属性值： 明确获取的对象是哪一个？ 查看API文档，找其中有哪些属性可以设置 修改标签体内容： 属性：``innerHTML` 获取元素对象 使用innerHTML属性修改标签体内容 概念 Document Object Model 文档对象模型 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作 功能 控制html文档的内容 W3C DOM 标准被分为 3 个不同的部分 核心 DOM — 针对任何结构化文档的标准模型 Document：文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 Node：节点对象，其他5个(D、E、A、T、C)的父对象 XML DOM — 针对 XML 文档的标准模型 HTML DOM — 针对 HTML 文档的标准模型 对象树当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM 模型被结构化为对象树： DOM: Document Object Model 文档对象模型 文档: 超文本文档(超文本标记文档) html, xml 对象: 提供了属性和方法. 模型: 使用属性和方法操作超文本标记文档 可以使用js里面的dom里面提供的对象,使用这些对象的属性和方法,对标记型文档进行操作. dom里面已经将html里面的标签,属性,文本内容都封装成了对象. 该部分笔记不全，详细见 JavaScript HTML DOM DOM解析html文档的过程 根据html的层级结构,在内存中分配一个树形结构, 需要把html中的每部分封装为对象. Document对象: 整个文档 Element对象: 标签对象 Attribute对象: 首先要获取标签对象 Text对象: 首先要获取标签对象 Comment对象: 注释对象 Node节点对象: 这个对象是上面这些对象的父对象, 如果在对象内找不到想要的方法, 此时可以在Node节点对象中去查找想要的方法. 核心DOM模型Document 文档对象创建(获取) 在html dom模型中可以使用window对象来获取 window.document document 方法write() 向页面输出变量/html代码 document.write(\"abc\"); document.write(\"&lt;hr&gt;\"); 获取Element对象getElementById() ： 根据id属性值获取元素对象,id属性值一般唯一getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组 创建其他的DOM对象 createAttribute(name) createComment() createElement() createTextNode() Element 元素对象(标签对象)创建(获取) 通过document来获取和创建 方法 首先通过document来获取元素,然后通过元素进行操作 getAttribute(attributename): 获取指定的属性 setAttribute(attributename,attributevalue): 给元素添加属性 removeAttribute(attributename): 移除指定名称的属性 注意: 不能删除 value 获取标签下面的子标签 childNodes: 这个属性兼容性很差 getElementsByTagName(标签名): 兼容性好,获取标签下面子标签的唯一有效方法. Node 节点对象特点 所有dom对象都可以被认为是一个节点. 属性 parentNode 返回节点的父节点 方法nodeName:获取节点的名称nodeType: 获取节点的类型nodeValue: 获取节点的value值因为dom在解析html的时候, html里面的标签,属性,文本都是一个节点,所以上面的三个属性对其都是不同的值. 标签节点对应的nodeType为1 属性节点对应的nodeType为2 文本节点对应的nodeType为3 parentNode: 获取父节点的属性childNodes: 得到所有子节点,兼容性差firstChild: 获取第一个子节点lastChild: 获取最后一个子节点nextSibling: 返回一个给定节点的下一个兄弟节点previousSibling: 返回一个给定节点的上一个兄弟节点 CRUD_DOM树查找节点 getElementById():通过节点的id属性,查找指定节点 添加节点 appendChild()：向节点的子节点列表的结尾添加新的子节点 插入节点 insertBefore(newNode, oldNode): 向oldNode节点前插入一个新节点.通过父节点添加 删除节点 removeChild()：删除（并返回）当前节点的指定子节点。 替换节点 replaceChild()：用新节点替换一个子节点。通过父节点替换 复制节点 cloneNode(true): 复制节点 innerHTML属性 innerHTML作用: 获取文本内容 向标签里面设置内容(可以是html代码) Demo&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div#div1 { width: 360px; height: 150px; border: 2px solid red; } div#div2 { width: 360px; height: 150px; border: 2px solid black; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"div1\"&gt; &lt;ul id=\"ul1\"&gt; &lt;li id=\"li1\"&gt;one&lt;/li&gt; &lt;li id=\"li2\"&gt;two&lt;/li&gt; &lt;li id=\"li3\"&gt;three&lt;/li&gt; &lt;li id=\"li4\"&gt;four&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=\"div2\"&gt;&lt;/div&gt; &lt;input id=\"input1\" type=\"button\" value=\"添加节点\"&gt; &lt;input id=\"input2\" type=\"button\" value=\"插入节点\"&gt; &lt;input id=\"input3\" type=\"button\" value=\"删除节点\"&gt; &lt;input id=\"input4\" type=\"button\" value=\"替换节点\"&gt; &lt;input id=\"input5\" type=\"button\" value=\"复制节点\"&gt; &lt;script type=\"text/javascript\"&gt; // 添加节点 /* 1.获取到ul 2.获取到div2 3.把ul添加到div2 */ var input1 = document.getElementById(\"input1\"); input1.onclick = function () { var ul = document.getElementById(\"ul1\"); var div = document.getElementById(\"div2\"); div.appendChild(ul); } // 插入节点 /* 1.获取到li3标签 2.创建li 3.创建文本 4.把文本添加到li下面 5.获取到ul 6.把li添加到ul下面 */ var input2 = document.getElementById(\"input2\"); input2.onclick = function () { var li3 = document.getElementById(\"li3\"); var li = document.createElement(\"li\"); var text = document.createTextNode(\"朝阳红\"); li.appendChild(text); var ul = document.getElementById(\"ul1\"); ul.insertBefore(li, li3); } // 删除节点 /* 1.获取到li标签 2.执行父节点ul标签 3.执行删除 */ var input3 = document.getElementById(\"input3\"); input3.onclick = function () { var li3 = document.getElementById(\"li3\"); var ul = document.getElementById(\"ul1\"); ul.removeChild(li3); } // 替换节点 /* 1.获取到li标签 2.创建标签li 3.创建文本 4.把文本添加到li下面 5.获取父节点Ul标签 6.执行替换 */ var input4 = document.getElementById(\"input4\"); input4.onclick = function () { var li3 = document.getElementById(\"li3\"); var li = document.createElement(\"li\"); var text = document.createTextNode(\"HelloWorld\"); li.appendChild(text); var ul = document.getElementById(\"ul1\"); ul.replaceChild(li, li3); } // 复制节点(把ul列表复制到另一个div中) /* 1.获取到ul 2.执行复制方法：cloneNode(true) 3.把复制后的内容放到div2中 获取div2 appendChild方法 */ var input5 = document.getElementById(\"input5\"); input5.onclick = function () { var ul = document.getElementById(\"ul1\"); var ulClone = ul.cloneNode(true); var div = document.getElementById(\"div2\"); div.appendChild(ulClone); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; HTML DOM 标签体的设置和获取：innerHTML 使用html元素对象的属性 控制元素样式 使用元素的style属性来设置 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。如：//修改样式方式1 div1.style.border = \"1px solid red\"; div1.style.width = \"200px\"; //font-size--&gt; fontSize div1.style.fontSize = \"20px\"; 控制样式 通过DOM来控制标签的样式 使用 style 属性来设置 提前定义好类选择器的样式，通过元素的 className 属性来设置其class属性值。 Demo&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .sun { font-weight: bold; font-size: 30px; color: skyblue; border: 2px dashed #000; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"zy\"&gt;桂朝阳&lt;/div&gt; &lt;div class=\"sun\"&gt;大太阳&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 获取类名为zy的标签 var zy = window.document.getElementsByClassName(\"zy\")[0]; // alert(zy.className); // 方式一(自己添加)给类名为zy的div添加样式 // zy.style.border = \"1px solid #ccc\"; // zy.style.fontSize = \"20px\"; // 方式二(调用已经写好的) zy.className = \"sun\"; &lt;/script&gt; &lt;/body&gt; 事件简单学习 功能： 某些组件被执行了某些操作后，触发某些代码的执行。 比如，造句： xxx被xxx,我就xxx。 我方水晶被摧毁后，我就责备对友。 敌方水晶被摧毁后，我就夸奖自己。 如何绑定事件 直接在html标签上，指定事件的属性(操作)，属性值就是 js 代码 事件：onclick — 单击事件 通过 js 获取元素对象，指定事件属性，设置一个函数 小案例： &lt;body&gt; &lt;img id=\"light\" src=\"img/off.gif\" onclick=\"fun();\"&gt; &lt;img id=\"light2\" src=\"img/off.gif\"&gt; &lt;script&gt; function fun(){ alert('我被点了'); alert('我又被点了'); } function fun2(){ alert('咋老点我？'); } //1.获取light2对象 var light2 = document.getElementById(\"light2\"); //2.绑定事件 light2.onclick = fun2; &lt;/script&gt; &lt;/body&gt; 功能些组件被执行了某些操作后，触发某些代码的执行 事件监听机制 概念: 某些组件被执行了某些操作后，触发某些代码的执行。 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了 事件源：组件。如： 按钮 文本输入框… 监听器：代码。 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。 常见的事件 点击事件： onclick：单击事件 ondblclick：双击事件 焦点事件 onfocus:元素获得焦点 onblur：失去焦点 一般用于表单验证 加载事件： onload：一张页面或一幅图像完成加载。 鼠标事件： onmousedown： 鼠标按钮被按下。 定义方法时，定义一个形参，接受event对象。 event对象的button属性可以获取鼠标按钮键被点击了。 onmouseup ：鼠标按键被松开。onmousemove ：鼠标被移动。onmouseover ：鼠标移到某元素之上。onmouseout ：鼠标从某元素移开。 键盘事件： onkeydown ：某个键盘按键被按下。 onkeyup ：某个键盘按键被松开。 onmouseout：某个键盘按键被按下并松开。 选择和改变 onchange ：域的内容被改变。 onselect ：文本被选中。 表单事件： onsubmit ：确认按钮被点击。 可以阻止表单的提交 方法返回false则表单被阻止提交。 onreset ：重置按钮被点击。 Demo:电灯开关&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;电灯开关&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=\"light\" src=\"img/off.gif\"&gt; &lt;script&gt; /* 分析： 1.获取图片对象 2.绑定单击事件 3.每次点击切换图片 * 规则： * 如果灯是开的 on,切换图片为 off * 如果灯是关的 off,切换图片为 on * 使用标记flag来完成 */ //1.获取图片对象 var light = document.getElementById(\"light\"); var flag = false;//代表灯是灭的。 off图片 //2.绑定单击事件 light.onclick = function(){ if(flag){//判断如果灯是开的，则灭掉 light.src = \"img/off.gif\"; flag = false; }else{ //如果灯是灭的，则打开 light.src = \"img/on.gif\"; flag = true; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 标记&gt;&gt;&gt;学习BOM和DOM时用的是CSDN博主「White Camel」的笔记，原文链接：https://blog.csdn.net/m0_37989980/article/details/103669620 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"}]},{"title":"歌《人命之河》","slug":"歌《人命之河》","date":"2020-02-17T14:49:52.000Z","updated":"2020-03-02T12:35:48.212Z","comments":true,"path":"2020/02/17/歌《人命之河》/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/17/%E6%AD%8C%E3%80%8A%E4%BA%BA%E5%91%BD%E4%B9%8B%E6%B2%B3%E3%80%8B/","excerpt":"","text":"记录昨天，2020-2-17，周日。 中午，老爸做了新菜，名叫“凉拌猪肉”（老爸自己起的名字），味道还不错 老弟“放假”（在家网上教学六天，周日放假hhh），下午我们去到外公外婆那。 外公外婆2人+二姨一家4人+我们一家3人=9人。 老爸又露了一手，一桌的饭菜，。结果留给我收尾，我也吃不完，实则太多了，嗝~~（太撑了hh） 看见外公的身体比之前还虚弱，很累的样子。保佑阿公身体健康🙆 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"[转]Git很慢怎么办","slug":"转-Git-很慢怎么办","date":"2020-02-17T11:35:47.000Z","updated":"2020-04-23T11:40:36.821Z","comments":true,"path":"2020/02/17/转-Git-很慢怎么办/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/17/%E8%BD%AC-Git-%E5%BE%88%E6%85%A2%E6%80%8E%E4%B9%88%E5%8A%9E/","excerpt":"","text":"it’s fucking slow, guess why当你想要解决一个问题的时候，最好先学会尽可能准确地描述你的问题，像「Git 很慢怎么办」之类的问题就是反面教材，这就像说「我的国家不行了」一样，这种模棱两可、似是而非的问题对出题人和答题人都是一种困扰，出题人把握不了自己的问题，便始终不会自查，答题人无法知晓出题人真正的问题，也只能一顿瞎猜。 如果你假以思考，结合实际情况，比如你操作的命令，是 git clone 还是 git checkout? 这样就能很快推断出真正的问题，即「Git clone 很慢怎么办」，如果更进一步，你想到你正在 clone 的是一个国外的地址，比如 github.com，你会想到这也许是网络问题。 当你做出更多的判断而不是用一个模糊的问题来让别人替你判断的时候，你的问题也就迎刃而解了。 现在这个模糊的问题变成了解决 Git 同步国外项目的网络问题了，这种情况你应该很熟悉，可以使用「代理」来解决。而 Git 支持两种网络传输协议，即 HTTP 和 SSH 协议，于是你只需要在 Google 搜索 Git 如何配置 HTTP 代理和 SSH 代理 就行了，当然也可以继续阅读，参考我用的配置。 配置 HTTP 代理如果你 git clone 时用的是 http 开头的地址，那就得配置 http 代理: git config --global http.proxy http://127.0.0.1:1087 # 或者 Socks5 代理 git config --global http.proxy socks5://127.0.0.1:1086 配置 SSH 代理如果你 git clone 时用的是 ssh 开头的地址，那就得配置 SSH 代理。 对 macOS 用户，你可以使用 connect，这是一个让 SSH 支持 SOCKS/HTTPS 代理的工具，这里我们用 homebrew 来安装: brew install connect 然后编辑你的 ~/.ssh/config 文件，加入以下代码: Host * User git ProxyCommand connect -S 127.0.0.1:1086 %h %p 这样 SSH 连接时就会使用位于 127.0.0.1:1086 的代理。 原文链接：https://egoist.moe/2019/08/15/git-is-slow/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://melodyjerry.github.io/blog/tags/Git/"}]},{"title":"制作一个简单的HTML登录页面","slug":"制作一个简单的HTML登录页面","date":"2020-02-17T10:20:00.000Z","updated":"2020-04-23T11:40:36.800Z","comments":true,"path":"2020/02/17/制作一个简单的HTML登录页面/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/17/%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84HTML%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/","excerpt":"需求制作一个HTML登录页面，包含邮箱，登录密码，立即注册，忘记密码等","text":"需求制作一个HTML登录页面，包含邮箱，登录密码，立即注册，忘记密码等 HTML部分&lt;div class=\"dowebok\"&gt; &lt;div class=\"dowebok\"&gt; &lt;div class=\"logo\"&gt;&lt;/div&gt; &lt;div class=\"form-item\"&gt; &lt;input id=\"username\" type=\"text\" autocomplete=\"off\" placeholder=\"邮箱\"&gt; &lt;/div&gt; &lt;div class=\"form-item\"&gt; &lt;input id=\"password\" type=\"password\" autocomplete=\"off\" placeholder=\"登录密码\"&gt; &lt;/div&gt; &lt;div class=\"form-item\"&gt;&lt;button id=\"submit\"&gt;登 录&lt;/button&gt;&lt;/div&gt; &lt;div class=\"reg-bar\"&gt; &lt;a class=\"reg\" href=\"javascript:\"&gt;立即注册&lt;/a&gt; &lt;a class=\"forget\" href=\"javascript:\"&gt;忘记密码&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; CSS部分* { margin: 0; padding: 0; } html { height: 100%; } body { height: 100%; background: #fff url(img/backgroud.png) 50% 50% no-repeat; background-size: cover;} .dowebok { position: absolute; left: 50%; top: 50%; width: 430px; height: 550px; margin: -300px 0 0 -215px; border: 1px solid #fff; border-radius: 20px; overflow: hidden;} .logo { width: 104px; height: 104px; margin: 50px auto 80px; background: url(img/login.png) 0 0 no-repeat; } .form-item { position: relative; width: 360px; margin: 0 auto; padding-bottom: 30px;} .form-item input { width: 288px; height: 48px; padding-left: 70px; border: 1px solid #fff; border-radius: 25px; font-size: 18px; color: #fff; background-color: transparent; outline: none;} .form-item button { width: 360px; height: 50px; border: 0; border-radius: 25px; font-size: 18px; color: #1f6f4a; outline: none; cursor: pointer; background-color: #fff; } #username { background: url(img/emil.png) 20px 14px no-repeat; } #password { background: url(img/password.png) 23px 11px no-repeat; } .tip { display: none; position: absolute; left: 20px; top: 52px; font-size: 14px; color: #f50; } .reg-bar { width: 360px; margin: 20px auto 0; font-size: 14px; overflow: hidden;} .reg-bar a { color: #fff; text-decoration: none; } .reg-bar a:hover { text-decoration: underline; } .reg-bar .reg { float: left; } .reg-bar .forget { float: right; } .dowebok ::-webkit-input-placeholder { font-size: 18px; line-height: 1.4; color: #fff;} .dowebok :-moz-placeholder { font-size: 18px; line-height: 1.4; color: #fff;} .dowebok ::-moz-placeholder { font-size: 18px; line-height: 1.4; color: #fff;} .dowebok :-ms-input-placeholder { font-size: 18px; line-height: 1.4; color: #fff;} @media screen and (max-width: 500px) { * { box-sizing: border-box; } .dowebok { position: static; width: auto; height: auto; margin: 0 30px; border: 0; border-radius: 0; } .logo { margin: 50px auto; } .form-item { width: auto; } .form-item input, .form-item button, .reg-bar { width: 100%; } } 效果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"CSS","slug":"CSS","permalink":"https://melodyjerry.github.io/blog/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"}]},{"title":"CSS：页面美化和布局控制","slug":"CSS页面美化和布局控制","date":"2020-02-17T08:20:00.000Z","updated":"2020-04-23T11:40:36.724Z","comments":true,"path":"2020/02/17/CSS页面美化和布局控制/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/17/CSS%E9%A1%B5%E9%9D%A2%E7%BE%8E%E5%8C%96%E5%92%8C%E5%B8%83%E5%B1%80%E6%8E%A7%E5%88%B6/","excerpt":"概念Cascading Style Sheets :层叠样式表 层叠：多个样式可以作用在同一个html的元素上，同时生效 好处 功能强大 将内容展示和样式控制分离 降低耦合度。解耦 让分工协作更容易 提高开发效率","text":"概念Cascading Style Sheets :层叠样式表 层叠：多个样式可以作用在同一个html的元素上，同时生效 好处 功能强大 将内容展示和样式控制分离 降低耦合度。解耦 让分工协作更容易 提高开发效率 使用方式CSS与html结合方式 1.内联样式（作用域最小） 在标签内使用style属性指定css代码 如：&lt;div style=\"color:red;\"&gt;hello css&lt;/div&gt; 2.内部样式 在head标签内，定义style标签，style标签的标签体内容就是css代码 如：&lt;style&gt; div{ color:blue; } &lt;/style&gt; &lt;div&gt;hello css&lt;/div&gt; 3.外部样式（作用域最大） 定义css资源文件。 在head标签内，定义link标签，引入外部的资源文件 如： &lt;!--a.css文件--&gt; div{ color:green; } &lt;!--html文件--&gt; &lt;link rel=\"stylesheet\" href=\"css/a.css\"&gt; &lt;div&gt;hello css&lt;/div&gt; &lt;div&gt;hello css&lt;/div&gt; 特别注意 1,2,3种方式 css作用范围越来越大 第1方式不常用，后期常用第2,3种 第3种格式可以写为：&lt;style&gt; @import \"css/a.css\"; &lt;/style&gt; 语法格式 格式：选择器 { 属性名1:属性值1; 属性名2:属性值2; ... } 选择器:筛选具有相似特征的元素 注意：每一对属性需要使用；隔开，最后一对属性可以不加； 选择器筛选具有相似特征的元素 分类选择器分两种： 基础选择器 扩展选择器 基础选择器id选择器选择具体的id属性值的元素.建议在一个html页面中id值唯一 语法：#id属性值{ 属性名1:属性值1; 属性名2:属性值2; ... } 元素选择器选择具有相同标签名称的元素 语法：标签名称{ 属性名1:属性值1; 属性名2:属性值2; ... } 注意：id选择器优先级高于元素选择器 类选择器选择具有相同的class属性值的元素。 语法：.class属性值{ 属性名1:属性值1; 属性名2:属性值2; ... } 注意：类选择器选择器优先级高于元素选择器 扩展选择器选择所有元素 语法： * { 属性名1:属性值1; 属性名2:属性值2; ... } 并集选择器选择多个元素 语法：选择器1, 选择器2 { 属性名1:属性值1; 属性名2:属性值2; ... } 子选择器筛选 选择器1下 的 选择器2 元素 语法： 选择器1 选择器2{ 属性名1:属性值1; 属性名2:属性值2; ... } 区别于 子选择器： 多个选择器之间的分隔符，一个是逗号，一个是空格。 父选择器筛选 选择器2 的 父元素选择器1 语法： 选择器1 &gt; 选择器2{ 属性名1:属性值1; 属性名2:属性值2; ... } 属性选择器选择元素名称，属性名=属性值的元素 语法： 元素名称 [属性名 = \"属性值\"] { 属性名1:属性值1; 属性名2:属性值2; ... } 伪类选择器选择一些元素具有的状态 语法： 元素: 状态{ 属性名1:属性值1; 属性名2:属性值2; ... } 比如： a:link{ color:red; } a:hover{ color: yellow; } a:visited{ color: blue; } a:active{ color: brown; } &lt;a&gt;的状态：link：初始化的状态visited：被访问过的状态active：正在访问状态hover：鼠标悬浮状态 属性属性有字体、文本、背景、边框、尺寸…… 字体、文本 font-size：字体大小 color：文本颜色 text-align：对其方式 line-height：行高 背景 background：设置背景 边框 border：设置边框，符合属性 尺寸 width：宽度 height：高度 盒子模型：控制布局 margin：外边距 padding：内边距 默认情况下内边距会影响整个盒子的大小 box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 float：浮动 left right 实践案例这里有 70个CSS实例 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"CSS","slug":"CSS","permalink":"https://melodyjerry.github.io/blog/tags/CSS/"}]},{"title":"MySQL中的约束","slug":"MySQL中的约束","date":"2020-02-16T09:24:41.000Z","updated":"2020-04-23T11:40:36.770Z","comments":true,"path":"2020/02/16/MySQL中的约束/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/16/MySQL%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F/","excerpt":"什么是约束 约束：constraintMySQL中的约束，实则是对数据表中数据的限制条件 约束的作用 约束保证数据的完整性和一致性 比如：设计数据表时，要求username字段不允许重复，这时候就需要在CREATE数据表时加入相应的约束。再比如注册时候必须填写邮箱、性别等。 约束的分类按约束定义的位置可分 列级约束 表级约束 按约束的作用可分 主键 约束 PRIMARY KEY 外键 约束 FOREIGN KEY 非空 约束 NOT NULL 唯一 约束 UNIQUE KEY 默认 约束 DEFAULT","text":"什么是约束 约束：constraintMySQL中的约束，实则是对数据表中数据的限制条件 约束的作用 约束保证数据的完整性和一致性 比如：设计数据表时，要求username字段不允许重复，这时候就需要在CREATE数据表时加入相应的约束。再比如注册时候必须填写邮箱、性别等。 约束的分类按约束定义的位置可分 列级约束 表级约束 按约束的作用可分 主键 约束 PRIMARY KEY 外键 约束 FOREIGN KEY 非空 约束 NOT NULL 唯一 约束 UNIQUE KEY 默认 约束 DEFAULT 列级约束、表级约束区别 列级约束：只能应用于一列上。 表级约束：可以应用于一列上，也可以应用在一个表中的多个列上。 即：如果你创建的约束涉及到该表的多个属性列，则必须创建的是表级约束（必须定义在表级上）；否则既可以定义在列级上也可以定义在表级上此时只是SQL语句格式不同而已。 列级约束：包含在列定义中，直接跟在该列的其它定义之后 ，用空格分隔；不必指定列名。 表级约束：与列定义相互独立，不包含在列定义中；与定义用‘，’分隔；必须指出要约束的列的名称。 注：因为在创建列级约束时，只需将创建列约束的语句添加到该字段（列）的定义子句后面；而在创建表级约束时，需要将创建表级约束的语句添加到各个字段（列）定义语句的后面，因为并不是每个定义的字段都要创建约束，所以必须指明需要创建的约束的列名。 举例说明Create Table project( 项目编号 INT CONSTRAINT pk_pno PRIMARY kEY， 项目名称 CHAR(20)， 项目负责人 CHAR(20)， CONSTRAINT un_pname_pm UNIQUE(项目名称，项目负责人) ); 分析：“项目编号”字段设置为主键，主键约束名为pk_pno，此主键约束为列主键约束。“项目名称”和“项目负责人”的组合字段设置唯一性约束，此约束为表级约束） 具体说明一：既可以创建列级约束又可以创建表级约束的： 1、主键约束（primary key constraint）： （1）定义列约束：CONSTRAINT &lt;约束名&gt; PRIMARY KEY （2）定义表约束：[CONSTRAINT &lt;约束名&gt;] PRIMARY KEY( &lt;列名&gt; [{&lt;列名&gt;}]) 2、唯一性约束（unique key constraint）： （1）定义列约束：[CONSTRAINT &lt;约束名&gt;] UNIQUE [KEY] （2）定义表约束：CONSTRAINT &lt;约束名&gt; UNIQUE [KEY] ( &lt;列名&gt; [{&lt;列名&gt;}]) 3、外键约束（foreign key constraint）： 定义 列级约束：[CONSTRAINT &lt;约束名&gt;] FOREIGN KEY REFERENCES &lt;外表名&gt; 定义表级约束：[CONSTRAINT &lt;约束名&gt;] FOREIGN KEY REFERENCES &lt;外表名&gt;( &lt;列名&gt; [{&lt;列名&gt;}]) 二：只能创建列级约束的： 1，缺省约束（default constraint）： [CONSTRAINT &lt;约束名&gt;] DEFAULT 约束条件 2，NULL 约束： [CONSTRAINT &lt;约束名&gt;] [NULL | NOT NULL] 主键约束 PRIMARY KEY“主键（PRIMARY KEY）”的完整称呼是“主键约束”。MySQL 主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。 涉及术语 主键约束 主键字段 主键值 三种术语的关系： 表中的某个字段添加主键约束后，该字段为主键字段，主键字段中出现的每一个数据都称为主键值 特点 保证数据的实体完整性 要求 一张表应该有主键字段，如果没有，表示该表无效 主键值：是当前行数据的唯一标识、是当前行数据的身份证号 即使表中两行记录相关数据相同，但由于主键值不同，所以也认为是两行不同的记录 按主键约束的字段数量分类 在MySQL的一个表中只有唯一的一个主键，不能有多列主键，但可以有复合主键。一个表中可以：单列做主键、多列做主键（复合主键）。 单一主键：给一个字段添加主键约束 复合主键：给多个字段联合添加一个主键约束(只能用表级定义) 单一主键（列级定义）mysql&gt; create table t_user( -&gt; id int(10) primary key, -&gt; name varchar(32) -&gt; ); Query OK, 0 rows affected (0.07 sec) 单一主键（表级定义）mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; constraint t_user_id_pk primary key(id) -&gt; ); Query OK, 0 rows affected (0.01 sec) 复合主键（表级定义） 一定要在表级定义。 mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; email varchar(128) unique, -&gt; primary key(id,name) -&gt; ); Query OK, 0 rows affected (0.05 sec) 配合AUTO_INCREMENT 在MySQL数据库提供了一个自增的数字，专门用来自动生成主键值，主键值不用用户维护，自动生成，自增数从1开始，以1递增(auto_increment) mysql&gt; create table t_user( -&gt; id int(10) primary key auto_increment, -&gt; name varchar(32) not null -&gt; ); Query OK, 0 rows affected (0.03 sec) /*插入两行记录，id主键值会自动增加*/ mysql&gt; insert into t_user(name) values('jay'); Query OK, 1 row affected (0.04 sec) mysql&gt; insert into t_user(name) values('man'); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from t_user; +----+------+ | id | name | +----+------+ | 1 | jay | | 2 | man | +----+------+ 2 rows in set (0.00 sec) 外键约束 FOREIGN KEY外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。 外键的主要作用是保持数据的一致性、完整性。例如，部门表 tb_dept 的主键是 id，在员工表 tb_emp5 中有一个键 deptId 与这个 id 关联。 主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表。 从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表。 快速理解之前创建表的时候都是在一张表中添加记录，比如如下表： 公司有3个部门，但是有1个亿的员工，那意味着部门这个字段需要重复存储，部门名字越长，越浪费。这个时候，解决方法：我们完全可以定义一个部门表，然后让员工信息表关联该表，如何关联，即foreign key。 我们可以将上表改为如下结构： 涉及到的术语 外键约束 外键字段 外键值 三种术语的关系： 某个字段添加外键约束之后，该字段称为外键字段，外键字段中每个数据都是外键值 特点 保持数据的一致性 完整性 实现一对一或者一对多关系 这也是为什么称为MySQL关系型数据库的原因 要求 ★父表（子表所参照的表）和子表（具有外键列的表）必须使用使用相同的存储引擎，而且禁止使用临时表。 ★外键对应的是参照完整性，一个表的外键可以为NULL，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。 ★定义外键时，创建先创建父表。定义外键后，插入先插入父表数据，同理，删除先删除子表数据。 数据表的存储引擎只能为InnoDB。（编辑数据库的默认存储引擎，修改完需要重启MySQL服务） 外键列（加FOREIGN KEY关键词的一列）和参照列（外键列参照的一列）必须具有相似的数据类型,如果是数字数据类型，则数字长度或者是否有符号位必须相同；如果为字符数据类型长度可以不同。 ★外键列和参照列（主键在创建的同时，会自动创建索引seq_in_index）必须创建索引。如果外键列不存在索引的话，MySQL将自动创建。 与主键的区别 一张表可以有多个外键，但是主键最多只有一个。 按外键约束的字段数量分类 单一外键：给一个字段添加外键约束 复合外键：给多个字段联合添加一个外键约束 表复合外键（表级定义）FOREIGN KEY(classno) REFERENCES t_class(cno); 非空约束用NOT NULL约束的字段不能为NULL值，必须给定具体的数据。 注意的是 NULL，表示空，并不是字符串中的空。两者需要区分开。 实例mysql&gt; CREATE TABLE t12(id INT NOT NULL); #设置字段id不为空 Query OK, 0 rows affected (0.03 sec) mysql&gt; DESC t12; +-------+---------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+---------+------+-----+---------+-------+ | id | int(11) | NO | | NULL | | +-------+---------+------+-----+---------+-------+ row in set (0.01 sec) 验证 mysql&gt; INSERT INTO t12 VALUES(); #不能插入空 ERROR 1364 (HY000): Field 'id' doesn't have a default value 唯一约束UNIQUE约束的字段，具有唯一性，不可重复，但可以为NULL。 列级约束mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; email varchar(128) unique -&gt; ); Query OK, 0 rows affected (0.03 sec) 表级约束mysql&gt; create table t_user( -&gt; id int(10), -&gt; name varchar(32) not null, -&gt; email varchar(128）， -&gt; unique(email) -&gt; ); 如果插入相同email会报错 mysql&gt; insert into t_user(id,name,email) values(1,'xlj','932834897@qq.com'); Query OK, 1 row affected (0.00 sec) mysql&gt; insert into t_user(id,name,email) values(2,'jay','932834897@qq.com'); ERROR 1062 (23000): Duplicate entry '932834897@qq.com' for key 'email' 扩展：联合唯一约束# 创建services表 mysql&gt; create table services( id int, ip char(15), port int, unique(id), unique(ip,port) ); Query OK, 0 rows affected (0.05 sec) mysql&gt; desc services; +-------+----------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+----------+------+-----+---------+-------+ | id | int(11) | YES | UNI | NULL | | | ip | char(15) | YES | MUL | NULL | | | port | int(11) | YES | | NULL | | +-------+----------+------+-----+---------+-------+ rows in set (0.01 sec) #联合唯一，只要两列记录，有一列不同，既符合联合唯一的约束 mysql&gt; insert into services values (1,'192,168,11,23',80), (2,'192,168,11,23',81), (3,'192,168,11,25',80); Query OK, 3 rows affected (0.01 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql&gt; select * from services; +------+---------------+------+ | id | ip | port | +------+---------------+------+ | 1 | 192,168,11,23 | 80 | | 2 | 192,168,11,23 | 81 | | 3 | 192,168,11,25 | 80 | +------+---------------+------+ rows in set (0.00 sec) mysql&gt; insert into services values (4,'192,168,11,23',80); ERROR 1062 (23000): Duplicate entry '192,168,11,23-80' for key 'ip' 更多可参考 mysql 给表添加唯一约束、联合唯一约束，指定唯一约束的名字 默认约束为某一字段提供默认值。 创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值 实例create table tb1( id int not null, sex char defalut 'b' ); 验证 mysql&gt; insert into tb1(id) values(1); #给t11表插一个空的值 Query OK, 1 row affected (0.00 sec) #查询结果如下 mysql&gt; select * from t11; +------+------+ | id | sex | +------+------+ | 1 | b | +------+------+ row in set (0.00 sec) 主要文献：[部分概念来自C语言中文网] http://c.biancheng.net/view/2440.html[大部分案例的代码块来自CSDN] https://blog.csdn.net/w_linux/article/details/79655073 注：案例中的SQL语句并非作者写的，存在规范问题，但不影响阅读。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[转]MySQL数据类型：UNSIGNED注意事项","slug":"转-MySQL数据类型：UNSIGNED注意事项","date":"2020-02-16T07:58:09.000Z","updated":"2020-04-23T11:40:36.822Z","comments":true,"path":"2020/02/16/转-MySQL数据类型：UNSIGNED注意事项/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/16/%E8%BD%AC-MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9AUNSIGNED%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"原文链接：https://www.cnblogs.com/blankqdb/archive/2012/11/03/blank_qdb.html","text":"原文链接：https://www.cnblogs.com/blankqdb/archive/2012/11/03/blank_qdb.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"HTML：基础网页开发语言","slug":"HTML基础网页开发语言","date":"2020-02-16T06:43:00.000Z","updated":"2020-04-23T11:40:36.735Z","comments":true,"path":"2020/02/16/HTML基础网页开发语言/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/16/HTML%E5%9F%BA%E7%A1%80%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/","excerpt":"概念HTML是最基础的网页开发语言 Hyper Text Markup Language 超文本标记语言 超文本 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本 标记语言 由标签构成的语言。 &lt;标签名称&gt; ,如 &lt;html&gt;，&lt;xml&gt; 标记语言不是编程语言 快速入门语法 html文档后缀名: .html 或者 .htm 标签分为 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt; 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt; 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 html的标签不区分大小写，但是建议使用小写html的标签 代码示例&lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color='red'&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color='green'&gt;Hello World&lt;/font&gt; &lt;/body&gt; &lt;/html&gt;","text":"概念HTML是最基础的网页开发语言 Hyper Text Markup Language 超文本标记语言 超文本 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本 标记语言 由标签构成的语言。 &lt;标签名称&gt; ,如 &lt;html&gt;，&lt;xml&gt; 标记语言不是编程语言 快速入门语法 html文档后缀名: .html 或者 .htm 标签分为 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt; 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt; 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 html的标签不区分大小写，但是建议使用小写html的标签 代码示例&lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color='red'&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color='green'&gt;Hello World&lt;/font&gt; &lt;/body&gt; &lt;/html&gt; 标签学习文件标签 构成html最基本的标签 html html文档的根标签 head 头标签。用于指定html文档的一些属性。引入外部的资源 title 标题标签。 body 体标签 html5中定义该文档是html文档 文本标签 和文本有关的标签 &lt;!-- --&gt;：注释 &lt;h1&gt;~&lt;h6&gt;：标题标签 h1~h6:字体大小逐渐递减 &lt;p&gt;：段落标签 &lt;br&gt;：换行标签 &lt;hr&gt;：展示一条水平线 属性： color：颜色 width：宽度 size：高度 align：对其方式 center：居中 left：左对齐 right：右对齐 &lt;b&gt;：字体加粗 &lt;i&gt;：字体斜体 &lt;center&gt;:文本居中 &lt;font&gt;:字体标签 属性： color：颜色 size：大小 face：字体 属性定义color 英文单词： red,green,blue rgb(值1，值2，值3)： 值的范围：0~255 如 rgb(0,0,255) #值1值2值3： 值的范围：00~FF之间。如： #FF00FF width 数值： width=’20’ ,数值的单位，默认是 px(像素) 数值% width=’20%’,占比相对于父元素的比例 图片标签&lt;img&gt;：展示图片 属性src：指定图片的位置 相对路径：以.开头的路径 ./:代表当前目录, 如 ./image/1.jpg ../:代表上一级目录 代码&lt;!--展示一张图片 img--&gt; &lt;img src=\"image/jingxuan_2.jpg\" align=\"right\" alt=\"古镇\" width=\"500\" height=\"500\"/&gt; &lt;img src=\"./image/jiangwai_1.jpg\"&gt; &lt;img src=\"../image/jiangwai_1.jpg\"&gt; 列表标签有序列表最外层用&lt;ol&gt;内层&lt;li&gt;：列表项 注意 默认为 数字1 开始排序。 可使用 type 属性，规定排序方式为“1/A/a/Ⅰ/ⅰ”。建议使用CSS样式。 也可以用 start 属性，规定起始位置。但是 HTML5 不赞成使用。建议使用CSS样式。 无序列表最外层用&lt;ul&gt;内层&lt;li&gt;：列表项 注意 默认列表项符号为 实心圆点· 。 可使用 type 属性，规定符号为“disc/square/circle” 。但是HTML5不支持。建议使用CSS样式。 链接标签&lt;a&gt;:定义一个超链接 属性 href：指定访问资源的URL(统一资源定位符) target：指定打开资源的方式 _self:默认值，在当前页面打开 _blank：在空白页面打开 代码&lt;!-- 文本 --&gt; &lt;a href=\"http://www.itcast.cn\"&gt;点我&lt;/a&gt; &lt;a href=\"http://www.itcast.cn\" target=\"_self\"&gt;点我&lt;/a&gt; &lt;a href=\"http://www.itcast.cn\" target=\"_blank\"&gt;点我&lt;/a&gt; &lt;!-- 图片 --&gt; &lt;a href=\"http://www.itcast.cn\"&gt;&lt;img src=\"image/jiangwai_1.jpg\"&gt;&lt;/a&gt; div&lt;div&gt;:每一个div占满一整行。块级标签 属性align left right center justify 不赞成使用。请使用样式取而代之。 代码示例&lt;div class=\"news\"&gt; &lt;h2&gt;News headline 1&lt;/h2&gt; &lt;p&gt;some text. some text. some text...&lt;/p&gt; ... &lt;/div&gt; 注意/提示 是一个块级元素，也就是说，浏览器通常会在 div 元素前后放置一个换行符。 如果用 id 或 class 来标记 &lt;div&gt;，那么该标签的作用会变得更加有效。 提示：请使用 元素来组合块级元素，这样就可以使用样式对它们进行格式化。 全局属性 标签支持 HTML 中的[全局属性](https://www.w3school.com.cn/tags/html_ref_standardattributes.asp)。 事件属性 标签支持 HTML 中的[事件属性](https://www.w3school.com.cn/tags/html_ref_eventattributes.asp)。 span&lt;span&gt;:文本信息在一行展示，行内标签 内联标签 代码示例&lt;p&gt;&lt;span&gt;some text.&lt;/span&gt;some other text.&lt;/p&gt; 注意/提示可以为 span 应用 id 或 class 属性，这样既可以增加适当的语义，又便于对 span 应用样式。 可以对同一个 元素应用 class 或 id 属性，但是更常见的情况是只应用其中一种。这两者的主要差异是，class 用于元素组（类似的元素，或者可以理解为某一类元素），而 id 用于标识单独的唯一的元素。 提示：事实上，您也许已经注意到了，W3School 站点上有一些文本的样式与其他文本是不同的。比如“提示”使用了粗体的橘红色。尽管实现这种效果的方法非常多，但是我们的做法是：使用“提示”使用 span 元素，然后对这个 span 元素的父元素，即 p 元素应用 class，这样就可以对这个类的子元素 span 应用相应的样式了。 HTML: &lt;p class=\"tip\"&gt;&lt;span&gt;提示：&lt;/span&gt;... ... ...&lt;/p&gt; CSS: p.tip span { font-weight:bold; color:#ff9955; } 全局属性 标签支持 HTML 中的全局属性。 事件属性 标签支持 HTML 中的事件属性。 语义化标签html5中为了提高程序的可读性，提供了一些标签。 &lt;header&gt;：页眉 &lt;footer&gt;：页脚 表格标签 &lt;table&gt;：定义表格 width：宽度 border：边框 cellpadding：定义内容和单元格的距离 cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、 bgcolor：背景色 align：对齐方式 &lt;tr&gt;：定义行 bgcolor：背景色 align：对齐方式 &lt;td&gt;：定义单元格 colspan：合并列 rowspan：合并行 &lt;th&gt;：定义表头单元格 &lt;caption&gt;：表格标题 &lt;thead&gt;：表示表格的头部分 &lt;tbody&gt;：表示表格的体部分 &lt;tfoot&gt;：表示表格的脚部分 表单标签 概念：用于采集用户输入的数据的。用于和服务器进行交互。 &lt;form&gt;：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围 &lt;form&gt;中的属性 action：指定提交数据的URL method:指定提交方式 分类：一共7种，2种比较常用 get： 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。 请求参数大小是有限制的。 不太安全。 post： 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解) 请求参数的大小没有限制。 较为安全。 注意表单项中的数据要想被提交：必须指定其name属性 表单项标签&lt;input&gt;可以通过type属性值，改变元素展示的样式 type属性 text：文本输入框，默认值 placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 password：密码输入框 radio:单选框 注意： 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 checkbox：复选框 注意： 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 file：文件选择框 hidden：隐藏域，用于提交一些信息。 按钮： submit：提交按钮。可以提交表单 button：普通按钮 image：图片提交按钮 src属性指定图片的路径 &lt;label&gt;指定输入项的文字描述信息 注意：label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。 &lt;select&gt;下拉列表select 元素可创建单选或多选菜单。 注意：&lt;select&amp;&gt; 元素中的 &lt;option&gt; 标签用于定义列表中的可用选项。 &lt;textarea&gt;文本域 属性： cols：指定列数，每一行有多少个字符 rows：默认多少行 表单案例&lt;!--定义表单 form--&gt; &lt;form action=\"#\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"username\"&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"username\" id=\"username\" placeholder=\"请输入用户名\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"password\"&gt;密码&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"password\" name=\"password\" id=\"password\" placeholder=\"请输入密码\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"email\"&gt;Email&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"email\" name=\"email\" id=\"email\" placeholder=\"请输入邮箱\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"name\"&gt;姓名&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"name\" id=\"name\" placeholder=\"请输入姓名\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"tel\"&gt;手机号&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"tel\" id=\"tel\" placeholder=\"请输入手机号\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt; &lt;input type=\"radio\" name=\"gender\" value=\"male\"&gt; 男 &lt;input type=\"radio\" name=\"gender\" value=\"female\"&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"birthday\"&gt;出生日期&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"date\" name=\"birthday\" id=\"birthday\" placeholder=\"请输入出生日期\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"checkcode\" &gt;验证码&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"checkcode\" id=\"checkcode\" placeholder=\"请输入验证码\"&gt; &lt;img id=\"img_check\" src=\"img/verify_code.jpg\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\" align=\"center\"&gt;&lt;input type=\"submit\" id=\"btn_sub\" value=\"注册\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"}]},{"title":"JavaWeb 概述","slug":"JavaWeb 概述","date":"2020-02-16T03:17:00.000Z","updated":"2020-04-23T11:40:36.766Z","comments":true,"path":"2020/02/16/JavaWeb 概述/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/16/JavaWeb%20%E6%A6%82%E8%BF%B0/","excerpt":"JavaWeb使用Java语言开发基于互联网的项目 今后主要使用B/S架构 软件架构C/S：Clien/Server 客服端/服务器端在用户本地有一个客户端程序，在远程有一个服务器端。如：QQ，讯雷…… 优点 用户体验好 缺点 开发、安装、部署、维护，麻烦 ★B/S：Browser/Server 浏览器/服务器端只需要一个浏览器，用户通过不同的网站（URL），客户访问不同的服务器端程序 优点： 开发、安装、部署、维护，简单 缺点 如果应用过大，用户的体验可能会受到影响 对硬件要求过高（带宽要高，……）","text":"JavaWeb使用Java语言开发基于互联网的项目 今后主要使用B/S架构 软件架构C/S：Clien/Server 客服端/服务器端在用户本地有一个客户端程序，在远程有一个服务器端。如：QQ，讯雷…… 优点 用户体验好 缺点 开发、安装、部署、维护，麻烦 ★B/S：Browser/Server 浏览器/服务器端只需要一个浏览器，用户通过不同的网站（URL），客户访问不同的服务器端程序 优点： 开发、安装、部署、维护，简单 缺点 如果应用过大，用户的体验可能会受到影响 对硬件要求过高（带宽要高，……） B/S架构详解客户端浏览器通过URL，向服务器端发送请求，请求一些资源，资源就包括“静态资源”和“动态资源”。服务器端就会响应，返回这些资源。 B/S架构是JavaWeb开发中重要的架构 资源分类静态资源使用静态网页开发技术发布的资源 特点 所有用户访问，得到的结果是一样的 如：文本，图片，音频，视频，HTML，CSS，JavaScript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎 静态资源可以直接被浏览器解析 1.HTML，CSS，JavaScript 统称：静态网页开发技术，也称静态网页三剑客2.经过解析引擎解析后，可以在浏览器中浏览图片、文字、超链接等3.不同浏览器的解析引擎不同，最终显示的网页可能不同 HTML用于搭建基础网页，展示页面的内容 CSS用于美化页面，布局页面 JavaScript控制页面的元素，让页面有一些动态的效果 ★动态资源使用动态网页技术发布的资源 动态资源是今后学习JavaWeb的重点之一 特点 所用用户访问，得到的结果可能不一样 如：jsp/servlet，php，asp…… 如果用户请求的是动态资源，那么服务器会执行动态资源转换为静态资源，再发送给用户 学习动态资源前，必须学习静态资源！ 网络通信三要素IP 电子设备(计算机)在网络中的唯一标识 端口 应用程序在计算机中的唯一标识。 值范围：0~65536 传输协议 规定了数据传输的规则 基础协议： tcp：安全协议，三次握手。 速度稍慢。 udp：不安全协议。 速度快。 Web服务器软件服务器 安装了服务器软件的计算机 服务器软件 接收用户的请求，处理请求，做出响应 Web服务器软件 接收用户的请求，处理请求，做出响应。 在Web服务器软件中，可以部署Web项目，让用户通过浏览器来访问这些项目 Web容器 常见的Java相关的Web服务器软件 WebLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 WebSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 三大组件 Servlet：服务器小程序 Filter：过滤器 Listener：监听器 参照 https://www.cnblogs.com/kefir/p/9426754.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"Web","slug":"Web","permalink":"https://melodyjerry.github.io/blog/tags/Web/"}]},{"title":"Web 概述","slug":"Web 概述","date":"2020-02-16T03:17:00.000Z","updated":"2020-03-02T12:35:48.183Z","comments":true,"path":"2020/02/16/Web 概述/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/16/Web%20%E6%A6%82%E8%BF%B0/","excerpt":"JavaWeb使用Java语言开发基于互联网的项目 今后主要使用B/S架构 软件架构C/S：Clien/Server 客服端/服务器端在用户本地有一个客户端程序，在远程有一个服务器端。如：QQ，讯雷…… 优点 用户体验好 缺点 开发、安装、部署、维护，麻烦 ★B/S：Browser/Server 浏览器/服务器端只需要一个浏览器，用户通过不同的网站（URL），客户访问不同的服务器端程序 优点： 开发、安装、部署、维护，简单 缺点 如果应用过大，用户的体验可能会受到影响 对硬件要求过高（带宽要高，……）","text":"JavaWeb使用Java语言开发基于互联网的项目 今后主要使用B/S架构 软件架构C/S：Clien/Server 客服端/服务器端在用户本地有一个客户端程序，在远程有一个服务器端。如：QQ，讯雷…… 优点 用户体验好 缺点 开发、安装、部署、维护，麻烦 ★B/S：Browser/Server 浏览器/服务器端只需要一个浏览器，用户通过不同的网站（URL），客户访问不同的服务器端程序 优点： 开发、安装、部署、维护，简单 缺点 如果应用过大，用户的体验可能会受到影响 对硬件要求过高（带宽要高，……） B/S架构详解客户端浏览器通过URL，向服务器端发送请求，请求一些资源，资源就包括“静态资源”和“动态资源”。服务器端就会响应，返回这些资源。 B/S架构是JavaWeb开发中重要的架构 资源分类静态资源使用静态网页开发技术发布的资源 特点 所有用户访问，得到的结果是一样的 如：文本，图片，音频，视频，HTML，CSS，JavaScript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎 静态资源可以直接被浏览器解析 1.HTML，CSS，JavaScript 统称：静态网页开发技术，也称静态网页三剑客2.经过解析引擎解析后，可以在浏览器中浏览图片、文字、超链接等3.不同浏览器的解析引擎不同，最终显示的网页可能不同 HTML用于搭建基础网页，展示页面的内容 CSS用于美化页面，布局页面 JavaScript控制页面的元素，让页面有一些动态的效果 ★动态资源使用动态网页技术发布的资源 动态资源是今后学习JavaWeb的重点之一 特点 所用用户访问，得到的结果可能不一样 如：jsp/servlet，php，asp…… 如果用户请求的是动态资源，那么服务器会执行动态资源转换为静态资源，再发送给用户 学习动态资源前，必须学习静态资源！ 网络通信三要素IP 电子设备(计算机)在网络中的唯一标识 端口 应用程序在计算机中的唯一标识。 值范围：0~65536 传输协议 规定了数据传输的规则 基础协议： tcp：安全协议，三次握手。 速度稍慢。 udp：不安全协议。 速度快。 Web服务器软件服务器 安装了服务器软件的计算机 服务器软件 接收用户的请求，处理请求，做出响应 Web服务器软件 接收用户的请求，处理请求，做出响应。 在Web服务器软件中，可以部署Web项目，让用户通过浏览器来访问这些项目 Web容器 常见的Java相关的Web服务器软件 WebLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 WebSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"Web","slug":"Web","permalink":"https://melodyjerry.github.io/blog/tags/Web/"}]},{"title":"MySQL的数据类型","slug":"MySQL的数据类型","date":"2020-02-15T12:42:25.000Z","updated":"2020-02-15T03:21:21.247Z","comments":true,"path":"2020/02/15/MySQL的数据类型/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/15/MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"MySQL的数据类型数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。 如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。 MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持所有标准SQL数值数据类型。 MySQL支持多种类型，大致可以分为三类： 数值 日期/时间 字符(串)类型。 数据类型分类 数值类型（整数类型和小数类型） 整数类型：包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT。 小数类型： 浮点数类型包括 FLOAT 和 DOUBLE。 定点数类型为 DECIMAL。 日期/时间类型 包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。 字符类型（文本字符串和二进制字符串） 字符串类型：包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。 二进制类型：包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。","text":"MySQL的数据类型数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。 如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。 MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持所有标准SQL数值数据类型。 MySQL支持多种类型，大致可以分为三类： 数值 日期/时间 字符(串)类型。 数据类型分类 数值类型（整数类型和小数类型） 整数类型：包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT。 小数类型： 浮点数类型包括 FLOAT 和 DOUBLE。 定点数类型为 DECIMAL。 日期/时间类型 包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。 字符类型（文本字符串和二进制字符串） 字符串类型：包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。 二进制类型：包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 数值类型MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值(整数)数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值(小数)数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 整数类型 整数类型又称数值型数据，数值型数据类型主要用来存储数字。 MySQL提供了多种数值型数据类型，不同的数据类型提供不同的取值范围，可以存储的值范围越大，所需的存储空间也会越大。 MySQL 主要提供的整数类型有 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，其属性字段可以添加 AUTO_INCREMENT 自增约束条件。下表中列出了 MySQL 中的数值类型。 类型名称 说明 存储需求 TINYINT 很小的整数 1个字节 SMALLINT 小的整数 2个宇节 MEDIUMINT 中等大小的整数 3个字节 INT (INTEGHR) 普通大小的整数 4个字节 BIGINT 大整数 8个字节 从上表中可以看到，不同类型的整数存储所需的字节数不相同，占用字节数最小的是 TINYINT 类型，占用字节最大的是 BIGINT 类型，占用的字节越多的类型所能表示的数值范围越大。 根据占用字节数可以求出每一种数据类型的取值范围。例如，TINYINT 需要 1 个字节（8bit）来存储，那么 TINYINT 无符号数的最大值为 28-1，即 255；TINYINT 有符号数的最大值为 27-1，即 127。其他类型的整数的取值范围计算方法相同，如下表所示。 类型名称 有符号值 无符号值 字节数 TINYINT -128〜127(-2^7 ~ 2^7-1) 0 〜255(0 ~ 2^8-1) 1 SMALLINT -32768〜32767(-2^15 ~ 2^15-1) 0〜65535(0 ~ 2^16-1) 2 MEDIUMINT -8388608〜8388607(-2^23 ~ 2^23-1) 0〜16777215(0 ~ 2^24-1) 3 INT (INTEGER) -2147483648〜2147483647(-2^31 ~ 2^31-1) 0〜4294967295(0 ~ 2^32-1) 4 BIGINT -9223372036854775808〜9223372036854775807(-2^63 ~ 2^63-1) 0〜18446744073709551615(0 ~ 2^64-1) 8 提示：显示宽度和数据类型的取值范围是无关的。显示宽度只是指明 MySQL 最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充。如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，year 字段插入 19999，当使用 SELECT 查询该列值的时候，MySQL 显示的将是完整的带有 5 位数字的 19999，而不是 4 位数字的值。 其他整型数据类型也可以在定义表结构时指定所需的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。 不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。 小数类型MySQL 中使用浮点数和定点数来表示小数。 浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL。 浮点类型和定点类型都可以用(M, D)来表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。 浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2），分别表示显示宽度和小数位数。M 和 D 在 FLOAT 和DOUBLE 中是可选的，FLOAT 和 DOUBLE 类型将被保存为硬件所支持的最大精度。DECIMAL 的默认 D 值为 0、M 值为 10。 下表中列出了 MySQL 中的小数类型和存储需求。 类型名称 说明 存储范围 存储需求 FLOAT 单精度浮点数，精确到大约7位小数位 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 DECIMAL 类型不同于 FLOAT 和 DOUBLE。DOUBLE 实际上是以字符串的形式存放的，DECIMAL 可能的最大取值范围与 DOUBLE 相同，但是有效的取值范围由 M 和 D 决定。如果改变 M 而固定 D，则取值范围将随 M 的变大而变大。 从上表中可以看到，DECIMAL 的存储空间并不是固定的，而由精度值 M 决定，占用 M+2 个字节。 FLOAT 类型的取值范围如下： 有符号的取值范围：-3.402823466E+38～-1.175494351E-38。 无符号的取值范围：0 和 -1.175494351E-38～-3.402823466E+38。 DOUBLE 类型的取值范围如下： 有符号的取值范围：-1.7976931348623157E+308～-2.2250738585072014E-308。 无符号的取值范围：0 和 -2.2250738585072014E-308～-1.7976931348623157E+308。 提示：不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。 FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。 浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。 最后再强调一下：在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。 日期/时间类型MySQL 中有多处表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。 每个时间类型有一个有效值范围和一个”零”值。当指定不合法的MySQL不能表示的值时，系统将“零”值插入数据库中。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP（时间戳） YYYY-MM-DD HH:MM:SS 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 4 个字节 YEAR 类型YEAR 类型是一个单字节类型，用于表示年，在存储时只需要 1 个字节。可以使用各种格式指定 YEAR，如下所示： 以 4 位字符串或者 4 位数字格式表示的 YEAR，范围为 ‘1901’～’2155’。输入格式为 ‘YYYY’ 或者 YYYY，例如，输入 ‘2010’ 或 2010，插入数据库的值均为 2010。 以 2 位字符串格式表示的 YEAR，范围为 ‘00’ 到 ‘99’。’00’～’69’ 和 ‘70’～’99’ 范围的值分别被转换为 2000～2069 和 1970～1999 范围的 YEAR 值。’0’ 与 ‘00’ 的作用相同。插入超过取值范围的值将被转换为 2000。 以 2 位数字表示的 YEAR，范围为 1～99。1～99 和 70～99 范围的值分别被转换为 2001～2069 和 1970～1999 范围的 YEAR 值。注意，在这里 0 值将被转换为 0000，而不是 2000。 提示：两位整数范围与两位字符串范围稍有不同。例如，插入 3000 年，读者可能会使用数字格式的 0 表示 YEAR，实际上，插入数据库的值为 0000，而不是所希望的 3000。只有使用字符串格式的 ‘0’ 或 ‘00’，才可以被正确解释为 3000，非法 YEAR值将被转换为 0000。 TIME 类型TIME 类型用于只需要时间信息的值，在存储时需要 3 个字节。格式为 HH:MM:SS。HH 表示小时，MM 表示分钟，SS 表示秒。 TIME 类型的取值范围为 -838：59：59～838：59：59，小时部分如此大的原因是 TIME 类型不仅可以用于表示一天的时间（必须小于 24 小时），还可能是某个事件过去的时间或两个事件之间的时间间隔（可大于 24 小时，或者甚至为负）。 可以使用各种格式指定 TIME 值，如下所示。 ‘D HH：MM：SS’ 格式的字符串。还可以使用这些“非严格”的语法：’HH：MM：SS’、’HH：MM’、’D HH’ 或 ‘SS’。这里的 D 表示日，可以取 0～34 之间的值。在插入数据库时，D 被转换为小时保存，格式为 “D*24+HH”。 ‘HHMMSS’ 格式、没有间隔符的字符串或者 HHMMSS 格式的数值，假定是有意义的时间。例如，’101112’ 被理解为’10：11：12’，但是 ‘106112’ 是不合法的（它有一个没有意义的分钟部分），在存储时将变为 00：00：00。 提示：为 TIME 列分配简写值时应注意：如果没有冒号，MySQL 解释值时，假定最右边的两位表示秒。（MySQL 解释 TIME 值为过去的时间而不是当前的时间）。例如，读者可能认为 ‘1112’ 和 1112 表示 11：12：00（即 11 点过 12 分钟），但MySQL 将它们解释为 00：11：12（即 11 分 12 秒）。同样 ‘12’ 和 12 被解释为00：00：12。相反，TIME 值中如果使用冒号则肯定被看作当天的时间，也就是说，’11：12’ 表示 11：12：00，而不是 00：11：12。 DATE 类型DATE 类型用于仅需要日期值时，没有时间部分，在存储时需要 3 个字节。日期格式为 ‘YYYY-MM-DD’，其中 YYYY 表示年，MM 表示月，DD 表示日。 在给 DATE 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATE 的日期格式即可。如下所示： 以 ‘YYYY-MM-DD’ 或者 ‘YYYYMMDD’ 字符中格式表示的日期，取值范围为 ‘1000-01-01’～’9999-12-3’。例如，输入 ‘2015-12-31’ 或者 ‘20151231’，插入数据库的日期为2015-12-31。 以 ‘YY-MM-DD’ 或者 ‘YYMMDD’ 字符串格式表示日期，在这里YY表示两位的年值。MySQL 解释两位年值的规则：’00～69’ 范围的年值转换为 ‘20002069’，’7099’ 范围的年值转换为 ‘1970～1999’。例如，输入 ‘15-12-31’，插入数据库的日期为 2015-12-31；输入 ‘991231’，插入数据库的日期为 1999-12-31。 以 YYMMDD 数字格式表示的日期，与前面相似，00~69 范围的年值转换为 2000～2069，80～99 范围的年值转换为 1980～1999。例如，输入 151231，插入数据库的日期为 2015-12-31，输入 991231，插入数据库的日期为 1999-12-31。 使用 CURRENT_DATE 或者 NOW()，插入当前系统日期。 提示：MySQL 允许“不严格”语法：任何标点符号都可以用作日期部分之间的间隔符。例如，’98-11-31’、’98.11.31’、’98/11/31’和‘98@11@31’ 是等价的，这些值也可以正确地插入数据库。 DATETIME 类型DATETIME 类型用于需要同时包含日期和时间信息的值，在存储时需要 8 个字节。日期格式为 ‘YYYY-MM-DD HH：MM：SS’，其中 YYYY 表示年，MM 表示月，DD 表示日，HH 表示小时，MM 表示分钟，SS 表示秒。 在给 DATETIME 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATETIME 的日期格式即可，如下所示。 以 ‘YYYY-MM-DD HH：MM：SS’ 或者 ‘YYYYMMDDHHMMSS’ 字符串格式表示的日期，取值范围为 ‘1000-01-01 00：00：00’～’9999-12-3 23：59：59’。例如，输入 ‘2014-12-31 05：05：05’ 或者 ‘20141231050505’，插入数据库的 DATETIME 值都为 2014-12-31 05：05：05。 以 ‘YY-MM-DD HH：MM：SS’ 或者 ‘YYMMDDHHMMSS’ 字符串格式表示的日期，在这里 YY 表示两位的年值。与前面相同，’00～79’ 范围的年值转换为 ‘2000～2079’，’80～99’ 范围的年值转换为 ‘1980～1999’。例如，输入 ‘14-12-31 05：05：05’，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。 以 YYYYMMDDHHMMSS 或者 YYMMDDHHMMSS 数字格式表示的日期和时间。例如，输入 20141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 140505050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。 提示：MySQL 允许“不严格”语法：任何标点符号都可用作日期部分或时间部分之间的间隔符。例如，’98-12-31 11：30：45’、’98.12.31 11+30+35’、’98/12/31 113045’ 和 ‘98@12@31 11^30^45’ 是等价的，这些值都可以正确地插入数据库。 TIMESTAMP 类型TIMESTAMP 的显示格式与 DATETIME 相同，显示宽度固定在 19 个字符，日期格式为 YYYY-MM-DD HH：MM：SS，在存储时需要 4 个字节。但是 TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，为 ‘1970-01-01 00：00：01’UTC～’2038-01-19 03：14：07’UTC。在插入数据时，要保证在合法的取值范围内。 提示：协调世界时（英：Coordinated Universal Time，法：Temps Universel Coordonné）又称为世界统一时间、世界标准时间、国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。 TIMESTAMP 与 DATETIME 除了存储字节和支持的范围不同外，还有一个最大的区别是： DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关； 而 TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。 提示：如果为一个 DATETIME 或 TIMESTAMP 对象分配一个 DATE 值，结果值的时间部分被设置为 ‘00：00：00’，因此 DATE 值未包含时间信息。如果为一个 DATE 对象分配一个 DATETIME 或 TIMESTAMP 值，结果值的时间部分被删除，因此DATE 值未包含时间信息。 字符类型MySQL 支持两类字符型数据：字符串类型和二进制类型 包括CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小/存储需求 说明/用途 CHAR 0-255字节 定长字符串 CHAR(M) M 字节，1&lt;=M&lt;=255 固定长度非二进制字符串 VARCHAR 0-65535 字节 变长字符串 1VARCHAR(M) L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255 变长非二进制字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 ENUM（枚举值） 1或2个字节，取决于枚举值的数目 (最大值为65535) 枚举类型，只能有一个枚举字符串值。一次从中只选择一个。 SET（集合） 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） 一个设置，字符串对象可以有零个或 多个SET成员。在集合中做任意的排列组合（任取一个或几个数据） CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 字符串类型 又称“文本字符串类型”。 字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据。字符串可以区分或者不区分大小写的串比较，还可以进行正则表达式的匹配查找。 MySQL 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。 下表中列出了 MySQL 中的字符串数据类型，括号中的M表示可以为其指定长度。 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1&lt;=M&lt;=255 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255 TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L&lt;2^8 TEXT 小的非二进制字符串 L+2字节，在此，L&lt;2^16 MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L&lt;2^24 LONGTEXT 大的非二进制字符串 L+4字节，在此，L&lt;2^32 ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） VARCHAR 和 TEXT 类型是变长类型，其存储需求取决于列值的实际长度（在前面的表格中用 L 表示），而不是取决于类型的最大可能尺寸。 例如，一个 VARCHAR(10) 列能保存一个最大长度为 10 个字符的字符串，实际的存储需要字符串的长度 L 加上一个字节以记录字符串的长度。对于字符 “abcd”，L 是 4，而存储要求 5 个字节。 CHAR 和 VARCHAR 类型CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255 个字符。 例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当检索到 CHAR 值时，尾部的空格将被删除。 VARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0～65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。 例如，VARCHAR(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。VARCHAR 在值保存和检索时尾部的空格仍保留。 【实例】下面将不同的字符串保存到 CHAR(4) 和 VARCHAR(4) 列，说明 CHAR 和 VARCHAR 之间的差别，如下表所示。 插入值 CHAR(4) 存储需求 VARCHAR(4) 存储需求 ‘ ‘ ‘ ‘ 4字节 ‘’ 1字节 ‘ab’ ‘ab ‘ 4字节 ‘ab’ 3字节 ‘abc’ ‘abc ‘ 4字节 ‘abc’ 4字节 ‘abcd’ ‘abcd’ 4字节 ‘abcd’ 5字节 ‘abcdef’ ‘abcd’ 4字节 ‘abcd’ 5字节 对比结果可以看到，CHAR(4) 定义了固定长度为 4 的列，无论存入的数据长度为多少，所占用的空间均为 4 个字节。VARCHAR(4) 定义的列所占的字节数为实际长度加 1。 TEXT 类型TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。 TEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。 TINYTEXT 表示长度为 255（28-1）字符的 TEXT 列。 TEXT 表示长度为 65535（216-1）字符的 TEXT 列。 MEDIUMTEXT 表示长度为 16777215（224-1）字符的 TEXT 列。 LONGTEXT 表示长度为 4294967295 或 4GB（232-1）字符的 TEXT 列。 ENUM 类型ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下： &lt;字段名&gt; ENUM( '值1', '值1', …, '值n' ) 字段名指将要定义的字段，值 n 指枚举列表中第 n 个值。 ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。 ENUM 值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号，枚举最多可以有 65535 个元素。 例如，定义 ENUM 类型的列（’first’，’second’，’third’），该列可以取的值和每个值的索引如下表所示。 值 索引 NULL NULL ‘’ 0 ’first 1 second 2 third 3 ENUM 值依照列索引顺序排列，并且空字符串排在非空字符串前，NULL 值排在其他所有枚举值前。 提示：ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。 SET 类型SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下： SET( '值1', '值2', …, '值n' ) 与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。 但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。 提示：如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。 二进制类型 二进制字符串类型有时候也直接被称为“二进制类型”。 MySQL 中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 下表中列出了 MySQL 中的二进制数据类型，括号中的M表示可以为其指定长度。 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)/8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L&lt;2^8 BLOB (M) 小 BLOB L+2 字节，在此，L&lt;2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L&lt;2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L&lt;2^32 BIT 类型位字段类型。M 表示每个值的位数，范围为 1～64。如果 M 被省略，默认值为 1。如果为 BIT(M) 列分配的值的长度小于 M 位，在值的左边用 0 填充。例如，为 BIT(6) 列分配一个值 b’101’，其效果与分配 b’000101’ 相同。 BIT 数据类型用来保存位字段值，例如以二进制的形式保存数据 13，13 的二进制形式为 1101，在这里需要位数至少为 4 位的 BIT 类型，即可以定义列类型为 BIT(4)。大于二进制 1111 的数据是不能插入 BIT(4) 类型的字段中的。 提示：默认情况下，MySQL 不可以插入超出该列允许范围的值，因而插入数据时要确保插入的值在指定的范围内。 BINARY 和 VARBINARY 类型BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字节字符串。使用的语法格式如下： 列名称 BINARY(M) 或者 VARBINARY(M) BINARY 类型的长度是固定的，指定长度后，不足最大长度的，将在它们右边填充 “\\0” 补齐，以达到指定长度。例如，指定列数据类型为 BINARY(3)，当插入 a 时，存储的内容实际为 “\\a0\\0”，当插入 ab 时，实际存储的内容为“ab\\0”，无论存储的内容是否达到指定的长度，存储空间均为指定的值 M。 VARBINARY 类型的长度是可变的，指定好长度之后，长度可以在 0 到最大值之间。例如，指定列数据类型为 VARBINARY(20)，如果插入的值长度只有 10，则实际存储空间为 10 加 1，实际占用的空间为字符串的实际长度加 1。 BLOB 类型BLOB 是一个二进制的对象，用来存储可变数量的数据。BLOB 类型分为 4 种：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB，它们可容纳值的最大长度不同，如下表所示。 数据类型 存储范围 TINYBLOB 最大长度为255 (28-1)字节 BLOB 最大长度为65535 (216-1)字节 MEDIUMBLOB 最大长度为16777215 (224-1)字节 LONGBLOB 最大长度为4294967295或4GB (231-1)字节BLOB 列存储的是二进制字符串（字节字符串），TEXT 列存储的是非进制字符串（字符字符串）。BLOB 列是字符集，并且排序和比较基于列值字节的数值；TEXT 列有一个字符集，并且根据字符集对值进行排序和比较。 以上笔记部分来自 C语言中文网 、百度知道、CSDN。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"hexo d后，网页出现乱码？","slug":"hexo d连后，网页出现乱码？","date":"2020-02-15T05:49:36.000Z","updated":"2020-04-23T11:40:36.781Z","comments":true,"path":"2020/02/15/hexo d连后，网页出现乱码？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/15/hexo%20d%E8%BF%9E%E5%90%8E%EF%BC%8C%E7%BD%91%E9%A1%B5%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81%EF%BC%9F/","excerpt":"问题如平时一样hexo d部署我的博客，但是当我去浏览时候，竟发现乱码。 解决重新hexo三连即可。","text":"问题如平时一样hexo d部署我的博客，但是当我去浏览时候，竟发现乱码。 解决重新hexo三连即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"![rejected]master->master(fetch first)问题的解决方案","slug":"rejected-master-master-fetch-first-问题的解决方案","date":"2020-02-14T11:08:32.000Z","updated":"2020-04-23T11:40:36.793Z","comments":true,"path":"2020/02/14/rejected-master-master-fetch-first-问题的解决方案/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/rejected-master-master-fetch-first-%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"今天在做git push -u origin master时出现了如下错误： ! [rejected] master -&gt; master (fetch first) 分析原因，基本上可以确定是因为github上的远程库与本地库版本不一致（我对github上的文件做了编辑操作，且未更新到本地，当然也可能还有其他原因…），通过一番研究，找到了两种解决方案： 温柔型方案： 通过git pull先将本地库更新到与远程库一致的版本，但要注意本地库后来做的修改可能被覆盖，最好使用git fetch(不会自动合并)，查看更新情况再有选择合并，或者先将本地库修改过的文件备份，git pull后再重新修改； 再运行git push即可成功。 暴力型方案：git提供了一种强制上传的方式：git push -f，它会忽略版本不一致等问题，强制将本地库上传的远程库，但是一定要谨慎使用，因为-f会用本地库覆盖掉远程库，如果远程库上有重要更新，或者有其他同伴做的修改，也都会被覆盖，所以一定要在确定无严重后果的前提下使用此操作。","text":"今天在做git push -u origin master时出现了如下错误： ! [rejected] master -&gt; master (fetch first) 分析原因，基本上可以确定是因为github上的远程库与本地库版本不一致（我对github上的文件做了编辑操作，且未更新到本地，当然也可能还有其他原因…），通过一番研究，找到了两种解决方案： 温柔型方案： 通过git pull先将本地库更新到与远程库一致的版本，但要注意本地库后来做的修改可能被覆盖，最好使用git fetch(不会自动合并)，查看更新情况再有选择合并，或者先将本地库修改过的文件备份，git pull后再重新修改； 再运行git push即可成功。 暴力型方案：git提供了一种强制上传的方式：git push -f，它会忽略版本不一致等问题，强制将本地库上传的远程库，但是一定要谨慎使用，因为-f会用本地库覆盖掉远程库，如果远程库上有重要更新，或者有其他同伴做的修改，也都会被覆盖，所以一定要在确定无严重后果的前提下使用此操作。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"}]},{"title":"[转]使用Cmder替换cmd,让开发更高效","slug":"转-使用Cmder替换cmd-让开发更高效","date":"2020-02-14T08:40:25.000Z","updated":"2020-04-23T11:40:36.823Z","comments":true,"path":"2020/02/14/转-使用Cmder替换cmd-让开发更高效/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/%E8%BD%AC-%E4%BD%BF%E7%94%A8Cmder%E6%9B%BF%E6%8D%A2cmd-%E8%AE%A9%E5%BC%80%E5%8F%91%E6%9B%B4%E9%AB%98%E6%95%88/","excerpt":"","text":"第一篇文章https://segmentfault.com/a/1190000021029858?utm_source=tag-newest 以下为第二篇文章的内容 一、为什么要更换为cmder在做项目时，有些时候我想复制控制台上面的代码时，cmd有的时候复制粘贴很麻烦，Cmder则不会，并且Cmder可以分屏多开窗口，可以设置窗口颜色,字体大小，并且很多快捷键和谷歌浏览器操作类似,等等很多功能。 二、官网下载地址: http://cmder.net/ 关于下载进入官网以后，有mini版和完整版，建议完整版，完整版功能更齐全，还可以使用git，下载好解压文件包以后就可以使用。 Cmder界面展示启动Cmder界面如下，当然我设置了背景色，透明度，字体样式，隐藏标签栏栏，增加底部的状态栏，以及分屏功能。 Cmder界面展示 三、关于cmder的一些配置1. 配置环境变量:在系统属性里面配置环境变量，将Cmder.exe所在文件路径添加至Path里 2. 配置右键快捷启动:以管理员身份打开cmd，执行以下命令即可，完了以后在任意地方点击右键即可使用cmder // 设置任意地方鼠标右键启动Cmder Cmder.exe /REGISTER ALL 鼠标右键启动Cmder 3. 界面效果的设置首先使用windows+alt+p进入界面设置 背景色设置 字体设置 背景透明度 隐藏标签栏 显示底部状态栏 将Cmder默认的命令提示符\"λ\"改为“$”， 在cmder\\vendor中的clink.lua内做如下修改”λ”替换成”$” 四、关于Cmder的一些常用快捷键Tab 自动路径补全 Ctrl+T 建立新页签 Ctrl+W 关闭页签 Ctrl+Tab 切换页签 Alt+F4 关闭所有页签 Alt+Shift+1 开启cmd.exe Alt+Shift+2 开启powershell.exe Alt+Shift+3 开启powershell.exe (系统管理员权限) Ctrl+1 快速切换到第1个页签 Ctrl+n 快速切换到第n个页签( n值无上限) Alt + enter 切换到全屏状态 Ctr+r 历史命令搜索 Tab 自动路径补全 Ctrl+T 建立新页签 Ctrl+W 关闭页签 Ctrl+Tab 切换页签 Alt+F4 关闭所有页签 Alt+Shift+1 开启cmd.exe Alt+Shift+2 开启powershell.exe Alt+Shift+3 开启powershell.exe (系统管理员权限) Ctrl+1 快速切换到第1个页签 Ctrl+n 快速切换到第n个页签( n值无上限) Alt + enter 切换到全屏状态 Ctr+r 历史命令搜索 Win+Alt+P 开启工具选项视窗 五、关于中文乱码问题：将下面的4行命令添加到cmder/config/aliases文件末尾,如果还是不行参考前面字体设置，将前面提到的字体设置里面的Monospace的复选框不选中。还有就是养成良好的编码习惯文件命名最好不要有中文。 l=ls --show-control-chars la=ls -aF --show-control-chars ll=ls -alF --show-control-chars 作者：_123hhh链接：https://www.jianshu.com/p/5b7c985240a7来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"删除磁盘管理中的OEM分区","slug":"删除磁盘管理中的OEM分区","date":"2020-02-14T08:13:08.000Z","updated":"2020-04-23T11:40:36.797Z","comments":true,"path":"2020/02/14/删除磁盘管理中的OEM分区/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/%E5%88%A0%E9%99%A4%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84OEM%E5%88%86%E5%8C%BA/","excerpt":"用windows自带的工具-DISKPART来实现，而且不会破坏其他分区的数据，具体操作如下： 首先打开CMD，输入 diskpart.exe 回车 提示转入DISKPART 然后输入 rescan 回车 （扫描硬盘） 接着输入 list disk 回车 （硬盘列表，可以看到连接到该主机的硬盘列表） 选择一个磁盘： select disk 磁盘号 回车 显示磁盘中的分区： list partition 回车 选择一个分区： select partition 分区号 回车 删除分区： delete partition override 回车 基本就能删除OEM分区了。","text":"用windows自带的工具-DISKPART来实现，而且不会破坏其他分区的数据，具体操作如下： 首先打开CMD，输入 diskpart.exe 回车 提示转入DISKPART 然后输入 rescan 回车 （扫描硬盘） 接着输入 list disk 回车 （硬盘列表，可以看到连接到该主机的硬盘列表） 选择一个磁盘： select disk 磁盘号 回车 显示磁盘中的分区： list partition 回车 选择一个分区： select partition 分区号 回车 删除分区： delete partition override 回车 基本就能删除OEM分区了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"系统","slug":"系统","permalink":"https://melodyjerry.github.io/blog/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"[工具]ScreenToGif:一款小而实用的屏幕录制生成gif工具","slug":"工具-ScreenToGif-一款小而实用的屏幕录制生成gif工具","date":"2020-02-14T07:27:31.000Z","updated":"2020-04-23T11:40:36.812Z","comments":true,"path":"2020/02/14/工具-ScreenToGif-一款小而实用的屏幕录制生成gif工具/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/%E5%B7%A5%E5%85%B7-ScreenToGif-%E4%B8%80%E6%AC%BE%E5%B0%8F%E8%80%8C%E5%AE%9E%E7%94%A8%E7%9A%84%E5%B1%8F%E5%B9%95%E5%BD%95%E5%88%B6%E7%94%9F%E6%88%90gif%E5%B7%A5%E5%85%B7/","excerpt":"因为写博客或工作等原因，经常需要录制屏幕并制作gif图。ScreenToGif使用了小半年了，给我的感觉就是“小而实用”，大小仅2M多（压缩后才几百K），但却包含了录制及常用的gif处理功能。 ScreenToGif：仅从名字就可以了解到它是一款屏幕转gif图的软件。而事实上，它不仅可以录制屏幕，同时也包含了摄像头录制，白板书写录制等功能，并且在录制后，可以对录制内容进行增删、修改、压缩等处理。 ScreenToGif是一款免安装软件，下载并解压缩后，双击exe文件就可以运行。ScreenToGif还支持打开多次，以上Gif就是用一个ScreenToGif来录制另一个ScreenToGif界面。 上图是ScreenToGif编辑器主页，ScreenToGif分两大功能，录制和编辑，从上图可以看到其编辑功能还是蛮强大的，至少在常规gif制作的功能都包含了： 在编辑中有很多对帧的操作如:增加删除、循环、反转，特别是移除重复帧功能，能很好的减小gif占用内存大小； 而在图片选项中则包含了水印、微动、模糊、字幕、自由文本、自由绘制等功能； ScreenToGif还支持简单的过渡动画； 统计功能则提供了总帧数、总时长、帧大小、延时、帧分辨率等数据的统计； 如下图：在编辑结束后，我们可以根据需求选择适合的类型及编码进行保存； 到目前为止，ScreenToGif已适配20多种语言，并提供上传服务。 ScreenToGif是一个开源项目ScreenToGif Github，本文下方也提供目前最新的2.14.1版本免安装exe程序。 版本2.14.1下载地址 作者：ThinkinLiu_IT老五链接：https://www.jianshu.com/p/17121d0587fc来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","text":"因为写博客或工作等原因，经常需要录制屏幕并制作gif图。ScreenToGif使用了小半年了，给我的感觉就是“小而实用”，大小仅2M多（压缩后才几百K），但却包含了录制及常用的gif处理功能。 ScreenToGif：仅从名字就可以了解到它是一款屏幕转gif图的软件。而事实上，它不仅可以录制屏幕，同时也包含了摄像头录制，白板书写录制等功能，并且在录制后，可以对录制内容进行增删、修改、压缩等处理。 ScreenToGif是一款免安装软件，下载并解压缩后，双击exe文件就可以运行。ScreenToGif还支持打开多次，以上Gif就是用一个ScreenToGif来录制另一个ScreenToGif界面。 上图是ScreenToGif编辑器主页，ScreenToGif分两大功能，录制和编辑，从上图可以看到其编辑功能还是蛮强大的，至少在常规gif制作的功能都包含了： 在编辑中有很多对帧的操作如:增加删除、循环、反转，特别是移除重复帧功能，能很好的减小gif占用内存大小； 而在图片选项中则包含了水印、微动、模糊、字幕、自由文本、自由绘制等功能； ScreenToGif还支持简单的过渡动画； 统计功能则提供了总帧数、总时长、帧大小、延时、帧分辨率等数据的统计； 如下图：在编辑结束后，我们可以根据需求选择适合的类型及编码进行保存； 到目前为止，ScreenToGif已适配20多种语言，并提供上传服务。 ScreenToGif是一个开源项目ScreenToGif Github，本文下方也提供目前最新的2.14.1版本免安装exe程序。 版本2.14.1下载地址 作者：ThinkinLiu_IT老五链接：https://www.jianshu.com/p/17121d0587fc来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"[随笔]相信自己","slug":"随笔-相信自己","date":"2020-02-14T06:55:11.000Z","updated":"2020-03-02T12:35:48.222Z","comments":true,"path":"2020/02/14/随笔-相信自己/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/14/%E9%9A%8F%E7%AC%94-%E7%9B%B8%E4%BF%A1%E8%87%AA%E5%B7%B1/","excerpt":"下午，起兴想整理笔记本里的数据时，发现了一些有趣的东西，拿出一部分来记作随笔。 相信自己在个人文件夹中，发现一个名为“相信自己”的Word文档，点开来，里面就一句话，简简单单的一句“如果有时候怀疑了，觉得不知道自己为什么一开始要做这个选择，或者觉得自己付出太多不值得，那就想想当初自己做这个决定的初心。或许一切就能释然了”。 一起玩耍吧18年，在网上看到一个视频，教用一些简单VB代码来制作的小程序。 只有连续点击确定/是，才能结束程序。 用来表白/坑人，挺不错的hh 猜猜我用来干嘛呢 ( ͡° ͜ʖ ͡°)✧ ~ 演示👇 制作过程很简单，新建一个txt文本，粘贴我写好的代码，保存后修改后缀为.vbs，完事。 代码👇 msgbox \"我们可以一起玩吗？\",vbQuestion,\"在吗？\" msgbox (\"可以吗？\") dim j do while j&lt;1 Select Case msgbox(\"真的真的真的可以吗？\",68,\"请郑重的回答我\") Case 6 j=1 Case 7 msgbox(\"别嘛，我就是要和你一起玩\") end Select loop msgbox(\"我就知道你会同意的，啦啦啦\")","text":"下午，起兴想整理笔记本里的数据时，发现了一些有趣的东西，拿出一部分来记作随笔。 相信自己在个人文件夹中，发现一个名为“相信自己”的Word文档，点开来，里面就一句话，简简单单的一句“如果有时候怀疑了，觉得不知道自己为什么一开始要做这个选择，或者觉得自己付出太多不值得，那就想想当初自己做这个决定的初心。或许一切就能释然了”。 一起玩耍吧18年，在网上看到一个视频，教用一些简单VB代码来制作的小程序。 只有连续点击确定/是，才能结束程序。 用来表白/坑人，挺不错的hh 猜猜我用来干嘛呢 ( ͡° ͜ʖ ͡°)✧ ~ 演示👇 制作过程很简单，新建一个txt文本，粘贴我写好的代码，保存后修改后缀为.vbs，完事。 代码👇 msgbox \"我们可以一起玩吗？\",vbQuestion,\"在吗？\" msgbox (\"可以吗？\") dim j do while j&lt;1 Select Case msgbox(\"真的真的真的可以吗？\",68,\"请郑重的回答我\") Case 6 j=1 Case 7 msgbox(\"别嘛，我就是要和你一起玩\") end Select loop msgbox(\"我就知道你会同意的，啦啦啦\") 💗我爱你们，爸妈！💗看到，我才发现我原来备份了一部分19年七八两月的一些照片。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"IDEA添加jar包的三种方式(小结)","slug":"IDEA 添加jar包的三种方式(小结)","date":"2020-02-13T09:36:53.000Z","updated":"2020-04-23T11:40:36.754Z","comments":true,"path":"2020/02/13/IDEA 添加jar包的三种方式(小结)/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/13/IDEA%20%E6%B7%BB%E5%8A%A0jar%E5%8C%85%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F(%E5%B0%8F%E7%BB%93)/","excerpt":"相关文章： 1、https://www.jb51.net/article/145327.htm 2、https://blog.csdn.net/wangxinyao1997/article/details/87527391 3、https://blog.csdn.net/simple_start/article/details/92422833 4、https://blog.csdn.net/yogima/article/details/81186092?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task","text":"相关文章： 1、https://www.jb51.net/article/145327.htm 2、https://blog.csdn.net/wangxinyao1997/article/details/87527391 3、https://blog.csdn.net/simple_start/article/details/92422833 4、https://blog.csdn.net/yogima/article/details/81186092?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"}]},{"title":"绚丽彩虹播放器","slug":"绚丽彩虹播放器","date":"2020-02-13T08:16:30.000Z","updated":"2020-04-23T11:40:36.817Z","comments":true,"path":"2020/02/13/绚丽彩虹播放器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/13/%E7%BB%9A%E4%B8%BD%E5%BD%A9%E8%99%B9%E6%92%AD%E6%94%BE%E5%99%A8/","excerpt":"","text":"代码来自绚丽彩虹播放器 &lt;!-- Your XlchPlayerKey --&gt; &lt;script&gt;XlchKey=\"O7NQ6f6YIg\";&lt;/script&gt; &lt;!-- font-awesome 4.2.0 --&gt; &lt;link href=\"https://lib.baomitu.com/font-awesome/4.2.0/css/font-awesome.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt; &lt;!-- JQuery 2.2.4 --&gt; &lt;script src=\"https://lib.baomitu.com/jquery/2.2.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- JQuery-mousewheel 3.1.9 --&gt; &lt;script src=\"https://lib.baomitu.com/jquery-mousewheel/3.1.9/jquery.mousewheel.min.js\"&gt;&lt;/script&gt; &lt;!-- Scrollbar --&gt; &lt;script src=\"https://static.https.badapple.top/BadApplePlayer/js/scrollbar.js\"&gt;&lt;/script&gt; &lt;!-- BadApplePlayer --&gt; &lt;script src=\"https://static.https.badapple.top/BadApplePlayer/Player.js\"&gt;&lt;/script&gt; 教程：https://www.liaofuzhan.com/posts/2636059693.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"动态时钟","slug":"动态时钟","date":"2020-02-13T05:28:19.000Z","updated":"2020-02-13T05:51:42.682Z","comments":true,"path":"2020/02/13/动态时钟/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/13/%E5%8A%A8%E6%80%81%E6%97%B6%E9%92%9F/","excerpt":"效果：","text":"效果： 在相应位置添加如下代码： &lt;center&gt; &lt;div&gt;&lt;canvas id=\"canvas\" style=\"width:20%\" width=\"820\" height=\"250\"&gt;&lt;/canvas&gt;&lt;/div&gt; &lt;script async=\"\"&gt;!function(){function t(t){var r=[];a.fillStyle=\"#1bc3fb\";var h=new Date,u=70,s=30,v=h.getHours(),g=Math.floor(v/10),m=v%10;r.push({num:g}),r.push({num:m}),r.push({num:10});var c=h.getMinutes(),g=Math.floor(c/10),m=c%10;r.push({num:g}),r.push({num:m}),r.push({num:10});var M=h.getSeconds(),g=Math.floor(M/10),m=M%10;r.push({num:g}),r.push({num:m});for(var p=0;p&lt;r.length;p++)r[p].offsetX=u,u=f(u,s,r[p].num,t),p&lt;r.length-1&amp;&amp;10!=r[p].num&amp;&amp;10!=r[p+1].num&amp;&amp;(u+=l);if(0==i.length)i=r;else for(var C=0;C&lt;i.length;C++)i[C].num!=r[C].num&amp;&amp;(n(r[C]),i[C].num=r[C].num);return e(t),o(),h}function n(t){for(var n=t.num,e=m[n],o=0;o&lt;e.length;o++)for(var f=0;f&lt;e[o].length;f++)if(1==e[o][f]){var a={offsetX:t.offsetX+u+2*u*f,offsetY:30+u+2*u*o,color:g[Math.floor(Math.random()*g.length)],g:1.5+Math.random(),vx:4*Math.pow(-1,Math.ceil(10*Math.random()))+Math.random(),vy:-5};v.push(a)}}function e(t){for(var n=0;n&lt;v.length;n++)t.beginPath(),t.fillStyle=v[n].color,t.arc(v[n].offsetX,v[n].offsetY,u,0,2*Math.PI),t.fill()}function o(){for(var t=0,n=0;n&lt;v.length;n++){var e=v[n];e.offsetX+=e.vx,e.offsetY+=e.vy,e.vy+=e.g,e.offsetY&gt;h-u&amp;&amp;(e.offsetY=h-u,e.vy=-e.vy*s),e.offsetX&gt;u&amp;&amp;e.offsetX&lt;r-u&amp;&amp;(v[t]=v[n],t++)}for(;t&lt;v.length;t++)v.pop()}function f(t,n,e,o){for(var f=m[e],a=0;a&lt;f.length;a++)for(var r=0;r&lt;f[a].length;r++)1==f[a][r]&amp;&amp;(o.beginPath(),o.arc(t+u+2*u*r,n+u+2*u*a,u,0,2*Math.PI),o.fill());return o.beginPath(),t+=f[0].length*u*2}var a,r=820,h=250,u=7,l=10,s=.65,v=[];const g=[\"#33B5E5\",\"#0099CC\",\"#AA66CC\",\"#9933CC\",\"#99CC00\",\"#669900\",\"#FFBB33\",\"#FF8800\",\"#FF4444\",\"#CC0000\"];var i=[],m=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]],c=document.getElementById(\"canvas\");c.width=r,c.height=h,a=c.getContext(\"2d\");new Date;setInterval(function(){a.clearRect(0,0,a.canvas.width,a.canvas.height),t(a)},50)}()&lt;/script&gt; &lt;/center&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"[转]Hexo主题使用Valine-Admin管理评论和评论提醒","slug":"转-Hexo主题使用Valine-Admin管理评论和评论提醒","date":"2020-02-12T16:31:06.000Z","updated":"2020-02-12T17:20:04.551Z","comments":true,"path":"2020/02/13/转-Hexo主题使用Valine-Admin管理评论和评论提醒/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/13/%E8%BD%AC-Hexo%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8Valine-Admin%E7%AE%A1%E7%90%86%E8%AF%84%E8%AE%BA%E5%92%8C%E8%AF%84%E8%AE%BA%E6%8F%90%E9%86%92/","excerpt":"原文链接：https://segmentfault.com/a/1190000021474516?utm_source=tag-newest 前言原本今天在写文章，然后没事就去博客看了一下。突然发现有人在文章下面评论。是早上评论的但是我晚上才看到。 我的留言系统使用的是Valine,发现留言并没有提醒，只有回复了才会有提醒。 这不能忍。毕竟好不容易来个朋友竟然没有交流上你说难受不难受😡 然后我就去百度了一下Valine-Admin Valine-Admin 是一个对 Valine 评论系统的拓展应用，可增强 Valine 的邮件通知功能。基于 Leancloud 的云引擎与云函数。可以提供邮件 通知站长 和 @ 通知 的功能，而且还支持自定义邮件通知模板。 发现这个插件很不错我就研究了一下。下面是整合教程。","text":"原文链接：https://segmentfault.com/a/1190000021474516?utm_source=tag-newest 前言原本今天在写文章，然后没事就去博客看了一下。突然发现有人在文章下面评论。是早上评论的但是我晚上才看到。 我的留言系统使用的是Valine,发现留言并没有提醒，只有回复了才会有提醒。 这不能忍。毕竟好不容易来个朋友竟然没有交流上你说难受不难受😡 然后我就去百度了一下Valine-Admin Valine-Admin 是一个对 Valine 评论系统的拓展应用，可增强 Valine 的邮件通知功能。基于 Leancloud 的云引擎与云函数。可以提供邮件 通知站长 和 @ 通知 的功能，而且还支持自定义邮件通知模板。 发现这个插件很不错我就研究了一下。下面是整合教程。 使用首先其他的不错说了，在阅读本篇文章之前你最好已经整合了Valine留言。 由于我已经整合过了所以前面几个步骤的图片来源自@Valine-Admin 首先登陆账号，找到云引擎在点击设置。 复制仓库地址：https://github.com/zhaojun199… 把git仓库地址房子代码库输入框中。 切换到部署标签页，分支使用 master，点击部署。 接下来输入分支为master 部署完成之后就是设置环境变量 环境变量点击设置，找到自定义环境变量点击新增变量 SITE_NAME : 网站名称。 SITE_URL : 网站地址, 最后不要加 / 。 SMTP_USER : SMTP 服务用户名，一般为邮箱地址。 SMTP_PASS : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式 SMTP_SERVICE : 邮件服务提供商，支持 QQ、163、126、Gmail、\"Yahoo\"、...... ，全部支持请参考 : Nodemailer Supported services。 — 如这里没有你使用的邮件提供商，请查看自定义邮件服务器 SENDER_NAME : 寄件人名称。 TO_EMAIL：这个是填收邮件提醒的邮箱地址，若没有这个字段，则将邮件发到SMTP_USER。 TEMPLATE_NAME：设置提醒邮件的主题，目前内置了两款主题，分别为 default 与 rainbow。默认为 default 设置好以上变量之后 点击实例 然后重启项目，注意任何变动都要重启项目 然后看一下效果 还不错 自定义后台点击设置然后点击Web主机域名找到自己的后台地址 然后在存储-数据-_User表中增加账号， 只需要填写 email、password、username 其中邮箱必须设置为你的上面环境变量的邮箱 设置完之后登录就能在你的后台管理评论 解决休眠免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行： 每天必须休眠 6 个小时 30 分钟内没有外部请求，则休眠。 休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。 也就是如果服务器休眠了的话用户第一次评论是提醒不了的。 参考了Valine-Admin官网找到了解决办法。 首先在环境变量ADMIN_URL增加服务器地址，就是你的后台服务器地址 下面是你的服务器地址，可以自定义 同样登录后台 找到定时任务 然后点击创建任务，上面是我创建好的 选择self_wake函数，然后运行时间使用cron表达式 0 0/30 7-23 ? 表示每天6点到11点 每30分钟叫醒服务器一次 这样就完美的解决了服务器休眠的问题 那如果用户不在时间范围内发留言了怎么办？我们也可以创建一个捡漏的定时任务 创建捡漏定时任务 然后运行函数选择resend_mails,同样使用cron表达式 0 0 8 ? 表示每八个小时进行捡漏一次，这样如果有留言遗漏的话就能即使的提醒。 附 crontab 定时器代码：** */20 7-23 * * * curl https://你配置的域名前缀.leanapp.cn 结语有人会说了不久一个破博客吗？都不知道有没有人看干嘛还要这么麻烦。其实并不麻烦，这只是一个态度而已。 欢迎关注我的公众号，也可在公众号进行留言会及时回复 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}],"author":{"name":"乱敲代码","url":"https://segmentfault.com/a/1190000021474516?utm_source=tag-newest"}},{"title":"一些关于halo博客的资源","slug":"一些关于halo博客的资源","date":"2020-02-11T08:23:57.000Z","updated":"2020-04-23T11:40:36.794Z","comments":true,"path":"2020/02/11/一些关于halo博客的资源/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/11/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8Ehalo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%B5%84%E6%BA%90/","excerpt":"https://github.com/halo-dev/halo-app/releases halo教程https://ryanc.cc/tags/halo Docker Compose 部署Halo教程https://ryanc.cc/archives/docker-compose-run-halo halo替换hexohttps://wenthywang.cn/archives/2019070217154001586/ halo替换hexohttps://www.shizuri.net/Z-Turn/halo.html","text":"https://github.com/halo-dev/halo-app/releases halo教程https://ryanc.cc/tags/halo Docker Compose 部署Halo教程https://ryanc.cc/archives/docker-compose-run-halo halo替换hexohttps://wenthywang.cn/archives/2019070217154001586/ halo替换hexohttps://www.shizuri.net/Z-Turn/halo.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"halo","slug":"halo","permalink":"https://melodyjerry.github.io/blog/tags/halo/"}]},{"title":"任正非:唯一有愧的是对不起父母","slug":"任正非-唯一有愧的是对不起父母","date":"2020-02-11T05:58:08.000Z","updated":"2020-02-13T05:16:48.084Z","comments":true,"path":"2020/02/11/任正非-唯一有愧的是对不起父母/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/11/%E4%BB%BB%E6%AD%A3%E9%9D%9E-%E5%94%AF%E4%B8%80%E6%9C%89%E6%84%A7%E7%9A%84%E6%98%AF%E5%AF%B9%E4%B8%8D%E8%B5%B7%E7%88%B6%E6%AF%8D/","excerpt":"前言​ 前几天，弟在做高考语文预测卷时，突然跟我说“老哥，你去看看任正非的文章《我的父亲母亲》，很有深意”。在看完文章后还有一篇作者是柳传志的读后感。对这两篇文章深有感触，所以专门开设并记录在博文里。","text":"前言​ 前几天，弟在做高考语文预测卷时，突然跟我说“老哥，你去看看任正非的文章《我的父亲母亲》，很有深意”。在看完文章后还有一篇作者是柳传志的读后感。对这两篇文章深有感触，所以专门开设并记录在博文里。 《我的父亲母亲》—— 任正非 《我的父亲母亲》 任正非 【一】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;上世纪末最后一天，我总算良心发现，在公务结束之后，买了一张从北京去昆明的机票，去看看妈妈。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;买好机票后，我没有给她打电话，我知道一打电话她一下午都会忙碌，不管多晚到达，都会给我做一些我小时候喜欢吃的东西。直到飞机起飞，我才告诉她，让她不要告诉别人，不要车来接，我自己坐出租车回家，目的就是好好陪陪她。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;前几年我每年也去看看妈妈，但一下飞机就给办事处接走了，说这个客户很重要，要拜见一下，那个客户很重要，要陪他们吃顿饭，忙来忙去，忙到上飞机时回家取行李，与父母匆匆告别。妈妈盼星星、盼月亮，盼唠唠家常，却一次又一次地落空。 【二】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;一个普通的早上，妈妈从菜市场出来，提着两小包菜，被汽车撞成重伤。我身在伊朗，飞机要多次中转才能回来，在巴林转机要待6.5个小时，真是心如煎熬，又遇巴林雷雨，飞机延误两个小时，到曼谷时又晚了10分钟，没有及时赶上回昆明的飞机，直到深夜才赶到昆明。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;回到昆明，就知道妈妈不行了，她的头部全部给撞坏了，当时的心跳、呼吸全是靠药物和机器维持，之所以在电话上不告诉我，是怕我在旅途中出事。我看见妈妈一声不响地安详地躺在病床上，不用操劳、烦心，好像她一生也没有这么休息过。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我真后悔没有在伊朗给妈妈打一个电话。因为以前不管我在国内、国外给她打电话时，她都唠叨：“你又出差了”，“非非你的身体还不如我好呢”，“非非你的皱纹比妈妈还多呢”，“非非你走路还不如我呢，你这么年纪轻轻就这么多病”，“非非，糖尿病参加宴会多了，坏得更快呢，你的心脏又不好”…… &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我想伊朗条件这么差，我一打电话，妈妈又唠叨，反正过不了几天就见面了，就没有打，而这是我一生中最大的憾事。如果我真打了，拖延她一两分钟出门，也许妈妈就躲过了这场灾难。这种悔恨的心情，真是难以形容。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我看了妈妈最后一眼，妈妈溘然去世。 【三】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1995年，我父亲在昆明街头的小摊上买了一瓶塑料包装的软饮料，喝后拉肚子，一直到全身衰竭去世。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;父亲任摩逊，尽职尽责一生，可以说是一个乡村教育家。妈妈程远昭，是一个陪伴父亲在贫困山区与穷孩子厮混了一生的一个普通得不能再普通的园丁。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;父亲穿着土改工作队的棉衣，随解放军剿匪部队一同进入贵州少数民族山区去筹建一所民族中学。一头扎进去就是几十年，他培养的学生不少成为党和国家的高级干部，有些还是中央院校的校级领导，而父亲还是那么位卑言微。 【四】 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我与父母相处的青少年时代，印象最深的就是度过三年自然灾害的困难时期。今天想来还历历在目。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我们兄妹七个，加上父母共九人。全靠父母微薄的工资来生活，毫无其他来源。本来生活就十分困难，儿女一天天在长大，衣服一天天在变短，而且都要读书，开支很大，每个学期每人要交2-3元的学费，到交费时，妈妈每次都发愁。我经常看到妈妈月底就到处向人借钱度饥荒，而且常常走了几家都未必借到。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;直到高中毕业我没有穿过衬衣。有同学看到很热的天，我还穿着厚厚的外衣，就让我向妈妈要一件衬衣，我不敢，因为我知道做不到。我上大学时妈妈一次送我两件衬衣，我真想哭，因为，我有衬衣了，弟妹们就会更难了。我家当时是2-3人合用一条被盖，而且破旧的被单下面铺的是稻草。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;上大学我要拿走一条被子，就更困难了，因为那时还实行布票、棉花票管制，最少的一年，每人只发0.5米布票。没有被单，妈妈捡了毕业学生丢弃的几床破被单缝缝补补，洗干净，这条被单就在重庆陪我度过了五年的大学生活。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我们家当时每餐实行严格分饭制，控制所有人欲望的配给制，保证人人都能活下来。如果不是这样，总会有一个、两个弟妹活不到今天。我真正能理解活下去这句话的含义。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;高三快高考时，我有时在家复习功课，实在饿得受不了了，用米糠和菜合一下，烙着吃，被父亲碰上几次，他心疼了。其实那时我家穷得连一个可上锁的柜子都没有，粮食是用瓦缸装着，我也不敢去随便抓一把。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;高考前三个月，妈妈经常在早上塞给我一个小小的玉米饼，要我安心复习功课，我能考上大学，小玉米饼功劳巨大。如果不是这样，也许我就进不了华为这样的公司，社会上多了一名养猪能手，或街边多了一名能工巧匠而已。这个小小的玉米饼，是从父母与弟妹的口中抠出来的，我无以报答他们。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;“记住知识就是力量，别人不学，你要学，不要随大流。”“以后有能力要帮助弟妹。”背负着这种重托，我在当时的环境下，将樊映川的高等数学习题集从头到尾做了两遍，学习了逻辑、哲学。还自学了三门外语，当时已到可以阅读大学课本的程度，终因我不是语言天才，加之在军队服务时用不上，20多年荒废，完全忘光了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我当年穿走父亲的皮鞋，没念及父亲那时是做苦工的，泥里水里，冰冷潮湿，他更需要鞋子。现在回忆起来，感觉自己太自私了。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;回顾我自己已走过的历史，唯一有愧的是对不起父母，没条件时没有照顾他们，有条件时也没有照顾他们。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;爸爸，妈妈，千声万声呼唤你们，千声万声唤不回。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;逝者已经逝去，活着的还要前行。 ​ ——2001年2月8日 于深圳 《要想富就要知道为何穷》——柳传志 《要想富就要知道为何穷》 柳传志 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;在手机上读着一篇任正非写的怀念他的父母亲的文章，而脑子里却想起了另一件事。那是2013年9月，我接到了一个邀请函。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;那天我是真的有事，但出于对老任发自内心的敬佩和尊重，我尽力挤开了别的事情，花了一个半小时的车程赶到了会场。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;老任的面子确实大，那天是贵州都匀一中的“校训研讨会”，真请来了不少领导和知名的企业家。他看见我来了显得非常高兴。我也高兴，那是因为在企业工作者里面，我们都是属于少有的“老家伙”序列里的人，相互都比较了解，然而又极少见面，所以紧紧的握手不愿松开。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;原来都匀一中就是任正非的母校，他的父亲在此曾任过三年校长，他毕生从事教育工作，50多年来倾注了全部的心血。在现任学校领导介绍学校的历史，介绍老任的父亲任摩逊先生事迹的时候，我注意盯着任正非，我想这样的内容他应该听过无数遍了，他却依然听得那么专注，那么动情! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;此刻我正在读他写的怀念他的父母的文章，我认真读这篇文章，是因为深深引起了我的共鸣。我和他是同年生人，我们的出生背景有所不同，但是上一辈在政治上受到的磨难和考验几乎是相同的。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;任正非谈到他的父亲在这考验的重压之下，依旧勤勤恳恳拼力地工作，为他自己后来在华为拼命地工作做出了表率，而父辈的榜样在他身上打下了深深的烙印。我的父亲也是我的榜样。给我最深刻的印象是在强大的政治压力下，他能够像以前教导我的那样，用行动做出表率-做一个正直的人。正直，这是一个多么平常的词藻，然而在特殊的考验面前，这个词就超过了千钧的分量。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1966年文化革命爆发的第一个年头，我亲眼看到我的父亲在威逼面前不肯诬陷当年的战友，被开除党籍。当时的气氛紧张惊恐。这深深地印在了我的脑海中，而我的父亲以身教的方式告诉了我如何做人，什么叫正直! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;联想发展到今天的三十年中，经过的风险无其数，尤其在早期还有一定的政策风险，我自诩是个敢担当的人，而在联想结出胜利果实时，我也以为自己是个舍得让利的人，这对联想能发展到今天也许有一定的影响。和任正非一样，我们能以身作则地把企业利益放在个人利益的前面。追根溯源，是我们的父辈给我们打下了如何做人的基础。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当我读到任正非的母亲是因为意外车祸辞世的，我的心一下子揪了起来。我能想象对他那是一种什么样的撕心裂肺! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;任正非讲到他在高三那年(也应该是我高三的那年吧，就是最困难的1961年)，母亲经常早上塞给他一个小小的玉米饼，他说我能考上大学，小玉米饼的功劳巨大，这个小小的玉米饼是从父母与弟妹的口中抠出来的，我无以报答他们。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我相信绝大多数的80后、90后的朋友是读不出玉米饼的感觉的，因为他们不懂什么叫饥饿。61年，我是北京25中的一名高三学生，我们中学生是早上8、9点钟的太阳，所以享受着最高待遇，一个月32斤粮，半斤油，半斤肉。知道什么叫一个月半斤油吗? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;那是在一锅熬白菜煮熟的时候，油瓶口顺着筷子点入几滴油，使锅里漂着油花，一个月下来，这半斤油就用完了。知道什么叫饿吗?那就是耗干净你身上的脂肪，然后再耗你的肌肉。有一天夜里，我饿的实在受不了，想起抽屉里有一盒中药是羚翘解毒丸，我就吃了两颗，几小时后药性发作，抽筋断肠，头痛欲裂。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;经过饥饿的人才知道什么叫从父母弟妹的嘴里面抠出的玉米饼。任正非想念着母亲，我何尝不想念自己的母亲、不想起在那最艰难的岁月里，母亲对我的慈爱。我的父母都已经去世了，我和老任一样也是老大，我会永远记住父母的恩德慈爱。我有兄弟姐妹四人，我们会永远相亲相爱。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我在想，读了老任的文章，是什么让我会拿起笔说了上边这段话，我想说给谁听呢? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;说给老任?让他知道我是他的知音?说给我的亲人、朋友、同学、同事?让我们更加珍惜今天的生活? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;好像是，但也不是。我明白，我最想说给那些年青、年少的，甚至是儿童，让他们长大了听。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我一直告诫自己不要成为一个碎嘴唠叨的老头。而说这些话，我估计孩子们是不爱听的。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;前些天，我看了一部叫“归来”的电影，写的是我亲眼看见过的年代，亲眼看见过的事情，电影演毕，潸然泪下。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;问过几个年青人是否看过这部片子，都说没有。有一个对我说：人总是要向前看么，老说那些老话，凄凄惨惨有什么意思?!他们爱看光鲜亮丽、富有、任性的电影，那是他们的追求。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;他们不爱看“归来”，不爱听我碎嘴唠叨，但我还是忍不住想对他们说，到底为了什么? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;因为我们这个民族就在不久以前还很苦，很凄惨，很窝囊。你要想今后过得富有光鲜亮丽，你就要知道过去为什么穷，为什么苦，为什么受人欺负。你就要懂得历史，你就要从中学到教训，我们已经是为数不多的见过那段历史的尾巴的人了，尽量还原真实的历史是我们的责任。不管你是哪国国籍，但你和你的子孙血管中流的是中国人的血，这是无法改变的事实! &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我谈不上是高尚的人，更谈不上是纯粹的人。但我努力在做一个知恩图报的人，做一个懂廉耻、要自强的人。我希望几十年以后，今天年青、年少的人们能凭追求、凭团结、凭实力让中国富强，让自己过上光鲜亮丽富有的生活。 重要文献[1] 题目《任正非：唯一有愧的是对不起父母》，摘自百家号“金融界”， https://baijiahao.baidu.com/s?id=1644249222074823165&amp;wfr=spider&amp;for=pc [2] 原文，转自凤凰网，http://news.ifeng.com/c/7nKjN9F2Uy0 [3] 插图，来自网络 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"文章","slug":"文章","permalink":"https://melodyjerry.github.io/blog/tags/%E6%96%87%E7%AB%A0/"}]},{"title":"解决bash: hexo: command not found","slug":"解决bash-hexo-command-not-found","date":"2020-02-10T13:28:02.000Z","updated":"2020-02-11T10:56:14.938Z","comments":true,"path":"2020/02/10/解决bash-hexo-command-not-found/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/10/%E8%A7%A3%E5%86%B3bash-hexo-command-not-found/","excerpt":"记录一次离奇的车祸现场。 问题今天用hexo新建文章hexo new时git报错： bash: hexo: command not found 解决办法将G:\\blog_gitee\\node_modules\\.bin添加进PATH。 原因可能是因为我今天更新npm了？","text":"记录一次离奇的车祸现场。 问题今天用hexo新建文章hexo new时git报错： bash: hexo: command not found 解决办法将G:\\blog_gitee\\node_modules\\.bin添加进PATH。 原因可能是因为我今天更新npm了？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"[转]CentOS 7镜像下载","slug":"转-CentOS-7镜像下载","date":"2020-02-10T13:26:37.000Z","updated":"2020-02-11T10:56:14.946Z","comments":true,"path":"2020/02/10/转-CentOS-7镜像下载/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/10/%E8%BD%AC-CentOS-7%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD/","excerpt":"官网下载链接：http://isoredirect.centos.org/centos/7/isos/x86_64/ step1: 进入下载页，选择阿里云站点进行下载 Actual Country 国内资源 Nearby Countries 周边国家资源 阿里云站点：http://mirrors.aliyun.com/centos/7/isos/x86_64/ 每个链接都包括了镜像文件的地址、类型及版本号等信息 选择当前国家资源区站点下载，获取资源速度比较快 step1: 进入阿里云站点，选择 CentOS-7-x86_64-DVD-1804.iso下载 各个版本的ISO镜像文件说明： CentOS-7-x86_64-DVD-1708.iso 标准安装版（推荐） CentOS-7-x86_64-Everything-1708.iso 完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像） CentOS-7-x86_64-LiveGNOME-1708.iso GNOME桌面版 CentOS-7-x86_64-LiveKDE-1708.iso KDE桌面版 CentOS-7-x86_64-Minimal-1708.iso 精简版，自带的软件最少 CentOS-7-x86_64-NetInstall-1708.iso 网络安装版（从网络安装或者救援系统） 作者：Ada54链接：https://www.jianshu.com/p/a63f47e096e8来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","text":"官网下载链接：http://isoredirect.centos.org/centos/7/isos/x86_64/ step1: 进入下载页，选择阿里云站点进行下载 Actual Country 国内资源 Nearby Countries 周边国家资源 阿里云站点：http://mirrors.aliyun.com/centos/7/isos/x86_64/ 每个链接都包括了镜像文件的地址、类型及版本号等信息 选择当前国家资源区站点下载，获取资源速度比较快 step1: 进入阿里云站点，选择 CentOS-7-x86_64-DVD-1804.iso下载 各个版本的ISO镜像文件说明： CentOS-7-x86_64-DVD-1708.iso 标准安装版（推荐） CentOS-7-x86_64-Everything-1708.iso 完整版，集成所有软件（以用来补充系统的软件或者填充本地镜像） CentOS-7-x86_64-LiveGNOME-1708.iso GNOME桌面版 CentOS-7-x86_64-LiveKDE-1708.iso KDE桌面版 CentOS-7-x86_64-Minimal-1708.iso 精简版，自带的软件最少 CentOS-7-x86_64-NetInstall-1708.iso 网络安装版（从网络安装或者救援系统） 作者：Ada54链接：https://www.jianshu.com/p/a63f47e096e8来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"镜像","slug":"镜像","permalink":"https://melodyjerry.github.io/blog/tags/%E9%95%9C%E5%83%8F/"}]},{"title":"给Hexo博客添加不蒜子统计","slug":"给Hexo博客添加不蒜子统计","date":"2020-02-10T05:46:31.000Z","updated":"2020-04-23T11:40:36.817Z","comments":true,"path":"2020/02/10/给Hexo博客添加不蒜子统计/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/10/%E7%BB%99Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1/","excerpt":"","text":"引入不蒜子&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 这段代码可以写在footer.ejs里或者header.ejs里或者layout.ejs里 添加站点访问量通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里加上如下标签： &lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次 &lt;/span&gt; 计算访问量的方法有两种： 算法a：pv的方式，单个用户连续点击n篇文章，记录 n次访问量。 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 添加文章访问量文章的访问量显示在文章里面，所以在article.ejs里加上文章访问量的标签： &lt;span id=\"busuanzi_container_page_pv\"&gt; 本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次 &lt;/span&gt; 这个标签里的汉字可以自行修改，还可以给标签写上你想要的样式。 参考： 不蒜子|不如 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"到博客里养鱼","slug":"到博客里养鱼","date":"2020-02-09T11:32:03.000Z","updated":"2020-04-23T11:40:36.801Z","comments":true,"path":"2020/02/09/到博客里养鱼/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E5%88%B0%E5%8D%9A%E5%AE%A2%E9%87%8C%E5%85%BB%E9%B1%BC/","excerpt":"鱼🐟","text":"鱼🐟 &lt;!-- 底部加了小鱼&lt;・)))&gt;&lt;&lt;~ --&gt; &lt;a name=\"top\"&gt;&lt;/a&gt; &lt;div id=\"page_begin_html\"&gt;&lt;marquee hspace=\"20\" vspace=\"20\" width=\"220\" bgcolor=\"White\"&gt;公告：欢迎访问我的博客😘，希望你在这里可以找到你需要的东西！本站内容为个人经验之谈，如有错误，欢迎指正！&lt;/marquee&gt; &lt;script type=\"text/javascript\"&gt;window['__document_write_ajax_callbacks__']['2']();&lt;/script&gt;&lt;script&gt;window['__document_write_ajax_callbacks__']['1']();&lt;/script&gt; &lt;/div&gt; &lt;!--done--&gt; &lt;!--end: home 自定义的最大容器 --&gt; &lt;div id=\"page_end_html\"&gt; &lt;script type=\"text/javascript\" src=\"https://js.users.noscript.cnitblog.com/20537745.js\"&gt;&lt;/script&gt; &lt;!-- 鼠标点击特效 --&gt; &lt;script src=\"https://example.com/cursor-effects.js\"&gt;&lt;/script&gt; &lt;!-- 鼠标点击特效end --&gt; &lt;!-- 页面点击小红心 --&gt; &lt;script&gt;!function(e,t,a){function n(){c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)}function o(){var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(\"div\");a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(\"style\");a.type=\"text/css\";try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(\"head\")[0].appendChild(a)}function s(){return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);&lt;/script&gt; &lt;!-- 底部加了小鱼&lt;・)))&gt;&lt;&lt;~ --&gt; &lt;script src=\"https://common.cnblogs.com/scripts/jquery-2.2.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 底部加了小鱼&lt;・)))&gt;&lt;&lt;~ --&gt; &lt;div id=\"jsi-flying-fish-container\" class=\"container\"&gt;&lt;canvas width=\"1010\" height=\"153\"&gt;&lt;/canvas&gt;&lt;/div&gt; &lt;script src=\"https://blog-static.cnblogs.com/files/elkyo/fish.js\"&gt;&lt;/script&gt; &lt;script src=\"https://common.cnblogs.com/scripts/jquery-2.2.0.min.js\"&gt;&lt;/script&gt; &lt;div id=\"jsi-flying-fish-container\" class=\"container\"&gt;&lt;canvas width=\"1058\" height=\"158\"&gt;&lt;/canvas&gt;&lt;/div&gt; &lt;script&gt; var RENDERER = { POINT_INTERVAL : 5, FISH_COUNT : 3, MAX_INTERVAL_COUNT : 50, INIT_HEIGHT_RATE : 0.5, THRESHOLD : 50, init : function(){ this.setParameters(); this.reconstructMethods(); this.setup(); this.bindEvent(); this.render(); }, setParameters : function(){ this.$window = $(window); this.$container = $('#jsi-flying-fish-container'); this.$canvas = $('&lt;canvas /&gt;'); this.context = this.$canvas.appendTo(this.$container).get(0).getContext('2d'); this.points = []; this.fishes = []; this.watchIds = []; }, createSurfacePoints : function(){ var count = Math.round(this.width / this.POINT_INTERVAL); this.pointInterval = this.width / (count - 1); this.points.push(new SURFACE_POINT(this, 0)); for(var i = 1; i &lt; count; i++){ var point = new SURFACE_POINT(this, i * this.pointInterval), previous = this.points[i - 1]; point.setPreviousPoint(previous); previous.setNextPoint(point); this.points.push(point); } }, reconstructMethods : function(){ this.watchWindowSize = this.watchWindowSize.bind(this); this.jdugeToStopResize = this.jdugeToStopResize.bind(this); this.startEpicenter = this.startEpicenter.bind(this); this.moveEpicenter = this.moveEpicenter.bind(this); this.reverseVertical = this.reverseVertical.bind(this); this.render = this.render.bind(this); }, setup : function(){ this.points.length = 0; this.fishes.length = 0; this.watchIds.length = 0; this.intervalCount = this.MAX_INTERVAL_COUNT; this.width = this.$container.width(); this.height = this.$container.height(); this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500; this.$canvas.attr({width : this.width, height : this.height}); this.reverse = false; this.fishes.push(new FISH(this)); this.createSurfacePoints(); }, watchWindowSize : function(){ this.clearTimer(); this.tmpWidth = this.$window.width(); this.tmpHeight = this.$window.height(); this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL)); }, clearTimer : function(){ while(this.watchIds.length &gt; 0){ clearTimeout(this.watchIds.pop()); } }, jdugeToStopResize : function(){ var width = this.$window.width(), height = this.$window.height(), stopped = (width == this.tmpWidth &amp;&amp; height == this.tmpHeight); this.tmpWidth = width; this.tmpHeight = height; if(stopped){ this.setup(); } }, bindEvent : function(){ this.$window.on('resize', this.watchWindowSize); this.$container.on('mouseenter', this.startEpicenter); this.$container.on('mousemove', this.moveEpicenter); this.$container.on('click', this.reverseVertical); }, getAxis : function(event){ var offset = this.$container.offset(); return { x : event.clientX - offset.left + this.$window.scrollLeft(), y : event.clientY - offset.top + this.$window.scrollTop() }; }, startEpicenter : function(event){ this.axis = this.getAxis(event); }, moveEpicenter : function(event){ var axis = this.getAxis(event); if(!this.axis){ this.axis = axis; } this.generateEpicenter(axis.x, axis.y, axis.y - this.axis.y); this.axis = axis; }, generateEpicenter : function(x, y, velocity){ if(y &lt; this.height / 2 - this.THRESHOLD || y &gt; this.height / 2 + this.THRESHOLD){ return; } var index = Math.round(x / this.pointInterval); if(index &lt; 0 || index &gt;= this.points.length){ return; } this.points[index].interfere(y, velocity); }, reverseVertical : function(){ this.reverse = !this.reverse; for(var i = 0, count = this.fishes.length; i &lt; count; i++){ this.fishes[i].reverseVertical(); } }, controlStatus : function(){ for(var i = 0, count = this.points.length; i &lt; count; i++){ this.points[i].updateSelf(); } for(var i = 0, count = this.points.length; i &lt; count; i++){ this.points[i].updateNeighbors(); } if(this.fishes.length &lt; this.fishCount){ if(--this.intervalCount == 0){ this.intervalCount = this.MAX_INTERVAL_COUNT; this.fishes.push(new FISH(this)); } } }, render : function(){ requestAnimationFrame(this.render); this.controlStatus(); this.context.clearRect(0, 0, this.width, this.height); this.context.fillStyle = 'hsl(0, 0%, 95%)'; for(var i = 0, count = this.fishes.length; i &lt; count; i++){ this.fishes[i].render(this.context); } this.context.save(); this.context.globalCompositeOperation = 'xor'; this.context.beginPath(); this.context.moveTo(0, this.reverse ? 0 : this.height); for(var i = 0, count = this.points.length; i &lt; count; i++){ this.points[i].render(this.context); } this.context.lineTo(this.width, this.reverse ? 0 : this.height); this.context.closePath(); this.context.fill(); this.context.restore(); } }; var SURFACE_POINT = function(renderer, x){ this.renderer = renderer; this.x = x; this.init(); }; SURFACE_POINT.prototype = { SPRING_CONSTANT : 0.03, SPRING_FRICTION : 0.9, WAVE_SPREAD : 0.3, ACCELARATION_RATE : 0.01, init : function(){ this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE; this.height = this.initHeight; this.fy = 0; this.force = {previous : 0, next : 0}; }, setPreviousPoint : function(previous){ this.previous = previous; }, setNextPoint : function(next){ this.next = next; }, interfere : function(y, velocity){ this.fy = this.renderer.height * this.ACCELARATION_RATE * ((this.renderer.height - this.height - y) &gt;= 0 ? -1 : 1) * Math.abs(velocity); }, updateSelf : function(){ this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height); this.fy *= this.SPRING_FRICTION; this.height += this.fy; }, updateNeighbors : function(){ if(this.previous){ this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height); } if(this.next){ this.force.next = this.WAVE_SPREAD * (this.height - this.next.height); } }, render : function(context){ if(this.previous){ this.previous.height += this.force.previous; this.previous.fy += this.force.previous; } if(this.next){ this.next.height += this.force.next; this.next.fy += this.force.next; } context.lineTo(this.x, this.renderer.height - this.height); } }; var FISH = function(renderer){ this.renderer = renderer; this.init(); }; FISH.prototype = { GRAVITY : 0.4, init : function(){ this.direction = Math.random() &lt; 0.5; this.x = this.direction ? (this.renderer.width + this.renderer.THRESHOLD) : -this.renderer.THRESHOLD; this.previousY = this.y; this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1); if(this.renderer.reverse){ this.y = this.getRandomValue(this.renderer.height * 1 / 10, this.renderer.height * 4 / 10); this.vy = this.getRandomValue(2, 5); this.ay = this.getRandomValue(0.05, 0.2); }else{ this.y = this.getRandomValue(this.renderer.height * 6 / 10, this.renderer.height * 9 / 10); this.vy = this.getRandomValue(-5, -2); this.ay = this.getRandomValue(-0.2, -0.05); } this.isOut = false; this.theta = 0; this.phi = 0; }, getRandomValue : function(min, max){ return min + (max - min) * Math.random(); }, reverseVertical : function(){ this.isOut = !this.isOut; this.ay *= -1; }, controlStatus : function(context){ this.previousY = this.y; this.x += this.vx; this.y += this.vy; this.vy += this.ay; if(this.renderer.reverse){ if(this.y &gt; this.renderer.height * this.renderer.INIT_HEIGHT_RATE){ this.vy -= this.GRAVITY; this.isOut = true; }else{ if(this.isOut){ this.ay = this.getRandomValue(0.05, 0.2); } this.isOut = false; } }else{ if(this.y &lt; this.renderer.height * this.renderer.INIT_HEIGHT_RATE){ this.vy += this.GRAVITY; this.isOut = true; }else{ if(this.isOut){ this.ay = this.getRandomValue(-0.2, -0.05); } this.isOut = false; } } if(!this.isOut){ this.theta += Math.PI / 20; this.theta %= Math.PI * 2; this.phi += Math.PI / 30; this.phi %= Math.PI * 2; } this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY); if(this.vx &gt; 0 &amp;&amp; this.x &gt; this.renderer.width + this.renderer.THRESHOLD || this.vx &lt; 0 &amp;&amp; this.x &lt; -this.renderer.THRESHOLD){ this.init(); } }, render : function(context){ context.save(); context.translate(this.x, this.y); context.rotate(Math.PI + Math.atan2(this.vy, this.vx)); context.scale(1, this.direction ? 1 : -1); context.beginPath(); context.moveTo(-30, 0); context.bezierCurveTo(-20, 15, 15, 10, 40, 0); context.bezierCurveTo(15, -10, -20, -15, -30, 0); context.fill(); context.save(); context.translate(40, 0); context.scale(0.9 + 0.2 * Math.sin(this.theta), 1); context.beginPath(); context.moveTo(0, 0); context.quadraticCurveTo(5, 10, 20, 8); context.quadraticCurveTo(12, 5, 10, 0); context.quadraticCurveTo(12, -5, 20, -8); context.quadraticCurveTo(5, -10, 0, 0); context.fill(); context.restore(); context.save(); context.translate(-3, 0); context.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)); context.beginPath(); if(this.renderer.reverse){ context.moveTo(5, 0); context.bezierCurveTo(10, 10, 10, 30, 0, 40); context.bezierCurveTo(-12, 25, -8, 10, 0, 0); }else{ context.moveTo(-5, 0); context.bezierCurveTo(-10, -10, -10, -30, 0, -40); context.bezierCurveTo(12, -25, 8, -10, 0, 0); } context.closePath(); context.fill(); context.restore(); context.restore(); this.controlStatus(context); } }; $(function(){ RENDERER.init(); }); &lt;/script&gt; &lt;style&gt; @media only screen and (max-width: 767px){ #sidebar_search_box input[type=text]{width:calc(100% - 24px)} } &lt;/style&gt; &lt;/div&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"[转]MySQL数据库引擎","slug":"转-MySQL数据库引擎","date":"2020-02-09T10:43:52.000Z","updated":"2020-02-11T10:56:14.918Z","comments":true,"path":"2020/02/09/转-MySQL数据库引擎/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E8%BD%AC-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/","excerpt":"接下来介绍一下存储引擎的基本概念、MySQL支持的存储引擎、存储引擎的选择以及操作默认存储引擎。","text":"接下来介绍一下存储引擎的基本概念、MySQL支持的存储引擎、存储引擎的选择以及操作默认存储引擎。 什么是存储引擎数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。 现在许多数据库管理系统都支持多种不同的存储引擎。MySQL 的核心就是存储引擎。 提示：InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎。 MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。 MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。 MySQL 5.7 支持的存储引擎MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 SHOW ENGINES 语句来显示可用的数据库引擎和默认引擎。 MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。 MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。可以使用SHOW ENGINES语句查看系统所支持的引擎类型，结果如图所示。 Support 列的值表示某种引擎是否能使用，YES表示可以使用，NO表示不能使用，DEFAULT表示该引擎为当前默认的存储引擎。 如何选择 MySQL 存储引擎不同的存储引擎都有各自的特点，以适应不同的需求，如表所示。为了做出选择，首先要考虑每一个存储引擎提供了哪些不同的功能。 功能 MylSAM MEMORY InnoDB Archive 存储限制 256TB RAM 64TB None 支持事务 No No Yes No 支持全文索引 Yes No No No 支持树索引 Yes Yes Yes No 支持哈希索引 No Yes No No 支持数据缓存 No N/A Yes No 支持外键 No No Yes No 可以根据以下的原则来选择 MySQL 存储引擎： 如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。 如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。 如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。 如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎。 提示：使用哪一种引擎要根据需要灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。 MySQL 默认存储引擎InnoDB 是系统的默认引擎，支持可靠的事务处理。 使用下面的语句可以修改数据库临时的默认存储引擎 SET default_storage_engine=&lt; 存储引擎名 &gt; 例如，将 MySQL 数据库的临时默认存储引擎修改为 MyISAM，输入的 SQL 语句和运行结果如图所示。 此时，可以发现 MySQL 的默认存储引擎已经变成了 MyISAM。但是当再次重启客户端时，默认存储引擎仍然是 InnoDB。 原文链接：http://c.biancheng.net/view/2418.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[转]MySQL区别大小写字母的问题","slug":"转-MySQL区别大小写的问题","date":"2020-02-09T08:29:12.000Z","updated":"2020-03-22T05:27:07.243Z","comments":true,"path":"2020/02/09/转-MySQL区别大小写的问题/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E8%BD%AC-MySQL%E5%8C%BA%E5%88%AB%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"如果直接使用MYSQL客户端用SQL语句查询数据库中的数据，SQL语句中字段的大写或小写查出的数据是一样的，说明查询条件对字段的大小写是不敏感（默认）。 怎样让MYSQL对大小字母写敏感？","text":"如果直接使用MYSQL客户端用SQL语句查询数据库中的数据，SQL语句中字段的大写或小写查出的数据是一样的，说明查询条件对字段的大小写是不敏感（默认）。 怎样让MYSQL对大小字母写敏感？ 解决方案一MYSQL区别大小写需要设置collate（校对） 。 collate规则： *_bin: 表示的是 binary casesensitive collation，也就是说是区分大小写的 *_cs: 表示的是 casesensitive collation，区分大小写 *_ci: 表示的是 caseinsensitive collation，不区分大小写 解决方法 可以将查询条件用binary()括起来。 比如： select * from emp where binary username= 'jack'; 可以修改该字段的collation 为 binary。比如： ALTER TABLE TABLENAME MODIFY COLUMN COLUMNNAME VARCHAR(50) BINARY CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL; 解决方案二mysql查询默认是不区分大小写的 如: select * from emp where username=‘jack'; select * from emp where username='JACK'; 得到的结果是一样的，如果我们需要进行区分的话可以按照如下方法来做： 第一种方法要让mysql查询区分大小写，可以： select * from emp where binary username='jack' select * from emp where binary username='JACK' 第二种方法在建表时时候加以标识 create table emp( username varchar(20) binary ) 原理：对于CHAR、VARCHAR和TEXT类型，BINARY属性可以为列分配该列字符集的校对规则。BINARY属性是指定列字符集的二元校对规则的简写。排序和比较基于数值字符值,因此也就自然区分了大小写。 原文链接：https://blog.csdn.net/qq_15160079/article/details/100976519 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}],"author":{"name":"曼巴进化者","url":"https://blog.csdn.net/qq_15160079/article/details/100976519"}},{"title":"Navicat Premium连接MySQL失败？","slug":"Navicat-Premium连接MySQL失败？","date":"2020-02-09T07:42:25.000Z","updated":"2020-02-11T10:56:14.881Z","comments":true,"path":"2020/02/09/Navicat-Premium连接MySQL失败？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/Navicat-Premium%E8%BF%9E%E6%8E%A5MySQL%E5%A4%B1%E8%B4%A5%EF%BC%9F/","excerpt":"问题描述使用Navicat Premium连接MySQL失败，并弹窗提示👇 分析从错误信息可知caching_sha2_password不能加载。 以上报错是由于目前已有的客户端连接软件还不支持Mysql8新增加的加密方式caching_sha2_password，所以我们需要修改用户的加密方式，将其改为老的加密验证方式。 大安装Mysql数据库的主机上登录Mysql对应的用户，上面连接时用的用户为root，所以我们登录root用户。 解决 执行命令，查看当前用户的加密方式： use mysql; select user,plugin from user where user='root'; 可以看到当前用户的加密方式为caching_sha2_password。 登录MySQL后输入，执行命令： ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'YourPassword'; FLUSH PRIVILEGES; 将用户的加密方式改为mysql_native_password。 再次尝试连接Mysql，连接成功。","text":"问题描述使用Navicat Premium连接MySQL失败，并弹窗提示👇 分析从错误信息可知caching_sha2_password不能加载。 以上报错是由于目前已有的客户端连接软件还不支持Mysql8新增加的加密方式caching_sha2_password，所以我们需要修改用户的加密方式，将其改为老的加密验证方式。 大安装Mysql数据库的主机上登录Mysql对应的用户，上面连接时用的用户为root，所以我们登录root用户。 解决 执行命令，查看当前用户的加密方式： use mysql; select user,plugin from user where user='root'; 可以看到当前用户的加密方式为caching_sha2_password。 登录MySQL后输入，执行命令： ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'YourPassword'; FLUSH PRIVILEGES; 将用户的加密方式改为mysql_native_password。 再次尝试连接Mysql，连接成功。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"文章内跳转","slug":"文章内跳转","date":"2020-02-09T07:19:00.000Z","updated":"2020-04-23T11:40:36.813Z","comments":true,"path":"2020/02/09/文章内跳转/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E6%96%87%E7%AB%A0%E5%86%85%E8%B7%B3%E8%BD%AC/","excerpt":"点击我跳转 1. 跳转起点 [点击我跳转](#jump) 2.跳转终点 &lt;span id=\"jump\"&gt;&lt;font color='blue'&gt;[我是跳转内容]&lt;/font&gt;&lt;/span&gt;&lt;a href=\"#jump\" class=\"footnote-backref\"&gt;↩&lt;/a&gt; [我是跳转内容]↩ 参考文章： https://www.jianshu.com/p/4898c2e9a36d https://blog.csdn.net/qq_38276669/article/details/86748936","text":"点击我跳转 1. 跳转起点 [点击我跳转](#jump) 2.跳转终点 &lt;span id=\"jump\"&gt;&lt;font color='blue'&gt;[我是跳转内容]&lt;/font&gt;&lt;/span&gt;&lt;a href=\"#jump\" class=\"footnote-backref\"&gt;↩&lt;/a&gt; [我是跳转内容]↩ 参考文章： https://www.jianshu.com/p/4898c2e9a36d https://blog.csdn.net/qq_38276669/article/details/86748936 内容 在MarkDown中是通过 链接 和 标题 来实现页面内跳转的，所以先讲下MarkDown中 链接 和 标题 的语法，然后再讲 MarkDown 中实现页面内跳转的方法； 一. 链接的定义Markdown 支持两种形式的链接语法： 行内式 和 参考式 两种形式。 1. 行内式链接语法： 行内式链接 = [内容](地址 \"标题\") 说明： 标题 是可选的，可以用单引号 或 双引号； 转换成HTML后，会生成如下标签： &lt;a href=\"地址\" title=\"标题\"&gt;内容&lt;/a&gt; 示例： [我的博客](https://www.jianshu.com/u/7ecaba2d594c \"郭斌勇的主页\") 渲染成HTML后，会生成如下标签： &lt;a href=\"https://www.jianshu.com/u/7ecaba2d594c\" title=\"郭斌勇的主页\"&gt;我的博客&lt;/a&gt; 效果如下： 我的博客 2. 参考式链接语法： 参考式链接 = [内容][参考标识符] 参考标识符 = [标识符]: 地址 \"标题\" 说明： 参考式链接 和 参考标识符 的定义没有先后顺序； [内容] 和 [参考标识符] 之间可以有一个空格，也可以没有空格； 如果 内容 和 参考标识符 一样，也可简写成 [参考标识符][] ; 标题 是可选的，可以用单引号、双引号或是圆括弧包着； 转换成HTML后，会生成如下标签： &lt;a href=\"地址\" title=\"标题\"&gt;内容&lt;/a&gt; 示例： [博客]: https://www.jianshu.com/u/7ecaba2d594c \"郭斌勇的主页\" [我的博客][博客] [博客][] 渲染成HTML后，会生成如下标签： &lt;a href=\"https://www.jianshu.com/u/7ecaba2d594c\" title=\"郭斌勇的主页\"&gt;我的博客&lt;/a&gt; &lt;a href=\"https://www.jianshu.com/u/7ecaba2d594c\" title=\"郭斌勇的主页\"&gt;博客&lt;/a&gt; 效果如下： 我的博客 博客 三.页面内跳转MarkDown中是通过定义链接的方式来定义跳转的，在这里，跳转也称为锚点，跳转的目标称为锚点目标； 所以，在 MarkDown 中实现页面内跳转的方法就是：定义一个 锚点目标 和 对应的 锚点 ，用户点击 锚点 便可跳转到对应的 锚点目标 位置处； 锚点 和 锚点目标 的定义格式如下： 1. 锚点的定义锚点就是一个链接，另外，由于在MarkDown中可以直接写HTML，所以在MarkDown中实现锚点有两种方式：MarkDown方式 和 HTML方式； 1.1 MarkDown锚点MarkDown锚点本质上就是一个MarkDown链接，只是链接地址的格式为： 链接地址 = #目标内容 所以 MarkDown锚点 的定义也有两种方式 行内式语法： 锚点 = [内容](#目标内容 \"标题\") 说明： 标题 是可选的，可以用单引号 或 双引号； 转换成HTML后，会生成如下标签： &lt;a href=\"#目标内容\" title=\"标题\"&gt;内容&lt;/a&gt; 示例： [MarkDown方式的锚点](#MarkDown锚点) 渲染成HTML后，会生成如下标签： &lt;a href=\"#MarkDown锚点\" &gt;MarkDown方式的锚点&lt;/a&gt; 效果如下：点击下面的锚点 MarkDown方式的锚点 参考式语法： 锚点 = [内容][参考标识符] 参考标识符 = [标识符]: #目标内容 \"标题\" 说明： 锚点 和 参考标识符 的定义没有先后顺序； [内容] 和 [参考标识符] 之间可以有一个空格，也可以没有空格； 如果 内容 和 参考标识符 一样，也可简写成 [参考标识符][] ; 标题 是可选的，可以用单引号、双引号或是圆括弧包着； 转换成HTML后，会生成如下标签： &lt;a href=\"#目标内容\" title=\"标题\"&gt;内容&lt;/a&gt; 示例： [MarkDown方式的锚点]: #MarkDown锚点 [MD锚点][MarkDown方式的锚点] [MarkDown方式的锚点][] 渲染成HTML后，会生成如下标签： &lt;a href=\"#MarkDown锚点\"&gt;MD锚点&lt;/a&gt; &lt;a href=\"#MarkDown锚点\"&gt;MarkDown方式的锚点&lt;/a&gt; 效果如下： MD锚点 MarkDown方式的锚点 1.2 HTML锚点HTML锚点本质上就是一个a链接，格式为： &lt;a href=\"#目标内容\"&gt;内容&lt;/a&gt; 注意： HTML锚点 的目标锚点只能是 标签形式的锚点目标 示例： &lt;a href=\"#html锚点\"&gt;HTML方式的锚点&lt;/a&gt; 效果如下：点击下面的锚点 HTML方式的锚点 2. 锚点目标的定义锚点目标有2种定义方式：MarkDown形式 和 标签形式； MarkDown形式的锚点目标MarkDown形式的锚点目标的定义其实就是标题的定义，即：任何级别的标题可以直接作为锚点目标； 标题内容 = 目标内容 所以，类Setext形式 和 类atx形式 的标题都可作为 锚点目标 ； 锚点目标定义的示例： 这是一个锚点目标 ==== 这是一个锚点目标 --- # 这是一个锚点目标 ## 这是一个锚点目标 ### 这是一个锚点目标 #### 这是一个锚点目标 ##### 这是一个锚点目标 ###### 这是一个锚点目标 注意： 锚点的 目标内容 中不能有大家字母和空格，所以如果锚点目标的 目标内容 中有大写字母或空格，则需要在定义锚点中的 目标内容 时，把大写字母改成小写字母，把空格改成 -； 锚点 的 目标内容 中不能含有以下字符： 半角点(即英文中的句号). 标签形式的锚点目标因为MarkDown链接会被转成a标签，并且MarkDown中也可以写标签，所以可以利用HTML的锚点机制直接定义一个带 id 特性的任意标签 或 带 name 特性的 a 标签（注意：在HTML5中，a标签已经不再支持 name 特性）作为锚点目标，然后把MarkDown中的锚点地址的目标内容设置为 id 或 name 特性的值；这样便可以实现页面内跳转； 这种形式的锚点目标的定义格式为： &lt;标签名 id=\"目标内容\"&gt;元素内容&lt;/标签名&gt; 或 &lt;a name=\"目标内容\"&gt;元素内容&lt;/a&gt; 注意： 标签形式的锚点目标的id特性值中是不能含有中文字符； name 特性只能应用在 a 标签上； HTML5不支持通过a标签的 name 特性来定义锚点目标； 示例： &lt;div id=\"这是锚点目标\"&gt;跳转到这里&lt;/div&gt; 或 &lt;a name=\"这是锚点目标\"&gt;跳转到这里&lt;/a&gt; 四. 总结MarkDown中实现页面跳转的方法如下： 定义锚点目标；锚点目标的定义方式有4种：类Setext形式的标题、类atx形式的标题、带id特性的HTML标签（id特性的值为目标内容）、带name特性的a标签（name特性的值为目标内容）； 定义锚点；锚点的定义方式有3种：行内式链接、参考式链接、HTML的a链接； 说明： 锚点 和 锚点目标 的定义不分先后顺序； 注意： 锚点的 目标内容 中不能有大家字母和空格，所以如果锚点目标的 目标内容 中有大写字母或空格，则需要在定义锚点中的 目标内容 时，把大写字母改成小写字母，把空格改成 -； 锚点 的 目标内容 中不能含有以下字符： 半角点(即英文中的句号). 标签形式的锚点目标的id特性值中是不能含有中文字符； name 特性只能应用在 a 标签上； HTML5不支持通过a标签的 name 特性来定义锚点目标； HTML锚点 的目标锚点只能是 标签形式的锚点目标 五. 示例示例1锚点： [跳转到个人简介](#个人简介) 锚点目标： # 个人简介 示例2锚点： [跳转到个人简介]: #个人简介 [跳转到个人简介][] 锚点目标： 个人简介 ===== 示例3锚点： [跳转到个人简介](#个人简介) 锚点目标： &lt;p id=\"个人简介\"&gt;这是个人简介&lt;/p&gt; 示例4锚点： [跳转到个人简介](#个人简介) 锚点目标： &lt;a name=\"个人简介\"&gt;这是个人简介&lt;/a&gt; 示例5锚点： &lt;a href=\"#个人简介\"&gt;跳转到个人简介&lt;/a&gt; 锚点目标： 个人简介 ---- 示例6锚点： &lt;a href=\"#个人简介\"&gt;跳转到个人简介&lt;/a&gt; 锚点目标： &lt;h1 id=\"个人简介\"&gt;这是个人简介&lt;/h1&gt; 示例7锚点： &lt;a href=\"#个人简介\"&gt;跳转到个人简介&lt;/a&gt; 锚点目标： &lt;a name=\"个人简介\"&gt;这是个人简介&lt;/a&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"输入密码后登录不上MySQL？","slug":"输入密码后登录不上MySQL？","date":"2020-02-09T07:08:37.000Z","updated":"2020-02-11T10:56:14.924Z","comments":true,"path":"2020/02/09/输入密码后登录不上MySQL？/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E5%90%8E%E7%99%BB%E5%BD%95%E4%B8%8D%E4%B8%8AMySQL%EF%BC%9F/","excerpt":"昨晚安装好MySQL后，可以登录。但是今天输入密码后，总是没办法登录。 刚开始我是用DOS窗口的，我检查了命令，命令也没输错啊。 接着转去MySQL Command Line Client试试，一直没反应。 我突然想到“是不是MySQL服务没有启动？” 果然！看了一下，这个时候MySQL需要手动启动，于是我把MySQL服务设置成开机自动启动，以后就省去手动启动这个麻烦。 回到DOS，输入mysql -h localhost -u root -p试试，可以正常登录MySQL了hh o(￣▽￣)o 除了上面这种到【服务】手动开启MySQL服务的方法外，也可以用PowerShell(管理员)来启动。 输入命令net start mysql，启动MySQL服务。启动成功会在左下角弹窗提示👇 一定是要带有管理员权限的PowerShell，否者只会是这个样子👇 输入net start mysql，按回车键，就能启动 MySQL 服务，停止服务的命令为net stop mysql。","text":"昨晚安装好MySQL后，可以登录。但是今天输入密码后，总是没办法登录。 刚开始我是用DOS窗口的，我检查了命令，命令也没输错啊。 接着转去MySQL Command Line Client试试，一直没反应。 我突然想到“是不是MySQL服务没有启动？” 果然！看了一下，这个时候MySQL需要手动启动，于是我把MySQL服务设置成开机自动启动，以后就省去手动启动这个麻烦。 回到DOS，输入mysql -h localhost -u root -p试试，可以正常登录MySQL了hh o(￣▽￣)o 除了上面这种到【服务】手动开启MySQL服务的方法外，也可以用PowerShell(管理员)来启动。 输入命令net start mysql，启动MySQL服务。启动成功会在左下角弹窗提示👇 一定是要带有管理员权限的PowerShell，否者只会是这个样子👇 输入net start mysql，按回车键，就能启动 MySQL 服务，停止服务的命令为net stop mysql。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[工具]文件加密软件","slug":"工具-文件加密软件","date":"2020-02-09T05:40:26.000Z","updated":"2020-02-11T10:56:14.889Z","comments":true,"path":"2020/02/09/工具-文件加密软件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/09/%E5%B7%A5%E5%85%B7-%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E8%BD%AF%E4%BB%B6/","excerpt":"Folder-locker这是一个小巧的文件上锁软件，没有压缩和加密过程，方便快捷。 功能展示 在想加密的文件夹上，右键则可呼出加密面板，输入两次密码确认加密。 在已加密的文件夹上，右键，输入密码，则取消加密 项目介绍项目分了两个目录： DButility 用于通过轻量极数据库SQLite 保存密码。 通过Md5算法对密码加密，通过SQL参数防止SQL注入。 folderLocker 用于实现业务逻辑。 软件使用 下载软件安装包 Folder Locker.exe 进行安装，建议安装在D盘。 可以右键使用，也可以打开软件主页面使用。 注意事项 密码保存在本机数据库，没有上传任何服务器。 删除软件会同时删除数据库，因而删除密码。 如果忘记密码： 如果密码遗失，文件被锁，可以通过命令行工具重命名： cd C:\\Users\\91991\\Music ren \"Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\" \"Test1\" 或者把文件复制出来。 cd C:\\Users\\91991\\Music cd '.\\Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\\' ls mv .\\* ..\\Test1\\ 项目地址： https://github.com/Albert-W/Folder-locker 项目展示： https://albert-w.github.io/Folder-locker/","text":"Folder-locker这是一个小巧的文件上锁软件，没有压缩和加密过程，方便快捷。 功能展示 在想加密的文件夹上，右键则可呼出加密面板，输入两次密码确认加密。 在已加密的文件夹上，右键，输入密码，则取消加密 项目介绍项目分了两个目录： DButility 用于通过轻量极数据库SQLite 保存密码。 通过Md5算法对密码加密，通过SQL参数防止SQL注入。 folderLocker 用于实现业务逻辑。 软件使用 下载软件安装包 Folder Locker.exe 进行安装，建议安装在D盘。 可以右键使用，也可以打开软件主页面使用。 注意事项 密码保存在本机数据库，没有上传任何服务器。 删除软件会同时删除数据库，因而删除密码。 如果忘记密码： 如果密码遗失，文件被锁，可以通过命令行工具重命名： cd C:\\Users\\91991\\Music ren \"Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\" \"Test1\" 或者把文件复制出来。 cd C:\\Users\\91991\\Music cd '.\\Test.{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}\\' ls mv .\\* ..\\Test1\\ 项目地址： https://github.com/Albert-W/Folder-locker 项目展示： https://albert-w.github.io/Folder-locker/ 教程这是国人开发的一款开源加密小程序，它只有一个功能，就是给文件夹上密码。 下载后安装，需要注意的是，软件默认安装到D盘，你可以改成其他盘，但不建议安装到C盘，因为可能导致数据库丢失，影响解密； 加密过程也很简单，右键需要加密的文件夹 – Folder locker – 输入密码– lock 即可； 加密后文件夹图标会变成锁，无法双击打开，需要解密的话，右键已加密文件夹 – Folder locker – 输入密码– unlock 即可； 整个过程没有任何数据上传，你的密码会通过Md5算法加密，并保存在本机数据库，卸载软件会同时删除数据库，导致密码丢失。 这个小程序原理非常简单，就是利用 Windows 的注册表修改了文件夹属性，使其不能直接已文件夹的形式打开，就像「上帝模式」一样，小程序并没有对文件夹内的文件做任何修改，没有压缩和加密过程，所以速度非常快。 但也正因为其简单，知道原理的话不需要程序也能解密。 忘记密码的解密方法： 以上就是使用这个小程序所有的方法，它的安全系数不高，不适用来加密非常重要的机密文件，但保护普通用户的小秘密应该是搓搓有余的。 目前这款软件好像在 Windows 2004 版本上失效了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}],"author":{"name":"Albert-W","url":"https://github.com/Albert-W/Folder-locker","avatar":"https://avatars0.githubusercontent.com/u/21038139?s=460&v=4"}},{"title":"登录MySQL","slug":"登录MySQL","date":"2020-02-08T14:54:46.000Z","updated":"2020-02-11T10:56:14.892Z","comments":true,"path":"2020/02/08/登录MySQL/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E7%99%BB%E5%BD%95MySQL/","excerpt":"安装好MySQL后，默认启动服务，这时候开始尝试登录MySQL数据库。 有两种登录方式： Power Shell 或 CMD（DOS窗口） 命令行客户端（MySQL Command Line Client）【安装软件时，一般会安装的】 Power Shell 启动 Power Shell 。 输入命令cd C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin（cd+空格+安装目录/bin），回车。 输入登录命令，回车。登录命令有4中，选其一即可： #第一种 服务器主机地址+不接密码 mysql -h localhost -u root -p #第二种 服务器主机地址+密码 mysql -h localhost -u root -proot #第三种 省略服务器主机地址+不接密码，默认localhost mysql -u root -p #第四种 省略服务器主机地址+密码，默认localhost mysql -u root -proot 提示：mysql 为登录命令，-h 后面的参数是服务器的主机地址，在这里客户端和服务器在同一台机器上，所以输入 localhost 或者 IP 地址；-u 后面跟登录数据库的用户名称，在这里为 root；-p 后面是用户登录密码。 在 DOS 窗口下运行该命令后，系统会提示输入密码。密码输入正确以后，即可登录到 MySQL 数据库。 可以在 mysql 命令中直接加上密码，该命令为 mysql -h localhost -u root -proot。这里的 -p 后面的 root 就是密码。此处特别注意 -p 和密码之间没有空格。如果出现空格，系统将不会把后面的字符串当成密码来对待。 系统提示输入密码。（若选用第二/四种方式进行登录，则跳过本步骤） 成功登录到MySQL数据库。登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，如下图所示。 登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，然后下面还有一些说明性的语句，如图所示。 这些说明性语句介绍如下： Commands end with; or\\g：说明 mysql 命令行下的命令是以分号（;）或“\\g”来结束的，遇到这个结束符就开始执行命令。 Your MySQL connection id is 3：id 表示 MySQL 数据库的连接次数。 Server version: 5. 7.29-log MySQL Community Server（GPL）：Server version 后面说明数据库的版本，这个版本为 5.7.29。Community 表示该版本是社区版。 Type ‘help;’ or ‘\\h’ for help：表示输入”help;“或者”\\h“可以看到帮助信息。 Type ‘\\c’ to clear the current input statement：表示遇到”\\c“就清除前面的命令。 提示：当窗口中出现如上图所示的说明信息，命令提示符变为“mysql&gt;”时，表明已经成功登录 MySQL 服务器，可以开始对数据库进行操作了。 输入命令exit，即可退出MySQL。 MySQL Command Line Client打开 MySQL Command Line Client 进入提示输入密码的界面，如图所示。 输入正确的密码后，登录到 MySQL 软件。如果以这种方式登录 MySQL，需要保证 MySQL 服务处于启动状态。","text":"安装好MySQL后，默认启动服务，这时候开始尝试登录MySQL数据库。 有两种登录方式： Power Shell 或 CMD（DOS窗口） 命令行客户端（MySQL Command Line Client）【安装软件时，一般会安装的】 Power Shell 启动 Power Shell 。 输入命令cd C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin（cd+空格+安装目录/bin），回车。 输入登录命令，回车。登录命令有4中，选其一即可： #第一种 服务器主机地址+不接密码 mysql -h localhost -u root -p #第二种 服务器主机地址+密码 mysql -h localhost -u root -proot #第三种 省略服务器主机地址+不接密码，默认localhost mysql -u root -p #第四种 省略服务器主机地址+密码，默认localhost mysql -u root -proot 提示：mysql 为登录命令，-h 后面的参数是服务器的主机地址，在这里客户端和服务器在同一台机器上，所以输入 localhost 或者 IP 地址；-u 后面跟登录数据库的用户名称，在这里为 root；-p 后面是用户登录密码。 在 DOS 窗口下运行该命令后，系统会提示输入密码。密码输入正确以后，即可登录到 MySQL 数据库。 可以在 mysql 命令中直接加上密码，该命令为 mysql -h localhost -u root -proot。这里的 -p 后面的 root 就是密码。此处特别注意 -p 和密码之间没有空格。如果出现空格，系统将不会把后面的字符串当成密码来对待。 系统提示输入密码。（若选用第二/四种方式进行登录，则跳过本步骤） 成功登录到MySQL数据库。登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，如下图所示。 登录成功后进入 MySQL 初始界面，会出现“Welcome to the MySQL monitor”的欢迎语，然后下面还有一些说明性的语句，如图所示。 这些说明性语句介绍如下： Commands end with; or\\g：说明 mysql 命令行下的命令是以分号（;）或“\\g”来结束的，遇到这个结束符就开始执行命令。 Your MySQL connection id is 3：id 表示 MySQL 数据库的连接次数。 Server version: 5. 7.29-log MySQL Community Server（GPL）：Server version 后面说明数据库的版本，这个版本为 5.7.29。Community 表示该版本是社区版。 Type ‘help;’ or ‘\\h’ for help：表示输入”help;“或者”\\h“可以看到帮助信息。 Type ‘\\c’ to clear the current input statement：表示遇到”\\c“就清除前面的命令。 提示：当窗口中出现如上图所示的说明信息，命令提示符变为“mysql&gt;”时，表明已经成功登录 MySQL 服务器，可以开始对数据库进行操作了。 输入命令exit，即可退出MySQL。 MySQL Command Line Client打开 MySQL Command Line Client 进入提示输入密码的界面，如图所示。 输入正确的密码后，登录到 MySQL 软件。如果以这种方式登录 MySQL，需要保证 MySQL 服务处于启动状态。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"博客中的icon","slug":"博客中的icon","date":"2020-02-08T13:45:34.000Z","updated":"2020-04-23T11:40:36.802Z","comments":true,"path":"2020/02/08/博客中的icon/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84icon/","excerpt":"在主题的配置文件中的 icon 是 fontawesome 图标名，你要显示什么图标，去 fontawesome.com 找免费版的就可以了。","text":"在主题的配置文件中的 icon 是 fontawesome 图标名，你要显示什么图标，去 fontawesome.com 找免费版的就可以了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"MySQL基础教学","slug":"MySQL基础教学","date":"2020-02-08T13:25:58.000Z","updated":"2020-02-11T10:56:14.874Z","comments":true,"path":"2020/02/08/MySQL基础教学/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/MySQL%E5%9F%BA%E7%A1%80%E6%95%99%E5%AD%A6/","excerpt":"两个学习MySQL基础的网站： C语言中文网 菜鸟教程","text":"两个学习MySQL基础的网站： C语言中文网 菜鸟教程 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}]},{"title":"[转]MySQL安装","slug":"转-MySQL安装","date":"2020-02-08T12:58:45.000Z","updated":"2020-03-22T04:42:24.376Z","comments":true,"path":"2020/02/08/转-MySQL安装/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E8%BD%AC-MySQL%E5%AE%89%E8%A3%85/","excerpt":"转载一份非常详细的【MySQL】的安装教程。","text":"转载一份非常详细的【MySQL】的安装教程。 进入官网找到自己所需的安装包：https://dev.mysql.com/ ，路径：DOWNLOAD–&gt;MYSQL Community Edition(GRL)–&gt;MYSQL on Windows (Installer &amp; Tool) 找到所需的安装包: 这里提供了直链下载【MySQL-5.7.20】：https://downloads.mysql.com/archives/get/p/25/file/mysql-installer-community-5.7.20.0.msi 点击download。这里选择的是安装版（mysql -install-community） 选择不登陆下载。 双击运行下载好的mysql-installer-community-5.7.19.0.msi，程序运行需要一些时间，请等待一下。 运行成功之后，进入欢迎的界面.选择我同意协议，不然无法进行下一步。 进入类型选择页面，本人需要mysql云服务就选择了developer default（7.1是默认安装的步骤），如果只想安装mysql server的就选择custom模式（7.2步骤是选择自己需要的服务器类型，所选择的用于做一些数据分析） developer default（开发者默认）：安装mysql开发所需的所有产品 server only（服务器）：只安装mysql服务器产品 client only（客户端）：只安装没有服务器的mysql客户端产品 full（完全）：安装所有包含的mysql产品和功能 custom（手动）：手动选择系统上应安装的产品 7.1 开发者默认模式检测以下程序会安装不成功，点击下一步进入下一个安装流程—&gt;跳到第八步。 check requirements：以下产品的请求失败，安装程序将自动尝试解决其中一些问题。标记为手动的要求无法自动解决。单击这些项目以尝试手动恢复。 检测到不可安装的程序说明： Visual Studio：是一款代码编辑工具（可编写C#、Visual Basic、C++、TypeScript、F# ），如果你安装的话就安装要求去安装Visual Studio version：2012.2013.2015.2017其中一个版本 Connector/pyton 3.4：电脑有python3.6了就没选择3.4版本的。如果你没安装有python可按要求去安装一些内容。 7.2 选择mysql server（服务） 5.7.19 x64 选择mysql workbench(mysql 的工作薄) 6.3.9 x64 选择mysql notiyier(通知) 1.1.7 x86(因为这里只有一个选择所以选择了86)点击下一步进入下一个安装流程—&gt;跳到第九步。 当我们点击下一步的时候安装程序出现了提示：（一个或者移动产品要求没有得到满足，那些符合要求的产品将不会安装/升级。你想要继续吗），这里我选择的是：YES 在安装所选界面能看到我们接下来所需要安装的程序，点击execute 安装程序进度界面，安装需要一些时间。点击dide tails能看到安装日志 程序安装完成之后，点击next 在product configutration（产品配置）页面能看到需要配置的程序，点击next（页面英语介绍：现在我们将逐一介绍以下产品的配置向导。您可以随时取消，如果您希望离开此向导，而不必配置所有产品） 先配置mysql server的类型以及网络：type and networking（类型和网络），这里有两种mysql server类型，选择第一种类型点击next。 有两种类型简单介绍 1.standalone mysql server/classic mysql replication：独立的mysql服务器/经典的mysql复制 choose this option if you want to run the mysql server either standalone with the opportunity to later configure classic mysql replication：选择这个选项，如果你想运行mysql服务器是独立的，有机会以后配置经典的mysql复制 2. innodb cluster sandbox thst setup(for testing only)： innodb集群沙箱thst设置（仅用于测试） 设置服务器配置类型以及连接端口：继续next Config Type:选择Development Machine，用于小型以及学习所用足够了。 Port number：输入3306，也可以输入其他最好是3306-3309之间。 配置root的密码（该密码要记住），系统提示这密码虚弱 添加其他管理员，点击add user 输入账号密码点击ok（如果添加的管理员只允许在本地登录就将host改成local），回到界面之后点击next 配置mysql在windows系统中的名字，是否选择开机启动mysql服务，其它的没进行修改，点击“Next”. 配置插件和扩展页面没进行修改直接下一步： Mysql server :apply configuration（应用配置页面），选择execute进行安装配置 mysql server应用配置的log，选择finish 安装程序又回到了product configutration（产品配置）页面，此时我们看到mysql server安装成功的显示，继续下一步： 配置mysql router：勾选configure mysql route for innoDB cluster之后输入密码。（如果不想输入密码可直接点击点一下）点击下一步 Mysql router :apply configuration（应用配置页面）点击execute, 安装完成之后点击选择finish 检测root密码 安装一些server，老规矩点击execute，完成之后点击finish 程序回到产品配置页面。继续下一步： 安装程序完成界面。 双击运行之前下载的安装包，能看到我们所安装的产品。 配置mysql环境变量 上面安装的是时候我们看到mysql默认安装路径是：C:\\Program Files\\MySQL\\MySQL Server 5.7 我的电脑右键—&gt;属性à高级系统设置à环境变量à新建MYSQL_HOME,将安装目录输入： 找到path编辑：输入%MYSQL_HOME%\\bin 打开cmd输入mysql –u root –p 输入root的密码 原文链接：https://www.cnblogs.com/xiaodingdong/p/7223245.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"}],"author":{"name":"叮咚丶哈哈","url":"https://www.cnblogs.com/xiaodingdong/p/7223245.html"}},{"title":"元宵团圆饭","slug":"元宵团圆饭","date":"2020-02-08T09:13:43.000Z","updated":"2020-02-08T09:37:50.898Z","comments":true,"path":"2020/02/08/元宵团圆饭/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E5%85%83%E5%AE%B5%E5%9B%A2%E5%9C%86%E9%A5%AD/","excerpt":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！”","text":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"第一个元宵","slug":"第一个元宵","date":"2020-02-08T09:13:43.000Z","updated":"2020-02-08T10:52:37.428Z","comments":true,"path":"2020/02/08/第一个元宵/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E5%AE%B5/","excerpt":"🌸于我们，这是妈走后的第一个元宵。 🎈这次没有汤圆…… 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” 👍附上老爸的新作(暂时想不出名字来hh，反正好吃hh)","text":"🌸于我们，这是妈走后的第一个元宵。 🎈这次没有汤圆…… 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” 👍附上老爸的新作(暂时想不出名字来hh，反正好吃hh) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"[转]jsdelivr的使用","slug":"转-jsdelivr的使用","date":"2020-02-08T06:22:39.000Z","updated":"2020-02-11T10:56:14.933Z","comments":true,"path":"2020/02/08/转-jsdelivr的使用/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/08/%E8%BD%AC-jsdelivr%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"本文链接：https://blog.csdn.net/qq_36910987/article/details/89562291","text":"本文链接：https://blog.csdn.net/qq_36910987/article/details/89562291 jsdelivr https://www.jsdelivr.com/ 下面就以举例子的方式说明 我是用 jsdelivr 来访问 github的资源，做博客来着 我的github https://github.com/yuDuChen/yuduchen 下面直接说怎么用jsdelivr，就不提如何创建github了 首先需要创建 releases 创建完,随便进入到一个文件,注意地址名 1 https://github.com/yuDuChen/yuduchen/blob/v1.5.6/layui/layui.js 这个地址用jsdelivr来访问 https://cdn.jsdelivr.net/gh/yuDuChen/yuduchen@v1.5.6/layui/layui.js 对比一下就发现怎么用了吧 注* 不使用jsdelivr直接引用github的文件 content-type 是 text/plain 页面无法解析 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"jQuery","slug":"jQuery","permalink":"https://melodyjerry.github.io/blog/tags/jQuery/"}],"author":{"name":"羽渡尘","url":"https://blog.csdn.net/qq_36910987/article/details/89562291"}},{"title":"蓝桥杯-基础练习-01字串","slug":"蓝桥杯-基础练习-01字串","date":"2020-02-07T13:24:17.000Z","updated":"2020-02-08T10:53:52.613Z","comments":true,"path":"2020/02/07/蓝桥杯-基础练习-01字串/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-01%E5%AD%97%E4%B8%B2/","excerpt":"在刷蓝桥杯试题时候，有一道很意思又有丶烧脑的题目👇 资源限制时间限制：1.0s 内存限制：256.0MB 问题描述对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是： 00000 00001 00010 00011 00100 请按从小到大的顺序输出这32种01串。 输入格式本试题没有输入。 输出格式输出32行，按从小到大的顺序每行一个长度为5的01串。 样例输出00000000010001000011&lt;以下部分省略&gt;","text":"在刷蓝桥杯试题时候，有一道很意思又有丶烧脑的题目👇 资源限制时间限制：1.0s 内存限制：256.0MB 问题描述对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是： 00000 00001 00010 00011 00100 请按从小到大的顺序输出这32种01串。 输入格式本试题没有输入。 输出格式输出32行，按从小到大的顺序每行一个长度为5的01串。 样例输出00000000010001000011&lt;以下部分省略&gt; 提交代码（Java）暴力输出刚开始想不出什么好办法，就直接把32个都写出来。抱着玩的心态，试试暴力输出看看系统给不给过，但是没想到，还真给我过了hhh public class Main { public static void main(String[] args) { System.out.println(\"00000\"); System.out.println(\"00001\"); System.out.println(\"00010\"); System.out.println(\"00011\"); System.out.println(\"00100\"); System.out.println(\"00101\"); System.out.println(\"00110\"); System.out.println(\"00111\"); System.out.println(\"01000\"); System.out.println(\"01001\"); System.out.println(\"01010\"); System.out.println(\"01011\"); System.out.println(\"01100\"); System.out.println(\"01101\"); System.out.println(\"01110\"); System.out.println(\"01111\"); System.out.println(\"10000\"); System.out.println(\"10001\"); System.out.println(\"10010\"); System.out.println(\"10011\"); System.out.println(\"10100\"); System.out.println(\"10101\"); System.out.println(\"10110\"); System.out.println(\"10111\"); System.out.println(\"11000\"); System.out.println(\"11001\"); System.out.println(\"11010\"); System.out.println(\"11011\"); System.out.println(\"11100\"); System.out.println(\"11101\"); System.out.println(\"11110\"); System.out.println(\"11111\"); } } 五层循环这是我想到的第二个方法，就类似说的“逢二进一”吧 public class Main { public static void main(String[] args) { int a,b,c,d,e; for(a=0;a&lt;2;++a) for(b=0;b&lt;2;++b) for(c=0;c&lt;2;++c) for(d=0;d&lt;2;++d) for(e=0;e&lt;2;++e) System.out.printf(\"%d%d%d%d%d\\n\",a,b,c,d,e); } } 以下两种方法均来自网络。 十进制转换二进制public class Main { public static void main(String[] args) { for(int i=0;i&lt;32;i++){ int a,b,c,d,e; a = i%32/16; b = i%16/8; c = i%8/4; d = i%4/2; e = i%2; System.out.printf(\"%d%d%d%d%d\\n\",a,b,c,d,e); } } } 以下标求1一共是32个串，给每个串设置0-31的下标。根据下标，寻找对应串中1出现的位置。👇 比如，下标3表示的串是“00011”，利用while循环可以找到出现1的下标是1、2 public class Main { public static void main(String[] args) { for(int i=0;i&lt;=31;i++){ int a[]= new int[5];// 默认初始化值为0 //或 int a[]= {0,0,0,0,0}; int temp=i; int index=0; while(temp!=0) { a[index]=temp%2; index++; temp/=2; } for(int idx=4;idx&gt;=0;idx--) System.out.print(a[idx]); System.out.println(); } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://melodyjerry.github.io/blog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"使用fancybox标签实现图片浏览器","slug":"使用-fancybox-标签实现图片浏览器","date":"2020-02-07T12:42:55.000Z","updated":"2020-02-07T15:20:51.233Z","comments":true,"path":"2020/02/07/使用-fancybox-标签实现图片浏览器/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/%E4%BD%BF%E7%94%A8-fancybox-%E6%A0%87%E7%AD%BE%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E5%99%A8/","excerpt":"使用&lt;fancybox&gt;&lt;/fancybox&gt;标签实现图片浏览器 单张图，只提供放大🔍关闭❌两个按钮，见黄色标记👇 多张图，可幻灯片播放，见红色标记👇","text":"使用&lt;fancybox&gt;&lt;/fancybox&gt;标签实现图片浏览器 单张图，只提供放大🔍关闭❌两个按钮，见黄色标记👇 多张图，可幻灯片播放，见红色标记👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"蓝桥杯-入门训练-Fibonacci数列","slug":"蓝桥杯—-入门训练-Fibonacci数列","date":"2020-02-07T11:48:54.000Z","updated":"2020-02-07T15:20:51.243Z","comments":true,"path":"2020/02/07/蓝桥杯—-入门训练-Fibonacci数列/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E2%80%94-%E5%85%A5%E9%97%A8%E8%AE%AD%E7%BB%83-Fibonacci%E6%95%B0%E5%88%97/","excerpt":"资源限制时间限制：1.0s 内存限制：256.0MB 问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 样例输入10 样例输出55 样例输入22 样例输出7704 数据规模与约定1 &lt;= n &lt;= 1,000,000。","text":"资源限制时间限制：1.0s 内存限制：256.0MB 问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 样例输入10 样例输出55 样例输入22 样例输出7704 数据规模与约定1 &lt;= n &lt;= 1,000,000。 提交代码（Java）第一次提交第一次时候，我想使用递归的方式👇 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); System.out.println(F(n)%10007); sc.close(); } private static int F(int n) { if(n==1||n==2) return 1; else return F(n-1)+F(n-2); } } 提交后，系统提示【运行超时】👇 第二次提交使用递归来处理，比较耗时。 而且这次我按照题目的提示【说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。】来处理，就改用数组来实现👇 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int F[] = new int[n+2]; F[1] = F[2] = 1; if(n &gt; 2) { for(int i=3; i&lt;=n; i++) // F[i]直接计算到求余数的值，即保存余数 F[i]=(F[i-1]+F[i-2])%10007; } //F[n]即所求值 System.out.println(F[n]); sc.close(); } } 这次直接通过👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://melodyjerry.github.io/blog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"Java之printf格式化输出的例子","slug":"Java之printf格式化输出的例子","date":"2020-02-07T09:46:23.000Z","updated":"2020-02-07T15:20:51.226Z","comments":true,"path":"2020/02/07/Java之printf格式化输出的例子/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/07/Java%E4%B9%8Bprintf%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%9A%84%E4%BE%8B%E5%AD%90/","excerpt":"转载自菜鸟教程","text":"转载自菜鸟教程 import java.util.Date; /** * 使用printf输出 */ /**关键技术点 * 使用java.io.PrintStream的printf方法实现C风格的输出 * printf 方法的第一个参数为输出的格式,第二个参数是可变长的,表示待输出的数据对象 */ public class Printf { public static void main(String[] args) { /*** 输出字符串 ***/ // %s表示输出字符串，也就是将后面的字符串替换模式中的%s System.out.printf(\"%s\", new Integer(1212)); // %n表示换行 System.out.printf(\"%s%n\", \"end line\"); // 还可以支持多个参数 System.out.printf(\"%s = %s%n\", \"Name\", \"Zhangsan\"); // %S将字符串以大写形式输出 System.out.printf(\"%S = %s%n\", \"Name\", \"Zhangsan\"); // 支持多个参数时，可以在%s之间插入变量编号，1$表示第一个字符串，3$表示第3个字符串 System.out.printf(\"%1$s = %3$s %2$s%n\", \"Name\", \"san\", \"Zhang\"); /*** 输出boolean类型 ***/ System.out.printf(\"true = %b; false = \", true); System.out.printf(\"%b%n\", false); /*** 输出整数类型***/ Integer iObj = 342; // %d表示将整数格式化为10进制整数 System.out.printf(\"%d; %d; %d%n\", -500, 2343L, iObj); // %o表示将整数格式化为8进制整数 System.out.printf(\"%o; %o; %o%n\", -500, 2343L, iObj); // %x表示将整数格式化为16进制整数 System.out.printf(\"%x; %x; %x%n\", -500, 2343L, iObj); // %X表示将整数格式化为16进制整数，并且字母变成大写形式 System.out.printf(\"%X; %X; %X%n\", -500, 2343L, iObj); /*** 输出浮点类型***/ Double dObj = 45.6d; // %e表示以科学技术法输出浮点数 System.out.printf(\"%e; %e; %e%n\", -756.403f, 7464.232641d, dObj); // %E表示以科学技术法输出浮点数，并且为大写形式 System.out.printf(\"%E; %E; %E%n\", -756.403f, 7464.232641d, dObj); // %f表示以十进制格式化输出浮点数 System.out.printf(\"%f; %f; %f%n\", -756.403f, 7464.232641d, dObj); // 还可以限制小数点后的位数 System.out.printf(\"%.1f; %.3f; %f%n\", -756.403f, 7464.232641d, dObj); /*** 输出日期类型***/ // %t表示格式化日期时间类型，%T是时间日期的大写形式，在%t之后用特定的字母表示不同的输出格式 Date date = new Date(); long dataL = date.getTime(); // 格式化年月日 // %t之后用y表示输出日期的年份（2位数的年，如99） // %t之后用m表示输出日期的月份，%t之后用d表示输出日期的日号 System.out.printf(\"%1$ty-%1$tm-%1$td; %2$ty-%2$tm-%2$td%n\", date, dataL); // %t之后用Y表示输出日期的年份（4位数的年）， // %t之后用B表示输出日期的月份的完整名， %t之后用b表示输出日期的月份的简称 System.out.printf(\"%1$tY-%1$tB-%1$td; %2$tY-%2$tb-%2$td%n\", date, dataL); // 以下是常见的日期组合 // %t之后用D表示以 \"%tm/%td/%ty\"格式化日期 System.out.printf(\"%1$tD%n\", date); //%t之后用F表示以\"%tY-%tm-%td\"格式化日期 System.out.printf(\"%1$tF%n\", date); /*** 输出时间类型***/ // 输出时分秒 // %t之后用H表示输出时间的时（24进制），%t之后用I表示输出时间的时（12进制）， // %t之后用M表示输出时间的分，%t之后用S表示输出时间的秒 System.out.printf(\"%1$tH:%1$tM:%1$tS; %2$tI:%2$tM:%2$tS%n\", date, dataL); // %t之后用L表示输出时间的秒中的毫秒 System.out.printf(\"%1$tH:%1$tM:%1$tS %1$tL%n\", date); // %t之后p表示输出时间的上午或下午信息 System.out.printf(\"%1$tH:%1$tM:%1$tS %1$tL %1$tp%n\", date); // 以下是常见的时间组合 // %t之后用R表示以\"%tH:%tM\"格式化时间 System.out.printf(\"%1$tR%n\", date); // %t之后用T表示以\"%tH:%tM:%tS\"格式化时间 System.out.printf(\"%1$tT%n\", date); // %t之后用r表示以\"%tI:%tM:%tS %Tp\"格式化时间 System.out.printf(\"%1$tr%n\", date); /*** 输出星期***/ // %t之后用A表示得到星期几的全称 System.out.printf(\"%1$tF %1$tA%n\", date); // %t之后用a表示得到星期几的简称 System.out.printf(\"%1$tF %1$ta%n\", date); // 输出时间日期的完整信息 System.out.printf(\"%1$tc%n\", date); } } /** *printf方法中,格式为\"%s\"表示以字符串的形式输出第二个可变长参数的第一个参数值; *格式为\"%n\"表示换行;格式为\"%S\"表示将字符串以大写形式输出;在\"%s\"之间用\"n$\"表示 *输出可变长参数的第n个参数值.格式为\"%b\"表示以布尔值的形式输出第二个可变长参数 *的第一个参数值. */ /** * 格式为\"%d\"表示以十进制整数形式输出;\"%o\"表示以八进制形式输出;\"%x\"表示以十六进制 * 输出;\"%X\"表示以十六进制输出,并且将字母(A、B、C、D、E、F)换成大写.格式为\"%e\"表 * 以科学计数法输出浮点数;格式为\"%E\"表示以科学计数法输出浮点数,而且将e大写;格式为 * \"%f\"表示以十进制浮点数输出,在\"%f\"之间加上\".n\"表示输出时保留小数点后面n位. */ /** * 格式为\"%t\"表示输出时间日期类型.\"%t\"之后用y表示输出日期的二位数的年份(如99)、用m * 表示输出日期的月份,用d表示输出日期的日号;\"%t\"之后用Y表示输出日期的四位数的年份 * (如1999)、用B表示输出日期的月份的完整名,用b表示输出日期的月份的简称.\"%t\"之后用D * 表示以\"%tm/%td/%ty\"的格式输出日期、用F表示以\"%tY-%tm-%td\"的格式输出日期. */ /** * \"%t\"之后用H表示输出时间的时(24进制),用I表示输出时间的时(12进制),用M表示输出时间 * 分,用S表示输出时间的秒,用L表示输出时间的秒中的毫秒数、用 p 表示输出时间的是上午还是 * 下午.\"%t\"之后用R表示以\"%tH:%tM\"的格式输出时间、用T表示以\"%tH:%tM:%tS\"的格式输出 * 时间、用r表示以\"%tI:%tM:%tS %Tp\"的格式输出时间. */ /** * \"%t\"之后用A表示输出日期的全称,用a表示输出日期的星期简称. */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}],"author":{"name":"菜鸟教程","url":"https://www.runoob.com/"}},{"title":"给博客添加一些挂件","slug":"转-给博客添加一些挂件","date":"2020-02-05T14:40:27.000Z","updated":"2020-04-23T06:23:01.981Z","comments":true,"path":"2020/02/05/转-给博客添加一些挂件/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/%E8%BD%AC-%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E6%8C%82%E4%BB%B6/","excerpt":"阅读了官方文档 和 TRHX‘S BLOG 等文档/文章后，搜集了一部分教程","text":"阅读了官方文档 和 TRHX‘S BLOG 等文档/文章后，搜集了一部分教程 自定义鼠标指针样式在 \\themes\\material-x\\source\\less\\_base.less 文件 body 样式里写入如下代码： body { cursor: url(https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur),auto; background-color: @theme_background; ...... ...... } 鼠标指针可以用 Axialis CursorWorkshop 这个软件自己制作，不同主题具体放的文件有所不同，确保在博客主体 body 的 CSS 文件中即可，其中的鼠标指针链接可替换成自己的，首先尝试加载 https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur ，如果该文件不存在或由于其他原因无效，那么 auto 会被使用，也就是自动默认效果，图片格式为.ico、.ani、.cur，建议使用.cur，如果使用.ani或者其他格式无效，原因是浏览器兼容问题，请阅读参考文档或者参考以下兼容表： 浏览器 最低版本 格式 Internet Explorer 6.0 .cur / .ani Firefox (Gecko), Windows and Linux 1.5 (1.8) .cur / .png / .gif / .jpg Firefox (Gecko) 4.0 (2.0) .cur / .png / .gif / .jpg / .svg Opera — — Safari (Webkit) 3.0 (522-523) .cur / .png / .gif / .jpg 拓展阅读：《CSS 鼠标样式 cursor属性》 （By：歪脖先生的博客） 打字特效（蓝色）&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.11\"&gt;&lt;/script&gt; &lt;script&gt;var typed = new Typed(\"#subtitle\", { strings: [\"Live a good life, write some good code !!!\", \"愿自己的努力终将获得回报。\", \"花开不是为了花落，而是为了开的更加灿烂。\", \"没有伞的孩子必须努力奔跑！\", \"欲望以提升热忱，毅力以磨平高山。\", \"如果放弃太早，你永远都不知道自己会错过什么。\", \"没有礁石，就没有美丽的浪花；没有挫折，就没有壮丽的人生。\"], startDelay: 1000, typeSpeed: 100, loop: !0, backSpeed: 60, backDelay: 2000, showCursor: !0 })&lt;/script&gt; &lt;div style=\"text-align: center;font-weight: bold;color: #1BC3FB;\"&gt; &lt;span id=\"subtitle\"&gt;没有伞的孩子必须努力奔跑！&lt;/span&gt;&lt;span class=\"typed-cursor typed-cursor--blink\"&gt;|&lt;/span&gt; &lt;span id=\"typed-cursor\"&gt;&lt;/span&gt; &lt;/div&gt; 效果 👇 var typed = new Typed(\"#subtitle\", { strings: [\"Live a good life, write some good code !!!\", \"愿自己的努力终将获得回报。\", \"花开不是为了花落，而是为了开的更加灿烂。\", \"没有伞的孩子必须努力奔跑！\", \"欲望以提升热忱，毅力以磨平高山。\", \"如果放弃太早，你永远都不知道自己会错过什么。\", \"没有礁石，就没有美丽的浪花；没有挫折，就没有壮丽的人生。\"], startDelay: 1000, typeSpeed: 100, loop: !0, backSpeed: 60, backDelay: 2000, showCursor: !0 }) 没有伞的孩子必须努力奔跑！| 网站访客地理信息 在.\\themes\\material-x\\layout\\layout.ejs中加入以下代码： &lt;!--网站访客地理信息--&gt; &lt;script type=\"text/javascript\" src=\"//rf.revolvermaps.com/0/0/8.js?i=5eqiqb8vl6p&amp;amp;m=2&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=33&amp;amp;z=17&amp;amp;rx=-40&amp;amp;lx=-540&amp;amp;ly=520&amp;amp;hi=60\" async=\"async\"&gt;&lt;/script&gt; 效果 👇 天气挂件 JS代码，用于将插件插入到网页内 &lt;div id=\"tp-weather-widget\"&gt;&lt;/div&gt; &lt;script&gt; (function(a,h,g,f,e,d,c,b){b=function(){d=h.createElement(g);c=h.getElementsByTagName(g)[0];d.src=e;d.charset=\"utf-8\";d.async=1;c.parentNode.insertBefore(d,c)};a[\"SeniverseWeatherWidgetObject\"]=f;a[f]||(a[f]=function(){(a[f].q=a[f].q||[]).push(arguments)});a[f].l=+new Date();if(a.attachEvent){a.attachEvent(\"onload\",b)}else{a.addEventListener(\"load\",b,false)}}(window,document,\"script\",\"SeniverseWeatherWidget\",\"//cdn.sencdn.com/widget2/static/js/bundle.js?t=\"+parseInt((new Date().getTime() / 100000000).toString(),10))); window.SeniverseWeatherWidget('show', { flavor: \"bubble\", location: \"WS0E9D8WN298\", geolocation: true, language: \"zh-Hans\", unit: \"c\", theme: \"auto\", token: \"5fd5b254-57fe-4f8a-8a13-f92485efeb0b\", hover: \"enabled\", container: \"tp-weather-widget\" }) &lt;/script&gt; 插件网页版链接，用于嵌入到iframe或webview中 &lt;iframe&gt;weather.seniverse.com/?token=5fd5b254-57fe-4f8a-8a13-f92485efeb0b&lt;/iframe&gt; 效果：见本博客页面左上角 背景添加动态线条效果在 .\\themes\\hexo-theme-spfk\\layout\\layout.ejs文件中添加如下代码： &lt;!--动态线条背景--&gt; &lt;script type=\"text/javascript\" color=\"220,220,220\" opacity='0.7' zIndex=\"-2\" count=\"200\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt; &lt;/script&gt; 其中： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0） opacity：表示线条透明度（0~1），默认：0.5 count：表示线条的总数量，默认：150 zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1 人体时钟无意中发现了个有趣的人体时钟 HONE HONE CLOCK，作者是个日本人，点击此处访问作者博客，点击此处在作者原博客上查看动态样式，点击此处查看动态大图，如果你的博客上有合适的地方，加上一个人体时钟会很有趣的 实现代码： &lt;!--人体时钟背景透明--&gt; &lt;script charset=\"Shift_JIS\" src=\"http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.js\"&gt;&lt;/script&gt; &lt;!--人体时钟背景白--&gt; &lt;script charset=\"Shift_JIS\" src=\"http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.js\"&gt;&lt;/script&gt; 背景动态彩带效果样式一是鼠标点击后彩带自动更换样式，样式二是飘动的彩带： 实现方法：在 \\themes\\material-x\\layout\\layout.ejs 文件的body前面添加如下代码： &lt;!-- 样式一（鼠标点击更换样式） --&gt; &lt;script src=\"https://g.joyinshare.com/hc/ribbon.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;!-- 样式二（飘动的彩带） --&gt; &lt;script src=\"https://g.joyinshare.com/hc/piao.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 樱花特效canvas樱花飘落动画特效 &lt;script&gt; var RENDERER = { INIT_CHERRY_BLOSSOM_COUNT : 30, MAX_ADDING_INTERVAL : 10, init : function(){ this.setParameters(); this.reconstructMethods(); this.createCherries(); this.render(); }, setParameters : function(){ this.$container = $('#jsi-cherry-container'); this.width = this.$container.width(); this.height = this.$container.height(); this.context = $('&lt;canvas /&gt;').attr({width : this.width, height : this.height}).appendTo(this.$container).get(0).getContext('2d'); this.cherries = []; this.maxAddingInterval = Math.round(this.MAX_ADDING_INTERVAL * 1000 / this.width); this.addingInterval = this.maxAddingInterval; }, reconstructMethods : function(){ this.render = this.render.bind(this); }, createCherries : function(){ for(var i = 0, length = Math.round(this.INIT_CHERRY_BLOSSOM_COUNT * this.width / 1000); i &lt; length; i++){ this.cherries.push(new CHERRY_BLOSSOM(this, true)); } }, render : function(){ requestAnimationFrame(this.render); this.context.clearRect(0, 0, this.width, this.height); this.cherries.sort(function(cherry1, cherry2){ return cherry1.z - cherry2.z; }); for(var i = this.cherries.length - 1; i &gt;= 0; i--){ if(!this.cherries[i].render(this.context)){ this.cherries.splice(i, 1); } } if(--this.addingInterval == 0){ this.addingInterval = this.maxAddingInterval; this.cherries.push(new CHERRY_BLOSSOM(this, false)); } } }; var CHERRY_BLOSSOM = function(renderer, isRandom){ this.renderer = renderer; this.init(isRandom); }; CHERRY_BLOSSOM.prototype = { FOCUS_POSITION : 300, FAR_LIMIT : 600, MAX_RIPPLE_COUNT : 100, RIPPLE_RADIUS : 100, SURFACE_RATE : 0.5, SINK_OFFSET : 20, init : function(isRandom){ this.x = this.getRandomValue(-this.renderer.width, this.renderer.width); this.y = isRandom ? this.getRandomValue(0, this.renderer.height) : this.renderer.height * 1.5; this.z = this.getRandomValue(0, this.FAR_LIMIT); this.vx = this.getRandomValue(-2, 2); this.vy = -2; this.theta = this.getRandomValue(0, Math.PI * 2); this.phi = this.getRandomValue(0, Math.PI * 2); this.psi = 0; this.dpsi = this.getRandomValue(Math.PI / 600, Math.PI / 300); this.opacity = 0; this.endTheta = false; this.endPhi = false; this.rippleCount = 0; var axis = this.getAxis(), theta = this.theta + Math.ceil(-(this.y + this.renderer.height * this.SURFACE_RATE) / this.vy) * Math.PI / 500; theta %= Math.PI * 2; this.offsetY = 40 * ((theta &lt;= Math.PI / 2 || theta &gt;= Math.PI * 3 / 2) ? -1 : 1); this.thresholdY = this.renderer.height / 2 + this.renderer.height * this.SURFACE_RATE * axis.rate; this.entityColor = this.renderer.context.createRadialGradient(0, 40, 0, 0, 40, 80); this.entityColor.addColorStop(0, 'hsl(330, 70%, ' + 50 * (0.3 + axis.rate) + '%)'); this.entityColor.addColorStop(0.05, 'hsl(330, 40%,' + 55 * (0.3 + axis.rate) + '%)'); this.entityColor.addColorStop(1, 'hsl(330, 20%, ' + 70 * (0.3 + axis.rate) + '%)'); this.shadowColor = this.renderer.context.createRadialGradient(0, 40, 0, 0, 40, 80); this.shadowColor.addColorStop(0, 'hsl(330, 40%, ' + 30 * (0.3 + axis.rate) + '%)'); this.shadowColor.addColorStop(0.05, 'hsl(330, 40%,' + 30 * (0.3 + axis.rate) + '%)'); this.shadowColor.addColorStop(1, 'hsl(330, 20%, ' + 40 * (0.3 + axis.rate) + '%)'); }, getRandomValue : function(min, max){ return min + (max - min) * Math.random(); }, getAxis : function(){ var rate = this.FOCUS_POSITION / (this.z + this.FOCUS_POSITION), x = this.renderer.width / 2 + this.x * rate, y = this.renderer.height / 2 - this.y * rate; return {rate : rate, x : x, y : y}; }, renderCherry : function(context, axis){ context.beginPath(); context.moveTo(0, 40); context.bezierCurveTo(-60, 20, -10, -60, 0, -20); context.bezierCurveTo(10, -60, 60, 20, 0, 40); context.fill(); for(var i = -4; i &lt; 4; i++){ context.beginPath(); context.moveTo(0, 40); context.quadraticCurveTo(i * 12, 10, i * 4, -24 + Math.abs(i) * 2); context.stroke(); } }, render : function(context){ var axis = this.getAxis(); if(axis.y == this.thresholdY &amp;&amp; this.rippleCount &lt; this.MAX_RIPPLE_COUNT){ context.save(); context.lineWidth = 2; context.strokeStyle = 'hsla(0, 0%, 100%, ' + (this.MAX_RIPPLE_COUNT - this.rippleCount) / this.MAX_RIPPLE_COUNT + ')'; context.translate(axis.x + this.offsetY * axis.rate * (this.theta &lt;= Math.PI ? -1 : 1), axis.y); context.scale(1, 0.3); context.beginPath(); context.arc(0, 0, this.rippleCount / this.MAX_RIPPLE_COUNT * this.RIPPLE_RADIUS * axis.rate, 0, Math.PI * 2, false); context.stroke(); context.restore(); this.rippleCount++; } if(axis.y &lt; this.thresholdY || (!this.endTheta || !this.endPhi)){ if(this.y &lt;= 0){ this.opacity = Math.min(this.opacity + 0.01, 1); } context.save(); context.globalAlpha = this.opacity; context.fillStyle = this.shadowColor; context.strokeStyle = 'hsl(330, 30%,' + 40 * (0.3 + axis.rate) + '%)'; context.translate(axis.x, Math.max(axis.y, this.thresholdY + this.thresholdY - axis.y)); context.rotate(Math.PI - this.theta); context.scale(axis.rate * -Math.sin(this.phi), axis.rate); context.translate(0, this.offsetY); this.renderCherry(context, axis); context.restore(); } context.save(); context.fillStyle = this.entityColor; context.strokeStyle = 'hsl(330, 40%,' + 70 * (0.3 + axis.rate) + '%)'; context.translate(axis.x, axis.y + Math.abs(this.SINK_OFFSET * Math.sin(this.psi) * axis.rate)); context.rotate(this.theta); context.scale(axis.rate * Math.sin(this.phi), axis.rate); context.translate(0, this.offsetY); this.renderCherry(context, axis); context.restore(); if(this.y &lt;= -this.renderer.height / 4){ if(!this.endTheta){ for(var theta = Math.PI / 2, end = Math.PI * 3 / 2; theta &lt;= end; theta += Math.PI){ if(this.theta &lt; theta &amp;&amp; this.theta + Math.PI / 200 &gt; theta){ this.theta = theta; this.endTheta = true; break; } } } if(!this.endPhi){ for(var phi = Math.PI / 8, end = Math.PI * 7 / 8; phi &lt;= end; phi += Math.PI * 3 / 4){ if(this.phi &lt; phi &amp;&amp; this.phi + Math.PI / 200 &gt; phi){ this.phi = Math.PI / 8; this.endPhi = true; break; } } } } if(!this.endTheta){ if(axis.y == this.thresholdY){ this.theta += Math.PI / 200 * ((this.theta &lt; Math.PI / 2 || (this.theta &gt;= Math.PI &amp;&amp; this.theta &lt; Math.PI * 3 / 2)) ? 1 : -1); }else{ this.theta += Math.PI / 500; } this.theta %= Math.PI * 2; } if(this.endPhi){ if(this.rippleCount == this.MAX_RIPPLE_COUNT){ this.psi += this.dpsi; this.psi %= Math.PI * 2; } }else{ this.phi += Math.PI / ((axis.y == this.thresholdY) ? 200 : 500); this.phi %= Math.PI; } if(this.y &lt;= -this.renderer.height * this.SURFACE_RATE){ this.x += 2; this.y = -this.renderer.height * this.SURFACE_RATE; }else{ this.x += this.vx; this.y += this.vy; } return this.z &gt; -this.FOCUS_POSITION &amp;&amp; this.z &lt; this.FAR_LIMIT &amp;&amp; this.x &lt; this.renderer.width * 1.5; } }; $(function(){ RENDERER.init(); });&lt;/script&gt; 或者 &lt;div id=\"jsi-cherry-container\" class=\"container\"&gt;&lt;canvas width=\"1536\" height=\"80\"&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt; var RENDERER = { INIT_CHERRY_BLOSSOM_COUNT : 30, MAX_ADDING_INTERVAL : 10, init : function(){ this.setParameters(); this.reconstructMethods(); this.createCherries(); this.render(); }, setParameters : function(){ this.$container = $('#jsi-cherry-container'); this.width = this.$container.width(); this.height = this.$container.height(); this.context = $('&lt;canvas /&gt;').attr({width : this.width, height : this.height}).appendTo(this.$container).get(0).getContext('2d'); this.cherries = []; this.maxAddingInterval = Math.round(this.MAX_ADDING_INTERVAL * 1000 / this.width); this.addingInterval = this.maxAddingInterval; }, reconstructMethods : function(){ this.render = this.render.bind(this); }, createCherries : function(){ for(var i = 0, length = Math.round(this.INIT_CHERRY_BLOSSOM_COUNT * this.width / 1000); i &lt; length; i++){ this.cherries.push(new CHERRY_BLOSSOM(this, true)); } }, render : function(){ requestAnimationFrame(this.render); this.context.clearRect(0, 0, this.width, this.height); this.cherries.sort(function(cherry1, cherry2){ return cherry1.z - cherry2.z; }); for(var i = this.cherries.length - 1; i &gt;= 0; i--){ if(!this.cherries[i].render(this.context)){ this.cherries.splice(i, 1); } } if(--this.addingInterval == 0){ this.addingInterval = this.maxAddingInterval; this.cherries.push(new CHERRY_BLOSSOM(this, false)); } } }; var CHERRY_BLOSSOM = function(renderer, isRandom){ this.renderer = renderer; this.init(isRandom); }; CHERRY_BLOSSOM.prototype = { FOCUS_POSITION : 300, FAR_LIMIT : 600, MAX_RIPPLE_COUNT : 100, RIPPLE_RADIUS : 100, SURFACE_RATE : 0.5, SINK_OFFSET : 20, init : function(isRandom){ this.x = this.getRandomValue(-this.renderer.width, this.renderer.width); this.y = isRandom ? this.getRandomValue(0, this.renderer.height) : this.renderer.height * 1.5; this.z = this.getRandomValue(0, this.FAR_LIMIT); this.vx = this.getRandomValue(-2, 2); this.vy = -2; this.theta = this.getRandomValue(0, Math.PI * 2); this.phi = this.getRandomValue(0, Math.PI * 2); this.psi = 0; this.dpsi = this.getRandomValue(Math.PI / 600, Math.PI / 300); this.opacity = 0; this.endTheta = false; this.endPhi = false; this.rippleCount = 0; var axis = this.getAxis(), theta = this.theta + Math.ceil(-(this.y + this.renderer.height * this.SURFACE_RATE) / this.vy) * Math.PI / 500; theta %= Math.PI * 2; this.offsetY = 40 * ((theta &lt;= Math.PI / 2 || theta &gt;= Math.PI * 3 / 2) ? -1 : 1); this.thresholdY = this.renderer.height / 2 + this.renderer.height * this.SURFACE_RATE * axis.rate; this.entityColor = this.renderer.context.createRadialGradient(0, 40, 0, 0, 40, 80); this.entityColor.addColorStop(0, 'hsl(330, 70%, ' + 50 * (0.3 + axis.rate) + '%)'); this.entityColor.addColorStop(0.05, 'hsl(330, 40%,' + 55 * (0.3 + axis.rate) + '%)'); this.entityColor.addColorStop(1, 'hsl(330, 20%, ' + 70 * (0.3 + axis.rate) + '%)'); this.shadowColor = this.renderer.context.createRadialGradient(0, 40, 0, 0, 40, 80); this.shadowColor.addColorStop(0, 'hsl(330, 40%, ' + 30 * (0.3 + axis.rate) + '%)'); this.shadowColor.addColorStop(0.05, 'hsl(330, 40%,' + 30 * (0.3 + axis.rate) + '%)'); this.shadowColor.addColorStop(1, 'hsl(330, 20%, ' + 40 * (0.3 + axis.rate) + '%)'); }, getRandomValue : function(min, max){ return min + (max - min) * Math.random(); }, getAxis : function(){ var rate = this.FOCUS_POSITION / (this.z + this.FOCUS_POSITION), x = this.renderer.width / 2 + this.x * rate, y = this.renderer.height / 2 - this.y * rate; return {rate : rate, x : x, y : y}; }, renderCherry : function(context, axis){ context.beginPath(); context.moveTo(0, 40); context.bezierCurveTo(-60, 20, -10, -60, 0, -20); context.bezierCurveTo(10, -60, 60, 20, 0, 40); context.fill(); for(var i = -4; i &lt; 4; i++){ context.beginPath(); context.moveTo(0, 40); context.quadraticCurveTo(i * 12, 10, i * 4, -24 + Math.abs(i) * 2); context.stroke(); } }, render : function(context){ var axis = this.getAxis(); if(axis.y == this.thresholdY &amp;&amp; this.rippleCount &lt; this.MAX_RIPPLE_COUNT){ context.save(); context.lineWidth = 2; context.strokeStyle = 'hsla(0, 0%, 100%, ' + (this.MAX_RIPPLE_COUNT - this.rippleCount) / this.MAX_RIPPLE_COUNT + ')'; context.translate(axis.x + this.offsetY * axis.rate * (this.theta &lt;= Math.PI ? -1 : 1), axis.y); context.scale(1, 0.3); context.beginPath(); context.arc(0, 0, this.rippleCount / this.MAX_RIPPLE_COUNT * this.RIPPLE_RADIUS * axis.rate, 0, Math.PI * 2, false); context.stroke(); context.restore(); this.rippleCount++; } if(axis.y &lt; this.thresholdY || (!this.endTheta || !this.endPhi)){ if(this.y &lt;= 0){ this.opacity = Math.min(this.opacity + 0.01, 1); } context.save(); context.globalAlpha = this.opacity; context.fillStyle = this.shadowColor; context.strokeStyle = 'hsl(330, 30%,' + 40 * (0.3 + axis.rate) + '%)'; context.translate(axis.x, Math.max(axis.y, this.thresholdY + this.thresholdY - axis.y)); context.rotate(Math.PI - this.theta); context.scale(axis.rate * -Math.sin(this.phi), axis.rate); context.translate(0, this.offsetY); this.renderCherry(context, axis); context.restore(); } context.save(); context.fillStyle = this.entityColor; context.strokeStyle = 'hsl(330, 40%,' + 70 * (0.3 + axis.rate) + '%)'; context.translate(axis.x, axis.y + Math.abs(this.SINK_OFFSET * Math.sin(this.psi) * axis.rate)); context.rotate(this.theta); context.scale(axis.rate * Math.sin(this.phi), axis.rate); context.translate(0, this.offsetY); this.renderCherry(context, axis); context.restore(); if(this.y &lt;= -this.renderer.height / 4){ if(!this.endTheta){ for(var theta = Math.PI / 2, end = Math.PI * 3 / 2; theta &lt;= end; theta += Math.PI){ if(this.theta &lt; theta &amp;&amp; this.theta + Math.PI / 200 &gt; theta){ this.theta = theta; this.endTheta = true; break; } } } if(!this.endPhi){ for(var phi = Math.PI / 8, end = Math.PI * 7 / 8; phi &lt;= end; phi += Math.PI * 3 / 4){ if(this.phi &lt; phi &amp;&amp; this.phi + Math.PI / 200 &gt; phi){ this.phi = Math.PI / 8; this.endPhi = true; break; } } } } if(!this.endTheta){ if(axis.y == this.thresholdY){ this.theta += Math.PI / 200 * ((this.theta &lt; Math.PI / 2 || (this.theta &gt;= Math.PI &amp;&amp; this.theta &lt; Math.PI * 3 / 2)) ? 1 : -1); }else{ this.theta += Math.PI / 500; } this.theta %= Math.PI * 2; } if(this.endPhi){ if(this.rippleCount == this.MAX_RIPPLE_COUNT){ this.psi += this.dpsi; this.psi %= Math.PI * 2; } }else{ this.phi += Math.PI / ((axis.y == this.thresholdY) ? 200 : 500); this.phi %= Math.PI; } if(this.y &lt;= -this.renderer.height * this.SURFACE_RATE){ this.x += 2; this.y = -this.renderer.height * this.SURFACE_RATE; }else{ this.x += this.vx; this.y += this.vy; } return this.z &gt; -this.FOCUS_POSITION &amp;&amp; this.z &lt; this.FAR_LIMIT &amp;&amp; this.x &lt; this.renderer.width * 1.5; } }; $(function(){ RENDERER.init(); });&lt;/script&gt; 其他： H5樱花掉落背景动画特效 ：https://www.17sucai.com/pins/36303.html 添加背景代码雨特效新建 DigitalRain.js，写入以下代码： 复制window.onload = function(){ //获取画布对象 var canvas = document.getElementById(\"canvas\"); //获取画布的上下文 var context =canvas.getContext(\"2d\"); var s = window.screen; var W = canvas.width = s.width; var H = canvas.height; //获取浏览器屏幕的宽度和高度 //var W = window.innerWidth; //var H = window.innerHeight; //设置canvas的宽度和高度 canvas.width = W; canvas.height = H; //每个文字的字体大小 var fontSize = 12; //计算列 var colunms = Math.floor(W /fontSize); //记录每列文字的y轴坐标 var drops = []; //给每一个文字初始化一个起始点的位置 for(var i=0;i&lt;colunms;i++){ drops.push(0); } //运动的文字 var str =\"WELCOME TO WWW.ITRHX.COM\"; //4:fillText(str,x,y);原理就是去更改y的坐标位置 //绘画的函数 function draw(){ context.fillStyle = \"rgba(238,238,238,.08)\";//遮盖层 context.fillRect(0,0,W,H); //给字体设置样式 context.font = \"600 \"+fontSize+\"px Georgia\"; //给字体添加颜色 context.fillStyle = [\"#33B5E5\", \"#0099CC\", \"#AA66CC\", \"#9933CC\", \"#99CC00\", \"#669900\", \"#FFBB33\", \"#FF8800\", \"#FF4444\", \"#CC0000\"][parseInt(Math.random() * 10)];//randColor();可以rgb,hsl, 标准色，十六进制颜色 //写入画布中 for(var i=0;i&lt;colunms;i++){ var index = Math.floor(Math.random() * str.length); var x = i*fontSize; var y = drops[i] *fontSize; context.fillText(str[index],x,y); //如果要改变时间，肯定就是改变每次他的起点 if(y &gt;= canvas.height &amp;&amp; Math.random() &gt; 0.99){ drops[i] = 0; } drops[i]++; } }; function randColor(){//随机颜色 var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return \"rgb(\"+r+\",\"+g+\",\"+b+\")\"; } draw(); setInterval(draw,35); }; 在主题文件的相关css文件中（以 Material X 1.2.1 主题为例，在\\themes\\material-x-1.2.1\\source\\less_main.less 文件末尾）添加以下代码： 复制canvas { position: fixed; right: 0px; bottom: 0px; min-width: 100%; min-height: 100%; height: auto; width: auto; z-index: -1; } 然后在主题的 layout.ejs 文件中引入即可： 复制&lt;!-- 数字雨 --&gt; &lt;canvas id=\"canvas\" width=\"1440\" height=\"900\" &gt;&lt;/canvas&gt; &lt;script type=\"text/javascript\" src=\"/js/DigitalRain.js\"&gt;&lt;/script&gt; 最终效果： 自定义一个不使用主题模板渲染的独立页面 有时候我们需要新建一个独立的页面，这个页面不使用主题的渲染，具有自己独立的样式，可以放一些自己的作品，相册什么的，以下就介绍这种独立页面的实现方法。 方法一： 使用 Hexo 提供的跳过渲染配置，在博客根目录的配置文件 _config.yml 里找到 skip_render 关键字，在后面添加想要跳过渲染的页面，比如我们创建 \\source\\about\\index.html， 配置文件填写：skip_render: about\\**，那么就表示 \\source\\about 里所有的文件将跳过渲染，里面的文件将会被直接复制到 public 文件夹，此时就会得到一个独立的 about 页面；官方文档：https://hexo.io/docs/configuration 方法二： 在文章头部的 Front-matter 里添加配置 layout: false 来跳过渲染配置，比如我们要使 about 页面跳过渲染，创建 \\source\\about\\index.md，将这个页面的相关 HTML 代码写进.md文件并保存，然后在 index.md 的头部写入： --- layout: false --- {% raw %} 这里是 HTML 代码 {% endraw %} PS：Front-matter 是 .md 文件最上方以 — 分隔的区域，用于指定个别文件的变量，官方文档：https://hexo.io/docs/front-matter 效果可以对比我的博客主页和关于页面 更改本地预览端口号hexo博客在执行 hexo s 进行本地预览的时候，默认端口号是4000，当该端口号被占用时会报错 Error: listen EADDRINUSE 0.0.0.0:4000 ，此时可以关闭占用该端口的进程，也可以更换端口号，更换端口号可以通过以下两种方法实现： 方法一：在根目录的 _config.yml 配置文件内加上如下代码更改 hexo s 运行时的端口号： server: port: 5000 compress: true header: true 方法二：通过 hexo server -p 5000 命令来指定端口，这种方法只是本次执行有效 其他网页小挂件推荐 http://abowman.com/ 里面有很多有趣的小挂件，可以养养鱼、龟、狗、仓鼠等各式各样的虚拟宠物，能根据你的鼠标指针位置移动，直接复制代码就可以用 http://www.revolvermaps.com/ 它提供网站访客地理信息，可以以2D、3D等形式显示 http://www.amazingcounters.com/ 免费网站计数器，有非常多的样式供你选择，可以设置计数器初始数值，可以设置按访问量计数，也可以按独立访问者计数 https://www.seniverse.com/widget/get 心知天气提供基于Web的免费天气插件，可以为你的网站添加一项简洁美观的天气预报功能，并自动适配PC和手机上的浏览 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"[转]使用Hexo-Git-Backup插件备份你的Hexo博客","slug":"转-使用Hexo-Git-Backup插件备份你的Hexo博客","date":"2020-02-05T12:20:43.000Z","updated":"2020-02-07T15:20:51.244Z","comments":true,"path":"2020/02/05/转-使用Hexo-Git-Backup插件备份你的Hexo博客/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/%E8%BD%AC-%E4%BD%BF%E7%94%A8Hexo-Git-Backup%E6%8F%92%E4%BB%B6%E5%A4%87%E4%BB%BD%E4%BD%A0%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/","excerpt":"欢迎关注我的 CSDN 专栏：《个人博客搭建：Hexo+Github Pages》，从搭建到美化一条龙，帮你解决 Hexo 常见问题！ 由于 Hexo 博客是静态托管的，所有的原始数据都保存在本地，如果哪一天电脑坏了，或者是误删了本地数据，那就是叫天天不应叫地地不灵了，此时定时备份就显得比较重要了，常见的备份方法有：打包数据保存到U盘、云盘或者其他地方，但是早就有大神开发了备份插件：hexo-git-backup ，只需要一个命令就可以将所有数据包括主题文件备份到 github 了","text":"欢迎关注我的 CSDN 专栏：《个人博客搭建：Hexo+Github Pages》，从搭建到美化一条龙，帮你解决 Hexo 常见问题！ 由于 Hexo 博客是静态托管的，所有的原始数据都保存在本地，如果哪一天电脑坏了，或者是误删了本地数据，那就是叫天天不应叫地地不灵了，此时定时备份就显得比较重要了，常见的备份方法有：打包数据保存到U盘、云盘或者其他地方，但是早就有大神开发了备份插件：hexo-git-backup ，只需要一个命令就可以将所有数据包括主题文件备份到 github 了 首先进入你博客目录，输入命令 hexo version 查看 Hexo 版本，如图所示，我的版本是 3.7.1： 安装备份插件，如果你的 Hexo 版本是 2.x.x，则使用以下命令安装： $ npm install hexo-git-backup@0.0.91 --save 如果你的 Hexo 版本是 3.x.x，则使用以下命令安装： $ npm install hexo-git-backup --save 到 Hexo 博客根目录的 _config.yml 配置文件里添加以下配置： backup: type: git theme: material-x-1.2.1 message: Back up my www.itrhx.com blog repository: github: git@github.com:TRHX/TRHX.github.io.git,backup coding: git@git.dev.tencent.com:TRHX/TRHX.git,backup 参数解释： theme：你要备份的主题名称 message：自定义提交信息 repository：仓库名，注意仓库地址后面要添加一个分支名，比如我就创建了一个 backup 分支 最后使用以下命令备份你的博客： $ hexo backup 或者使用以下简写命令也可以： $ hexo b 备份成功后可以在你的仓库分支下看到备份的原始文件： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"}],"author":{"name":"TRHX","avatar":"https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.9/images/trhx.png","url":"https://www.itrhx.com/"}},{"title":"RSS订阅(含转载内容)","slug":"RSS订阅-含转载内容","date":"2020-02-05T12:06:45.000Z","updated":"2020-02-07T15:20:51.229Z","comments":true,"path":"2020/02/05/RSS订阅-含转载内容/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/RSS%E8%AE%A2%E9%98%85-%E5%90%AB%E8%BD%AC%E8%BD%BD%E5%86%85%E5%AE%B9/","excerpt":"添加RSS订阅RSS订阅是站点用来和其他站点之间共享内容的一种简易方式，即Really Simple Syndication（简易信息聚合），如果不会使用，可以参见百度百科：https://baike.baidu.com/item/RSS%E8%AE%A2%E9%98%85/663114 ；首先我们安装feed插件，在本地hexo目录下右键git bash here，输入以下命令： $ npm install hexo-generator-feed 等待安装完成后，打开hexo目录下配置文件的_config.yml，在末尾添加以下配置： # Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 随后打开主题配置文件_config.yml，添加以下配置： rss: /atom.xml 至此，RSS订阅功能添加完成 【注】以下内容转载自互联网，其作者：奔跑中的奶酪 《可能是目前最全的RSS订阅源了》导读继上一篇文章《当我们谈论RSS时，我们在谈论什么？ 》发布后，阅读甚少，反响也是平平。奶酪不得不承认一个事实，RSS 做为一种“上古神器”，如果你经历过 RSS 的风光时期，你会一直喜欢它。但如果你对它了解甚少，尽管我再如何推荐，高使用门槛还是很难让你对RSS喜欢得起来。 RSS 高门槛的主要原因在于，优质RSS阅读器选择少，以及订阅源的缺失。上一期我极力推荐了一款在线 RSS 阅读器 Feeder.co，它已经足够的优秀了。所以接下来的问题，就是解决如何寻找订阅源的问题了，而本期内容正是解决如何查找RSS 订阅源的问题。","text":"添加RSS订阅RSS订阅是站点用来和其他站点之间共享内容的一种简易方式，即Really Simple Syndication（简易信息聚合），如果不会使用，可以参见百度百科：https://baike.baidu.com/item/RSS%E8%AE%A2%E9%98%85/663114 ；首先我们安装feed插件，在本地hexo目录下右键git bash here，输入以下命令： $ npm install hexo-generator-feed 等待安装完成后，打开hexo目录下配置文件的_config.yml，在末尾添加以下配置： # Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 随后打开主题配置文件_config.yml，添加以下配置： rss: /atom.xml 至此，RSS订阅功能添加完成 【注】以下内容转载自互联网，其作者：奔跑中的奶酪 《可能是目前最全的RSS订阅源了》导读继上一篇文章《当我们谈论RSS时，我们在谈论什么？ 》发布后，阅读甚少，反响也是平平。奶酪不得不承认一个事实，RSS 做为一种“上古神器”，如果你经历过 RSS 的风光时期，你会一直喜欢它。但如果你对它了解甚少，尽管我再如何推荐，高使用门槛还是很难让你对RSS喜欢得起来。 RSS 高门槛的主要原因在于，优质RSS阅读器选择少，以及订阅源的缺失。上一期我极力推荐了一款在线 RSS 阅读器 Feeder.co，它已经足够的优秀了。所以接下来的问题，就是解决如何寻找订阅源的问题了，而本期内容正是解决如何查找RSS 订阅源的问题。 一、万物皆可RSS如果你细心观察就会发现，提供 RSS 相关服务的网站都是国外的，国内与 RSS 相关的网站都相继宣布关闭了。你会发现国内提供 RSS 相关服务的网站都是个人或者小机构，这其中有一个叫 RSSHub 的网站，是这其中的集大成者，它的作用是可以给任何奇奇怪怪的内容生成 RSS 订阅源。 一般网站和博客： 1). 通常在顶部菜单、右侧菜单、底部菜单等地方会有RSS图标。 2). 如果没有，可以尝试在网站地址后面加上/rss或者/feed，有时会出现在二级域名里。 3). 如果还没有，可以使用奶酪制作的小书签来自动查找RSS订阅源，订阅到Feeder ，订阅到Inoreader ，订阅到Feedly 4). 如果还是没有，可能网站没有提供RSS订阅。可以借用 Fivefilters.org 或者 Feedity.com来制作订阅源。 5). 对于一些只提供了摘要RSS的网站，可以使用 FeedEx.Net 来制作全文RSS。 论坛： 一般会有 RSS 图标，如果没有，在网址后面加上 ?mod=rss。 比如网址 http://bbs.kafan.cn/forum-215-1.html ，其 rss 地址为 http://bbs.kafan.cn/forum-215-1.html?mod=rss 微博： https://rsshub.app/weibo/user2/博主ID，比如 https://rsshub.app/weibo/user2/1195230310 微信公众号： 在 瓦斯阅读 搜索要订阅的公众号名称，就会有专门的RSS订阅地址。 简书： https://rsshub.app/jianshu/user/作者ID，比如 https://rsshub.app/jianshu/user/yZq3ZV B站： https://rsshub.app/bilibili/user/video/UP主ID，比如 https://rsshub.app/bilibili/user/video/2267573 贴吧： 精品贴订阅：https://rsshub.app/tieba/forum/good/贴吧吧名（支持中文）， 比如 https://rsshub.app/tieba/forum/good/哲学 知乎： 知乎热榜： https://rsshub.app/zhihu/hotlist 用户动态：https://rsshub.app/zhihu/people/activities/用户ID， 比如 https://rsshub.app/zhihu/people/activities/runningcheese 知乎专栏：https://rsshub.app/zhihu/zhuanlan/专栏ID， 比如 https://rsshub.app/zhihu/zhuanlan/methodology 知乎日报： 订阅： https://rsshub.app/zhihu/daily 分栏订阅： http://zhihurss.miantiao.me/section 豆瓣小组： https://www.douban.com/feed/group/豆瓣小组ID/discussion， 比如 https://www.douban.com/feed/group/beijing/discussion Twiter： https://rsshub.app/twitter/user/用户ID，比如 https://rsshub.app/twitter/user/runningcheese Instagram： https://rsshub.app/instagram/user/用户ID，比如 https://rsshub.app/instagram/user/runningcheeselive U2B： https://rsshub.app/youtube/user/用户ID，比如 https://rsshub.app/youtube/user/JFlaMusic/ https://rsshub.app/youtube/channel/频道ID，比如 https://rsshub.app/youtube/channel/UCDwDMPOZfxVV0x_dz0eQ8KQ Reddit： 在当前链接后面加入.rss，比如 https://www.reddit.com/r/nba/top/ 改成 https://www.reddit.com/r/nba/top/.rss 抖音： https://rsshub.app/douyin/user/用户ID，比如 https://rsshub.app/douyin/user/93610979153 网易云音乐： 1). 歌单歌曲https://rsshub.app/ncm/playlist/歌单ID，比如 https://rsshub.app/ncm/playlist/1523069432). 用户歌单https://rsshub.app/ncm/user/playlist/用户ID，比如 https://rsshub.app/ncm/user/playlist/709382423). 电台节目https://rsshub.app/ncm/djradio/电台ID，比如 https://rsshub.app/ncm/djradio/347317067 喜马拉雅： https://rsshub.app/ximalaya/album/专辑ID，比如 https://rsshub.app/ximalaya/album/299146 Github： 1). 用户动态: 地址 + .atom，比如 https://github.com/runningcheese.atom2). 仓库releases: 地址 + .atom，比如 https://github.com/soimort/you-get/releases.atom3). 仓库commits: 地址 + .atom，比如 https://github.com/runningcheese/RunningCheese-Firefox/commits/master.atom4). 仓库issues：https://rsshub.app/github/issue/用户名/仓库名，比如 https://rsshub.app/github/issue/runningcheese/RunningCheese-Firefox V2EX： 周报： http://vdaily.iu.vc/old-weekly.xml Dribble： https://rsshub.app/dribbble/user/用户ID，比如 https://rsshub.app/dribbble/user/google二、RSS的一些其他玩用法1、监视网页内任意内容的变化。 有一款叫 Distill Web Monitor 的拓展 （支持 Firefox / Chrome），可以让你监视网页某处内容的变化，并在第一时间通知你。 使用的场景非常多，比如监控某商城网站商品是否有货是否有降价，某网站上的房价涨跌提醒，某个页面是否有内容更新，某视频网站Po主发布新视频的提醒，再比如你是做运营的，想要监视竞争对手产品的动态，这款拓展都能做到。更加强大的地方在于它可以自定义提醒的条件，比如价格变化超过10%才提醒你。 2，指定新闻内容动态提醒。 Google Alerts 可以让用户指定监控的关键词，Google 会在第一时间内向用户推送新内容更新提醒，支持邮件提醒，也支持RSS提醒，非常方便，用户可以用这个功能来跟踪一些新闻报道，业界动态，获取最新的国际事件等等。 Google Alerts的最大作用就是：让用户能迅速而方便地获得其所关注的信息。Google Alerts能将有价值的信息主动推给用户，大大减少了用户获取信息的时间。实现了“不上网而知天下事”。百度也有类似产品。 3，RSS 配合 IFTTT IFTTT是“if this then that”的缩写，可以让你的网络行为能够引发连锁反应。以RSS为例，比如在你的RSS订阅源里出现了有关于”iPhone8”的信息，联接上IFTTT后就可以在手机上弹窗通知我们了。 结尾1，整理RSS订阅源是一件有趣的事情，上一期奶酪说过不推荐使用本地RSS阅读器，但本地RSS阅读器在整理RSS订阅源的时候非常方便（推荐使用拓展Feedbro，支持 Firefox / Chrome），你可以把订阅源在本地RSS阅读器里整理好后导出为 opml文件，再导入到在线RSS阅读器中去。2，下载链接如若失效，关注奶酪公众号（ID：runningcheese01）回复关键字“RSS”获取奶酪的opml文件，可一键导入。 高效方法论(8) 注：本文由 奔跑中的奶酪 作者：奔跑中的奶酪 发表，其版权均为作者所有，如需转载，请注明作者名字以及文章来源。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"将本地文件上传到GitHub","slug":"将本地文件上传到Github","date":"2020-02-05T11:28:23.000Z","updated":"2020-02-08T09:22:16.587Z","comments":true,"path":"2020/02/05/将本地文件上传到Github/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/05/%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0Github/","excerpt":"百度“如何将文件上传到Github”，其中发现两篇很有用的教程： 使用git将项目上传到github（最简单方法）如何使用git把本地代码上传（更新）到github上","text":"百度“如何将文件上传到Github”，其中发现两篇很有用的教程： 使用git将项目上传到github（最简单方法）如何使用git把本地代码上传（更新）到github上 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"}]},{"title":"浏览器网页标签页图标显示","slug":"浏览器网页标签页图标显示","date":"2020-02-04T12:20:00.000Z","updated":"2020-02-07T15:20:51.240Z","comments":true,"path":"2020/02/04/浏览器网页标签页图标显示/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E9%A1%B5%E6%A0%87%E7%AD%BE%E9%A1%B5%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA/","excerpt":"","text":"对于IE浏览器：把需要显示的16x16像素的ICO图标命名为favicon.ICO放置在网站根目录下，浏览器会自动检索 对于其他浏览器通用的在标签页加入指定图标的方法：把favicon.ico图标放到网站根目录下，在网页的``&lt;head&gt;&lt;/head&gt;``中加入 &lt;!-- 地址栏显示 --&gt; &lt;link rel=\"Shortcut Icon\" href=\"./favicon.ico\" type=\"image/x-icon\" /&gt; &lt;!-- 收藏栏也显示 --&gt; &lt;link rel=\"Bookmark\" href=\"./favicon.ico\" type=\"image/x-icon\" /&gt; 火狐浏览器对图标格式没有那么严格，GIF和PNG格式的图标也可以显示，图标名称也可以不是favcion 链接在线的图片 &lt;link rel=\"Shortcut Icon\" href=\"http://csdnimg.cn/www/images/favicon.ico\"&gt; 获取ico图标的资源网 http://sc.chinaz.com/ favicon在线制作网站 https://tool.lu/favicon/ 图标制作，经常搞一些图标替换桌面图标 http://www.faviconico.org/ 或者在html的head表头中加 &lt;link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\" /&gt; 如果icon是gif动态图需要修改type属性 &lt;link rel=\"icon\" href=\"gif_favicon.gif\" type=\"image/gif\" &gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"}]},{"title":"文章作者","slug":"文章作者","date":"2020-02-03T09:36:53.000Z","updated":"2020-02-08T09:37:28.999Z","comments":true,"path":"2020/02/03/文章作者/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E4%BD%9C%E8%80%85/","excerpt":"由于支持多作者共同维护一个博客，所以可以设置单独一篇文章的作者： --- author: name: 作者 avatar: https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png url: https://baidu.com ---","text":"由于支持多作者共同维护一个博客，所以可以设置单独一篇文章的作者： --- author: name: 作者 avatar: https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png url: https://baidu.com --- document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"文章置顶","slug":"文章置顶","date":"2020-02-03T09:34:15.000Z","updated":"2020-02-08T09:36:28.899Z","comments":true,"path":"2020/02/03/文章置顶/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6/","excerpt":"在Front-matter中设置以下值： top: true 如果想自定义置顶标签的文字，可以直接设置为字符串，例如： top: 近期更新","text":"在Front-matter中设置以下值： top: true 如果想自定义置顶标签的文字，可以直接设置为字符串，例如： top: 近期更新 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"文章分类","slug":"文章分类","date":"2020-02-03T09:34:05.000Z","updated":"2020-02-08T09:36:28.898Z","comments":true,"path":"2020/02/03/文章分类/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/","excerpt":"多个分类有两种关系，一种是层级（等同于文件夹），一种是并列（等同于标签）。 多级分类 categories: [分类A, 分类B] 或者 categories: - 分类A - 分类B 并列分类 categories: - [分类A] - [分类B] 多级+并列分类 categories: - [分类A, 分类B] - [分类C, 分类D]","text":"多个分类有两种关系，一种是层级（等同于文件夹），一种是并列（等同于标签）。 多级分类 categories: [分类A, 分类B] 或者 categories: - 分类A - 分类B 并列分类 categories: - [分类A] - [分类B] 多级+并列分类 categories: - [分类A, 分类B] - [分类C, 分类D] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"文章配置","slug":"文章配置","date":"2020-02-03T09:34:05.000Z","updated":"2020-08-27T05:55:24.210Z","comments":true,"path":"2020/02/03/文章配置/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E9%85%8D%E7%BD%AE/","excerpt":"","text":"文章配置文章的配置（Front Matter）写在文章的 md 文件开头，只对当前文章有效。 #是否生成目录默认值：true 如果主题配置中的 toc 为 false，则这里的设置无效。 toc: false#是否显示推荐文章默认值：true 如果主题配置中没有提供 recommended_posts，则这里的设置无效。 recommended_posts: false#是否显示评论默认值：true 如果主题配置中没有提供任何一种评论系统，则这里的设置无效。 comments: false#是否开启渲染 MathJax默认值：false 如果某一篇文章含有 MathJax 数学公式，可以在这篇文章中设置为 true。 mathjax: true document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"文章音乐bgm","slug":"文章音乐bgm","date":"2020-02-03T09:14:27.000Z","updated":"2020-02-29T12:08:45.168Z","comments":true,"path":"2020/02/03/文章音乐bgm/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%96%87%E7%AB%A0%E9%9F%B3%E4%B9%90bgm/","excerpt":"标题右边显示迷你音乐播放器，支持的字段有：server、type、id，取值详见【进阶设定 -&gt; 第三方服务 -&gt; APlayer】。 示例--- music: enable: true # true（文章内和文章列表都显示） internal（只在文章内显示） autoplay: true # 自动播放。默认：false server: netease # netease（网易云音乐）tencent（QQ音乐） xiami（虾米） kugou（酷狗） type: song # song （单曲） album （专辑） playlist （歌单） search （搜索） id: 26664345 # 歌曲/专辑/歌单 ID volume: 0.3 #声音大小 --- 实际效果见：《文章专属BGM》","text":"标题右边显示迷你音乐播放器，支持的字段有：server、type、id，取值详见【进阶设定 -&gt; 第三方服务 -&gt; APlayer】。 示例--- music: enable: true # true（文章内和文章列表都显示） internal（只在文章内显示） autoplay: true # 自动播放。默认：false server: netease # netease（网易云音乐）tencent（QQ音乐） xiami（虾米） kugou（酷狗） type: song # song （单曲） album （专辑） playlist （歌单） search （搜索） id: 26664345 # 歌曲/专辑/歌单 ID volume: 0.3 #声音大小 --- 实际效果见：《文章专属BGM》 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"添加CNZZ统计代码","slug":"添加CNZZ统计代码","date":"2020-02-03T08:13:53.000Z","updated":"2020-02-07T15:20:51.245Z","comments":true,"path":"2020/02/03/添加CNZZ统计代码/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E6%B7%BB%E5%8A%A0CNZZ%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/","excerpt":"先在博客主题配置文件themes\\material-x_config.yml添加代码： #添加CNZZ统计 cnzz: true 这里这个cnzz的名字可以自己取；然后在themes\\material-x\\layout_partial里面创建一个 cnzz.ejs文件；把cnzz给的代码复制进去； &lt;% if (theme.cnzz){ %&gt; //这里添加复制的CNZZ代码 &lt;% } %&gt; 然后再在footer.ejs的后面添加上一行代码就可以显示了（这里的位置可以换，可以不是scripts.ejs，或者是head.ejs，看自己的喜好） &lt;!--CNZZ统计--&gt; &lt;%- partial('cnzz') %&gt; 对百度统计也可以进行同样的处理； &lt;% if (theme.cnzz){ %&gt;//前面要添加的代码 //百度统计的代码 &lt;% } %&gt; 与上面的操作基本一致只是取得名字不一样。 上面的是一种方法； 如果嫌麻烦的话直接就在footer.ejs的后面添加cnzz的代码；直接就可以显示了（同理，可以添加在其他位置），貌似添加在这里速度最快。 &lt;% if (theme.cnzz){ %&gt; //前面要添加的代码 //这里添加复制的CNZZ代码 &lt;% } %&gt; //后面要添加的 参考链接：https://blog.csdn.net/whjkm/article/details/37884563","text":"先在博客主题配置文件themes\\material-x_config.yml添加代码： #添加CNZZ统计 cnzz: true 这里这个cnzz的名字可以自己取；然后在themes\\material-x\\layout_partial里面创建一个 cnzz.ejs文件；把cnzz给的代码复制进去； &lt;% if (theme.cnzz){ %&gt; //这里添加复制的CNZZ代码 &lt;% } %&gt; 然后再在footer.ejs的后面添加上一行代码就可以显示了（这里的位置可以换，可以不是scripts.ejs，或者是head.ejs，看自己的喜好） &lt;!--CNZZ统计--&gt; &lt;%- partial('cnzz') %&gt; 对百度统计也可以进行同样的处理； &lt;% if (theme.cnzz){ %&gt;//前面要添加的代码 //百度统计的代码 &lt;% } %&gt; 与上面的操作基本一致只是取得名字不一样。 上面的是一种方法； 如果嫌麻烦的话直接就在footer.ejs的后面添加cnzz的代码；直接就可以显示了（同理，可以添加在其他位置），貌似添加在这里速度最快。 &lt;% if (theme.cnzz){ %&gt; //前面要添加的代码 //这里添加复制的CNZZ代码 &lt;% } %&gt; //后面要添加的 参考链接：https://blog.csdn.net/whjkm/article/details/37884563 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"即日起，博客双平台同步发布","slug":"即日起，博客双平台同步发布","date":"2020-02-03T05:36:56.000Z","updated":"2020-02-20T11:08:20.206Z","comments":true,"path":"2020/02/03/即日起，博客双平台同步发布/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/03/%E5%8D%B3%E6%97%A5%E8%B5%B7%EF%BC%8C%E5%8D%9A%E5%AE%A2%E5%8F%8C%E5%B9%B3%E5%8F%B0%E5%90%8C%E6%AD%A5%E5%8F%91%E5%B8%83/","excerpt":"为了确保博客网站的连接，经历6h的打造，现新增Gitee版，目前两个可用博客如下： Hexo+Github 版 https://melodyhub.ltd/ Hexo+Gitee 版 https://melodyjerry.gitee.io/（新增） 值得注意的是，除去连接速度的差异外，两个网站的区别： 后增的Gitee版暂无HomePage（动画主页），后续会计划加入 计划加入一些新的动画、特效等 优化部分cdn 调整卡片的透明度，计划值：80% 其他，略","text":"为了确保博客网站的连接，经历6h的打造，现新增Gitee版，目前两个可用博客如下： Hexo+Github 版 https://melodyhub.ltd/ Hexo+Gitee 版 https://melodyjerry.gitee.io/（新增） 值得注意的是，除去连接速度的差异外，两个网站的区别： 后增的Gitee版暂无HomePage（动画主页），后续会计划加入 计划加入一些新的动画、特效等 优化部分cdn 调整卡片的透明度，计划值：80% 其他，略 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"[转]Hexo 博客主题个性化","slug":"[转]Hexo 博客主题个性化","date":"2020-02-02T06:25:47.000Z","updated":"2020-02-07T15:20:51.231Z","comments":true,"path":"2020/02/02/[转]Hexo 博客主题个性化/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/02/[%E8%BD%AC]Hexo%20%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96/","excerpt":"permalink: https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/ 以下为原文的摘要： 本文将讲述一些博客主题的美化、实用功能的添加，本文以作者 luuman 的 spfk 主题和作者 xaoxuu 的 Material X 主题为例，文章会不定时进行更新。文章涉及有关参考资料、教程、链接如有侵权请联系我删除！ 本文在CSDN的链接：《Hexo 博客优化之博客美化》、《Hexo 博客优化之实用功能添加》，Hexo 博客专栏，从前期搭建到后期美化，帮您解决常见问题：《Github/Coding Pages + Hexo》，对您有帮助就点个赞吧❤️ 请注意：不同主题可能方法有些不同，相同主题不同版本，配置方法也有所差异！ 博客美化前提条件：有一定的前端基础，了解 HTML、CSS、JS，了解 CSS 预处理语言 Sass、Less、Stylus，搞懂 hexo 的目录结构。 博客美化通用步骤：选定主题，认真阅读主题文档，分析主题目录结构，了解每个文件是对应网页哪个部分的，认真阅读美化教程，美化教程本质上只为你提供核心代码和思路，具体代码要添加到哪个地方，需要你自己搞懂主题结构，添加到需要的、合适的位置！ 博客美化终极奥秘：创作第一，体验第二，避免繁杂，简洁为上！","text":"permalink: https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/ 以下为原文的摘要： 本文将讲述一些博客主题的美化、实用功能的添加，本文以作者 luuman 的 spfk 主题和作者 xaoxuu 的 Material X 主题为例，文章会不定时进行更新。文章涉及有关参考资料、教程、链接如有侵权请联系我删除！ 本文在CSDN的链接：《Hexo 博客优化之博客美化》、《Hexo 博客优化之实用功能添加》，Hexo 博客专栏，从前期搭建到后期美化，帮您解决常见问题：《Github/Coding Pages + Hexo》，对您有帮助就点个赞吧❤️ 请注意：不同主题可能方法有些不同，相同主题不同版本，配置方法也有所差异！ 博客美化前提条件：有一定的前端基础，了解 HTML、CSS、JS，了解 CSS 预处理语言 Sass、Less、Stylus，搞懂 hexo 的目录结构。 博客美化通用步骤：选定主题，认真阅读主题文档，分析主题目录结构，了解每个文件是对应网页哪个部分的，认真阅读美化教程，美化教程本质上只为你提供核心代码和思路，具体代码要添加到哪个地方，需要你自己搞懂主题结构，添加到需要的、合适的位置！ 博客美化终极奥秘：创作第一，体验第二，避免繁杂，简洁为上！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}],"author":{"name":"TRHX","avatar":"https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.9/images/trhx.png","url":"https://www.itrhx.com/"}},{"title":"[转]如何搭建基于Hexo的独立博客","slug":"[转]如何搭建基于Hexo的独立博客","date":"2020-02-01T06:25:47.000Z","updated":"2020-09-18T04:38:29.652Z","comments":true,"path":"2020/02/01/[转]如何搭建基于Hexo的独立博客/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/02/01/[%E8%BD%AC]%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/","excerpt":"permalink-1: https://xaoxuu.com/blog/2017-07-05-hexo-blog/ permalink-2: https://www.jianshu.com/p/1bcad7700c46","text":"permalink-1: https://xaoxuu.com/blog/2017-07-05-hexo-blog/ permalink-2: https://www.jianshu.com/p/1bcad7700c46 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}],"author":{"name":"xaoxuu","avatar":"https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png","url":"https://xaoxuu.com"}},{"title":"第一个除夕","slug":"第一个除夕","date":"2020-01-24T10:15:53.000Z","updated":"2020-02-08T09:30:11.038Z","comments":true,"path":"2020/01/24/第一个除夕/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/01/24/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%99%A4%E5%A4%95/","excerpt":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！”","text":"🌸于我们，这是妈走后的第一个除夕、春节。 💓“老妈，我们都在等你回来。就差你了，快和我们一起来吃团圆饭啦！” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"再见2019，你好2020","slug":"再见，2019；你好，2020","date":"2019-12-31T16:00:00.000Z","updated":"2020-02-23T09:18:28.382Z","comments":true,"path":"2020/01/01/再见，2019；你好，2020/","link":"","permalink":"https://melodyjerry.github.io/blog/2020/01/01/%E5%86%8D%E8%A7%81%EF%BC%8C2019%EF%BC%9B%E4%BD%A0%E5%A5%BD%EF%BC%8C2020/","excerpt":"# 前言 这是作为我2019年最后一年博客，同时是2020的第一篇博客。 起手写这篇博客时候是2019年12月晚上8点57分，距离2019的结束约3个小时👇","text":"# 前言 这是作为我2019年最后一年博客，同时是2020的第一篇博客。 起手写这篇博客时候是2019年12月晚上8点57分，距离2019的结束约3个小时👇 概括用一个词来概括我的2019年，我想到的是“酸甜苦辣咸”。 没错，我整一年的经历就和这五种味道一样，多而杂…… 我在成长的路上，一步一步地，独自前进…… 没错，独自，我甚至是常常自己对自己聊天。 我的微信置顶是自己，把想说的就发给自己，这样舒服些了👇 基本每天都有，随笔、想说的话、计划、临时的想法……👇 这一年来到现在，因为经历、看清一些事情后，我性格有所改变，为人处事有了较大的变化。 最为突出的就是暑假和国庆这两段时间，我对我自己“重新洗牌”了。 思考是我最常做的事情之一，思考什么呢？ 我现在到底在做什么？ 我为什么做？ 我想做什么？ 我要做什么？ 我还有多少时间做？ 未来我会往哪里去，往哪里回？ 现在的我我是不是我要的那个“我”？ …… …… 还有很多，为什么呢？ “好好做人”“好好做人“ 是我从小听到大，被唠叨最多次的话之一就是它。 除了经常被爸妈唠叨，我最近一次看见听见是在一部网剧《一起同过窗》（背景是大一大二），里面的叶老师是班主任，他的口头禅就是“好好做人”，学生惹没惹事，他都挂嘴上。 可是，真的明白“好好做人”吗？ “好好”在这是副词，用来修饰动词“做人”。 今年经历了太多太多难以忘记的事情，我似乎开始懂得为什么爸妈在我七岁时候就开始教导我要“好好做人”。 想必他们可能花费了几十年的阅历才懂得为什么吧…… 感动、感谢、感恩初略地把涉及到”感动“、”感恩“、”感谢“的人列在这里~ “因为感动，所以感谢，更要感恩！”这是爸妈教育我的。 我凭我的记忆最大限度地检索了这些人，但一定还是会有漏的…… 家人：爸和妈、弟弟（妮）、外公外婆、奶奶、大姨一家人、二姨一家人、小姨、小姨丈、大舅一家人、小舅、奕剑叔、文燕姑姑姑、还有很多不记得称呼的亲戚…… 朋友：廖鑫圣、陈波、赖洁莹、何庆钊、冼俊贤、张桂源、刘千瑜、朱茜妍、吴嘉隆、蔡泽佳、钟叶茂、杨迎、杨天瑞、谢佳豪、冯皓明、梁大浩、袁舒恩、欧芝妍、陈晓霞、吴森、陈子平…… 师兄姐（归属于朋友）：邱海燕、纪秋荣、卢情波、海英姐（李海英）、海雯师姐、王梁兴、张康、林逸豪、何庄芸、键林、林金翼、王景华、钟榴炜、吴丹婷（广外）、周卓颖、陈庆鸿…… 老师：倪宇班主任、老罗（罗智杰老师）、陈鑫老师、廖老师（勤工网络中心）、郭世仁老师、史婷婷老师、曾宪贵老师、古笑珍老师（小学班数学兼两年班主任）、陈彩玉老师（初中三年数学老师）…… 愿望我在日记本、便签等等上写了很多愿望，其中有些是想在2020年实现的。 我直接copy了，会有重复的，以下是我对自己微信聊天中的部分愿望👇 2020我想当个好儿子、好哥哥、好朋友、好学生、好人。 希望能有人能了解、能理解并接受我的人。 秉承信念，好好做人。 常回家看看，多陪陪家人 我想做自己，我想做“吴锐杰” 不想做那些不符合我风格的事 想拿到国家励志奖学金 希望找到一个人来填补我内心的空白 2020年我要来考驾照了 改变自己，让自己多一些坚硬、刚正、远谋、顾己 好好赚钱、好好学习、好好生活 希望每个人都平安、健康、幸福、好运、快乐 珍惜当下、好好做人、万事生意 找到能陪伴、鼓励、支持我的人 我想拿奖助学金，很想要 还掉所有欠别人的钱 给老弟预留一万的存款，供9月份上大学 好好勤工、挣多点钱，多吃些肉，长胖些 学更多的知识、技能，听更多的歌 想要一副好的身体，能不能搞好我的皮肤病呢 …… …… END文字没法完全表述我想表达的，其他的就存在我的心、记忆里吧 我可以忘记很多东西，也可以记得很多东西 2019年发生的一些事我不会忘🧡…… 2020年，Jerry加油，给我冲冲冲💪…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"绚丽彩虹同学录V1.4公测版","slug":"绚丽彩虹同学录V1-4公测版","date":"2019-12-28T06:34:01.000Z","updated":"2020-02-13T08:17:13.188Z","comments":true,"path":"2019/12/28/绚丽彩虹同学录V1-4公测版/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/28/%E7%BB%9A%E4%B8%BD%E5%BD%A9%E8%99%B9%E5%90%8C%E5%AD%A6%E5%BD%95V1-4%E5%85%AC%E6%B5%8B%E7%89%88/","excerpt":"","text":"部分截图 版本更新 自动更新(推荐): 管理员登陆后，进入控制台，点击检查更新，如有新版本点击“一键更新”等待更新完成即可。 手动更新流程: 更新包地址: http://cdn.badapple.top/PHP/XlchClassbook/UpdatePack下载对应版本的更新包,手动解压覆盖更新包到同学录安装目录。 更新日志☆ 1.4 公测版 (1004) 更新内容： 重要提示：更新完毕后请到 管理员控制台-&gt;站点配置-&gt;保存，以刷新数据！ 修复:手机上传图片打开相机 修复:“对我留言”功能 修复:无法删除相册 修复:允许空名相册 修复:权限组配置错误导致的安全漏洞 修复:验证码大小写问题 增加:可选绚丽彩虹播放器 增加:自定义导航栏功能 增加:教师、班长等权限组 增加:畅言图床、sm.ms、七牛云存储上传 增加:评论回复支持表情 增加:导入似水年华V3数据 优化:图片流设计 优化:同学录页面卡片设计 优化:管理员可设置用户是否允许上传相册 优化:安装时自动修复数据表结构 优化:配置文件结构变更 优化:做了一点微小的工作(细节优化) 更新时间：2018-07-03 23:39:54 ☆ 1.3 公测版 (1003) 更新内容： 修复:后台修改用户组 提示“用户名已被使用” 修复:“对TA留言”功能 修复:验证码大小写问题 修复:代码逻辑错误导致的安全隐患 修复:代码逻辑错误导致的无法在后台更新到新版本 更新时间：2018-04-22 21:20:20 文章附件蓝奏网盘 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"文章内长图","slug":"文章内长图","date":"2019-12-23T09:36:53.000Z","updated":"2020-03-02T12:35:48.209Z","comments":true,"path":"2019/12/23/文章内长图/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/23/%E6%96%87%E7%AB%A0%E5%86%85%E9%95%BF%E5%9B%BE/","excerpt":"文章内长图，使用html来实现 &lt;center&gt;&lt;div style=\"position:relative;width:400px; height:400px; overflow:auto\"&gt;&lt;img src =\"https://i.loli.net/2019/12/31/LiP98f6XqgoHmla.png\"&gt;&lt;/div&gt;&lt;/center&gt; 效果👇","text":"文章内长图，使用html来实现 &lt;center&gt;&lt;div style=\"position:relative;width:400px; height:400px; overflow:auto\"&gt;&lt;img src =\"https://i.loli.net/2019/12/31/LiP98f6XqgoHmla.png\"&gt;&lt;/div&gt;&lt;/center&gt; 效果👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"2019冬至","slug":"2019冬至","date":"2019-12-22T09:57:04.000Z","updated":"2020-02-03T08:31:36.470Z","comments":true,"path":"2019/12/22/2019冬至/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/22/2019%E5%86%AC%E8%87%B3/","excerpt":"😄2019.12.20-22，三天，在小姨家度过了一个冬至小长假。 🧡周五下午从学校出发，骑着小蓝到地铁站乘地铁，经过3条（2、3、9线）地铁线、18（13+3+2）个站、2次（嘉禾望岗、 高增）换乘，来到花都的小姨家。 以下为20号下午抵达花都时发的随笔 #生活 #记录三个月来，第一次出学校出趟远门. ᶘ ͡°ᴥ͡°ᶅ 今天的天气真不错，音乐、风、云……都陪伴着我，特别轻松 (୨୧•͈ᴗ•͈) 因为想家了，但回深圳有些麻烦，先来趟花都吧 ( ´◔ ‸◔`) 海珠来花都，还是有丶远。到了花都就变得有丶冷了 💛","text":"😄2019.12.20-22，三天，在小姨家度过了一个冬至小长假。 🧡周五下午从学校出发，骑着小蓝到地铁站乘地铁，经过3条（2、3、9线）地铁线、18（13+3+2）个站、2次（嘉禾望岗、 高增）换乘，来到花都的小姨家。 以下为20号下午抵达花都时发的随笔 #生活 #记录三个月来，第一次出学校出趟远门. ᶘ ͡°ᴥ͡°ᶅ 今天的天气真不错，音乐、风、云……都陪伴着我，特别轻松 (୨୧•͈ᴗ•͈) 因为想家了，但回深圳有些麻烦，先来趟花都吧 ( ´◔ ‸◔`) 海珠来花都，还是有丶远。到了花都就变得有丶冷了 💛 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"phpEnv一款优雅强大的php集成开发环境","slug":"phpEnv一款优雅强大的php集成开发环境 (1)","date":"2019-12-21T05:47:34.000Z","updated":"2020-04-23T11:40:36.783Z","comments":true,"path":"2019/12/21/phpEnv一款优雅强大的php集成开发环境 (1)/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/21/phpEnv%E4%B8%80%E6%AC%BE%E4%BC%98%E9%9B%85%E5%BC%BA%E5%A4%A7%E7%9A%84php%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%20(1)/","excerpt":"","text":"phpEnv一款优雅强大的php集成开发环境php集成开发环境有很多种，例如phpstudy，wamp，xmapp等等，各有各的优点和缺点，本文并不是对各个 IDE 的使用和调试进行详细的对比和评测，因为每一款 IDE 均提供了大同小异的功能，只是在细节方面有所差异罢了，phpStudy程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+Zend Loader，一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境。该程序绿色小巧简易迷你仅有13M，有专门的控制面板。总之学习PHP只需一个包。但是当最近phpstudy爆出重大漏洞后门后，相信很多人都在寻找可替代品，这里推荐给大家一款希望能对大家的参考和选择有所助益： phpEnv软件界面颜值超高，简洁优雅，完全绿色化，不需要安装vc环境，在同等软件中清新脱俗。 突破端口限制，更有管理员模式解除Windows Service服务端口占用。 运行服务错误提示，快速定位错误，提高开发效率。 自带软件商店，PHP和MySQL版本应有尽有，还有Redis和其他工具等。 功能强大的站点管理，为每个网站配置不同的PHP版本，不同PHP版本的网站共存，可视化配置https等。 简洁优雅而不失强大的软件设置，大大提高了开发效率。 功能强大的cmd命令行，无须你再繁琐的配置环境变量。 可视化TCP端口进程列表，功能强大，快速查看端口监听情况。 能够和phpstudy媲美，和wamp相互比对， 本文分享自微信公众号 - 风帆（wdswhf） 原文出处及转载信息见文内详细说明，如有侵权，请联系 yunjia_community@tencent.com 删除。 原始发表时间：2019-09-23 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"valine评论框样式美化","slug":"valine评论框样式美化","date":"2019-12-17T11:24:01.000Z","updated":"2020-09-24T08:55:08.041Z","comments":true,"path":"2019/12/17/valine评论框样式美化/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/17/valine%E8%AF%84%E8%AE%BA%E6%A1%86%E6%A0%B7%E5%BC%8F%E7%BE%8E%E5%8C%96/","excerpt":"valine的优势： 免登陆，使用方便，直接填了昵称和邮箱就可以评论 有回复邮件提醒功能！很好用 美化 直接在对应的css（在Hexo大多是less后缀）文件中添加：","text":"valine的优势： 免登陆，使用方便，直接填了昵称和邮箱就可以评论 有回复邮件提醒功能！很好用 美化 直接在对应的css（在Hexo大多是less后缀）文件中添加： /*valine 评论系统样式*/ div#comments.comments.v{ margin-top: 0px !important; margin-left: 0px !important; margin-right: 0px !important; } div.vheader.item2{ border-bottom: 1px solid #5f5f5f; height: 35px !important; } .v .vwrap .vheader.item2 .vinput{ height: 30px !important; border: 0px !important; width: 25% !important; margin: 0px !important; } input.vnick.vinput{ border-right: 2px solid #a4d8fa !important; } div.vcontrol{ padding-top: 0px !important; } div#comments.comments.v{ border: 0px; } .v .vwrap{ border: 2px solid black !important; height: 210px !important; border-radius: 6px !important; overflow: visible !important; counter-reset: avater; } .v .vwrap .vedit .vemojis{ width: 600px !important; background-color: #fff !important; border-radius: 5px !important; } .v .vwrap .vedit .vpreview { width: 600px !important; background-color: #fff !important; border-radius: 5px !important; } .v .vbtn{ background-color: #5f5f5f !important; color: #fff !important; } .v .vwrap .vedit .vctrl{ text-align: left !important; } .v .vwrap .vedit .vctrl span{ background-color: #7f7f7f !important; color: #fff !important; border-radius: 3px !important; padding: 3px !important; } .v .vwrap .vedit .vctrl{ padding: 0px !important; margin: 0px !important; } div.vedit{ height: 120px; } .v .veditor{ min-height: 70px !important; height: 70px !important; } .v .vlist .vcard { border: 1px dashed #49b1f5 !important; } .v .vlist .vcard .vhead .vsys{ display: none !important; background-color: #fff !important; } .v .vlist .vcard .vh .vmeta .vat{ background-color: #7f7f7f !important; color: #fff !important; border-radius: 3px !important; padding-left: 10px !important; padding-right: 10px !important; } .v .vlist .vcard .vhead:before{ display: block; float: left; width: 50px; height: 50px; line-height: 50px; margin: 0 12px 0 0; color: #fff; font-size: 15px; font-weight: bold; font-style: normal; background-color: #55aacf; border-radius: 50%; text-align: center; content: counter(avater)&amp;apos楼&amp;apos; counter-increment: avater; } .v .vlist .vcard .vquote{ margin-left: 80px; } .v .vlist .vcard .vquote{ counter-reset: avaters; } .v .vlist .vcard .vquote .vhead:before{ display: block; float: left; width: 38px; height: 38px; line-height: 38px; margin: 0 12px 0 0; color: #fff; font-size: 15px; font-weight: bold; font-style: normal; background-color: #fff; border: 3px solid #60a1e5; color: #60a1e5; border-radius: 50%; text-align: center; content: counter(avaters); counter-increment: avaters; } .v .vlist .vcard p{ margin-bottom: 0px !important; color: #666; text-align: left; letter-spacing: 3px; line-height: 25.59375px; } .v .vlist .vcard .vquote a.at{ float: left; margin-right: 13px; color: #567843; text-decoration: none; } .v .vlist .vcard .vquote .vcontent{ font-size: 15px; font-weight: 200; } .v .vlist .vcard .vcontent{ margin-top: 58px !important; font-size: 15px !important; font-weight: 500 !important; padding-top: 0px !important; } .v .vlist .vcard .vhead .vnick{ font-size: 17px !important; font-weight: 600 !important; } .v .vlist .vcard{ padding-top: 8px !important; } .v .vlist .vcard .vhead{ float: left !important; } .v .vlist .vcard .vh .vmeta{ float: right !important; } .v .vlist .vcard .vcontent.expand:after{ content: \"点击查看全部\" !important; font-weight: 400 !important; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"原生js实现网页图片点击展示效果","slug":"原生js实现网页图片点击展示效果","date":"2019-12-17T11:24:01.000Z","updated":"2020-09-24T08:55:08.047Z","comments":true,"path":"2019/12/17/原生js实现网页图片点击展示效果/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/17/%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E5%9B%BE%E7%89%87%E7%82%B9%E5%87%BB%E5%B1%95%E7%A4%BA%E6%95%88%E6%9E%9C/","excerpt":"之前博客用过一些第三方的图片展示插件，比如fancybox，但是用久了感觉还是有点问题，反正自己用着不舒服，而且这些第三方插件大都使用jQuery，就想自己写个原生就是实现的图片展示。 网上看了一些代码，实现起来还是很简单的，大概思路就在每个图片的点击事件中添加图层与图片副本。 具体的实现代码就一点点了，100多行原生js。 用法 直接在页面引入js &lt;script type=\"text/javascript\" src=\"https://me.idealli.com/js/src/image.js\"&gt;&lt;/script&gt;","text":"之前博客用过一些第三方的图片展示插件，比如fancybox，但是用久了感觉还是有点问题，反正自己用着不舒服，而且这些第三方插件大都使用jQuery，就想自己写个原生就是实现的图片展示。 网上看了一些代码，实现起来还是很简单的，大概思路就在每个图片的点击事件中添加图层与图片副本。 具体的实现代码就一点点了，100多行原生js。 用法 直接在页面引入js &lt;script type=\"text/javascript\" src=\"https://me.idealli.com/js/src/image.js\"&gt;&lt;/script&gt; 以下是js内容： let container = document.documentElement||document.body; let img,div,src,btnleft,btnright; var imgid=0; let x,y,w,h,tx,ty,tw,th,ww,wh; let closeMove=function(){ if(div==undefined){ return false; } div.style.opacity=0; img.style.height=h+\"px\"; img.style.width=w+\"px\"; img.style.left=x+\"px\"; img.style.top=(y - container.scrollTop)+\"px\"; // 延迟移除dom setTimeout(function(){ div.remove(); img.remove(); btnright.remove(); btnleft.remove(); },100); }; let closeFade=function(){ if(div==undefined){ return false; } div.style.opacity=0; img.style.opacity=0; // 延迟移除dom setTimeout(function(){ div.remove(); img.remove(); btnright.remove(); btnleft.remove(); },100); }; // 监听滚动关闭层 document.addEventListener(\"scroll\",function(){ closeFade(); }); document.querySelectorAll(\"img\").forEach(v=&gt;{ if (v.parentNode.localName!=a) { v.id=imgid; imgid++; v.addEventListener(\"click\",function(e){ // 注册事件 // 记录小图的位置个大小 x=e.target.offsetLeft; y=e.target.offsetTop; w=e.target.offsetWidth; h=e.target.offsetHeight; src=e.target.src; id=e.target.id; // 创建遮罩层 div=document.createElement(\"div\"); div.style.cssText=` position:fixed; left:0; top:0; bottom:0; right:0; background-color: rgba(25,25,25,0.8); z-index:99999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); `; document.body.appendChild(div); setTimeout(function(){ div.style.opacity=1; },0); // (此处可以加loading) // 创建副本 img=new Image(); btnright=document.createElement(\"button\"); btnleft=document.createElement(\"button\"); img. src=src; btnleft.style.cssText=` position:fixed; border-radius: 50%;; left:${x - 20}px; top:${y - container.scrollTop + h/2}px; width:50px; height:50px; border: 0px; background-color: rgba(200,200,200,0.8); font-size: 20px; z-index: 999999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); `; btnright.style.cssText=` position:fixed; border-radius: 50%; left:${x + w + 20}px; top:${y - container.scrollTop + h/2}px; width:50px; border: 0px; height:50px; font-size: 20px; background-color: rgba(200,200,200,0.8); z-index: 999999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); `; btnleft.innerText=\"&lt;\"; btnright.innerText=\"&gt;\"; img.style.cssText=` position:fixed; border-radius: 12px; left:${x}px; top:${y - container.scrollTop}px; width:${w}px; height:${h}px; z-index: 999999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); opacity:0; `; btnleft.onclick=function(){ if(id===0){ alert(\"已经是第一张了！\"); return; } var left=document.getElementById(id-1); img. src=left.src; x=left.offsetLeft; y=left.offsetTop; w=left.offsetWidth; h=left.offsetHeight; id--; } btnright.onclick=function(){ id++; if(id&gt;=imgid){ alert(\"已经是最后一张了！\"); return; } var right=document.getElementById(id); img. src=right.src; x=right.offsetLeft; y=right.offsetTop; w=right.offsetWidth; h=right.offsetHeight; } img.onload=function(){ document.body.appendChild(img); document.body.appendChild(btnright); document.body.appendChild(btnleft); // 浏览器宽高 wh=window.innerHeight; ww=window.innerWidth; // 目标宽高和坐标 if(w/h&lt;ww/wh){ th=wh-80; tw=w/h*th &gt;&gt; 0; tx=(ww - tw) / 2; ty=40; } else{ tw=ww*0.8; th=h/w*tw &gt;&gt; 0; tx=ww*0.1; ty=(wh-th)/2; } // 延迟写入否则不会有动画 setTimeout(function(){ img.style.opacity=1; img.style.height=th+\"px\"; img.style.width=tw+\"px\"; img.style.left=tx+\"px\"; img.style.top=ty+\"px\"; btnleft.style.left=(tx-90)+\"px\"; btnleft.style.top=(ty+th/2)+\"px\"; btnright.style.left=(tx+tw+40)+\"px\"; btnright.style.top=(ty+th/2)+\"px\"; // 点击隐藏 div.onclick=img.onclick=closeMove; },10); }; });//end event } });//end forEach document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"}]},{"title":"[转]分享几款不错的浪漫素材","slug":"转-分享几款不错的浪漫素材","date":"2019-12-13T10:58:22.000Z","updated":"2020-04-23T11:40:36.824Z","comments":true,"path":"2019/12/13/转-分享几款不错的浪漫素材/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/13/%E8%BD%AC-%E5%88%86%E4%BA%AB%E5%87%A0%E6%AC%BE%E4%B8%8D%E9%94%99%E7%9A%84%E6%B5%AA%E6%BC%AB%E7%B4%A0%E6%9D%90/","excerpt":"原文链接：https://www.liaofuzhan.com/posts/3564551888.html 双旦将至，快找个暖冬又暖心的 TA 一起跨年吧！如果你还是一枚单身汪，那么再过几天的时间，又到了别人狂欢你孤单的圣诞之夜！再再再过几天时间，又双叒叕到了别人狂欢你孤单的跨年之夜！落单的人往往最怕过节，更何况双旦佳节的连环暴击，别人疯狂撒着狗粮，而你只能接受着来自情侣们的亿万点伤害，SO，与其不甘寂寞，何不为爱情放纵一次？撩个对象一起过双旦吧，2019 年最后一个脱单的机会，为你呈现 ！ 感谢 leafjame 和 EnfangZhong 提供的素材！ 本站只集成了以下四种，其它效果可下载源码后查看 表白专场","text":"原文链接：https://www.liaofuzhan.com/posts/3564551888.html 双旦将至，快找个暖冬又暖心的 TA 一起跨年吧！如果你还是一枚单身汪，那么再过几天的时间，又到了别人狂欢你孤单的圣诞之夜！再再再过几天时间，又双叒叕到了别人狂欢你孤单的跨年之夜！落单的人往往最怕过节，更何况双旦佳节的连环暴击，别人疯狂撒着狗粮，而你只能接受着来自情侣们的亿万点伤害，SO，与其不甘寂寞，何不为爱情放纵一次？撩个对象一起过双旦吧，2019 年最后一个脱单的机会，为你呈现 ！ 感谢 leafjame 和 EnfangZhong 提供的素材！ 本站只集成了以下四种，其它效果可下载源码后查看 表白专场 hexo 跳过渲染Hexo 默认会对根目录 /source/ 下所有页面应用主题模板渲染，但有一些前端作品或 demo 页我们不希望经过渲染，而是能保持完全自定义的样子，那该怎么用 Hexo 添加自定义的 web 页面呢？下面介绍两种方法 skip_render使用 Hexo 提供的跳过渲染配置。在站点 _config.yml 中找到 skip_render，这项是用来配置 /source/ 下需要跳过渲染的文件或目录，例如希望跳过 /source/love/ 里的所有文件，可以配置为 skip_render: love/** 如果有多项，可以这样配置 skip_render: - README.md - love/** - test1/*.html 或者 skip_render: [README.md, love/**, test1/*.html] 可参考 如何不处理 source 目录下某个子目录的所有文件 layout使用 layout 给单个文件添加不应用模板的标记。适用于个别需特殊处理的文件，可在文件头部添加 --- layout: false --- 这个文件就不会经过模板渲染，最终发布到 /public/ 里的文件就是去掉标记后的文件的样子。本站使用的是第一种配置方式，源码目录截图如下 访问域名 + 文件目录名即可出现效果，Enjoy ！ 表白专场 相关文章点击查看表白神器—JS生成的玫瑰花Hexo Next主题「哈林摇」特效Hexo NexT主题美化1.0随笔—过节那点事 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"素材","slug":"素材","permalink":"https://melodyjerry.github.io/blog/tags/%E7%B4%A0%E6%9D%90/"}],"author":{"name":"北宸","avatar":"https://www.liaofuzhan.com/images/beichen.png","url":"https://www.liaofuzhan.com/"}},{"title":"[工具]ASCII字符画制作工具","slug":"工具-ASCII-字符画制作工具","date":"2019-12-12T11:48:31.000Z","updated":"2020-04-23T11:40:36.803Z","comments":true,"path":"2019/12/12/工具-ASCII-字符画制作工具/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/12/%E5%B7%A5%E5%85%B7-ASCII-%E5%AD%97%E7%AC%A6%E7%94%BB%E5%88%B6%E4%BD%9C%E5%B7%A5%E5%85%B7/","excerpt":"想为自己的博客设计一个专属的ASCII字符画，便找到以下三款工具（含线上）","text":"想为自己的博客设计一个专属的ASCII字符画，便找到以下三款工具（含线上） 工具 http://patorjk.com/software/taag/ https://www.degraeve.com/img2txt.php 使用Ascii Generator 2制作，下载地址：https://sourceforge.net/projects/ascgen2/ 展示 _ooOoo_ o8888888o 88\" · \"88 (| ^.^ |) O\\ = /O ____/`---'\\____ . ' \\\\| |// `. / \\\\||| : |||// \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | \\_| ''\\---/'' | | \\ .-\\__ `-` ___/-. / ___`. .' /--.--\\ `. . __ .\"\" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'\"\". | | : `- \\`.;`\\ _ /`;.`/ - `: | | \\ \\ `-. \\_ __\\ /__ _/ .-` / / `.____`-.___\\_____/___.-`____.-' ⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒⌒ ............................................. 佛 祖 保 佑 代 码 无 BUG &lt;!-- s&amp;@@@@@@@@@@@#HX9hr: ;GM@@@@@@@@@@@@@@@@#MBA85i .G@@@@@@@@@@@@@@@@@@@@@@@@@@M9: .&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#1 h@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@, .;rssr, ,sA@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@88B@@@@@#5 .rHHA#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: rB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@i ,5B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X is&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X#@@@@@@@A ,s8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Hr M@@@@@@@B. .,1&amp;M@@@@@@@B#@@@@@@@@@@@@@@@@@@@8 ;@@@@@@@Hi. :1991: ,s9&amp;81;. , sA@@@@@@BG8XHB#@@@@@@@@@@@@@HS: 5@@@@@@@@i .;13XM@@#H#@H91;. :s3&amp;##A&amp;#@@MA8Ss: .5HAX#@M@#BHHBM#@@@@@@@@#&amp;Ah.. G@@@@@@@@G ,s9AMM@@@Xh;. .i9@@@BX9hr, .,ih9&amp;B@@@#s. :hM@@HBMBXSi. ..ShSM@@@@@@&amp;XBHsHMHS: .: 3@@@@@@@@8 ,;19H#BG5irB@@H3. r#@@@@@#@@ B@@@BB@@@@M; 5H@@@9 ,r3ABM&amp;8Shsrii;;i;ir1h1. .iM@@@@@@@@91, ;S, sGXH@@@@@@@@X&amp;HM@@@9: X@@@@@#s &amp;@@@@@@G:s @A;.hM@@@@@A G@@@@@@h s#@@AXXXGGXGX#@@#@@Bs .r58&amp;HM@@@@@@@@@@@#BA8Sr. ,8@@#X@@@@@@Ariii5M@@H3. 8@@@@@@9 1B@@@@@@: H; &amp;@@@@@#h &amp;@@@@@Mi ,G@@@@X ;8#@#hrX@@X8M@@@@@@@@@@@@@@@@@@@@@@@M8SM@Hh.3@@@@M8. .H@@@@@Hi S@@@@@5 .SM@@@@S . H@@@@X: 5@@@@M; &amp;@@@@@@9 s#@@@@#r.9@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#3:9@@@@@@9 :M@@@@@@s 1@@@@s ,9#@@H ,M@@#h i@@@M; 3@@@@@Mi X@@@@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8 ;M@@@@M, rM@@i :G@@i i@@X: .B@M; :#@@@@r :#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M. ;M@@@X :B@: i&amp;S hMh GM; X@@@h S@@@@B#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B8@@@@h i#@@h ,1 ., ,: s@@3 .H@@MB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;A@@H r#@; HG r@#r&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S B@r s9 , 95G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@h;S 3@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@i r@@@@@@@H8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B. H@@@@@@#:;@@@@@@@@@@@@@@@@@@@@@@@@@@B8@@@@@@@S .;S@@@@@@@r ,M@@@@@@@@@@@@@@@@@@@@@@@@@X 9@@@@@@Mhi, .. ;831: .iSXM@@@@@@@#s .M@@@@@@@@@@@@@@@@@@@@@@@@@X 9@@@@@@@@#A91: i8AA1 :h, iBH. .5B@#8i. .iS&amp;M@@@@@@@@@@Ai i@@@@@@@@@@@@@@@@@@@@@@@@@@M, hB@@@@@@@@@@@H8h; ;9@@#s :&amp;@X, .B@@H359GX&amp;XGGM@@@@B9:,rSXM@@@@@@@@@@@B8s h@@@@@@@@@@@@@@@@@@@@@@@@@@@s .1GB@@@@@@@@@@@@BX5r,sA@@@@@MHAHBHHA&amp;#@@@9 iG@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@#H8h; S@@@@@@@@@@@@@@@@@@@@@@@@@@#s :19AM@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@h. 1B@@@@@@@@@@@@@@@@@@@@@@@@BXSr, 5#@@@@@@@@@@@@@@@@@@@@@@@@@@@#h .ih8A#@@@@@@@@@@@@@@@@@@@@@@M@@8 ,,,595i:i1S9G&amp;AHBMBAGSr, 9@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3 :13XHM###MMBHAX95SXBMGii, --&gt; 参考文章 让console充满情怀Chrome 控制台新玩法Tools for Web Developers浏览器控制台个性化输出 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Java—替换字符串右侧出现的第一个子串","slug":"Java—替换字符串右侧出现的第一个子串","date":"2019-12-08T04:46:08.000Z","updated":"2019-12-08T09:18:36.934Z","comments":true,"path":"2019/12/08/Java—替换字符串右侧出现的第一个子串/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/08/Java%E2%80%94%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%B3%E4%BE%A7%E5%87%BA%E7%8E%B0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%90%E4%B8%B2/","excerpt":"🔺需求 👇 编程实现一个方法，能把一个字符串src的右侧出现的第一个olds子串替换为news，并把替换后的结果返回。","text":"🔺需求 👇 编程实现一个方法，能把一个字符串src的右侧出现的第一个olds子串替换为news，并把替换后的结果返回。 🔺代码 👇 public class StringReplaceLast { public static String replaceLast(String src, String olds, String news){ /* 实现一个尾部替换方法 */ System.out.println(src); StringBuffer sbsrc = new StringBuffer(src); int lenolds = olds.length(); int tail = src.lastIndexOf(olds); sbsrc = sbsrc.replace(tail,tail+lenolds, news); src = sbsrc.toString(); return src; } public static void main(String[] args) { System.out.println(replaceLast(\"goodJava,I love it, very good,Truly.\", \"good\", \"yes\" )); } } 🔺截图 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"文章视频（B站）","slug":"文章视频","date":"2019-12-07T16:00:00.000Z","updated":"2020-03-02T12:35:48.210Z","comments":true,"path":"2019/12/08/文章视频/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/08/%E6%96%87%E7%AB%A0%E8%A7%86%E9%A2%91/","excerpt":"目前博文主要引用的是B站视频👇 小窗口版、修改src即可👇 &lt;iframe src=\"//player.bilibili.com/player.html?aid=76560081&amp;cid=130958803&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"&gt; &lt;/iframe&gt;&lt;br&gt; 浏览测试效果👇 大窗口版👇 &lt;div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"&gt;&lt;iframe src=\"//player.bilibili.com/player.html?aid=76560081&amp;amp;page=0\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"&gt;&lt;/iframe&gt;&lt;/div&gt; 浏览测试效果👇","text":"目前博文主要引用的是B站视频👇 小窗口版、修改src即可👇 &lt;iframe src=\"//player.bilibili.com/player.html?aid=76560081&amp;cid=130958803&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"&gt; &lt;/iframe&gt;&lt;br&gt; 浏览测试效果👇 大窗口版👇 &lt;div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"&gt;&lt;iframe src=\"//player.bilibili.com/player.html?aid=76560081&amp;amp;page=0\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\"&gt;&lt;/iframe&gt;&lt;/div&gt; 浏览测试效果👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"Java—转置数组","slug":"Java—转置数组","date":"2019-12-07T13:43:33.000Z","updated":"2019-12-08T14:07:45.921Z","comments":true,"path":"2019/12/07/Java—转置数组/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/07/Java%E2%80%94%E8%BD%AC%E7%BD%AE%E6%95%B0%E7%BB%84/","excerpt":"🔺需求 👇 编写一个程序，其功能是能随机生成一个数组、同时完成对该数组的转置并打印输出转置后的数组。","text":"🔺需求 👇 编写一个程序，其功能是能随机生成一个数组、同时完成对该数组的转置并打印输出转置后的数组。 🔺代码 👇 import static java.lang.System.out; import java.util.Random; public class Reverse2dArray { static int[][] a; // 存放两位随机整数的int二维数组a /** * 构造方法，初始化数组a，r和c分别是行数和列数row column */ public Reverse2dArray(int r, int c){ a = new int[r][c]; buildRandArray(); } /** * 构造随机数组 */ public void buildRandArray(){ Random random = new Random(); for(int i = 0; i &lt; a.length; i++) for(int j = 0; j &lt; a[i].length; j++) a[i][j] = random.nextInt(100); } /** * 转置本类成员的二维数组a，并返回一个新的二维数组 * @return */ public int[][] reverse2dArray(){ int [][] b = new int [a[0].length] [a.length] ; for (int i = 0; i &lt; a.length; i++) { for (int j = 0; j &lt; a[0].length; j++) { b[j][i] = a[i][j] ; } } return b ; } /* 显示二维数组 */ public void showArray(int[][] c){ out.printf(\"=========%2d×%-2d=========%n\", c.length, c[0].length); for(int[] cr : c){ for(int cc : cr){ out.printf(\"%5d \", cc); } out.println(); } out.println(\"=======================\"); } public static void main(String[] args) { int row = 3, col = 4; Reverse2dArray me = new Reverse2dArray(row, col); me.showArray(a); // 显示原数组 int[][] r = me.reverse2dArray(); me.showArray(r); // 显示转置的数组 } } 🔺截图 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"[转]Hexo建站笔记之彩色标签云","slug":"[转]hexo建站笔记之彩色标签云","date":"2019-12-07T11:24:01.000Z","updated":"2020-09-24T08:55:08.036Z","comments":true,"path":"2019/12/07/[转]hexo建站笔记之彩色标签云/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/07/[%E8%BD%AC]hexo%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BD%A9%E8%89%B2%E6%A0%87%E7%AD%BE%E4%BA%91/","excerpt":"外链：https://me.idealli.com/post/d6caa003.html","text":"外链：https://me.idealli.com/post/d6caa003.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"【纪念】我的博客上线一个月","slug":"【纪念】我的博客上线一个月","date":"2019-12-06T16:41:29.000Z","updated":"2019-12-06T17:20:33.920Z","comments":true,"path":"2019/12/07/【纪念】我的博客上线一个月/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/07/%E3%80%90%E7%BA%AA%E5%BF%B5%E3%80%91%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E6%9C%88/","excerpt":"大致写完这文章时，已是2019年12月7日的夜晚00时41分。 从最简单的纯粹的文字，到文字加粗，到用图床（SM.MS）来插入图片，到利用HTML来丰富博客，等等……本小白的博客之旅早已开始，学习、生活，图文、视频、音乐，想写想分享的都不会少。 今天这篇文章，一是回顾这一个多月来写博客的点滴，二是对未来的一些期望、想法，三是纪念一个人！！！","text":"大致写完这文章时，已是2019年12月7日的夜晚00时41分。 从最简单的纯粹的文字，到文字加粗，到用图床（SM.MS）来插入图片，到利用HTML来丰富博客，等等……本小白的博客之旅早已开始，学习、生活，图文、视频、音乐，想写想分享的都不会少。 今天这篇文章，一是回顾这一个多月来写博客的点滴，二是对未来的一些期望、想法，三是纪念一个人！！！ 尝试 &amp; 第一篇博客2019十月的最后一天，那是我写博客的第一天。 第一篇博客，同时用来纪念我的开始。 https://blog.csdn.net/weixin_43438052/article/details/102841961 那篇博客的标签我给的是#尝试#。 没错，这是我第一次尝试写博客，一次伟大的尝试和开始。 博客的内容也很简单。 当然，这也是我人生以来 第一次全面地接触 MarkDown 语言。 又迈出一步 &amp; 小小的收获之后，先后在CSDN和简书上，又发表共5篇文章（含重复）。 我的CDSN主页：https://blog.csdn.net/weixin_43438052 我的简书主页： https://www.jianshu.com/u/a75808cbb13e 经过写这几篇博客，对于MD（Markdown）的使用越来越熟练。 这也让我收获一些东西，比如点击量、评论量、点赞数、收藏数等等。 虽然和那些大佬比起来微不足道，不过我还是很开心。 尤其是我合计了（双平台）全部文章的浏览量是1726。 截止到写这篇博客，有1726‬人看过我的文章。1726啊啊啊，大数字了hhhh 于是，我傻乎乎地打开计算器，用1726除了30，得到这个数‭57.53。 忍不住说了句 卧槽 ，平均每天有57人看我的文章。 57人啊，我也算是个小网红 (不算，那我自个变红) 了吧？！！ 此刻的我👉一时自恋+持续傻笑ing 大胆地想法 &amp; 勇敢地再尝试2019.11.1 我突然有个 大想法 ，和这三个字那么大的想法——我要搭建自己Blog（博客）。 那又是为什么呢？ 很简单，还是 尝试 。 然而，想法是好，实践起来，不容易啊。 起初是使用 Gridea 来撰写、发布博客。 不过，没多久被我舍弃了这个方案。并不是说Gridea不好，而是缺少了自定义。 我说的自定义是，可以给自己的博客加入一些其他的东西，比如页面动画之类的。 于是，在朋友的推荐下，我接触了 Hexo 。这是一个专门用来搭建博客的框架。 没错，就是框架。因为是框架，所以能直接、便利地搭建、撰写、发布博客文章。 更重要的是，Hexo提供现成的主题模板，你可以直接利用，甚至对其二次加工。 就这样，前前后后，在没课的时候、还有半夜，大概花了四天左右来研究Hexo，从命令行开始。 终于在2019.11.6初步搭建完成，隔天7号发布了第一篇文章。 同时也是记录我搭建博客的大致过程。 人生第一个域名 &amp; 一写小坎坷2019.11.6 也是我获取人生第一个专属域名【melodyhub.ltd】的日子。 43买了五年，真的很值很划算。 不过，在接下的两三天也遇到点麻烦。 第一个是DNS解析，这个还好办，查ip、到阿里云控制台改一下就好。 第二个是，每次``hexo d` 后，用域名总是404。每次都要到GitHub仓库里修改CNAME，太麻烦了。于是，我干脆就直接在Hexo的框架中写入CNAME文件，这样每次更新到远端（仓库）时，都会有正确的CNAME。机智的我 ( ͡° ͜ʖ ͡°)✧ 第三个，也是最麻烦的一个，浏览器打开我的网站，总是提示“证书失效 / 危险链接”等字段。这个懊恼了我两天，反复查了一堆东西，最后发现原来是主题模板中重定向到一个外国授权认证的网站去了。 真的是，整的我发愁，好在最后能够解决了。 进一步尝试优化到目前为止，我的网站一共经历两次大变化，一次是在11.8，另一次是11.24。 主要就是优化了主题模板中存在的一些问题，然后加入了一点自己想要的东西，还有一些待以后再实现。 具体的，主要的，大致在【博客v1.4上线】这篇博客中提到了。 其实，这个过程很难，一个是我对Hexo内部的设计的了解不是很深，另一个是对HTML语言不是精通。主要是前者，后者可以通过百度、书籍来学习。 反反复复，查阅各个文档、修改一堆文件、增删改n次代码。 总算是，得到了一个较为满意的博客。 期间，还丢失过几次代码和文件，折腾死我了。😂 奋笔疾书（敲键盘）写写写截至到写这篇博客，一共在自己的网站上发布了26篇正式博客。 但是由于目前还没不会使用“不蒜子” 的接口来显示浏览量，所以我页没法知道有多少人看过我的文章。 我就假装每天就一共吧，那就是我哈哈哈。 26篇博客文章，不仅提升为了我的打字速度，还让我更加地想搞IT。** 当然，我一向对IT感兴趣。** 写 ，这个过程让我在不断地遇到困难，然后解决它。 不懂的，就琢磨它。再不懂，找大佬、问大佬。 也就一步步地，收获了知识、也认识了几位大佬。 期望 &amp; 未来我的目标是成为以为IT技术大佬，目前的想法是能熟练Java+一种数据库+HTML+其他语言/技术。 这几个月来，因为一件事、一些人，重新洗牌了我的生活，同时也让我有了全新的目标、计划。 现如今，我有新的顾虑，我有家、有朋友的期望，我必须自强自立。放眼到以前，熟悉我的人也知道我一向比较执着于想做的事，虽然现在我也也是，不过更多了一些热情、勇气、认识。 这一个多月来，得到很多人的帮助、指导、建议。朋友啊、老师啊、师兄师姐啊…… 人总要向前看向前走，无论是失去某样东西，或者某个人，都得向前。 我在博客中用到一句话当【归档页】的副标题“生命不过三天：昨天、今天、明天”。 反思昨天，珍惜今天，把握明天。所以，但看到别人在向前走时，我就要跑、向前跑。 就这样，我也才给我的网站的主页设置了 “你用走 可是我用跑” . 我希望这句话能够在关键时候提醒我，你不能停还得跑。 同时我也希望，能够看到这里的你，也要向前向前再向前。 晚安计划分享截止到现在的所有【晚安计划】 👇 END😊 最后，希望 健康、平安、简单、快乐、好运。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"用JDBC连接数据库","slug":"用JDBC连接数据库","date":"2019-12-03T04:12:50.000Z","updated":"2020-02-09T16:02:16.381Z","comments":true,"path":"2019/12/03/用JDBC连接数据库/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/03/%E7%94%A8JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"简单理解JDBC（Java DataBase Connectivity）是 Java 和 数据库 之前的一座桥。 实则，JDBC 是用于Java编程语言和数据库之间的标准Java API。 三者之间的关系就如下图 👇","text":"简单理解JDBC（Java DataBase Connectivity）是 Java 和 数据库 之前的一座桥。 实则，JDBC 是用于Java编程语言和数据库之间的标准Java API。 三者之间的关系就如下图 👇 JDBC介绍官方文档：https://www.oracle.com/technetwork/java/javase/jdbc/index.htmlJava 原文👇 译文（可能有偏差）👇 数据库连接 （JDBC） Java 数据库连接 （JDBC） API 是 Java 编程语言与各种数据库 SQL 数据库和其他表格数据源（如电子表格或平面文件）之间的独立于数据库的连接的行业标准。JDBC API 为基于 SQL 的数据库访问提供了调用级 API。 JDBC 技术允许您使用 Java 编程语言来利用需要访问企业数据的应用程序的”一次写入，随处运行”功能。借助支持 JDBC 技术的驱动程序，即使在异构环境中，您也可以连接所有企业数据。 教程本文环境 OS IDE 数据库 Windows 10 专业版 Eclipse(v4.11.0)—jdk8 SQL server 2017 SQL Server 2017 设置【SQL 身份验证登录】 设置【登录名 sa】 的状态为【授予】和【启用】 关闭程序 SQL Server 配置管理器==因为SQL Server 2012装好后，默认协议是没有开启的，所以要打开SQL Server配置管理器中开启。== 打开【SQL server2017配置管理器】 启用【Named Pipes】 修改 【TCP/IP 属性】： 将【IP1 、IP10】中的【IP地址】改成【 127.0.0.1】，并将所有的【IPx】的【已启用】设置为【是】，将 【IPAII】中的【TCP端口】设成 【1433】，其余不变。 重启【SQL Server服务】 【win+r】打开【运行】，键入【cmd】，打开命令行，键入以下命令👇 telnet 127.0.0.1 1433 提示【talent不是内部命令】，则【打开控制面版】-&gt;【程序】-&gt;【启用或关闭Windows功能】-&gt;【勾选talent】-&gt;【确定】。 重新【步骤4】，进入【telnet】。 JDBC驱动 下载驱动包：http://www.microsoft.com/zh-cn/download/details.aspx?id=11774 选择、下载【 sqljdbc_6.0.8112.200_chs.tar.gz】 解压上述压缩包，得到目录文件夹 复制【”sqljdbc_6.0\\chs\\jre8”】中的包【sqljdbc42.jar】，粘贴到IDE【Eclipse目录】下的【jdk1.8\\jre\\lib\\ext】中。 右键【我的电脑】-&gt;【高级系统设置】-&gt;【系统属性】-&gt;【高级】-&gt;【环境变量】，编辑【系统变量】中的【CLASSPATH】的【变量值】，加入【;路径】（该路径为步骤4中包的完整路径，注意路径前一定要加 ;）-&gt;【确定】。 Eclipse 【右键】工程项目-&gt;【Build Path】-&gt;【Configure Build Path】 选择【Libraries】页-&gt;【Add External JARs…】-&gt;【添加】前面粘贴jar包的路径-&gt;【Apply and Close】 实践新建一个class，复制粘贴一下代码👇 import java.sql.*; public class JDBC_Demo { // MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL //static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; //static final String DB_URL = \"jdbc:mysql://localhost:3306/数据库名\"; // MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL //static final String JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\"; //static final String DB_URL = \"jdbc:mysql://localhost:3306/数据库名?useSSL=false&amp;serverTimezone=UTC\"; // SQL Server数据库引擎 static final String JDBC_DRIVER = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\"; // 数据源！！！注意若出现加载或者连接数据库失败一般是这里出现问题 static final String DB_URL = \"dbc:sqlserver://localhost:1433;DatabaseName=数据库名\"; //【1】修改 数据库名 // 数据库的用户名与密码，需要根据自己的设置 static final String Name=\"登录名\";//【2】修改 登录名 static final String Pwd=\"密码\";//【3】修改 密码 public static void main(String[] args) { try { Class.forName(JDBC_DRIVER); Connection conn=DriverManager.getConnection(DB_URL,Name,Pwd); System.out.println(\"连接数据库成功\"); }catch(Exception e){ e.printStackTrace(); System.out.println(\"连接失败\"); } } } 运行截图👇 心得体会前前后后，总计花了差不多三天的时间来研究怎么用JDBC连接数据库。 期间，遇到好多问题。问过指导老师，老师说可能是SQL Server版本的问题。 实验要求是2014，而我的是2017。但我觉得这不是问题。 反反复复地，其他都配置好了，但是总是连接不上数据库。 后来关注点放在了Eclipse的Path上，注意到我用的是jdk12，于是我想换成jdk8。 一换、一 run ……咦，可以了哈哈哈哈。 期间参考了很多人的博客，但是那些都没有强调 IDE中的环境要设置为【jdk8】。 写博客不易，如果本文对你有帮助，可以考虑给我 打赏 哦 *( ͡° ͜ʖ ͡°)✧ * 2020.2.10 补充：关于JDBC连接MySQL的具体实例，可以前往 这里 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"https://melodyjerry.github.io/blog/tags/SQL-Server/"}]},{"title":"Java——API中文手册","slug":"Java-API中文手册","date":"2019-12-01T12:00:15.000Z","updated":"2019-12-02T12:56:16.300Z","comments":true,"path":"2019/12/01/Java-API中文手册/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/01/Java-API%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/","excerpt":"【Java 8中文版开发文档，Java 8中文版 API手册中文版】( http://www.matools.com/api/java8 )","text":"【Java 8中文版开发文档，Java 8中文版 API手册中文版】( http://www.matools.com/api/java8 ) L2Dwidget.init({\"model\":{\"jsonPath\":\"/blog/live2dw/assets/assets/haruto.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"tagMode\":false,\"debug\":false,\"mobile\":{\"show\":true},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\"}); 为了避免版权问题，再次声明：移植该文档，仅供学习交流，别无其它目的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"}]},{"title":"2019的最后一个月","slug":"2019年的最后一个月","date":"2019-12-01T05:32:39.000Z","updated":"2019-12-31T14:16:35.253Z","comments":true,"path":"2019/12/01/2019年的最后一个月/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/12/01/2019%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88/","excerpt":"","text":"💛今天，2019年12月01日，是 今年最后一个月的第一天。 🔺回想去年的12月，经历了很多，一切都是从 【晚安计划】的短信 开始。时至今天，我仍保存着去年的“晚安计划”短信。 💙今晚开始，又是新的一轮【晚安计划】。不知道你有没有呢？ 🧡从国庆回到学校后，课多了、要处理的事情多了，总之这两个月来搞的东西太多了。 💚不过呢，也是有收哦的哦！像比如，现在这个博客(2019.11.07)就是之一。还有自己写的小玩意，以后会放出来。 💜忙完这最后的12月，也该是时候让自己出去走走了。总是待在宿舍、教学楼，会傻的hh。 💛最近很想家，很想回家。不过也要等到2020元旦之后啦，也快了快了。 最后，祝我自己和大家12月健康、平安、快乐、好运…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Java—(递归+非递归)阶层","slug":"Java—（递归-非递归）阶层","date":"2019-11-30T08:08:51.000Z","updated":"2019-12-01T01:01:56.156Z","comments":true,"path":"2019/11/30/Java—（递归-非递归）阶层/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94%EF%BC%88%E9%80%92%E5%BD%92-%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89%E9%98%B6%E5%B1%82/","excerpt":"递归阶层算法、非递归阶层算法 扩展①：求阶层的和 扩展②：寻找最高阶、打印阶层的计算过程","text":"递归阶层算法、非递归阶层算法 扩展①：求阶层的和 扩展②：寻找最高阶、打印阶层的计算过程 非递归阶层算法import java.util.Scanner; public class UnRecurrenceFactorial { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"input:\"); int n = sc.nextInt(); int a = 1; while(n != 1){ a = a*n; n--; } System.out.println(a); sc.close(); } } 递归阶层算法public class RecurrenceFactorial { public static void main(String[] args) { long fac = fac(k);//修改k的值即可 System.out.println(\"n的阶乘为:\" + fac); } public static long fac(int n){ if(n == 1){ return 1; }else{ return fac(n-1) * n; } } } 扩展①：求阶层的和🔺计算 1!+2!+3!+···+k! 的值： public static void main(String[] args) { int i,j; long sum = 0; for(i = 1; i &lt;= k; i++){ //修改k的值即可 int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } sum += t; } System.out.println(sum); } 扩展②：寻找最高阶、打印阶层的计算过程🔺题目： 指定一个整型数MAX，试编写一个程序求满足1!+2!+3!…+n!&lt;=MAX 的最大整数n。并把满足条件的求和式子和找到的最大整数n打印输出。 示例1：MAX=111时，输出 1!+2!+3!+4!=33 满足条件的最大整数:4 示例2：MAX=9876 1!+2!+3!+4!+5!+6!+7!=5,913 满足条件的最大整数:7 🔺代码： import java.util.Scanner; public class Du { public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.println(\"the value of MAX:\"); int MAX; MAX=input.nextInt(); System.out.println(\"满足条件的最大整数：\"+SUM(MAX)); input.close(); } public static int SUM(int MAX) { int i = 0,j; long sum = 0; for(i = 1; i &lt;= 10; i++){ int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } sum += t; if(sum&gt;MAX) break; } Print(i-1); return i-1; } /*打印阶层的计算过程*/ public static void Print(int k) { int i,j; long sum = 0; for(i = 1; i &lt;= k; i++){ //修改k的值即可 int t = 1; for(j = 1; j &lt;= i; j++){ t *= j; } System.out.printf(\"%d! + \",i); sum += t; } System.out.print(\"\\b\\b= \"+ sum);//退两个，删去最后一个+ System.out.println(); } } 🔺截图： 我的文章、代码简单，这里有更详细文章，见大佬👉Java实现n阶阶乘的计算 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java—向下/上取整","slug":"Java—-向下-上取整","date":"2019-11-30T05:44:08.000Z","updated":"2019-12-01T00:58:39.448Z","comments":true,"path":"2019/11/30/Java—-向下-上取整/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94-%E5%90%91%E4%B8%8B-%E4%B8%8A%E5%8F%96%E6%95%B4/","excerpt":"Java中对数的舍入也分有 向上舍入（向上取整） 向下舍入（向下取整） Java的Math类中包含数舍入的方法： ceil() floor() ceil()和floor() ceil() floor() 向上取整 向下取整 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 返回小于等于（&lt;=）给定参数的最大整数 。","text":"Java中对数的舍入也分有 向上舍入（向上取整） 向下舍入（向下取整） Java的Math类中包含数舍入的方法： ceil() floor() ceil()和floor() ceil() floor() 向上取整 向下取整 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 返回小于等于（&lt;=）给定参数的最大整数 。 看个栗子👇 关于Math类的说明，参考 Number &amp; Math 类方法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java—打印字母表","slug":"Java—打印字母表","date":"2019-11-30T03:46:31.000Z","updated":"2019-12-02T15:24:50.647Z","comments":true,"path":"2019/11/30/Java—打印字母表/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94%E6%89%93%E5%8D%B0%E5%AD%97%E6%AF%8D%E8%A1%A8/","excerpt":"A到Z的ASCII码值是65到90 a到z的ASCII码值是97到122","text":"A到Z的ASCII码值是65到90 a到z的ASCII码值是97到122 Demopublic class AlphabetDemo { public static void main(String[] args) { /*char和int类型能够相互转换，相信大家都明白 */ //A到Z的ASCII码是65到90，a到z的ASCII码值是97到122 for (char c = 0; c &lt; 128; c++) { //java里包装类的一个静态方法，确定c是字母还是小写！！！） if (Character.isLowerCase(c)) { System.out.printf(\"value: %3d char: %c\\n\", (int)c, c); //同上，判断c是大写 } else if (Character.isUpperCase(c)) { System.out.printf(\"value: %3d char: %c\\n\", (int)c, c); } } } } 注：关于isLowerCase和isUpperCase在文末有进一步的说明。 扩展 ①🔺题目： 🔺参考代码： import java.util.Scanner; public class Alphabet { public static void main(String[] args) { Scanner input=new Scanner(System.in); int n,level; System.out.println(\"the value of n:\"); n=input.nextInt(); level=(int)Math.ceil(26/n);//向上取整 System.out.println(\"======Upper========\"); char CH=65; for(int i=0;i&lt;=level;i++) { for(int j=0;j&lt;n;j++) { System.out.printf(\"%c \",CH); ++CH; if(CH&gt;=90) break; } System.out.println(); } System.out.println(); /* 另一个版本，这就看个人理解了！ System.out.println(\"======Upper========\"); char CH=65; for(int i=1;i&lt;=26;i++) { System.out.print(CH+\" \"); CH++; if(i%n==0) { System.out.println(); } } System.out.println(); */ System.out.println(\"======Lower========\"); char ch=97; for(int i=0;i&lt;=level;i++) { for(int j=0;j&lt;n;j++) { System.out.printf(\"%c \",ch); ++ch; if(ch&gt;=123) break; } System.out.println(); } System.out.println(); input.close(); } } 注意：Math.ceil();//向上取整 参考：我的另一篇博客：Java—向下/上取整 🔺执行截图： 扩展 ②上面常规思考题中的第6题是自左往右从上往下的水平顺序输出大写堆和小写堆字母表。假如想要按照自上而下从左往右的垂直顺序输出大写堆，该如何实现程序？ 即假如每列输出N=5个，则程序的输出情况如下： = = = Upper = = = A F K P U Z B G L Q V C H M R W D I N S X E J O T Y 试用一重循环编写程序，指定一个整型数N(1&lt;=N&lt;=26)，按示例规格输出列优先排序的大写字母表。 🔺代码： import java.util.Scanner; public class Aphabet { public static void main(String[] args) { System.out.println(\"======Upper========\"); Scanner input = new Scanner(System.in); int n,level; System.out.println(\"the value of n:\"); n = input.nextInt(); level = (int)Math.ceil(26/n);//向上取整 int j = 0; char ch = 65; p(1, n, ch); } public static void p(int x,int n,char ch) { if(x &gt; n) return; for(int i = x;i &lt;= 26;i += n){ ch = (char)(i + 64); System.out.print(ch + \" \"); } System.out.println(); ++x; p(x, n, ch); } } 下午做了半个多小时都没做出来，晚上玩了会游戏突然想到用递归，下午怎么就没想到呢？然后游戏就挂机被举报了，但一气呵成搞定了这题。说明思想不够灵活hhh 🔺截图： 补充：Java Character 类isLowerCase() 方法🔺作用：用于判断指定字符是否为小写字母。 🔺语法 boolean isLowerCase(char ch) 🔺参数 ch – 要测试的字符。 🔺返回值 如果字符为小写，则返回 true；否则返回 false。 🔺实例 public class Test { public static void main(String args[]) { System.out.println( Character.isLowerCase('a')); System.out.println( Character.isLowerCase('A')); } } 🔺以上程序执行结果为： true false isUpperCase() 方法 🔺作用：用于判断指定字符是否为大写字母。 🔺语法 boolean isUpperCase(char ch) 🔺参数 ch – 要测试的字符。 🔺返回值 如果字符为大写，则返回 true；否则返回 false。 🔺实例 public class Test { public static void main(String args[]) { System.out.println( Character.isUpperCase('b')); System.out.println( Character.isUpperCase('B')); } } 🔺以上程序执行结果为： false true document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java—5种生成随机数的方法","slug":"Java—5种生成随机数的方法","date":"2019-11-30T02:33:25.000Z","updated":"2019-12-01T01:53:18.885Z","comments":true,"path":"2019/11/30/Java—5种生成随机数的方法/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%945%E7%A7%8D%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"5种生成随机数的简单方法 和一篇大佬的文章👇","text":"5种生成随机数的简单方法 和一篇大佬的文章👇 方法①🔺 通过java.Math包的random方法得到1-10的int随机数 🔺 公式： 最小值—最大值（整数）的随机数 (类型) 最小值+Math.random()*最大值 import java.util.Random; public class RandomDemo { public static void main(String[] args) { for (int i=0;i&lt;5;i++) { System.out.println((int)(1+Math.random()*10)); int k; k=(int)(1+Math.random()*10); } } } 方法②🔺借助java.util.Random类来产生一个随机数发生器，也是最常用的一种，构造函数有两个，Random()和Random(long seed)。第一个就是以当前时间为默认种子，第二个是以指定的种子值进行。产生之后，借助不同的语句产生不同类型的数。 🔺种子就是产生随机数的第一次使用值,机制是通过一个函数,将这个种子的值转化为随机数空间中的某一个点上,并且产生的随机数均匀的散布在空间中。以后产生的随机数都与前一个随机数有关 import java.util.Random; public class RandomDemo { public static void main(String[] args) { Random r = new Random(); for(int i=0 ; i&lt;5 ; i++) { int ran1 = r.nextInt(100);//种子：100 System.out.println(ran1); } } } 注：类似的方法可参考 利用Random类来产生5个20~50之间的随机整数 方法③ 生成随机数需要使用到Java工具类中的Random类。 要求是随机x到y之间的整数，即指定范围，则使用Random类中的nextInt(int n)方法。 该方法生成从0（包括）到n（不包括）之间的随机整数，是一个伪随机数，并不是真正的随机数。 若x不为0，则需要在随机结果后加上x。参数n的值也需要加上1后减去x。最后结果才符合要求的范围。 import java.util.Random; public class RandomDemo { public static final int START = 50; //定义范围开始数字 public static final int END = 99; //定义范围结束数字 public static void main(String[] args) { //创建Random类对象 Random random = new Random(); //产生随机数 int number = random.nextInt(END - START + 1) + START; //打印随机数 System.out.println(\"产生一个\"+START+\"到\"+END+\"之间的随机整数：\"+number); } } 注：更多方法可参考【Java工具类】—-产生随机数 方法④🔺 返回的数值是 [ 0.0 , 1.0 ) 的double型数值，由于double类数的精度很高，可以在一定程度下看做随机数，借助（int）来进行类型转换就可以得到整数随机数了 public static void main(String[] args) { for (int i = 1; i &lt;= 10; i++) { int max=99,min=10;//生成两位随机正整数 int ran2 = (int) (Math.random()*(max-min)+min); System.out.println(ran2); } } 方法⑤🔺 返回从1970年1月1日0时0分0秒（这与OS有关）到现在的一个long型的毫秒数，取模之后即可得到所需范围内的随机数 public static void main(String[] args) { int max=100,min=1; long randomNum = System.currentTimeMillis(); int ran3 = (int) (randomNum%(max-min)+min); System.out.println(ran3); } 大佬的文章这个大佬【peabits】的文章贼详细，可以好好琢磨琢磨 👇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java中的<<、>>和>>>","slug":"Java中的、-和","date":"2019-11-29T16:33:38.000Z","updated":"2019-11-29T17:14:55.054Z","comments":true,"path":"2019/11/30/Java中的、-和/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E4%B8%AD%E7%9A%84%E3%80%81-%E5%92%8C/","excerpt":"左移 左移运算符 &lt;&lt; 👉使指定值的所有位都左移规定的次数 左移m&lt;&lt;n，代表把数字m在无溢出的前提下乘以2的n次方 右移 右移运算符 &gt;&gt; 👉 使指定值的所有位都右移规定的次数 右移m&gt;&gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数 注意，如果是单数，也就是二进制末位为1，则结果是将m除以2的n次方的整数商 无符号右移 无符号右移运算符 &gt;&gt;&gt; 👉同右移，但是结果全变正数","text":"左移 左移运算符 &lt;&lt; 👉使指定值的所有位都左移规定的次数 左移m&lt;&lt;n，代表把数字m在无溢出的前提下乘以2的n次方 右移 右移运算符 &gt;&gt; 👉 使指定值的所有位都右移规定的次数 右移m&gt;&gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数 注意，如果是单数，也就是二进制末位为1，则结果是将m除以2的n次方的整数商 无符号右移 无符号右移运算符 &gt;&gt;&gt; 👉同右移，但是结果全变正数 Demo 以下内容转载于 Java中的&lt;&lt; 和 &gt;&gt; 和 &gt;&gt;&gt; 详细分析 详细分析&lt;&lt;表示左移，不分正负数，低位补0； 注：以下数据类型默认为byte-8位 左移时不管正负，低位补0 正数：r = 20 &lt;&lt; 2 20的二进制补码：0001 0100 向左移动两位后：0101 0000 结果：r = 80 负数：r = -20 &lt;&lt; 2 -20 的二进制原码 ：1001 0100 -20 的二进制反码 ：1110 1011 -20 的二进制补码 ：1110 1100 左移两位后的补码：1011 0000 反码：1010 1111 原码：1101 0000 结果：r = -80 &gt;&gt;表示右移，如果该数为正，则高位补0，若为负数，则高位补1； 注：以下数据类型默认为byte-8位 正数：r = 20 &gt;&gt; 2 20的二进制补码：0001 0100 向右移动两位后：0000 0101 结果：r = 5 负数：r = -20 &gt;&gt; 2 -20 的二进制原码 ：1001 0100 -20 的二进制反码 ：1110 1011 -20 的二进制补码 ：1110 1100 右移两位后的补码：1111 1011 反码：1111 1010 原码：1000 0101 结果：r = -5 &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0 正数： r = 20 &gt;&gt;&gt; 2 的结果与 r = 20 &gt;&gt; 2 相同； 负数： r = -20 &gt;&gt;&gt; 2 注：以下数据类型默认为int 32位 -20:源码：10000000 00000000 00000000 00010100 反码：11111111 11111111 11111111 11101011 补码：11111111 11111111 11111111 11101100 右移：00111111 11111111 11111111 11111011 结果：r = 1073741819 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java用最有效率的方法计算2乘以8","slug":"Java—用最有效率的方法计算2乘以8","date":"2019-11-29T16:24:00.000Z","updated":"2019-12-01T01:58:23.398Z","comments":true,"path":"2019/11/30/Java—用最有效率的方法计算2乘以8/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/30/Java%E2%80%94%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%972%E4%B9%98%E4%BB%A58/","excerpt":"","text":"最有效率的方法 👉 2 &lt;&lt; 3 其中，左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方 再比如，31 * num 等价于( num &lt;&lt; 5 ) – num 左移5位相当于乘以2的5次方（32），再减去自身（-1），这一过程就相当于乘以31 注：关于移位运算符，可参考我的下一篇博客 Java中的&lt;&lt;、&gt;&gt;和&gt;&gt;&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—static关键字","slug":"Java笔记—static关键字","date":"2019-11-28T09:24:41.000Z","updated":"2020-02-15T14:06:51.884Z","comments":true,"path":"2019/11/28/Java笔记—static关键字/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/28/Java%E7%AC%94%E8%AE%B0%E2%80%94static%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"static 关键字static类型，又叫类类型。 修饰目标 (成员数据/方法/成员内部类/代码块)属于类的 静态类 静态块 静态方法 静态变量 static 成员内部类 static 代码块 static 成员方法 static 成员变量 直接通过类就可以访问。所有对象共享该类 只能出现在类中不能出现方法体中，类加载后初始化时被执行一次。注意:区分构造代码块，每次构造都被执行 直接通过类就可以调用。不用等创建了实例后 类加载时在Java方法区分配空间，所有对象共享 区别：无static关键字成员属于具体的对象实例： 实例变量、实例方法(只能通过对象调用)、实例成员内部类(只能通过对象引用) 静态的特点 随着类的加载而加载 也就是，说静态会随着类的消失而消失，说明静态的生命周期最长。 优先于对象的存在 明确一点：静态是先存在的，对象是后存在的。 被所有对象共享。 可以直接被类名多调用。 static 成员的访问格式一般要通过 *“ 类名. ” * 的形式来访问 静态变量 静态方法 静态成员内部类 类名.静态变量 类名.静态方法 类名.静态成员内部类 注意事项🔺 static成员方法/代码块：静态方法 只能 使用静态成员变量(或内部类)或调用静态方法。（任课老师称： 静者恒静） 🔺非静态方法可以访问静态、也可以访问非静态。 🔺 static成员方法/代码块：方法体中不能出现this(当前对象)或super(基类对象)。因为静态优先于对象存在，所以静态方法中不可以出现this、super关键字。 实例变量和类变量的区别 存放位置 类变量随着类的加载存在于方法区中，实例变量随着对象的对象的建立存在于堆内存里 生命周期 类变量生命周期最长，随着“类”的加载而加载，随着类的消失而消失 实例变量随着“对象”的消失而消失 静态的利弊 利：1、对对象的共享数据进行单独空间的存储，节省空间，没有必要没一个对象中都存储一份。2、可以直接被类名所调用。 弊：生命周期过长，访问出现局限性（只能访问静态）","text":"static 关键字static类型，又叫类类型。 修饰目标 (成员数据/方法/成员内部类/代码块)属于类的 静态类 静态块 静态方法 静态变量 static 成员内部类 static 代码块 static 成员方法 static 成员变量 直接通过类就可以访问。所有对象共享该类 只能出现在类中不能出现方法体中，类加载后初始化时被执行一次。注意:区分构造代码块，每次构造都被执行 直接通过类就可以调用。不用等创建了实例后 类加载时在Java方法区分配空间，所有对象共享 区别：无static关键字成员属于具体的对象实例： 实例变量、实例方法(只能通过对象调用)、实例成员内部类(只能通过对象引用) 静态的特点 随着类的加载而加载 也就是，说静态会随着类的消失而消失，说明静态的生命周期最长。 优先于对象的存在 明确一点：静态是先存在的，对象是后存在的。 被所有对象共享。 可以直接被类名多调用。 static 成员的访问格式一般要通过 *“ 类名. ” * 的形式来访问 静态变量 静态方法 静态成员内部类 类名.静态变量 类名.静态方法 类名.静态成员内部类 注意事项🔺 static成员方法/代码块：静态方法 只能 使用静态成员变量(或内部类)或调用静态方法。（任课老师称： 静者恒静） 🔺非静态方法可以访问静态、也可以访问非静态。 🔺 static成员方法/代码块：方法体中不能出现this(当前对象)或super(基类对象)。因为静态优先于对象存在，所以静态方法中不可以出现this、super关键字。 实例变量和类变量的区别 存放位置 类变量随着类的加载存在于方法区中，实例变量随着对象的对象的建立存在于堆内存里 生命周期 类变量生命周期最长，随着“类”的加载而加载，随着类的消失而消失 实例变量随着“对象”的消失而消失 静态的利弊 利：1、对对象的共享数据进行单独空间的存储，节省空间，没有必要没一个对象中都存储一份。2、可以直接被类名所调用。 弊：生命周期过长，访问出现局限性（只能访问静态） Demo：类内使用import static java.lang.System.*; //静态导入静态方法或对象 public class StaticDemo1 { static int a = 3, b, i = 0; // 静态变量 char ch = 'Y'; // 实例变量 static void meth(int x) { // 静态方法 out.println(\"x = \" + x); //out.println(\"ch = \" + ch);//【1】Error! } static { // 静态代码块-类加载时只执行1次 out.println(\"静态块初始化：仅1次\"); b = a * 4; //out.println(\"ch = \" + ch);//【1】Error! } public static void main(String[] args) { meth(42); //静态方法调用静态方法 new StaticDemo1(); //创建匿名对象1 new StaticDemo1(); //创建匿名对象2 } { out.println(\"ch = \" + ch);//【2】OK! out.printf(\"构造代码块：第%d次构造第%1$d次执行\\n\", (++i)); } } } 注意： 🔺特别注意：类的静态代码块仅在类在加载后初始化时被执行1次 🔺第一次new一个类时才加载该类 🔺静态方法、静态块不能访问非静态的成员（即，静者恒静）。如上述代码中的注释【1】 🔺静态块初始化：仅1次 Demo：类外使用和静态块执行时机import static java.lang.System.out; class MyD{ private static int m; public static int n; static{ // 静态代码块【2】 m = n = 0; out.println(\"仅1次\"); } public static void callMe(){ out.printf(\"m=%d,n=%d\", m, n); } } public class StaticDemo2 { public static void main(String[] args) { MyD d; //【0】MyD被加载，但未主动使用 d = new MyD(); //【1】这里才【主动使用】MyD，于是执行其静态代码块【2】 MyD.n++; //最佳：类名.静态变量 MyD.callMe(); //最佳：类名.静态方法 } } 特别留意： 🔺用一个类声明一个类对象变量，至多会加载该类，但还未主动使用🔺老师说：【主动使用】，是一个比较高级的专题，暂不深入 DEMO：静态方法的声明class Person{ String name; //定义name属性 private static String nation = \"中国\"; //定义静态属性nation int age; //定义age属性 public Person(String name, int age){//声明一个有参的构造方法 this.name = name; this.age = age; } public String talk(){ //声明了一个talk()方法 return \"我是：\" + this.name + \"，今年：\" + this.age + \"岁，来自：\" + nation; } public static void setNation(String nat){//声明一个静态方法，给静态变量赋值 nation = nat; } } public class StaticMethod{ public static void main(String[] args){ Person p1 = new Person(\"张三\", 25); Person p2 = new Person(\"李四\", 30); Person p3 = new Person(\"王五\", 35); System.out.println(\"修改之前信息：\" + p1.talk()); System.out.println(\"修改之前信息：\" + p2.talk()); System.out.println(\"修改之前信息：\" + p3.talk()); System.out.println(\" ***********修改之后信息***********\"); // 修改后的信息 Person.setNation(\"美国\"); System.out.println(\"修改之后信息：\" + p1.talk()); System.out.println(\"修改之后信息：\" + p2.talk()); System.out.println(\"修改之后信息：\" + p3.talk()); } } DEMO：调用外部类定义的方法（有static+无static）首先定义方法 public class Dy { public int Add(int x,int y) { //定义Add(),该方法没有被static修饰 return x+y; } public static int Sub(int x,int y) {//定义Sub(),该方法被static修饰 return x-y; } } 调用方法 public class Test { public static void main(String[] args){ int a=5; int b=4; int result=0; //通过实例化调用外部类的Add方法 Dy dy=new Dy(); result=dy.Add(a, b); System.out.println(result); //直接调用外部类的Sub方法 result=Dy.Sub(a, b); System.out.println(result); } } 🔺static main方法调用外部方法/成员变量： 有static：“类名.”形式调用 无static：“对象.”形式调用 综上 什么时候使用静态？ 因为静态修饰的内容有成员变量和方法。 什么时候定义静态变量（类变量）呢？ 当对象中出现共享数据时，该数据被静态所修饰，对象中的特有数据要定义成非静态存在于堆内存中。 什么时候定义静态函数？ 当功能内部没有访问到非静态数据（或者称为对象的特有数据） 那么该功能可以定义成静态的。 注：前面的几篇Java笔记中也有提到static，后来上课老师再小结static关键词，结合前面的笔记食用效果更佳。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—this关键字","slug":"Java笔记—this关键字","date":"2019-11-28T09:11:18.000Z","updated":"2019-11-29T17:36:57.692Z","comments":true,"path":"2019/11/28/Java笔记—this关键字/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/28/Java%E7%AC%94%E8%AE%B0%E2%80%94this%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"this 关键字三个形式上的用途，但本质上就两个： 调用重载的其他构造方法：放置在构造方法体首行的this()或this(实参列表) 作为当前对象，引用成员（数据、方法等）：区分同名变量等 作为当前对象，方法返回当前对象的引用，形成链式调用","text":"this 关键字三个形式上的用途，但本质上就两个： 调用重载的其他构造方法：放置在构造方法体首行的this()或this(实参列表) 作为当前对象，引用成员（数据、方法等）：区分同名变量等 作为当前对象，方法返回当前对象的引用，形成链式调用 案 例 ： public class ThisDemo { private int a = 1; private String name = \"good\"; private int i = 0; public ThisDemo(){ System.out.println(\"无参构造子\" + this); } public ThisDemo(int a, String name){ this(); // 【1】调用无参构造子 this.a = a; // 【2】当前对象，引用成员 this.name = name; } public ThisDemo setA(int a){ this.a = a; return this; // 【3】返回当前对象 } public ThisDemo setName(String name){ this.name = name; return this; } public ThisDemo inc(){ i++; return this; } public static void main(String[] args) { ThisDemo t1 = new ThisDemo(); t1.setA(100).setName(\"guo\").inc().inc(); System.out.println(t1.i); ThisDemo t2 = new ThisDemo(2, \"Tom\"); t2.inc().setA(8).inc().inc(); //【4】链式调用 System.out.println(t2.i); } } 特别注意，案例中的【3】和【4】。 注：前面的几篇Java笔记中也有提到this，后来上课老师再小结this关键词，结合前面的笔记食用效果更佳。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"对SQL的触发器的浅理解","slug":"浅谈SQLServer触发器","date":"2019-11-26T05:08:18.000Z","updated":"2019-11-28T11:22:43.203Z","comments":true,"path":"2019/11/26/浅谈SQLServer触发器/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/26/%E6%B5%85%E8%B0%88SQLServer%E8%A7%A6%E5%8F%91%E5%99%A8/","excerpt":"","text":"个人理解如果需要做一些特定的增删改操作，就可以使用触发器。 触发 ，当做了某种预设的操作时才会执行触发器的命令。 栗子：假设现在有个员工基础信息表，里面有员工的身份证号码，手机等基本信息。那么，当你换了身份证或手机，需要修改号码的时候，肯定是去修改员工的基础资料表。假设你现在有别的地方，比如人事档案啊之类的，同样使用了员工的手机等信息，难道还要再去修改一次档案表么？那么如果还有其他地方使用了呢？而在这种时候有触发器就好解决了。如果设置一个触发器来判断，如果修改了基础表的信息，那么就同步把其他使用了基础表的关联信息也更改成最新的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"SQL Server","slug":"SQL-Server","permalink":"https://melodyjerry.github.io/blog/tags/SQL-Server/"}]},{"title":"G.E.M.邓紫棋《句号》MV首播！","slug":"G.E.M.邓紫棋《句号》MV首播！","date":"2019-11-25T14:21:12.000Z","updated":"2019-11-29T04:53:27.657Z","comments":true,"path":"2019/11/25/G.E.M.邓紫棋《句号》MV首播！/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/25/G.E.M.%E9%82%93%E7%B4%AB%E6%A3%8B%E3%80%8A%E5%8F%A5%E5%8F%B7%E3%80%8BMV%E9%A6%96%E6%92%AD%EF%BC%81/","excerpt":"G.E.M.邓紫棋《句号》MV首播！ 🧡点击破亿『全创作天后』G.E.M.邓紫棋和过去告别，向未来大步迈开，开启音乐版图新起点的一个“句号”。 这是华语乐坛前所未见的真实披露之作，她用&lt;句号&gt;这首歌，预告了全新的音乐篇章，翻页之后，就要开始。 榜单Top 1 💗邓紫棋新歌《句号》上线颇有波折，国内几大音乐平台推迟上线，但在唯一上线的Apple Music平台，已经超过霉霉新歌《lover》，一举拿下 榜单 Top1！ 官方MV视频第一发布于微博： GEM鄧紫棋 2019.11.28更换 1 网页视频源： B站官方合作发布","text":"G.E.M.邓紫棋《句号》MV首播！ 🧡点击破亿『全创作天后』G.E.M.邓紫棋和过去告别，向未来大步迈开，开启音乐版图新起点的一个“句号”。 这是华语乐坛前所未见的真实披露之作，她用&lt;句号&gt;这首歌，预告了全新的音乐篇章，翻页之后，就要开始。 榜单Top 1 💗邓紫棋新歌《句号》上线颇有波折，国内几大音乐平台推迟上线，但在唯一上线的Apple Music平台，已经超过霉霉新歌《lover》，一举拿下 榜单 Top1！ 官方MV视频第一发布于微博： GEM鄧紫棋 2019.11.28更换 1 网页视频源： B站官方合作发布 ( ͡° ͜ʖ ͡°)✧我已经 循环 MV几天了，等待网易云上架。 听说 “连Siri都被圈粉？有网友发现现在向Siri提出“播放世界第一的歌曲”，结果直接是《句号》” 有iPhone的，赶紧试试看吧 ( ͡° ͜ʖ ͡°)✧ 1.第一次发这篇文章的第二天发现视频链接失效，研究了一下，发现微博视频用的是临时链接，就是生命周期只有1天的临时链接，于是我改由B站的视频 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"音乐","slug":"音乐","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"[电影]《Ladybird》演绎完整18岁的青春","slug":"电影-《Ladybird》演绎完整18岁的青春","date":"2019-11-23T13:33:12.000Z","updated":"2020-02-11T06:44:37.415Z","comments":true,"path":"2019/11/23/电影-《Ladybird》演绎完整18岁的青春/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/23/%E7%94%B5%E5%BD%B1-%E3%80%8ALadybird%E3%80%8B%E6%BC%94%E7%BB%8E%E5%AE%8C%E6%95%B418%E5%B2%81%E7%9A%84%E9%9D%92%E6%98%A5/","excerpt":"《LadyBird》，2017年的青春轻喜剧，烂番茄指数高达99%！","text":"《LadyBird》，2017年的青春轻喜剧，烂番茄指数高达99%！ ​ 该电影讲的是一个入不敷出的家庭，强势严厉的Mom，慈祥宽容却患有抑郁症的Dad，自称LadyBird的叛逆少女Christian克里斯汀，从高中步入大学时期所经历的亲情、友情、爱情，酸甜苦辣。 ​ 虽然欧美家庭的相处方式离我们很远，但影片展现的青春经历却与我们都有可对照之处。 ​ Christian不喜欢父母取的名字，自己取名为LadyBird，盼望自己化身为鸟，渴望获得自由。她横冲直撞，怼哥哥，怼老师，怼修女，公然挑衅和搞恶作剧。18岁的第一天，就去买了骆驼香烟，一张彩票，一本成人杂志，站在家乡萨克拉门托的阳光下，体会成长放纵的快感。她想逃离家乡，去纽约，去外面的世界闯荡，瞒着妈妈偷偷申请纽约的学校。 ​ 她不去考虑别人地感受，想要的太多，对得到的总是不够满足。当然，她也有自卑虚荣的一面。会纠结自己不够出众的长相，“为什么我看起来不像是杂志里的女孩？”，不喜欢贫寒的出身，把男朋友外婆家的dreamhouse说成是自己家；为了接近乐队的凯尔，成为同样酷酷的类型，她和珍娜套近乎而疏远了自己最好的朋友。 ​ 两次恋爱纷纷落空。第一次是个贴心男友，交往顺利，却被发现是个同性恋。第二次是个俊俏阴郁乐队选手（是有点帅），但性生活不够严肃，上完床两人就分了一半了吧。直到在去舞会的路上，男友和他的朋友们想中途逃出来，LadyBird却对舞会充满期待。其实就是三观不合啊！她开始同意，却也意识到，坚持自己内心的感受，不适合跟这些人做朋友。生活就是这样啊，我们期待、努力、相信又落空。谁的青春没遇上过渣男，只是帅不帅而已。 ​ LadyBird和老妈的冲突贯穿影片。强势得老妈常常扮演成长中的“黑脸角色”，总是试图把自己的意念强加给孩子：上一秒还被广播感动的母女二人，下一秒迅速争执起来，LadyBird用跳车的方式宣扬自己的逃离和叛逆；衣服不叠会被老妈骂，走路的姿势会被嫌弃，穿什么衣服都得不到赞扬，浴室不能反锁门，进屋从来不敲门……青春期的孩子都渴望自由，太想脱离大人的管教——“告诉我你抚养花了多少钱！等我长大了努力赚钱都还给你！这样我就再也不用和你讲话！” ​ 这份冲突的亲情在最后得到了和解。平安夜不在家过看得出妈妈最难过；会在半夜为女儿修剪裙边；暗自用没有语法韵律的信件记录下对女儿的冲突和爱意；当LadyBird真的去上大学，表面保持冷漠严肃，车都不下，实际内心有满满地不舍。一切地情感在试衣间前得到合理地解释： “I want you to be the best version of yourself you can be.” “What if this is the best version?” ​ 这也是每个家长对我们地期待吧。然而，对于家长地对我们地改变，我们总是无意识就反驳，就对抗。你有你的唠叨，我有我的骄傲！ ​ 失业、并长期患有抑郁症的老爸是影片温情的存在，是家里的“好人角色”担当。记得在女儿十八岁生日时送上生日蛋糕；瞒着妈妈帮女儿申请纽约的学校，是女儿地‘同党’；问是否要和门外那个按喇叭的男孩走，虽然爸爸内心是不喜欢的，但依然会尊重女儿；影片最后，悄悄把妈妈写的信放进Ladybird书包，告诉她，妈妈其实是多么爱她——这也是促进母女关系和解的重要一环。 ​ 这是一个与自己、与家人和解的故事，像极了青春期的我们。影片的最后，她真的到达纽约。在家乡，这个女孩给自己取名为LadyBird，向所有人宣称自己的叛逆，想像鸟一样自由挣脱；而到了纽约，她要像鸟一样开始漂泊时，又叫回Christian。因未来而出走，因出走而怀乡。 影片的最后，她在电话里说“妈妈，我发现我从来没有意识到，萨克拉门托是那么美的地方。似乎每一处细节，每一个弯道，都是那么的美丽。” ​ 我们总想为逃离自己的家庭出身而奋斗，终有一天会觉得，走得再远，都想再回到最初的地方。蜷局于母体时的安全是最安全。 大二上学期《英语影视鉴赏》课结作业。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"电影","slug":"电影","permalink":"https://melodyjerry.github.io/blog/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"Java笔记—包","slug":"Java笔记—包","date":"2019-11-23T05:54:59.000Z","updated":"2019-11-29T17:36:24.562Z","comments":true,"path":"2019/11/23/Java笔记—包/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/23/Java%E7%AC%94%E8%AE%B0%E2%80%94%E5%8C%85/","excerpt":"Java笔记——包创建时间：2019.11.23 说明：持续更新ing 概念 包(package) 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 ✔ 用来组织和管理类、接口、枚举和注解✔ 有三方面作用：1)便于组织,比如按功能、按团队等；2)解决命名冲突；3)进行访问权限控制(同包可用，包外不可见等) 如同类似OS的文件夹(或目录或路径)一样，包也采用了树形目录的存储方式。","text":"Java笔记——包创建时间：2019.11.23 说明：持续更新ing 概念 包(package) 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 ✔ 用来组织和管理类、接口、枚举和注解✔ 有三方面作用：1)便于组织,比如按功能、按团队等；2)解决命名冲突；3)进行访问权限控制(同包可用，包外不可见等) 如同类似OS的文件夹(或目录或路径)一样，包也采用了树形目录的存储方式。 作用 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 🔺 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 同一个包中类名字是不同的，不同包中类的名字可以相同，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 语法格式 package 包名 或 package 父包名[.子包名][.孙包名][.层次下去] 🔸包名符合标识符命名规范，一般由小写字母组成🔹必须出现在源文件的第一行(忽略注释语句)🔸每个源文件至多只能出现一个package语句🔹如果没有package语句，那就使用无名包(或称默认包:所在的当前目录)🔸包的背后对应着操作系统的路径名称 示例： package ch08.web.sample; public class Person { String name; int age; //省略部分代码 } class Dog { String name; int age; //省略部分代码 } 🔺package ch08.web.sample; 这个层级的文件夹必须先存在：即ch08/web/sample 包的使用 🔺import 关键字 为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。 为了使用另外一个包中的成员(主要是类)，可以明确import该成员。 避免重复使用完整路径的类名。 语法格式： import package1[.package2…].(classname|*); 注意： 必须紧跟在package语句之后(若有的话，若无package，则import出现在源文件头部)。 可以使用 * 来表示导入当前一层包中的所有类。但是* 不可以连续使用。 import java.*.*; // Error! 不表示可以继续导入当前包的子包。如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。 类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。 Java常用包 🔵JavaAPI的类库也是按照包的方式组织的 包名 描述 备注 Java.lang Java语言进行程序设计的基础类(核心类库)，它是默认导入的包 Runnable接口和Object、Math、String、StringBuffer、System、Thread、Throwable类 Java.util 实用工具类包 定义系统特性、随机数、日期时间、日历、集合类等 Java.io IO类包 包含能提供多种输入输出的文件读写类 Java.net 网络编程API Java.sql 数据库操作包 Java.text 文本处理相关类 包含了一些用来处理文本、数字和消息的类和接口 Java.awt 提供创建界面和绘制图形图像的所有类 Javax.asing awt上封装的GUI包 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"推荐3款文本编辑器","slug":"文本编辑器","date":"2019-11-22T02:34:04.000Z","updated":"2019-11-29T17:38:00.468Z","comments":true,"path":"2019/11/22/文本编辑器/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/22/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/","excerpt":"前言今天作者推荐两款文本编辑器。 我先后使用的Notepad 3、Sublime、Atom、VS Code、Vim。 这里作者就只推荐Notepad 3、Sublime和Atom。 关于VS Code和Vim，文末有两篇教程供大家入手。","text":"前言今天作者推荐两款文本编辑器。 我先后使用的Notepad 3、Sublime、Atom、VS Code、Vim。 这里作者就只推荐Notepad 3、Sublime和Atom。 关于VS Code和Vim，文末有两篇教程供大家入手。 //截断文章 Notepad 3 虽然 Windows 操作系统在过去几年中有了显著变化，但是，默认的 Windows 记事本却鲜有更新。如果您需要一个简单且适于编程的文本编辑器，Notepad3 将是一个不错的选择！ Notepad3是一款轻便快捷的基于 Scintilla 的文本编辑器，具有语法高亮、代码折叠、括号匹配、自动缩进、编码转换、换行格式转换、多次撤销或重做、书签、基于正则表达式的查找和替换等实用功能。它占用的内存很小，但功能强大，足以处理大多数编程工作。 Notepad 3 的界面 可能 是我见过所有主流文本编辑器里最最最简单清爽的吧？ 蓝奏云：下载链接（作者提供了已经汉化过的便携版本） （注意：Notepad 3和Notepad++没有关系 ） Sublime官方的介绍简单又粗暴 一款用于代码、标记和散文的精致文本编辑器 Sublime支持 Windows 、Mac 平台。插件是程序员的灵魂，Sublime不失这点。类似于 Eclipse，IDEA，它有着丰富的插件系统，完全可以满足各种开发编辑需求。1）安装 官网关于Sublime的介绍语下就是win版的下载入口或者点击这里快速下载最新版==Sublime Text 3 (Build 3207)== 下载得到的是exe，双击开始安装。 安装导向界面，点击【Next】继续安装。选择Sublime Text 3安装位置，您可以点击【Next】，软件会自动安装。或者您可以单击【Browse】，在弹出的安装位置窗口中，您可以自己选择Sublime Text安装位置，选择完成后点击【Next】。这里可选择 添加到资源管理器上下文菜单 。 安装完后可以在桌面或者开始菜单中找到Sublime。 2）使用Sublime的界面特别简洁，让人看着很舒服。这里，作者已经汉化过了。初始语言是English。 3）汉化 sublime 的插件的强大之处，sublime 通过 package control来统一管理安装的插件。现版本sublime 3自带package control功能。 将English变成Chinese，也可以通过Sublime的插件实现。 作者已经汉化过。为了教程，故在win7虚拟机上教大家如何实现汉化。 官网下载，并安装好, 刚安装好的是没有 Package Control 选项 找到 Tools-&gt;Install Package Control 选项，即可调出 Package Contro 不能直接找到 Install Package Control，去找“Tools-&gt;Command Palette…”选项 输入 ipc ,点击 Install Package Control，即可调出 Package Control 等待完成 找到 Preferences-&gt;Package Control 选项弹出命令行输入框，输入ip，点击“install Package 弹出命令行输入框，输入clz，点击“ChineseLocalizations” 搞定，设置成中文了 开开心心地食用汉化地Sublime吧 o(￣▽￣)o Atom Atom 是 Github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持CSS，HTML，JavaScript等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。 官网在这里👈友情链接：w3school之Atom教程Atom 中文社区 1）安装官网地Downloa或者点击这里快速下载最新版==Atom (1.41.0)== 下载得到exe，双击开始安装。安装过程很简单，直接省略。 2）使用Atom 的界面也比较简洁。Atom提供了侧栏、标签栏，可提高效率。Atom还能链接到GitHub，这真是GitHub用户的福利。(当然，Atom本来就是Github推出的hhhh)3）汉化Atom的汉化有两种方法： 方法一 打开软件后，点击 File&gt; Settings&gt; install 搜索 chinese，安装两个插件 重启软件因为插件托管在国外，可能因为网速原因，会非常慢，因此推荐下载中文插件包，请看方法二👇 方法二 打开https://atom.io/packages/去官网下载中文包，搜索【Chinese】，找到【atom-simplified-chinese-menu】点击进入主页（如上图），然后再点【Verions】，之后，找到最新版本，点【zip】包下载即可。。作者在这已经准备好中文包了，点击这里下载 将下载好了的压缩包解压到 C:/user/&lt;用户名&gt;/.atom/packages/目录下面 打开Atom，发现已经Chinese了。 综上主流的文本编辑器有很多。每个人的需求不一样，找到合适自己的才是好的。Notepad 3、Sublime、Atom、VS Code、Vim、Notepad++（前段时间闹事，作者不方便再提） VS Code：传送门 Vim：传送门 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Java笔记—继承","slug":"Java笔记—继承","date":"2019-11-21T09:54:59.000Z","updated":"2019-11-29T17:36:14.410Z","comments":true,"path":"2019/11/21/Java笔记—继承/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/21/Java%E7%AC%94%E8%AE%B0%E2%80%94%E7%BB%A7%E6%89%BF/","excerpt":"Java笔记——继承 创建时间：2019.11.21 说明：持续更新ing 继承源于自然 就比如：兔子和羊属于食草动物类，狮子和豹属于食肉动物类。食草动物和食肉动物又是属于动物类。虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以 子类会具有父类的一般特性也会具有自身的特性。","text":"Java笔记——继承 创建时间：2019.11.21 说明：持续更新ing 继承源于自然 就比如：兔子和羊属于食草动物类，狮子和豹属于食肉动物类。食草动物和食肉动物又是属于动物类。虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以 子类会具有父类的一般特性也会具有自身的特性。 //截断文章 概念、目的、本质、特性 概念 它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 其主要作用在于，在已有基础上继续进行功能的扩充。（即，以存在的类为基础定义新的类，新类即拥有基类的数据成员和成员方法） 目的 继承的目的是代码重用 本质 描述了自然界中广泛存在的一种关系——类属关系（is-a），对应还有一种has-a关系即组合（聚合）关系。 特性 Java 继承的特性 子类拥有父类非private的属性，方法 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展 子类可以用自己的方式实现父类的方法 Java的继承是单继承，【但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性】 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系） 继承的关键字 继承可以使用 extends(单继承) 和 implements（变相的多继承）， 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 （1）extends关键字 Java只支持单继承，即：一个子类只能有一个父类.但可以有多个间接祖先类。 语法格式： 权限修饰符 class 父类名 { //父类体 } 权限修饰符 class 子类名 extends 父类名 { //子类体 } 实例： public class Animal { private String name; private int id; public Animal(String myName, String myid) { //初始化属性值 } public void eat() { //吃东西方法的具体实现 } public void sleep() { //睡觉方法的具体实现 } } public class Penguin extends Animal{ } —————————————————————— 我 是 分 割 线 ——————————————————————— （2）implements关键字 变相地使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 public interface A { public void eat(); public void sleep(); } public interface B { public void show(); } public class C implements A,B { } &lt;!--￼2--&gt; 执行结果： &lt;!--￼3--&gt; —————————————————————— 我 是 分 割 线 ——————————————————————— （4）this关键字 指向”自己的引用“。 实例： class Animal { void eat() { System.out.println(\"animal : eat\"); } } class Dog extends Animal { void eat() { System.out.println(\"dog : eat\"); } void eatTest() { this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 } } public class Test { public static void main(String[] args) { Animal a = new Animal(); a.eat(); Dog d = new Dog(); d.eatTest(); } } 输出结果： animal : eat dog : eat animal : eat ——————————————————————————— 我 是 分 割 线 ———————————————————————————— （5）final关键字 声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。 继承类型 Java 不支持多继承，但支持多重继承 （ 一般不会超过三层 ）。 继承的限制 🔺 Java只允许单继承、不允许多继承（一个子类继承一个父类）。 🔺 子类对象在进行实例化前首先调用父类构造方法，再调用子类构造方法实例化子类对象。 🔺 在继承时，子类会继承父类的所有结构。 在进行继承的时候，子类会继承父类的所有结构（包括私有属性、构造方法、普通方法）显示继承：所有非私有操作属于显示继承（可以直接调用）。隐式继承：所有私有操作属于隐式继承（不可以直接调用，需要通过其它形式调用（get或者set））。 子类能够使用的是所有非private操作，而所有的private操作无法被直接使用，所以称为隐式继承。 继承中“域的隐藏” 在子类中重新定义( 同 名 )继承自父类的域. 🔺子类继承父类非私域。 🔺子类定义与从父类继承下来的同名域，在子类中用该名直接访问就只能访问到子类定义的域，即隐藏了同名的继承下来的父类域。 🔺如果要访问同名父类域：通过父类方法，或者使用“*super . *” 实例： import static java.lang.System.*; class Super{ private int v1 = 1; int v2 = 2; public int getV1() { return v1; } } class Sub extends Super{ int v1 = 11; int v2 = 22; public void show() { out.println(v1); //out.println(super.v1); out.println(getV1()); out.println(v2); out.println(super.v2); } } public class FHTest{ public static void main(String[] args) { new Sub().show(); } } 继承情况的构造 首先🔺类初始化时,继承链上(包括当前类)的全部静态代码块最先执行一次。之后不再执行，除非程序又重启。(按链序和声明序且仅1次) 其次🔺创建子类实例时,会先进行父类的构造(要么显式进行，要么隐式用super()进行) 最后🔺类的构造顺序：构造代码块(按声明序) ➡ 构造方法 总体🔺父类静态块 ➡ 子类静态块 ➡ 父类构造块 ➡ 父类构造子 ➡ 子类构造块 ➡ 子类构造子（下划线”__”部分， 仅执行一次） 总结 1、为什么使用继承 从已有的类派生出新的类，称为继承。 在不同的类中也可能会有共同的特征和动作，可以把这些共同的特征和动作放在一个类中，让其它类共享。 因此可以定义一个通用类，然后将其扩展为其它多个特定类，这些特定类继承通用类中的特征和动作。 继承是 Java 中实现软件重用的重要手段，避免重复，易于维护，易于理解。 2、父类和子类 如果类 B 从类 A 派生，或者说类 B 扩展自类 A，或者说类 B 继承类 A， 则称类 A 为”父类”，也称为超类、基类； 称类 B 为”子类”，也称为次类、扩展类、派生类。 子类从它的父类中继承可访问的数据域和方法，也可以添加新的数据域和新的方法。 定义继承的语法： 修饰符 class 子类名 extends 父类名 例如：Shape 类是父类，其子类可以有 Circle 类、Rectangle 类、Triangle 类，等等。 继承的注意点： 子类不是父类的子集，子类一般比父类包含更多的数据域和方法。 父类中的 private 数据域在子类中是不可见的，因此在子类中不能直接使用它们。 继承是为”是一个”的关系建模的，父类和其子类间必须存在”是一个”的关系，否则不能用继承。 但也并不是所有”是一个”的关系都应该用继承。例如，正方形是一个矩形，但不能让 Square 类来继承 Rectangle 类，因为正方形不能从矩形扩展得到任何东西。正确的继承关系是 Square 类继承 Shape 类 Java 只允许单一继承（即一个子类只能有一个直接父类），C++ 可以多重继承（即一个子类有多个直接父类）。 3、super 关键字 super 表示使用它的类的父类。super 可用于： 调用父类的构造方法； 调用父类的方法（子类覆盖了父类的方法时）； 访问父类的数据域（可以这样用但没有必要这样用）。 调用父类的构造方法语法： super(); 或 super(参数列表); 注意：super 语句必须是子类构造方法的第一条语句。不能在子类中使用父类构造方法名来调用父类构造方法。 父类的构造方法不被子类继承。调用父类的构造方法的唯一途径是使用 super 关键字，如果子类中没显式调用，则编译器自动将 super(); 作为子类构造方法的第一条语句。这会形成一个构造方法链。 静态方法中不能使用 super 关键字。 调用父类的方法语法： super.方法名(参数列表); 如果是继承的方法，是没有必要使用 super 来调用，直接即可调用。但如果子类覆盖或重写了父类的方法，则只有使用 super 才能在子类中调用父类中的被重写的方法。 4、this 关键字 this 关键字表示当前对象。可用于： 调用当前类的构造方法，并且必须是方法的第一条语句。如：this(); 调用默认构造方法。this(参数); 调用带参构造方法。 限定当前对象的数据域变量。一般用于方法内的局部变量与对象的数据域变量同名的情况。如 this.num = num。this.num 表示当前对象的数据域变量 num，而 num 表示方法中的局部变量。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—数组","slug":"Java笔记—数组","date":"2019-11-20T04:54:46.000Z","updated":"2019-11-29T17:36:21.566Z","comments":true,"path":"2019/11/20/Java笔记—数组/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/20/Java%E7%AC%94%E8%AE%B0%E2%80%94%E6%95%B0%E7%BB%84/","excerpt":"Java笔记——数组创建时间：2019.11.20 说明：持续更新ing ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 数组 数组是一组相同类型的变量（元素）的集合。可以用来存放一组相同类型的数据。数组的学习涉及数组的定义、赋值和使用。再扩展一点就是二维数组的应用。数组既是一种重要的数据类型，也是一种重要的数据结构。 数组（array）————一组相同类型的变量(元素)集合 相同的任意类型 (包括基本类型、类类型等) 这组变量被连续地存放在Java堆区的内存空间 数组是一种引用类型，数组名是一个地址的别名 数组需要创建（new），否则不会被分配堆空间 数组名对应的地址单元中存放上述连续堆区空间的首地址 🔺 对程序员而言, 数组总体有三样东西：数组名+数组长度+数组元素","text":"Java笔记——数组创建时间：2019.11.20 说明：持续更新ing ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 数组 数组是一组相同类型的变量（元素）的集合。可以用来存放一组相同类型的数据。数组的学习涉及数组的定义、赋值和使用。再扩展一点就是二维数组的应用。数组既是一种重要的数据类型，也是一种重要的数据结构。 数组（array）————一组相同类型的变量(元素)集合 相同的任意类型 (包括基本类型、类类型等) 这组变量被连续地存放在Java堆区的内存空间 数组是一种引用类型，数组名是一个地址的别名 数组需要创建（new），否则不会被分配堆空间 数组名对应的地址单元中存放上述连续堆区空间的首地址 🔺 对程序员而言, 数组总体有三样东西：数组名+数组长度+数组元素 “声明、创建、初始化、访问”数组 声明数组： 🔺只给数组变量(由数组名描述)分配空间，而不会给数组按要存放的元素的多少来分配空间。 有两种形式——&gt;推荐第一种： 数据类型[] 数组名 //数据类型[] 数组名 int[] a; //数据类型 数组名[] int a[]; ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 创建数组：用new运算符，同对象的创建。 有两种形式——&gt; //先声明，后创建 int[] a; //声明存放int型数据的数组a a = new int[10]; //在Java堆区中创建10个int型元素空间(共40个字节) //声明和创建合一 int[] test = new int[12]; 注意： 🔺声明数组，仅仅创建数组变量🔺创建数组，才在堆区中分配空间 [ ]中必须是非负整数，否则执行时异常。可以是字面常量、也可以是变量，只要保证其值是非负整数。 创建数组之后，各元素的默认初始值是：数值型为0(0.0)；字符型’\\0’；引用类型null；布尔型false ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 初始化数组：在创建好的数组元素空间中存放初始值.否则按默认值初始化。 🔺数组创建时（即new时使用）初始化器语法：{元素值列表}。 //声明存放int型数据的数组aMonth并初始化 int[] aMonth = new int[]{1,2,3,4,5,6,7,8,9,10,11,12}; 注意： 使用了初始化器之后不能显式指定长度 即 new int[12]{…} ，不对 int[] a; //先声明数组a a = new int[2]{1,2}; // Error,不能显式指明长度[2] a = {1,2}; // Error a = new int[]{1,2}; // OK! int[] b = {1, 2}; // OK!此方式用得最多 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 访问数组： 🔺数组元素：数组中的每一个变量，也被称为下标变量，索引变量 🔺下标从0开始：用[ ]运算符访问元素，即 数组名 [ 数组下标 ] 🔺既然是变量，所以数组元素可以作为左值也可以作为右值，比如a[i]++、b[0]=5;、a=b[0]+2;等等。 数组长度属性 🔺数组唯一的一个 只读 属性：length 存有数组元素个数值。 🔺*数组名.length * 遍历数组 🔺增强版for语句：foreach语句（JDK5开始提供） 🔺适用于遍历数组、集合元素等形式 for(元素的数据类型 遍历变量x : 遍历对象obj){ //x是自定义遍历变量名 引用了x的Java语句; //循环体 } 注意： foreach语句是for的简化,任何foreach语句都可以改用for语句，反之不行。 foreach语句不关注下标。 用foreach的遍历变量不能修改元素值。 public class Demo { public static void main(String[] args) { int[] a = {1, 3, 4, 5, 6, 8, 10}; /* 循环输出a */ for(int n : a){ // 利用变量n遍历数组a System.out.printf(\"%4d \", n); // n表示数组a的每一个元素值 } } } 二维数组、多维数组 Arrays 类 主要功能： 🔺java.util.Arrays类： 数组操作实用类,它提供了一系列静态方法 equals()方法:比较两个数组长度是否相同和对应索引上的元素值是否相同. fill()方法:向数组中填充数据. copyOf()方法:复制一个数组的部分元素并生成一个新的数组返回 sort()方法:若是基本类型则把数组元素按自然顺序升序排列.若是引用类型,其该实现了Comparable接口才能调用sort方法,否则报异常. binarySearch()方法:对已排序数组使用二分查找算法查找指定元素. asList()方法:返回数组的List对象形式. toString()方法:返回包含所有元素信息的字符串 parallelSort()方法:开启多线程的排序. deepEquals()方法:深度比较两个数组是否相同.适于任何深度的多维(嵌套)数组. 问：数组可以作为方法的参数或返回值吗？ 当然是可以的 。答案来源 m博客 数组作为方法参数 🔺数组作为方法参数传递，传递的参数是数组内存的地址。 public static void main(String[] args) { int[] arr = {11, 22, 33, 44, 55}; System.out.println(\"1位置: \" + arr); printArray(arr); // 数组作为方法参数传递，传递的参数是数组内存的地址 } public static void printArray(int[] arr) { System.out.println(\"2位置: \" + arr); for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); } } 1234567891011 数组作为方法返回值 🔺数组作为方法的返回值，返回的是数组的内存地址。 public static void main(String[] args) { //调用方法，接收数组的返回值 //接收到的是数组的内存地址 int[] arr = getArray(); for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); } } /* 创建方法，返回值是数组类型 return返回数组的地址 */ public static int[] getArray() { int[] arr = { 1, 3, 5, 7, 9 }; //返回数组的地址，返回到调用者 return arr; } 1234567891011121314151617 该博主的延伸阅读： Java–数组的定义和访问、Java–数组原理内存图、Java–数组的常见操作 判断： Java中数组可以动态改变长度？ 错误。 Java中的数组的定义就是相同类型，固定长度的一组数据，一旦被初始化，长度不可更改。 10. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"教会你怎么安装和使用 Visio 哦 ~ ~","slug":"Visio教程","date":"2019-11-19T01:34:04.000Z","updated":"2019-11-29T17:38:35.080Z","comments":true,"path":"2019/11/19/Visio教程/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/19/Visio%E6%95%99%E7%A8%8B/","excerpt":"前言 很多学生会在编程、设计或其他时候可能使用到【制图工具】。最好用的莫不过【微软的Visio】了。但是很多学生不会使用Visio，甚至不会安装Visio。 &gt; Visio 这么好的工具，一定要会用。 今天，作者写一份教程，教会大家了解如何安装和使用 ==Visio==。 在正式教程之前，我们先介绍 Visio。 Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。 &gt; Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。","text":"前言 很多学生会在编程、设计或其他时候可能使用到【制图工具】。最好用的莫不过【微软的Visio】了。但是很多学生不会使用Visio，甚至不会安装Visio。 &gt; Visio 这么好的工具，一定要会用。 今天，作者写一份教程，教会大家了解如何安装和使用 ==Visio==。 在正式教程之前，我们先介绍 Visio。 Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。 &gt; Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。 //截断文章 安装1. 【下载资源】 网上也有很多资源，但是包是不完整的。版本也很多，要激活也不容易。 作者在这里已经打包好“Visio 2019”和“激活工具”了，点击这里(提取码: rwtr)开始下载。 由于现在的笔记本都是预装win10的，所以不用担心Visio 2019合不合适。毕竟Visio 2019在win7上是安装不了的。2. 【解压】 下载得到压缩包，解压，打开文件夹。 3. 【打开Setup】 打开“Visio 2019”，右键“Setup”选中“以管理员身份运行”。（似乎不用管理员也行？？？） 4. 【正在安装】 等待就好，很快的。 5. 【安装完成】 安装结束，点击“关闭”。 6. 【激活】 Visio 2019是==必须激活==才可以使用的。 否则，会一直弹窗提示激活的。 激活工具在另一个文件夹里。 补充一些关于KMS： KMS（全称:Key Management Service），这个是微软的一种新型产品激活机制，目的是为了Microsoft更好的遏制非法软件授权行为(盗版)。 当然作者不提倡破解、或盗版。 对于有能力的人，还是支持正版。但是学生嘛，能用就好了。 使用激活工具前，作者建议： ==最好关闭杀毒软件，如果有的话。== 作者没安装360那些，很流畅地激活成功。 ==激活工具无毒的。不关闭的话，可能被误报。== 1).【打开】 界面如下： 这个激活工具还可以xxxxxx。（你懂的） 我啥都没说哦hh 2).【激活】 简单一按，等待激活成功就好。 补充：可能有的电脑打开软件时会提示这个。解决很简单，安装框架就好。 （1）打开“控制面板”。（2）找到并点击“程序和功能”项，在打开的页面中，点击“启用或关闭Windows功能”。（3）在打开的“Windows功能”对话框中，找到并勾选“Microsoft.Net Framework”服务，单击“确定”即可。 使用激活后，就可以安安心心、大大方方地使用 Visio 了。o(￣▽￣)o 【打开】 【新建】新建页面，有一些初始模板可以使用。一般选择“基本框图”就好，然后“新建”。 【制图】 左侧可以选择很多官方自带的形状，当然还可以自己建立自己的模型。 右侧可以对图形自定义，包括颜色、线条、端点等等。 结尾使用 Visio 来制图真的很爽。但是，如果只是临时制图使用 Visio ，还得安装确实不太方便。因此 作者还收藏了几个线上制图的网站，在这提供给大家临时使用。 1. https://www.draw.io/ 2. https://zh.numberempire.com/graphingcalculator.php 3. https://www.processon.com 4. 当然用电脑自带的【画图】也是可以的，你看。 emmm只是好难看啊hhhh。 这就是结尾：如果教程上有什么不足的或者有问题的，可以私信我。谢谢你的阅读！ 本博客第一次发表于【简书】： https://www.jianshu.com/p/32648bcc6f1c 。现转载到作者的网站上。谢谢阅读！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"百合","slug":"百日","date":"2019-11-16T12:54:59.000Z","updated":"2019-11-25T12:23:15.221Z","comments":true,"path":"2019/11/16/百日/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/16/%E7%99%BE%E6%97%A5/","excerpt":"2019.11.16 星期六 晴天","text":"2019.11.16 星期六 晴天 💙汪曾祺老人的散文《活着多好呀》中“活着多好呀”为汪老一句名言。这位老人不管遇到什么环境，永远不消沉沮丧，守护心中的热情与生机，兴致盎然地生活。💛时光机，这个世界不存在的理想物品。可是我多希望有这东西，真是可惜无法回到两三年前，“时间就是让人猝不及防的东西”……💜有段时间，喜欢黑暗安静的环境。肚子一个人发呆，内室里一个窗户也不开，杜绝所有来往。但已经走出来那段抑郁期，今后不知道，但是现在我挺好的。恍惚发现，最好掩盖哭的方式，除了偷偷一个人，就是洗澡的时候。💚或记日记或写随笔或向月亮倾诉或对空气说说，~生活不易，但也没那么糟糕。柏拉图说：没有什么比健康更快乐的了，虽然在他们生病之前并不曾觉得那是最大的快乐。💗“谢谢你的不告而别”。下辈子，我们再会 ! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"解除课程中心看视频时的“ 窗口获取焦点事件 ”","slug":"解除课程中心看视频时的“ 窗口获取焦点事件 ”","date":"2019-11-16T09:54:59.000Z","updated":"2019-11-23T02:16:39.416Z","comments":true,"path":"2019/11/16/解除课程中心看视频时的“ 窗口获取焦点事件 ”/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/16/%E8%A7%A3%E9%99%A4%E8%AF%BE%E7%A8%8B%E4%B8%AD%E5%BF%83%E7%9C%8B%E8%A7%86%E9%A2%91%E6%97%B6%E7%9A%84%E2%80%9C%20%E7%AA%97%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6%20%E2%80%9D/","excerpt":"前言前段时间，在观看课程中心的马克思视频，因为要至少看到80%以上。 发现那我挂着刷不就得了？偏偏。。。。。 发现这个课程中心存在某个机制——一定要使视频一直处于“置顶”的状态，否者会自动暂停视频。","text":"前言前段时间，在观看课程中心的马克思视频，因为要至少看到80%以上。 发现那我挂着刷不就得了？偏偏。。。。。 发现这个课程中心存在某个机制——一定要使视频一直处于“置顶”的状态，否者会自动暂停视频。 //截断文章 就像下图这样： 操作鼠标前——&gt; 操作鼠标后——&gt; 你会注意到，视频的播放状态跟鼠标的行为有关，准确来说是==和鼠标点击的位置（焦点）有关==。 第一时间想到“这不就是windows的“窗口获取焦点”吗？ 补充先补充补充什么是窗口获取焦点？ 在你浏览其他窗口页面、或是浏览器最小化、又或是点击了程序窗口时，等等都算是浏览器窗口失去焦点，这时候 window.onblur 事件就会触发。 当然，当你的页面获得焦点的时候一样也会触发window.onfocus。 应该有人会注意到过，当你点击不同窗口时，窗口栏会有不同的颜色反馈，就比如win 10的资源管理器，前置窗口和后置窗口的窗口颜色是不是不一样？ 寻找直接按下F12，打开控制台，查看Elements…… emmmmmm结果，没找到对应的代码（或许我没仔细去挖hh） 再试那我直接Console。不就是当前窗口获取了焦点吗？？？？直接暴力敲下代码，并Enter，嘿嘿…… javascript:window.onblur=null;void 0 //有无`void 0`，都可以 当我Enter时，诶，成功了hhh效果就是这样。 后续测试了一段时间后，成功率基本达97%左右。后来就分享到班群，让更多人试试效果。两天刷完所有马克思的视频哈哈有木有？ 建议 一次最多同时两个视频在看，因为后台有个计时器再加上我不会写自动播放、自动静音的脚本hhhhh（有时间再去琢磨哈） 一旦刷新页面，就得重新Enter脚本 极小几率会失败，原因我也不清楚，失败重新Enter即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://melodyjerry.github.io/blog/tags/%E8%84%9A%E6%9C%AC/"}]},{"title":"Java笔记—对象、类","slug":"Java笔记—对象、类","date":"2019-11-15T04:54:59.000Z","updated":"2019-11-30T10:18:12.578Z","comments":true,"path":"2019/11/15/Java笔记—对象、类/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/15/Java%E7%AC%94%E8%AE%B0%E2%80%94%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB/","excerpt":"Java笔记——对象、类创建时间：2019.11.11 说明：持续更新ing 对象和类的概念。 对象：对象是类的一个实例（实实在在存在的个体），有属性（状态）和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 属性(property)： 静态特征行为(behavior)： 动态特征 类：类是对现实生活中事物的描述。类是一个模板，它描述一类对象的行为和状态。同种类型对象共性的抽象","text":"Java笔记——对象、类创建时间：2019.11.11 说明：持续更新ing 对象和类的概念。 对象：对象是类的一个实例（实实在在存在的个体），有属性（状态）和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 属性(property)： 静态特征行为(behavior)： 动态特征 类：类是对现实生活中事物的描述。类是一个模板，它描述一类对象的行为和状态。同种类型对象共性的抽象 用老师的话来说，就是下面这样——&gt; 下图中男孩（boy）、女孩（girl）为类（class），而具体的每个人为该类的对象（object）： 【定义类】 Java中的类 类可以看成是创建Java对象的模板。 通过下面一个简单的类来理解下Java中类的定义： public class Student { int id; String name; double score1, score2, score3; public Student(int id, String name) { this.id = id; this.name = name; } public double getAverageScore() { return (score1 ＋ score2 + score3) / 3; } } 一个类可以包含以下类型变量： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。一个类可以拥有多个方法。 Java中的对象现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。对比现实对象和软件对象，它们之间十分相似。 软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 创建对象——&gt; /*有两种基本形式*/ /*1.对象声明和创建*/ 类名 对象名 = new 类名(); Student xiaoming = new Student (); /*2.先声明,后创建*/ 类名 对象名; // 类(对象)变量 对象名 = new 类名(); //实例化 Student xiaobai ; xiaobai = new Student(); 类和对象的关系：类是具有相同==属性和方法==的集合，是对对象的抽象描述。 现实生活中的对象：张三、李四。 【想要描述】提取对象中的共性内容。对具体的抽象。 【描述时】这些对象的共性有：姓名、学号、年龄、性别、学习Java等等。（即定义类：描述事物的属性和行为，就是在定义属性和行为。属性和行为共同成为类中的成员（成员变量和成员方法）。） 映射到Java中，描述就是class定义的类，具体对象就是new建立的实体。 这些描述在Java当中是用类的形式来体现的。而对象是通过Java的new操作符所产生的一个实体，这个的实体存在于==堆内存==当中。 //定义类，就是描述事物，就是在定义属性和行为。属性和行为共同成为类中的成员（成员变量和成员方法）。 //需求：描述车汽车（颜色，轮胎数）。 class Car { //描述颜色 String color = \"red\"; //描述轮胎数 int num = 4; //运行行为。 void run() { System.out.println(color+\"..\"+num); } } class CarDemo { public static void main(String[] args){ //生产汽车：在Java中通过new操作符来完成。 //其实就是在堆内存中产生一个实体。 Car c = new Car(); //c就是一个【类类型】变量。记住：类类型变量只想对象。 //需求：将已有车的颜色的颜色改成蓝色。指定该对象做使用。 //在Java指挥方式是：【对象.对象成员】 c.color = \"blue\"; //需求：想要车运行起来。 c.run(); } } Car c = new Car();在内存中的示意图——&gt; c.run();——&gt;输出这个车的颜色“蓝色”和轮胎数“4”。 (1)倘若在c.run();后加入Car c1=new Car();c1.run();——&gt; (2)若main的代码块改为： class CarDemo { public static void main(String[] args){ Car c = new Car(); c.num = 5; Car c1 = c; c1.color = \"green\"; c.run(); } } 在内存中的示意图——&gt; 对对象调用的基本概念：用new建立对象，在堆内存中产生对象。那么对象的特点在于封装数据，数据包含属性和行为。想要操作对象中的内容就指挥对象做事，指挥哪个对象要明确，操作什么也要明确，用对象.xyz的形式就能完成。 【注意】：如下图， 以前定义在函数里面，现在定义在函数外面 【方法】 方法的定义： 方法是类或对象的行为特征的抽象。 Java中的方法不能独立存在，所有的方法必须定义在类中。 使用 “类名.方法” 或 “对象.方法” 的形式调用。 语法格式： 权限修饰符 返回值类型 方法名（参数类型 参数名1,参数类型 参数名2,...） { // 方法体 方法语句序列//当返回类型非void时,最后一条被执行语句必须是return语句,返回对应类型的值 } 访问权限/权限修饰符（4P权限）： 访问权限 类内 包层内 子类 包层外 public √ √ √ √ protected √ √ √ × package （缺省） √ √ × × private √ × × × return语句： 结束方法调用，并返回值。 return 表达式; return; 🔺方法被调用时,执行到方法内的return语句,则不论方法里是否还有语句未执行,立即结束方法的调用,并将return 后的表达式的值返回方法调用者🔺利用return 语句返回值，仅能返回一个值🔺return语句仅结束方法的执行 🔺void型方法 方法分类： 无参数无返回值 有参数无返回值 无参数有返回值 有参数有返回值 public class Method { public void aMethod() { System.out.println(\"无参数无返回值的方法\"); } public void bMethod(int b) { System.out.println(\"有参数无返回值的方法\"); } public int cMethod() { System.out.println(\"无参数有返回值的方法\"); return 10; } public int dMethod(int d) { System.out.println(\"有参数有返回值的方法\"); return d; } public static void main(String[] args) { int ret; // 创建Method类的对象 Method md = new Method(); // 通过对象.方法调用 md.aMethod(); md.bMethod(10); ret = md.cMethod(); ret = md.dMethod(10); System.out.println(ret); } } 方法的参数： 方法可以没有参数，或者有多个参数，参数类型可以是任意类型 方法参数也是局部变量 参数为引用数据类型4时： 当对象实例作为参数传递给方法时，传递的是对象的引用，为地址传递，接受参数的方法可以改变参数的值。 参数为简单数据类型时： 传递的是参数的副本，为值传递，接受参数的方法中不会改变参数的值。 public class MethodParam { /** * 方法的参数为基本数据类型时，传递的是值的副本（值拷贝） * 方法中不会改变元参数的值 */ public void swap(int a, int b) {//a, b为形参 int tmp; tmp = a; a = b; b = tmp; } int x = 100, y = 200; /** * 方法的参数为引用数据类型时，传递的对象的引用（传地址） * 方法中可以改变参数的值 */ public void swap2(MethodParam mp) { int tmp = mp.x; mp.x = mp.y; mp.y = tmp; } public static void main(String[] args) { MethodParam mp = new MethodParam(); int m = 10, n = 20; System.out.println(\"交换前：a = \"+m+\",b = \"+n); mp.swap(m, n);// m,n为实参 System.out.println(\"交换后：a = \"+m+\",b = \"+n); System.out.println(\"交换前：x = \"+mp.x+\",y = \"+mp.y); mp.swap2(mp); System.out.println(\"交换后：x = \"+mp.x+\",y = \"+mp.y); } } 普通方法调用——&gt; 成员方法和成员变量的关系——&gt; 【成员方法】和【构造方法】 【成员方法】 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【构造方法】 构造方法需满足以下三个条件 ： 1、方法名与类名同名 2、在方法中不能使用 return 语句，即无返回值 3、在方法名的前面*没有返回值的类型声明 * （有看到“ 构造方法无返回值也不可以加void，但其实返回的是首地址 ”这话还得去证实，先放在这里） ==老师推荐==：显式无参构造子,作为一种良好实践,定义了其他构造子，那就准备一个无参构造子 package me; public class Me { private String name; //成员变量 public Me(String name){ //构造方法 this.name = name; } public String getName() { //成员方法 return name; } public void setName(String name) {//成员方法 this.name = name; } } 我如果我在添加一age 如下 添加方法依然是成员方法 , package me; public class Me { private String name; //成员变量 private String age; //成员变量 public Me(String name){ //构造方法 this.name = name; } public String getName() { //成员方法 return name; } public void setName(String name) {//成员方法 this.name = name; } public String getAge() {//成员方法 return age; } public void setAge(String age) {//成员方法 this.age = age; } } 个人理解：无论多少方法，==除了构造方法外，其余都是成员方法==，当然这样理解可能有点偏见.. 它们的区别： 构造方法一般是给对象的数据进行初始化,没有返回值 成员方法一般实现对类中成员变量的操作，提供某些功能,有返回类型，可以为void类型 成员方法与构造方法调用的区别 package me; public class Book { public static void main(String[] args) { Me me = new Me(\"张三\");//构造方法调用 System.out.println(me); me.setName(\"李四\");//成员方法调用 System.out.println(me.getName()); } } 从上面的demo中可以看出，==构造方法通过new运算符调用==，==成员方法通过对象调用==。 注意：类中除了构造方法以外的方法都是成员方法。原因是在类中，除了变量外的基本都是成员方法。 ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【this 关键字】 https://i.loli.net/2019/11/16/49d7AMODXhKbsuy.png ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【重载构造方法之间的调用】 【含对象成员的构造方法调用】 【无继承情况下的对象初始化顺序】 【创建对象】 对象是根据类创建的。在Java中，使用关键字new 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 下面是一个创建对象的例子： public class Puppy{ public Puppy(String name){ //这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public static void main(String[] args){ // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( \"tommy\" ); } } 编译并运行上面的程序，会打印出下面的结果： 小狗的名字是 : tommy ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【访问实例变量和方法】 通过已创建的对象来访问成员变量和成员方法，如下所示： /* 实例化对象 */ Object referenceVariable = new Constructor(); /* 访问类中的变量 */ referenceVariable.variableName; /* 访问类中的方法 */ referenceVariable.methodName(); ——————————————————————————— 我 是 分 割 线 ———————————————————————————— 【访问实例变量】和【调用成员方法】： public class Puppy{ int puppyAge; public Puppy(String name){ // 这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public void setAge( int age ){ puppyAge = age; } public int getAge( ){ System.out.println(\"小狗的年龄为 : \" + puppyAge ); return puppyAge; } public static void main(String[] args){ /* 创建对象 */ Puppy myPuppy = new Puppy( \"tommy\" ); /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println(\"变量值 : \" + myPuppy.puppyAge ); } } 编译并运行上面的程序，产生如下结果： 小狗的名字是 : tommy 小狗的年龄为 : 2 变量值 : 2 【方法重载，重构，覆盖，重写的区别】 方法重载还是比较好理解的，就是在类的内部，定义多个方法，这些方法的方法名字相同，参数类型、参数顺序、参数个数不同，注意，返回值类型并不能区分重载 。 public void show(int a,double b){ } public void show(double c){ } public int show(double d){ return 1; } //报错，方法已经定义了 方法重写（override)方法重写和方法覆盖都是一个道理，发生在子类继承父类或者实现接口的类，要求的是： 1.方法名字相同，2.参数个数不同，3.返回值类型不同 ， 代码： 方法重构 定义：在不改变外界外界访问的情况下对代码进行修改，但是不改变原方法的效果，提高其性能，使程序更加易读，可维护。重构是在不改变软件可观察行为的前提下改善其内部结构重构通常不是一次性的，它贯穿软件的整个生命周期，只要觉得不合理都是重构的时机。 题目：下面说法中，错误的有（ ） ​ A. Java面向对象语言容许单独的过程与函数存在； ​ B. Java面向对象语言容许单独的方法存在； ​ C. Java语言中的方法属于类中的成员（member）； ​ D. Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同。 答案：ABC 解释： 方法与函数：这两个概念不严格区分，就是一个东西，通过对象调用的，就是方法，直接调用，就是函数； 在java中，everything is object 所以，方法，函数，必须隶属于某一个类或对象， java中没有过程。（类中的代码块不知道算不算，就算代码块是过程，也是必须在类中才有的） 对于C选项，方法分为静态方法和非静态方法，静态方法属于类成员，非静态方法属于实例成员。 类其实一种类型，它封装了数据和操作。 对象是类的实例 一个对象比属于某个类 一个类可以声明多个对象 问：构造方法可以调用本类的其他方法吗？ 1,构造方法可以调用本类的其他方法。既然可以调用本类的属性,那么也就可以调用属于本类的其他方法。 2,需要注意的是,如果要在构造方法里调用一个非静态方法时,应该将该方法声明为private。因为如果这个类被其他类继承成为父类时,这个方法不是private的又被子类所重载，这样在实际创建子类的过程中递归调用到了父类的构造器时，父类构造器对这个方法的调用就会由于多态而实际上调用了子类的方法，当这个子类方法需要用到子类中实例变量1的时候，就会由于变量没有初始化而出现异常（子类中的实例变量没有初始化这种情况还是会遇见的），这是Java不想看到的情况。 一个类的构造方法有多个，在其他类中是否可以被调用？ 只要不是私有的构造函数，在其他类中就可以调用。 传对应的参数就行了 。 class` `A{ ``public` `A(String s){} ``public` `A(``int` `n){} ``public` `A(String s, ``int` `n){} } class` `B{ ``A a1 = ``new` `A(``\"abc\"``); ``A a2 = ``new` `A(``1``); ``A a3 = ``new` `A(``\"aaa\"``,``2``); } 类是一种引用类型。 Java的引用类型只有三种，分别是 类(class) 接口(interface) 数组 参考资料 问：方法一定是在类内部被定义的？ 所有方法必须写在类体里，也包括构造方法2的。 static方法同样属于类，叫类方法或静态方法，它与类一同被加载时，处于内存的公共代码区中，无需创建实例来调用，只需用类名引用即可。 static方法既可以通过类名来调用，也可以通过类的实例调用。 Java一切都是以类的形式存在，方法是类的一部分，需要通过类才能进行方法的调用。 从内存存储角度来说，java中找对应方法时，都是先找对应类实例，类实例是根据类来初始化内存的。如果方法在类外部，则无法找到该方法。 所以方法必须在类体里。 注意： 可以在其他类里使用这个类的方法（在不同的包下就要引ltem这个类），继承就是一个类从另一个类继承通过关键字extends 来实现 问：构造方法中可不可以有return语句呢? （这个解释有问题？）可以。而是我们写成这个样子就OK了：return; 其实，在任何的void类型的方法的最后你都可以写上：return; 问：非构造方法的一般成员方法必须有return语句？ 错。 （待补充……） 问：类中的数据成员可以按需选择任意类型，包括类本身？ 可以。可以参考下图，图源于陈三千的博客 问：Java中构造函数的权限可以是private吗？ 可以，这个类就不能再外部被new了，如果需要这个类的实例化对象，就只能在类内部提供静态方法生产这个类的对象了。 问：构造方法能不能被重载，构造方法能不能被重写？ 在回答这两个问题之前，首先先回顾：什么是构造方法？构造方法的特点是什么？ 概述：构造方法存在于类中，给对象数据（属性）初始化； 特点：方法名与类名一样；无返回值无void; 默认构造方法：我们不创建一个构造方法时，系统默认提供一个无参构造；当我们创建一个构造方法时，系统不再提供无参构造，所以在实际项目中，全部手动给出无参构造 其次\\什么是重载？什么是重写？** 重载：存在于在一个类中，方法名相同，方法参数的类型或个数不同 重写：存在于子父类中，方法名、方法参数、返回值全部相同 所以：构造方法可以重载，不能重写 在一个类中，可以有多个构造方法（方法参数不同） ，即重载，来实现对象属性不同的初始化； 但是子类中不能定义一个方法无void无返回值的方法，编译错误，即子类无法继承构造方法，但是子类的构造器中可以调用父类的构造方法（默认自动调用无参构造） 注意：回答来源于 CSDN博客 Java中可以定义一个空类（即没有数据成员和成员方法） 。 问： 下面这个类有几个构造方法？ class A{} 1个。（待补充……） 问：Java 类可以作为（ C ） A．类型定义机制 B．数据封装机制 C．类型定义机制和数据封装机制 D．上述都不对 用于定义类头的修饰符可以是public、abstract、final或者是默认(friendly) 题目：下列说法错误的有（ CD ） A． 在类方法中可用this来调用本类的类方法B． 在类方法中调用本类的类方法时可直接调用 C． 在类方法中只能调用本类中的类方法 D． 在类方法中绝对不能调用实例方法 C：类方法可以调用外部其他类的方法。D：只要实力化对象，也是可以调用实例方法的。 判断： 只有基本类型的参数传递使用值传递。 错误。 引用类型参数的传递，依然是值传递。但因为是地址值，所以会指向同一个对象实例。 Java中方法的参数传递是值传递（pass by value），并且为单向传递。 《Java 变量参数传入方法，修改后是否影响外面的值》。参考 博客 《某个变量当作函数的参数传递后，函数内部修改了。到底这个变量是否受影响》。参考 博客 问：类设计get方法和set方法的作用是什么？ 答1：一般类的成员变量被设置为private（私有的），这样设置安全性比较高，但是设置为私有的后其他的类和对象则无法调用该对象了，所以会有get和set方法，这两个方法一般设置为public，在其他的类中通过对象调用set或get方法即可操作私有的变量，增强程序的安全性，set为给对象赋值的方法，而get则是取得变量值的方法！ 答2：get set常用在自定义类，类创建了一个实例对象后，用set设置对象的某一个属性，get得到对象某一属性。如果不使用get set，你就得用点，点出来还得是个方法。其实就是给get set换个名而已。而且get set作为内部方法，可以访问私有数据 答3：别说的那么专业化了，理解都要半天。就这么理解吧，面向对象中，想对类的成员变量设置访问一些权限，于是，就将该字段设置为private的，这样别的类就不能访问了，然后在该内定义两个方法，一个专门用于获取，一个用于修改，这样，在你不想让别人乱动该字段的时候，就在该方法内写一些限制条件。而为了规范起见（团队开发需要嘛），就根据人家老外的习惯，将方法名设置为set+字段名，get+字段名（名字乱改没问题），既然规范了，那就是别人都叫这名了，于是，有些框架给对象赋值就有方法了，方法名称由get或set开始的又有private变量名的，就找出来调用。hibernate1框架就这样弄得，至于后面的版本是不是这样就不大清楚了。JavaBean就是一个JAVA类，既然是JAVA类就不需要什么组件了，这玩意直接深入到虚拟机了的 Java的包装类： 【包装类的概念】 【Integer类的用法】 【自动装箱机制和自动拆箱机制】 匿名对象： 使用方法： 当对对象的方法只调用一次，可以使用匿名对象来完成，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。 可以将匿名对象作为实际参数进行传递。 注脚：1.实例变量（全局变量）、成员变量、实例变量、属性 ↩2.java的构造方法、java的构造方法、Java入门：构造方法 ↩3.来创建一个新的对象。创建对象需要以下三步： ↩3.java之new的用处 ↩4.JAVA中基本数据类型和引用数据类型区别 ↩ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—面向对象","slug":"Java笔记—面向对象","date":"2019-11-13T04:54:46.000Z","updated":"2019-11-29T17:35:40.535Z","comments":true,"path":"2019/11/13/Java笔记—面向对象/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/13/Java%E7%AC%94%E8%AE%B0%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"Java笔记——面向对象创建时间：2019.11.11 说明：持续更新ing Java作为一种面向对象语言。支持以下基本概念： 多态 | 继承 | 封装 | 抽象 类 | 对象 | 实例 | 方法 | 重载 “面向对象”和“面向过程”的区别： 面向过程：如 C/C++ 例子：冰箱装大象。1、打开冰箱门；2、放进大象；3、关上冰箱门。强调过程，“打开”、“存储”、“关闭”三个动作。注重过程，注重的是过程涉及的行为（即功能）。 面向对象：如 Java 将功能封装进对象，强调具备了功能的对象。 面向对象是基于面向过程的。","text":"Java笔记——面向对象创建时间：2019.11.11 说明：持续更新ing Java作为一种面向对象语言。支持以下基本概念： 多态 | 继承 | 封装 | 抽象 类 | 对象 | 实例 | 方法 | 重载 “面向对象”和“面向过程”的区别： 面向过程：如 C/C++ 例子：冰箱装大象。1、打开冰箱门；2、放进大象；3、关上冰箱门。强调过程，“打开”、“存储”、“关闭”三个动作。注重过程，注重的是过程涉及的行为（即功能）。 面向对象：如 Java 将功能封装进对象，强调具备了功能的对象。 面向对象是基于面向过程的。 使用不同思想，对“冰箱装大象”的理解——&gt; 问：“人开冰箱”事件，其中人、冰箱都是实物（对象），开是动作。若使用面向对象思维，“开”的这个动作是属于“人”还是属于“冰箱”？ 答：属于“冰箱”，“人”只是调用了“冰箱”的“开”的方法（或功能），用力作用了门一下并将门打开了。 人开门：名词提炼法。 /* 人{ 开门（门）{ 门.开（）; } } 门{ 开（）{ 操作门轴; ……等等; } } */ 面向对象的三个特征：封装、继承、多态。 以后开发：其实就是找对象使用，没有对象就创建一个对象。 找对象，建立对象，使用对象，维护对象的关系。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Java笔记—语法","slug":"Java笔记—语法","date":"2019-11-13T04:54:20.000Z","updated":"2019-11-29T17:36:18.031Z","comments":true,"path":"2019/11/13/Java笔记—语法/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/13/Java%E7%AC%94%E8%AE%B0%E2%80%94%E8%AF%AD%E6%B3%95/","excerpt":"Java笔记——语法创建时间：2019.11.11说明：持续更新ing 单引号’’中存放一个字符，不能存放字符串。双引号””中存放字符串。 Java是强类型语言。对于每一种数据都定义了明确的具体数据类型，在内存中总分配了不同的内存空间。 布尔型常量只有2个值：true、false 标识符由字母：26个，大小写；数字：0- 8；符号：$ _ 组成。 标识符不能数字开头、不能使用关键字 main不是关键字，但是是被JVM识别的名字，是程序的入口 Java中的名称规范： 包名：多单词组成，全为小写 xxxyyyy 类名接口： 多单词组成，所有单词的首字母大写 XxxYyyZzz 变量名和函数名：多单词组成时，第一个单词的首字母小写，其余首字母大写 xxxYyyZzz 常量名：所有字母都大写。每个单词用_隔开 XXX_YYY_ZZZ","text":"Java笔记——语法创建时间：2019.11.11说明：持续更新ing 单引号’’中存放一个字符，不能存放字符串。双引号””中存放字符串。 Java是强类型语言。对于每一种数据都定义了明确的具体数据类型，在内存中总分配了不同的内存空间。 布尔型常量只有2个值：true、false 标识符由字母：26个，大小写；数字：0- 8；符号：$ _ 组成。 标识符不能数字开头、不能使用关键字 main不是关键字，但是是被JVM识别的名字，是程序的入口 Java中的名称规范： 包名：多单词组成，全为小写 xxxyyyy 类名接口： 多单词组成，所有单词的首字母大写 XxxYyyZzz 变量名和函数名：多单词组成时，第一个单词的首字母小写，其余首字母大写 xxxYyyZzz 常量名：所有字母都大写。每个单词用_隔开 XXX_YYY_ZZZ //截断文章 注释，写在代码前面 对于整数：Java有三种表现形式。· 十进制：0-9，满10进1· 八进制：0-7，满8进1，用0开头表示· 十六进制：0-9，A-F或a-f（A\\a是10，B\\b是11…F\\f是15），满16进1，用0x开头表示 null常量：只有一个值null。在对象、引用数据类型时会用上。 二进制。一个字节8位0、1组合。 八进制：3位二进制位代表1位八进制位；十六进制：4位二进制位代表1位十六进制位。进制转换：进制越大，表示越短，更方便地表示数据。 二进制计算：5 + 4 = 9 负数地二进制表现形式：对应的整数二进制取反加1。负数的最高位都是1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"博客v1.4上线","slug":"博客v1.4","date":"2019-11-08T14:30:21.000Z","updated":"2019-11-29T17:39:13.419Z","comments":true,"path":"2019/11/08/博客v1.4/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/08/%E5%8D%9A%E5%AE%A2v1.4/","excerpt":"搞了半天时间，优化一些模板上的问题后，新博客1.4版本上线了","text":"搞了半天时间，优化一些模板上的问题后，新博客1.4版本上线了 //截断文章 新增 主页动画，点击体验效果（这里） 文字跳动（menu、head中的文字均可跳动）,比如顶部的“你用走，可是我用跑”…… 新增Valine评论（可以使用表情；发送前浏览）。想用别的，但是暂时先着Valine。可以试着来骚扰我（滑稽~~ 有评论，邮件提示(还未测试)。接入Leancloud（文档）。 底部开启鼠标滑动渲染 开启“一言”api。menu中作者名（Melody Jerry）下面随机显示一句话。同时，使用文字扭曲动画。 修复 1.重写三个按钮（menu、搜索、回到顶部）的代码，现在可以正常使用了。 更新menu的Github的url 修复移动端提示证书错误的问题（移动端重定向太多次了，难怪hhh） 主页和首页分仓（也不算是修复，不知道写哪而已） 已知问题（加粗的为重要问题） menu中的“分类”、“标签”、“关于”，仍然无法正常使用（原因未知） menu的Email仍旧无法mailto 文章增加标签或类名，无法被tags或categories绑定 浏览人数、浏览次数，无法使用（接口有问题？） 文字截断，异常。（原因位置） 等待发现 未来加入 音乐控件（自动？手动？浮窗？嵌入？音源线上还是本地？） 实时颜色 加载网页时、侧栏、搜索、进度条等动画 留言板？ 友情链接？快速导航？ 嵌入播放（这个很想要，链接一些学习视频） 天气控件 等待脑洞大开 最后从早上9点搞到下午4点，午饭还没吃hh，就一直坐在电脑前。找模板中的问题代码、修改代码，还是很麻烦的。最后分享一首今天网易日推的英文歌（版权原因，没法生成外联播放器）I’ll Be There-Jess Glynne对于我的博客有问题或建议，欢迎在评论或邮件中告诉我。谢谢每一位读者。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"多图片滚动测试","slug":"多图片滚动测试","date":"2019-11-07T23:10:13.000Z","updated":"2019-12-01T06:31:24.901Z","comments":true,"path":"2019/11/08/多图片滚动测试/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/08/%E5%A4%9A%E5%9B%BE%E7%89%87%E6%BB%9A%E5%8A%A8%E6%B5%8B%E8%AF%95/","excerpt":"","text":"无缝滚动 *{margin: 0;padding: 0;} #div1{position: relative;border:1px solid #0ff;width:800px; height: 180px;margin:50px auto 0;overflow: hidden;} /* 修改容器规模 */ #div1 ul{position: absolute;left: 0;} #div1 ul li{list-style: none;width:200px;float: left;padding: 10px;height: 160px;} #div1 ul li img{width:100%;} window.onload=function(){ var oDiv=document.getElementById('div1'); var oUl=oDiv.getElementsByTagName('ul')[0]; var aLi=oUl.getElementsByTagName('li'); var aA=document.getElementsByTagName('a');//获取向右向左的箭头 var timer=null; var iSpeed=10; oUl.innerHTML+=oUl.innerHTML;//定义图片可以循环播放 oUl.style.width=aLi.length*aLi[0].offsetWidth+'px';//定义外层ul的宽度，根据图片的个数和每个图片的宽度计算，保证总宽度是可调整的 function fnMove(){ if(oUl.offsetLeft0){ oUl.style.left=-oUl.offsetWidth/2+'px'; }//定义到边界的时候，实现无缝衔接 oUl.style.left=oUl.offsetLeft+iSpeed+'px'; //定义图片的右边距随着速度不断不断增加，或减小，实现运动的效果 } timer=setInterval(fnMove,30); aA[0].onclick=function(){ iSpeed=-10; //按下左箭头，定义向左运动 } aA[1].onclick=function(){ iSpeed=10; //按下右箭头，定义向右运动 } oDiv.onmouseover=function(){ clearInterval(timer); //鼠标移动到图片上，清除定时器，停止运动 } oDiv.onmouseout=function(){ timer=setInterval(fnMove,30); //鼠标移出，重新开启定时器，重新运动 } }; ←→！！！方向选择按钮异常！！！L2Dwidget.init({\"model\":{\"jsonPath\":\"/blog/live2dw/assets/assets/haruto.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"tagMode\":false,\"debug\":false,\"mobile\":{\"show\":true},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\"}); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"网页视频测试","slug":"网页视频测试","date":"2019-11-07T16:00:00.000Z","updated":"2020-02-20T09:46:04.960Z","comments":true,"path":"2019/11/08/网页视频测试/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/08/%E7%BD%91%E9%A1%B5%E8%A7%86%E9%A2%91%E6%B5%8B%E8%AF%95/","excerpt":"浏览测试效果👇","text":"浏览测试效果👇 video大窗口 video小窗口 embed窗口 iframe窗口 测试完毕 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]},{"title":"博客文章太长？截断！","slug":"文章截断","date":"2019-11-06T08:49:56.000Z","updated":"2020-01-04T01:51:09.574Z","comments":true,"path":"2019/11/06/文章截断/","link":"","permalink":"https://melodyjerry.github.io/blog/2019/11/06/%E6%96%87%E7%AB%A0%E6%88%AA%E6%96%AD/","excerpt":"写的md文章太长，担心放到首页上浏览效果不好，怎么办？ 那就直接截断文章。 截断按钮文字不是通过配置文件_config.yml实现的，而是在文章内容里实现。 只要在需要被截断的文章位置加上： &lt;!-- more --&gt; 就可以了！ 效果就像下面的这个按钮 可以点点看哦👇","text":"写的md文章太长，担心放到首页上浏览效果不好，怎么办？ 那就直接截断文章。 截断按钮文字不是通过配置文件_config.yml实现的，而是在文章内容里实现。 只要在需要被截断的文章位置加上： &lt;!-- more --&gt; 就可以了！ 效果就像下面的这个按钮 可以点点看哦👇 插入测试代码 （无任何作用、意义，仅提供该页面测试用） javascript:window.onblur=null;void 0; //all var open_all_chapter = document.getElementsByClassName(\"fold_chapter\"); for (var i = 1; i &lt; open_all_chapter.length; i++) { open_all_chapter[i].click() } //each var chapters = document.getElementsByClassName(\"rate_box\"); var count = 0; chapters[++count].click(); setInterval(() =&gt; { // var playButton = document.getElementById(\"div_play_wrapper\"); // if (playButton) { // playButton.click(); // } var TC = document.getElementsByClassName(\"layui-layer-close1\"); if (TC.length &gt; 0) { console.log(\"检测到弹窗\"); TC[0].click(); } console.log(\"正在\" + count + \"个\"); var isFinish = chapters[count].getElementsByClassName(\"round_complete\"); if (isFinish.length &gt; 0) { chapters[++count].click() console.log(\"进入下\"); if(chapters[count].className===\"rate_box\"){ chapters[++count].click() } } }, 5000); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"}]}],"categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"https://melodyjerry.github.io/blog/categories/uncategorized/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://melodyjerry.github.io/blog/tags/IDEA/"},{"name":"SPringBoot","slug":"SPringBoot","permalink":"https://melodyjerry.github.io/blog/tags/SPringBoot/"},{"name":"小技巧","slug":"小技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"工具","slug":"工具","permalink":"https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"开发","slug":"开发","permalink":"https://melodyjerry.github.io/blog/tags/%E5%BC%80%E5%8F%91/"},{"name":"SSM","slug":"SSM","permalink":"https://melodyjerry.github.io/blog/tags/SSM/"},{"name":"笔记","slug":"笔记","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://melodyjerry.github.io/blog/tags/JavaWeb/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://melodyjerry.github.io/blog/tags/SpringBoot/"},{"name":"Linux","slug":"Linux","permalink":"https://melodyjerry.github.io/blog/tags/Linux/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://melodyjerry.github.io/blog/tags/JavaScript/"},{"name":"API","slug":"API","permalink":"https://melodyjerry.github.io/blog/tags/API/"},{"name":"Hexo","slug":"Hexo","permalink":"https://melodyjerry.github.io/blog/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://melodyjerry.github.io/blog/tags/GitHub/"},{"name":"博客","slug":"博客","permalink":"https://melodyjerry.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Java","slug":"Java","permalink":"https://melodyjerry.github.io/blog/tags/Java/"},{"name":"服务器","slug":"服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Git","slug":"Git","permalink":"https://melodyjerry.github.io/blog/tags/Git/"},{"name":"Maven","slug":"Maven","permalink":"https://melodyjerry.github.io/blog/tags/Maven/"},{"name":"SVN","slug":"SVN","permalink":"https://melodyjerry.github.io/blog/tags/SVN/"},{"name":"CSS","slug":"CSS","permalink":"https://melodyjerry.github.io/blog/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://melodyjerry.github.io/blog/tags/HTML/"},{"name":"JQuery","slug":"JQuery","permalink":"https://melodyjerry.github.io/blog/tags/JQuery/"},{"name":"Web","slug":"Web","permalink":"https://melodyjerry.github.io/blog/tags/Web/"},{"name":"Java web","slug":"Java-web","permalink":"https://melodyjerry.github.io/blog/tags/Java-web/"},{"name":"MySQL","slug":"MySQL","permalink":"https://melodyjerry.github.io/blog/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"https://melodyjerry.github.io/blog/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"算法","slug":"算法","permalink":"https://melodyjerry.github.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"java","slug":"java","permalink":"https://melodyjerry.github.io/blog/tags/java/"},{"name":"Docker","slug":"Docker","permalink":"https://melodyjerry.github.io/blog/tags/Docker/"},{"name":"宝塔","slug":"宝塔","permalink":"https://melodyjerry.github.io/blog/tags/%E5%AE%9D%E5%A1%94/"},{"name":"技巧","slug":"技巧","permalink":"https://melodyjerry.github.io/blog/tags/%E6%8A%80%E5%B7%A7/"},{"name":"Github","slug":"Github","permalink":"https://melodyjerry.github.io/blog/tags/Github/"},{"name":"HTTP","slug":"HTTP","permalink":"https://melodyjerry.github.io/blog/tags/HTTP/"},{"name":"MVC","slug":"MVC","permalink":"https://melodyjerry.github.io/blog/tags/MVC/"},{"name":"JAVA","slug":"JAVA","permalink":"https://melodyjerry.github.io/blog/tags/JAVA/"},{"name":"数据库","slug":"数据库","permalink":"https://melodyjerry.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"C/C++","slug":"C-C","permalink":"https://melodyjerry.github.io/blog/tags/C-C/"},{"name":"随笔","slug":"随笔","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://melodyjerry.github.io/blog/tags/Tomcat/"},{"name":"Druid","slug":"Druid","permalink":"https://melodyjerry.github.io/blog/tags/Druid/"},{"name":"云服务器","slug":"云服务器","permalink":"https://melodyjerry.github.io/blog/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Servlet","slug":"Servlet","permalink":"https://melodyjerry.github.io/blog/tags/Servlet/"},{"name":"系统","slug":"系统","permalink":"https://melodyjerry.github.io/blog/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"halo","slug":"halo","permalink":"https://melodyjerry.github.io/blog/tags/halo/"},{"name":"文章","slug":"文章","permalink":"https://melodyjerry.github.io/blog/tags/%E6%96%87%E7%AB%A0/"},{"name":"镜像","slug":"镜像","permalink":"https://melodyjerry.github.io/blog/tags/%E9%95%9C%E5%83%8F/"},{"name":"jQuery","slug":"jQuery","permalink":"https://melodyjerry.github.io/blog/tags/jQuery/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://melodyjerry.github.io/blog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"素材","slug":"素材","permalink":"https://melodyjerry.github.io/blog/tags/%E7%B4%A0%E6%9D%90/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"https://melodyjerry.github.io/blog/tags/SQL-Server/"},{"name":"音乐","slug":"音乐","permalink":"https://melodyjerry.github.io/blog/tags/%E9%9F%B3%E4%B9%90/"},{"name":"电影","slug":"电影","permalink":"https://melodyjerry.github.io/blog/tags/%E7%94%B5%E5%BD%B1/"},{"name":"脚本","slug":"脚本","permalink":"https://melodyjerry.github.io/blog/tags/%E8%84%9A%E6%9C%AC/"}]}