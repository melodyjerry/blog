<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.png">
  <link rel="icon" type="image/png" href="/blog/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#b9b9b9">
  <meta name="description" content="">
  <meta name="author" content="Melody Jerry">
  <meta name="keywords" content="">
  <title>Vue快速入门学习笔记(更新ing) - MelodyHub</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/blog/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/atom-one-dark-reasonable.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/blog/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/blog/atom.xml" title="MelodyHub" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>MelodyHub</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('https://s1.ax1x.com/2020/07/16/UDRtE9.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-10-04 20:47">
      2020年10月4日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      24.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      317
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-post-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-post-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：16 天前
                
              </p>
            
            <article class="markdown-body">
              <blockquote>
<p>本笔记综合了视频<a href="https://www.bilibili.com/video/BV18E411a7mC" target="_blank" rel="noopener">狂神说的Vue快速上手</a>和菜鸟教程、CSDN等博客文章，以及个人的一些学习见解与体会。</p>
<p>由于是为了团队需要而快速入门，HTML、CSS、JS、Vue等基础均不全，故本笔记仅供参考学习使用。</p>
</blockquote>
<p>Vue 的<code>核心库只关注视图层</code>，方便与第三方库或既有项目整合。</p>
<p>HTML + CSS + JS : 视图 ： <code>给用户看，刷新后台给的数据</code></p>
<p>网络通信 ： <code>axios</code></p>
<p>页面跳转 ： <code>vue-router</code></p>
<p>状态管理：<code>vuex</code></p>
<p>Vue-UI : <code>ICE</code>、 <code>Element UI</code></p>
<h1 id="一、VUE-概述"><a href="#一、VUE-概述" class="headerlink" title="一、VUE 概述"></a>一、VUE 概述</h1><p><code>Vue</code>(读音<code>/vju/</code>, 类似于view)是<strong>一套用于构建用户界面的渐进式框架</strong>，发布于2014年2月。</p>
<p>与其它大型框架不同的是，<strong>Vue被设计为可以自底向上逐层应用。</strong></p>
<p><strong>Vue的核心库只关注视图层</strong>，不仅易于上手，还便于与第三方库(如: <code>vue-router</code>: 跳转，<code>vue-resource</code>: 通信，<code>vuex</code>:管理)或既有项目整合。</p>
<a id="more"></a>

<h1 id="二、前端核心知识分析"><a href="#二、前端核心知识分析" class="headerlink" title="二、前端核心知识分析"></a>二、前端核心知识分析</h1><h2 id="1-前端三要素"><a href="#1-前端三要素" class="headerlink" title="1. 前端三要素"></a>1. 前端三要素</h2><ul>
<li><code>HTML</code><strong>(结构层)</strong> : 超文本标记语言(Hyper Text Markup Language) ，决定网页的结构和内容</li>
<li><code>CSS</code><strong>(表现层)</strong> : 层叠样式表(Cascading Style sheets) ，设定网页的表现样式</li>
<li><code>JavaScript</code><strong>(行为层)</strong> : 是一种弱类型脚本语言，其源代码不需经过编译，而是由浏览器解释运行,用于控制网页的行为</li>
</ul>
<h3 id="1-1-CSS-预处理器有"><a href="#1-1-CSS-预处理器有" class="headerlink" title="1.1 CSS 预处理器有"></a>1.1 CSS 预处理器有</h3><ul>
<li>SASS：基于Ruby，通过服务端处理，功能强大。解析效率稿。需要学习 Ruby 语言，上手难度高于LESS。</li>
<li><code>LESS</code>：基于 NodeJS，通过客户端处理，使用简单。功能比 SASS 简单，解析效率也低于 SASS，但<strong>在实际开发中足够了，所以后台人员如果需要的话，建议使用 LESS。</strong></li>
</ul>
<h3 id="1-2-Native原生JS开发"><a href="#1-2-Native原生JS开发" class="headerlink" title="1.2 Native原生JS开发"></a>1.2 Native原生JS开发</h3><p>原生JS开发，也就是让我们按照【<strong>ECMAScript</strong>】标准的开发方式，简称是ES,特点是所有浏览器都支持。截止到当前博客发布时间，ES标准已发布如下版本:</p>
<ul>
<li><p>ES3</p>
</li>
<li><p>ES4 (内部,未正式发布)</p>
</li>
<li><p><code>ES5 (全浏览器支持)</code></p>
</li>
<li><p><code>ES6 (常用，当前主流版本: webpack打包成为ES5支持! )</code></p>
</li>
<li><p>ES7</p>
</li>
<li><p>ES8</p>
</li>
<li><p>ES9 (草案阶段)</p>
</li>
</ul>
<blockquote>
<p>区别就是逐步增加新特性。</p>
</blockquote>
<h3 id="1-3-TypeScript微软的标准"><a href="#1-3-TypeScript微软的标准" class="headerlink" title="1.3 TypeScript微软的标准"></a>1.3 TypeScript微软的标准</h3><p>TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。由安德斯海尔斯伯格（C#、Delphi、TypeScript 之父； .NET 创立者）主导。</p>
<p>该语言的特点就是除了具备 ES 的特性之外还纳入了许多不在标准范围内的新特性，所以会导致很多浏览器不能直接支持 TypeScript 语法，需要编译后（编译成 JS ）才能被浏览器正确执行。</p>
<h2 id="2-JavaScript框架"><a href="#2-JavaScript框架" class="headerlink" title="2. JavaScript框架"></a>2. JavaScript框架</h2><p><font color="blue">前端三大框架：Angular、React、Vue</font></p>
<ul>
<li><strong>jQuery</strong>: 大家熟知的JavaScript框架，优点是简化了DOM操作，缺点是DOM操作太频繁,影响前端性能;在前端眼里使用它仅仅是为了兼容IE6、7、8。</li>
<li><strong>Angular</strong>: Google收购的前端框架，由一群Java程序员开发，其<code>特点是将后台的MVC模式搬到了前端并增加了模块化开发的理念</code>，与微软合作，采用TypeScript语法开发;对后台程序员友好，对前端程序员不太友好;最大的缺点是版本迭代不合理(如: 1代-&gt; 2代，除了名字，基本就是两个东西;截止发表博客时已推出了Angular6)。</li>
<li><strong>React</strong>: Facebook出品，一款高性能的JS前端框架;<code>特点是提出了新概念[虚拟DOM]用于减少真实DOM操作，在内存中模拟DOM操作，有效的提升了前端渲染效率</code>;缺点是使用复杂，因为需要额外学习一门[JSX] 语言。</li>
<li><strong>Vue</strong>:一款渐进式JavaScript框架，<strong>所谓渐进式就是逐步实现新特性的意思</strong>，如实现模块化开发、路由、状态管理等新特性。<strong>其特点是综合了Angular (模块化)和React (虚拟DOM)的优点;</strong>。</li>
<li><strong>Axios</strong> :<strong>前端通信框架</strong>；因为Vue 的边界很明确，就是为了处理DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用jQuery提供的AJAX通信功能。</li>
</ul>
<h2 id="3-UI框架"><a href="#3-UI框架" class="headerlink" title="3. UI框架"></a>3. UI框架</h2><ul>
<li>Ant-Design：阿里巴巴出品，基于React的UI框架</li>
<li><strong>ElementUI、 iview、 ice</strong>: 基于Vue的UI框架</li>
<li><strong>Bootstrap</strong>：Twitter推出的一个用于前端开发</li>
<li>AmazeUI：又叫”妹子UI”，一款HTML5跨屏前端框架</li>
</ul>
<h2 id="4-JavaScript构建工具"><a href="#4-JavaScript构建工具" class="headerlink" title="4. JavaScript构建工具"></a>4. JavaScript构建工具</h2><ul>
<li>Babel: JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript</li>
<li><strong>WebPack</strong>: <em>模块打包器，主要作用是打包、压缩、合并及按序加载</em></li>
</ul>
<blockquote>
<p>前端开发主要使用<code>WebPack</code>。</p>
</blockquote>
<h2 id="5-三端合一"><a href="#5-三端合一" class="headerlink" title="5. 三端合一"></a>5. 三端合一</h2><h3 id="5-1-混合开发（Hybid-App）"><a href="#5-1-混合开发（Hybid-App）" class="headerlink" title="5.1 混合开发（Hybid App）"></a>5.1 混合开发（Hybid App）</h3><p>主要目的是实现一套代码三端统一(PC、Android:.apk、iOS:.ipa )并能备够调用到底层件(如:传感器、GPS、 摄像头等)，打包方式主要有以下两种:</p>
<ul>
<li>云打包: <strong>HBuild -&gt; HBuildX， DCloud出品; API Cloud</strong></li>
<li>本地打包: <strong>Cordova</strong> (前身是PhoneGap)</li>
</ul>
<h3 id="5-2-微信小程序"><a href="#5-2-微信小程序" class="headerlink" title="5.2 微信小程序"></a>5.2 微信小程序</h3><p>详见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">微信小程序官网</a>，这里就只介绍一个方便小程序开发的框架：</p>
<ul>
<li>WeUI</li>
</ul>
<h2 id="6-后端技术"><a href="#6-后端技术" class="headerlink" title="6. 后端技术"></a>6. 后端技术</h2><p>前端人员为了方便开发也需要掌握一定的后端技术， 但我们Java后台人员知道后台知识体系极其庞大复杂，所以为了方便前端人员开发后台应用，就出现了<code>NodeJS</code>这样的技术。</p>
<p>NodeJS的作者已经声称放弃NodeJS (说是架构做的不好再加上笨重的node_ modules，可能让作者不爽了吧)，开始开发全新架构的Deno</p>
<p>既然是后台技术，那肯定也需要框架和项目管理工具，<code>NodeJS</code>框架及项目管理工具如下:</p>
<ul>
<li>Express: NodeJS框架</li>
<li>Koa: Express简化版</li>
<li><code>NPM</code>: 项目综合管理工具，类似于Maven</li>
<li><code>YARN</code>: NPM的替代方案，类似于Maven和Gradle的关系</li>
</ul>
<h2 id="7-主流前端框架"><a href="#7-主流前端框架" class="headerlink" title="7. 主流前端框架"></a>7. 主流前端框架</h2><ul>
<li><strong>Vue.js</strong></li>
</ul>
<h3 id="7-1-iView"><a href="#7-1-iView" class="headerlink" title="7.1 iView"></a>7.1 iView</h3><p>iview 是一个强大的基于 Vue 的 UI 库，有很多实用的基础组件比 elementui 的组件更丰富，主要服务于 PC 界面的中后台产品。使用单文件的 Vue 组件化开发模式基于 npm + webpack + babel 开发，支持 ES2015 高质量、功能丰富友好的 API，自由灵活地使用空间。</p>
<ul>
<li><a href="https://iviewui.com/" target="_blank" rel="noopener">官网地址</a></li>
<li><a href="https://github.com/view-design/ViewUI" target="_blank" rel="noopener">Github</a></li>
<li><a href="https://gitee.com/icarusion/iview-admin" target="_blank" rel="noopener">iview-admin</a></li>
</ul>
<blockquote>
<p>备注：属于前端主流框架，选型时可以考虑使用，主要特点是移动端支持较多</p>
</blockquote>
<h3 id="7-2-ElementUI"><a href="#7-2-ElementUI" class="headerlink" title="7.2 ElementUI"></a>7.2 ElementUI</h3><p><code>Element</code> 是饿了么前端开源维护的 Vue UI 组件库，组件齐全，基本涵盖后台所需的所有组件，文档讲解详细，例子也很丰富。<strong>主要用于开发 PC 端的页面，是一个质量比较高的 Vue UI 组件库。</strong></p>
<ul>
<li><a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener">官网地址</a></li>
<li>Github：<a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">vue-element-admin</a></li>
</ul>
<blockquote>
<p>备注：属于前端主流框架，选型时可以考虑使用，<strong>主要特点是桌面端支持较多</strong></p>
</blockquote>
<h3 id="7-3-ICE"><a href="#7-3-ICE" class="headerlink" title="7.3 ICE"></a>7.3 ICE</h3><p>飞冰 是阿里巴巴团队基于 React/Angular/Vue 的中后台应用解决方案，在阿里巴巴内部，已经有270多个来自几乎所有 BU 的项目在使用。飞冰包含了一条从设计端到开发端的完整链路，帮助用户快速搭建属于自己的中后台应用。</p>
<blockquote>
<p>备注:主要组件还是以 React 为主，截止 2019 年 02 月 17 日更新博客前对 Vue 的支持还不太完善，目前尚处于观望阶段</p>
</blockquote>
<h3 id="7-4-VantUI"><a href="#7-4-VantUI" class="headerlink" title="7.4 VantUI"></a>7.4 VantUI</h3><p>Vant UI 是有赞前端团队基于有赞统一的规范实现的 Vue 组件库,提供了一整套 UI 基础组件和业务组件。通过 Vant，可以快速搭建出风格统一的页面， 提升开发效率。</p>
<h3 id="7-5-AtUI"><a href="#7-5-AtUI" class="headerlink" title="7.5 AtUI"></a>7.5 AtUI</h3><p>at-ui是一款基于 Vue 2.x 的前端UI组件库,主要用于快速开发PC网站产品。它提供了一套 npm + webpack + babel 前端开发工作流程，CSS 样式独立，即使采用不同的框架实现都能保持统一的UI风格。</p>
<h3 id="7-6-CubeUI"><a href="#7-6-CubeUI" class="headerlink" title="7.6 CubeUI"></a>7.6 CubeUI</h3><p>cube-ui 是滴滴团队开发的基于 Vue.js 实现的精致移动端组件库。支持按需引入和后编译，轻量灵活；扩展性强，可以方便地基于现有组件实现二次开发。</p>
<h3 id="混合开发"><a href="#混合开发" class="headerlink" title="混合开发"></a>混合开发</h3><h4 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h4><p>Flutter是谷歌的移动端UI框架，可在极短的时间内构建Android 和iOs.上高质量的原生级应用。Flutter 可与现有代码一起工作,它被世界各地的开发者和组织使用,并且Flutter是免费和开源的。</p>
<blockquote>
<p>备注: Google出品，主要特点是快速构建原生APP应用程序，如做混合应用该框架为必选框架</p>
</blockquote>
<h4 id="lonic"><a href="#lonic" class="headerlink" title="lonic"></a>lonic</h4><p>lonic 既是一个 CSS 框架也是一个 Javascript UI 库，lonic 是目前最有潜力的一款 HTML5 手机应用开发框架。通过 SASS 构建应用程序，它提供了很多 UI 组件来帮助开发者开发强大的应用。它使用 JavaScript MVVM框架和 AngularJS/Vue 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动开发者的共同选择。</p>
<h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><h4 id="mpvue"><a href="#mpvue" class="headerlink" title="mpvue"></a>mpvue</h4><p>mpvue 是美团开发的一一个使用 <code>Vue.js</code> 开发小程序的前端框架，目前支持微信小程序、百度智能小程序，头条小程序和支付宝小程序。框架基于 <code>Vue.js</code> ，修改了的运行时框架 <code>runt ime</code> 和代码编译器 <code>compiler</code> 实现，使其可运行在小程序环境中，从而为小程序开发引入了 <code>Vue.js</code> 开发体验。</p>
<blockquote>
<p>备注:完备的Vue开发体验，并且支持多平台的小程序开发，推荐使用</p>
</blockquote>
<h4 id="WeUl"><a href="#WeUl" class="headerlink" title="WeUl"></a>WeUl</h4><p>WeUI 是一套同微信原生视觉体验一致的基础样式库， 由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。包含 button、cell、 dialog、toast、article、 icon 等各式元素。</p>
<h1 id="三、了解前后端分离的演变史"><a href="#三、了解前后端分离的演变史" class="headerlink" title="三、了解前后端分离的演变史"></a>三、了解前后端分离的演变史</h1><h2 id="1-后端为主的-MVC-时代"><a href="#1-后端为主的-MVC-时代" class="headerlink" title="1 后端为主的 MVC 时代"></a>1 后端为主的 MVC 时代</h2><p>为了降低开发的复杂度，以后端为出发点,比如：Struts、 SpringMVC 等框架的使用，就是后端的MVC时代；</p>
<p>以 <code>Spring MVC</code> 的流程为例：</p>
<p><img src="https://s1.ax1x.com/2020/10/04/0JmdxA.png" srcset="/blog/img/loading.gif" alt="0JmdxA.png"></p>
<ul>
<li>发起请求到前端控制器( <code>DispatcherServlet</code> )</li>
<li>前端控制器请求 <code>HandlerMapping</code> 查找 <code>Handler</code>, 可以根据 <code>xml</code> 配置、注解进行查找</li>
<li>处理器映射器 <code>HandlerMapping</code> 向前端控制器返回 <code>Handler</code></li>
<li>前端控制器调用处理器适配器去执行Handler</li>
<li>处理器适配器去执行 <code>Handler</code></li>
<li><code>Handler</code> 执行完成给适配器返回 <code>ModelAndView</code></li>
<li>处理器适配器向前端控制器返回 <code>ModelAndView</code> ，<code>Mode lAndView</code> 是 <code>SpringMVC</code> 框架的一一个底层对象，包括 <code>Model</code> 和 <code>View</code></li>
<li>前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图( <code>JSP</code> )</li>
<li>视图解析器向前端控制器返回 <code>View</code></li>
<li>前端控制器进行视图渲染，视图渲染将模型数据（在 <code>ModelAndView</code> 对象中）填充到 <code>request</code> 域</li>
<li>前端控制器向用户响应结果</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>MVC是一个非常好的协作模式，能够有效降低代码的耦合度,从架构上能够让开发者明白代码应该写在哪里。</li>
<li>为了让View更纯粹,还可以使用Thymeleaf、Freemarker 等模板引擎，使模板里无法写入Java代码,让前后端分工更加清晰。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>前端开发重度依赖开发环境，开发效率低，这种架构下，前后端协作有两种模式：<ul>
<li>第一种是前端写 DEMO，写好后，让后端去套模板。好处是 DEMO 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大；</li>
<li>另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。</li>
</ul>
</li>
<li>前后端职责纠缠不清：模板弓|擎功能强大，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 <code>Controller</code> ，页面路由等功能本应该是前端最关注的，但却是由后端来实现。<code>Controller</code> 本身与 <code>Model</code> 往往也会纠缠不清，看了让人咬牙的业务代码经常会出现在 <code>Controller</code> 层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。</li>
<li>对前端发挥的局限性：性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作，但由于后端框架限制，我们很难使用<strong>【Comet】</strong> 、<strong>【BigPipe】</strong> 等技术方案来优化性能。</li>
</ul>
<blockquote>
<p>注：在这期间（2005 年以前），包括早期的 JSP、PHP 可以称之为 Web 1.0 时代。因为时代在变、技术在变、什么都在变。</p>
<blockquote>
<p>世界著名作家、大思想家斯宾塞·约翰逊的一句话：唯一不变的是变化本身。</p>
</blockquote>
<p>一些陈旧的技术对于市场来说早就过时了，比如 JSP。</p>
</blockquote>
<h2 id="2-基于-AJAX-带来的-SPA-时代"><a href="#2-基于-AJAX-带来的-SPA-时代" class="headerlink" title="2 基于 AJAX 带来的 SPA 时代"></a>2 基于 AJAX 带来的 SPA 时代</h2><p>时间回到 2005 年 <code>AJAX</code> （Asynchronous JavaScript And XM，异步JavaScript和XML,老技术新用法）被正式提出并开始使用 <code>CDN</code> 作为静态资源存储，于是出现了JavaScript王者归来（在这之前 JS 都是用来在网页上贴狗皮膏药广告的）的 SPA （Single Page Application）单页面应用时代。</p>
<p><img src="https://s1.ax1x.com/2020/10/04/0JKK2Q.png" srcset="/blog/img/loading.gif" alt="0JKK2Q.png"></p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>这种模式下，<strong>前后端的分工非常清晰，前后端的关键协作点是AJAX接口</strong>。看起来是如此美妙,但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，<strong>这个时代开始出现浏览器端的分层架构</strong>：</p>
<p><img src="https://s1.ax1x.com/2020/10/04/0JKlKs.png" srcset="/blog/img/loading.gif" alt="0JKlKs.png"></p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><strong>前后端接口的约定：</strong>如果后端的接口一塌糊涂,如果后端的业务模型不够稳定,那么前端开发会很痛苦；不少团队也有类似尝试，通过接口规则、接口平台等方式来做。<strong>有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发</strong>。</li>
<li><strong>前端开发的复杂度控制：</strong>SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。</li>
</ul>
<h2 id="3-前端为主的-MV-时代"><a href="#3-前端为主的-MV-时代" class="headerlink" title="3 前端为主的 MV* 时代"></a>3 前端为主的 MV* 时代</h2><p>此处的 MV* 模式如下：</p>
<ul>
<li>MVC （同步通信为主）：Model、View、Controller</li>
<li>MVP （异步通信为主）： Model、 View、 Presenter</li>
<li>MVVM （异步通信为主）：Model、 View、 ViewModel</li>
</ul>
<p>为了降低前端开发复杂度，涌现了大量的前端框架，比如：<code>AngularJS</code>、 <code>React</code>、 <code>Vue.js</code> 、<code>EmberJS</code>等，这些框架总的原则是先按类型分层,比如 Templates、Controllers、 Models, 然后再在层内做切分，如下图：</p>
<p><img src="https://s1.ax1x.com/2020/10/04/0JK3bq.png" srcset="/blog/img/loading.gif" alt="0JK3bq.png"></p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>前后端职责很清晰：</strong>前端工作在浏览器端，后端工作在服务器端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。</li>
<li><strong>前端开发的复杂度可控：</strong>前端代码很重，但合理分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计都有很大学位，得花一本书的厚度去说明。</li>
<li><strong>部署相对独立：</strong>可以快速改进产品的体验。</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。</li>
<li>全异步，对 SEO 不利。往往还需要服务端做同步渲染的降级方案。</li>
<li>性能并非最佳，特别是移动互联网环境下。</li>
<li>SPA 不能满足所有需求，依旧存在大量多页面应用。URL Design 需要后端配合，前端无法完全掌握。</li>
</ul>
<h2 id="4-NodeJS-代理的全栈时代"><a href="#4-NodeJS-代理的全栈时代" class="headerlink" title="4 NodeJS 代理的全栈时代"></a>4 NodeJS 代理的全栈时代</h2><p>前端为主的 MV* 模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着 NodeJS 的兴起， JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式：</p>
<p><img src="https://s1.ax1x.com/2020/10/04/0JKGV0.png" srcset="/blog/img/loading.gif" alt="0JKGV0.png"></p>
<p>在这种研发模式下，前后端的职责很清晰。对前端来说，两个UI层各司其职：</p>
<ul>
<li>Front-end UI layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互 功能，HTML 的生成也可以放在这层,具体看应用场景。</li>
<li>Back-end UI layer 处理路由、模板、数据获取、Cookie 等。通过路由,前端终于可以自主把控URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。</li>
</ul>
<p>通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要SEO的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。</p>
<p>与JSP模式相比,全栈模式看起来是一种回归，也的确是-种向原始开发模式的回归,不过是一种螺旋上升式的回归。</p>
<p>基于NodeJS的全栈模式，依旧面临很多挑战:</p>
<ul>
<li>需要前端对服务端编程有更进一 步的认识。比如 TCP/IP 等网络知识的掌握。</li>
<li>NodeJS 层与 Java 层的高效通信。NodeJS 模式下，都在服务器端，RESTful HTTP 通信未必高效,通过 SOAP 等方式通信更高效。-切需要在验证中前行。</li>
<li>对部署、运维层面的熟练了解，需要更多知识点和实操经验。</li>
<li>大量历史遗留问题如何过渡。这可能是最大最大的阻力。</li>
</ul>
<blockquote>
<p>注：为什么说:” 前端想学后台很难，而我们后端程序员学任何东西都很简单“；就是因为后端程序员具备相对完善的知识体系。</p>
</blockquote>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>综上所述，模式也好，技术也罢，没有好坏优劣之分，只有适合不适合；前后分离的开发思想主要是基于 <code>SoC（关注度分离原则）</code>，上面种种模式，都是让前后端的职责更清晰，分工更合理高效。</p>
<h1 id="四、MVVM模式"><a href="#四、MVVM模式" class="headerlink" title="四、MVVM模式"></a>四、MVVM模式</h1><h2 id="1-回顾MVC"><a href="#1-回顾MVC" class="headerlink" title="1 回顾MVC"></a>1 回顾MVC</h2><p>MVC 模式代表 <code>Model-View-Controller（模型-视图-控制器）</code>模式。</p>
<p>这种模式用于<strong>应用程序的分层开发。</strong></p>
<ul>
<li><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</li>
<li><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。</li>
<li><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/10/06/0NQRwd.png" srcset="/blog/img/loading.gif" alt="0NQRwd.png"></p>
<h2 id="2-什么是MVVM？"><a href="#2-什么是MVVM？" class="headerlink" title="2 什么是MVVM？"></a>2 什么是MVVM？</h2><blockquote>
<p><code>MVVM (Model-View-ViewModel) 是一种软件架构设计模式</code>，由微软WPF (用于替代WinForm，以前就是用这个技术开发桌面应用程序的)和Silverlight (类似于Java Applet,简单点说就是在浏览器上运行的WPF)的架构师Ken Cooper和Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由John Gossman (同样也是WPF和Silverlight的架构师)于2005年在他的博客上发表。</p>
</blockquote>
<p><code>MVVM</code> 源自于经典的<code>MVC (ModI-View-Controller) 模式</code>。</p>
<p>MVVM的核心是<code>ViewModel</code>层，<strong>负责转换Model中的数据对象来让数据变得更容易管理和使用</strong>，其作用如下:</p>
<ul>
<li>该层向上与<code>View</code>层进行双向数据绑定</li>
<li>向下与<code>Model</code>层通过接口请求进行数据交互</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/10/06/0Nlt9P.png" srcset="/blog/img/loading.gif" alt="0Nlt9P.png"></p>
<h2 id="3-MVVM组成部分"><a href="#3-MVVM组成部分" class="headerlink" title="3 MVVM组成部分"></a>3 MVVM组成部分</h2><p><img src="https://s1.ax1x.com/2020/10/06/0NlXuD.png" srcset="/blog/img/loading.gif" alt="0NlXuD.png"></p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>View 是视图层，也就是用户界面。</p>
<p>前端主要由 <code>HTML</code> 和 <code>CSS</code> 来构建，为了更方便地展现 <code>ViewModel</code> 或者 <code>Model</code> 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Thymeleaf 等等，各大 MVVM 框架如 Vue.js，AngularJS，EJS 等也都有自己用来构建用户界面的内置模板语言。</p>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。</p>
<p>这里的难点主要在于需要和前端约定统一的 <code>接口规则</code>。</p>
<h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p>
<p>需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的</p>
<ul>
<li>比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示）</li>
<li>页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互）</li>
</ul>
<p>视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层`。由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图。</p>
<blockquote>
<p>MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，真正实现 <code>事件驱动编程</code>。</p>
</blockquote>
<blockquote>
<p>View 层展现的不是 <code>Model</code> 层的数据，而是 <code>ViewModel</code> 的数据，由 <code>ViewModel</code> 负责与 <code>Model</code> 层交互，这就<strong>完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</strong></p>
</blockquote>
<h2 id="4-为什么要使用MVVM"><a href="#4-为什么要使用MVVM" class="headerlink" title="4 为什么要使用MVVM"></a>4 为什么要使用MVVM</h2><p>MVVM 模式和 MVC 模式一样，主要目的是<code>分离视图（View）和模型（Model）</code>，有几大好处</p>
<ul>
<li><strong>低耦合</strong>： 视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li>
<li><strong>可复用</strong>： 你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 View 重用这段视图逻辑。</li>
<li><strong>独立开发</strong>： 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li>
<li><strong>可测试</strong>： 界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li>
</ul>
<h2 id="5-MVVM框架"><a href="#5-MVVM框架" class="headerlink" title="5 MVVM框架"></a>5 MVVM框架</h2><p>当下流行的 MVVM 框架有:</p>
<ul>
<li><code>Vue.js</code></li>
<li><code>AngularJS</code></li>
<li>……</li>
</ul>
<h1 id="五、Vue-是-MVVM-模式的实现者"><a href="#五、Vue-是-MVVM-模式的实现者" class="headerlink" title="五、Vue 是 MVVM 模式的实现者"></a>五、Vue 是 MVVM 模式的实现者</h1><p><img src="https://s1.ax1x.com/2020/10/06/0NlXuD.png" srcset="/blog/img/loading.gif" alt="0NlXuD.png"></p>
<ul>
<li><code>Model</code> : 模型层，在这里表示JavaScript对象</li>
<li><code>View</code> : 视图层,在这里表示DOM (HTML操作的元素)</li>
<li><code>ViewModel</code> : 连接视图和数据的中间件，Vue.js就是MVVM中的ViewModel层的实现者在MVVM架构中，是不允许数据和视图直接通信的，只能通过ViewModel来通信，而ViewModel就是定义了一个Observer观察者<ul>
<li><code>ViewModel</code> 能够观察到数据的变化，并对视图对应的内容进行更新</li>
<li><code>ViewModel</code> 能够监听到视图的变化，并能够通知数据发生改变</li>
</ul>
</li>
</ul>
<blockquote>
<p>Vue.js 就是一个MVVM的实现者，他的核心就是实现了<strong>DOM监听</strong>与<strong>数据绑定</strong>。</p>
</blockquote>
<h1 id="六、为什么要使用-Vue-js"><a href="#六、为什么要使用-Vue-js" class="headerlink" title="六、为什么要使用 Vue.js"></a>六、为什么要使用 Vue.js</h1><ul>
<li>轻量级，体积小是一个重要指标。Vue.js 压缩后有只有 20多kb （Angular 压缩后 56kb+，React 压缩后 44kb+）</li>
<li>移动优先。更适合移动端，比如移动端的 Touch 事件</li>
<li>易上手，学习曲线平稳，文档齐全</li>
<li>吸取了 Angular（模块化）和 React（虚拟 DOM）的长处，并拥有自己独特的功能，如：计算属性</li>
<li>开源，社区活跃度高</li>
<li>…</li>
</ul>
<h1 id="七、第一个Vue程序"><a href="#七、第一个Vue程序" class="headerlink" title="七、第一个Vue程序"></a>七、第一个Vue程序</h1><h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h2><ul>
<li>IDEA 可以安装 Vue 的插件！</li>
</ul>
<blockquote>
<p>注意：Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。</p>
</blockquote>
<h2 id="2-下载"><a href="#2-下载" class="headerlink" title="2 下载"></a>2 下载</h2><ul>
<li><p>开发版本</p>
<ul>
<li>包含完整的警告和调试模式：<a href="https://vuejs.org/js/vue.js" target="_blank" rel="noopener">https://vuejs.org/js/vue.js</a></li>
<li>删除了警告，30.96KB min + gzip：<a href="https://vuejs.org/js/vue.min.js" target="_blank" rel="noopener">https://vuejs.org/js/vue.min.js</a></li>
</ul>
</li>
<li><p>CDN</p>
<ul>
<li><pre><code class="js">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>
&lt;!--￼<span class="number">0</span>--&gt;

</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="3-实例-demo"><a href="#3-实例-demo" class="headerlink" title="3 实例 demo"></a>3 实例 demo</h2><ul>
<li>Vue.js 就是一个MVVM的实现者，他的核心就是实现了<strong>DOM监听</strong>与<strong>数据绑定</strong>。</li>
</ul>
<p>1、新建一个HTML文件</p>
<p>2、导入Vue.js</p>
<pre><code class="hljs js">&lt;script src=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre>

<p>3、创建一个Yue对象实例</p>
<pre><code class="hljs js">&lt;script&gt;
    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({
        el: <span class="hljs-string">"#app"</span>,
        <span class="hljs-comment">// Model: 数据</span>
        data: {
            message: <span class="hljs-string">"Hello, Vue!"</span>
        },
    });
&lt;<span class="hljs-regexp">/script&gt;</span></code></pre>

<blockquote>
<ul>
<li><code>el:"#app"</code>：绑定元素的 ID</li>
<li><code>data:{message: "Hello,Vue!"}</code>：数据对象中有一个名为 message 的属性，并设置了初始值”Hello,Vue!”</li>
</ul>
</blockquote>
<p>4、将实例绑定到页面元素</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span> {{message}} <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>

<p>只需要在绑定的元素中使用 <code>双{}</code> 将 <code>Vue</code> 创建的名为 <code>message</code>属性包裹起来，即可实现数据绑定功能，也就实现了 ViewModel 层所需的效果，是不是和 EL 表达式非常像？</p>
<p>5、完整代码</p>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span> {{message}} <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span>
<span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span>
<span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>
<span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>
            data: {
<span class="actionscript">                message: <span class="hljs-string">"Hello, Vue!"</span></span>
            },
        });
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<p>6、viewModel双向绑定</p>
<p>为了能够更直观的体验 Vue 带来的双向绑定，可以直接在浏览器控制台演示一下：</p>
<p><img src="https://s1.ax1x.com/2020/10/06/0UeB9O.png" srcset="/blog/img/loading.gif" alt="0UeB9O.png"></p>
<blockquote>
<p>此时就可以在控制台直接输入 <code>vm.message</code> 来修改值，中间是可以省略 <code>data</code> 的，在这个操作中，并没有主动操作 <code>DOM</code>，就让页面的内容发生了变化，这就是借助了 Vue 的 数据绑定 功能实现的。</p>
<p><code>MVVM</code> 模式中要求 <code>ViewModel</code> 层就是使用 <code>观察者模式</code> 来实现数据的监听与绑定，以做到数据与视图的快速响应。</p>
</blockquote>
<h1 id="八、基础语法-amp-用法"><a href="#八、基础语法-amp-用法" class="headerlink" title="八、基础语法 &amp; 用法"></a>八、基础语法 &amp; 用法</h1><ul>
<li><p>现在数据和DOM已经被建立了关联，所有的东西都是响应式的。</p>
</li>
<li><p>我们在控制台操作对象的属性，界面可以实时更新。</p>
</li>
</ul>
<h2 id="1-v-bind-绑定数据和元素属性"><a href="#1-v-bind-绑定数据和元素属性" class="headerlink" title="1. v-bind 绑定数据和元素属性"></a>1. v-bind 绑定数据和元素属性</h2><p> 我们可以使用<code>v-bind</code>来 <strong>绑定数据和元素属性</strong>！</p>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"message"</span>&gt;</span>
          鼠标悬停几秒钟查看此处动态绑定的提示信息！
        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span>
<span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span>
<span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>
<span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>
            data: {
<span class="actionscript">                message: <span class="hljs-string">"Hello, Vue!"</span></span>
            },
        });
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<p>控制台：</p>
<pre><code class="hljs js">vm.message=<span class="hljs-string">"wonderful U"</span></code></pre>

<h2 id="2-v-if-amp-v-else-条件渲染"><a href="#2-v-if-amp-v-else-条件渲染" class="headerlink" title="2. v-if &amp; v-else 条件渲染"></a>2. v-if &amp; v-else 条件渲染</h2><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>9
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- &lt;h1 v-if="ok"&gt;Yes&lt;/h1&gt;</span>
<span class="hljs-comment">        &lt;h1 v-else=&gt;No&lt;/h1&gt; --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"type=='A'"</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"type=='B'"</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"type=='D'"</span>&gt;</span>D<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span>
<span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span>
<span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>
<span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>
            data: {
<span class="actionscript">                <span class="hljs-comment">// ok: true,</span></span>
<span class="actionscript">                type: <span class="hljs-string">'A'</span>,</span>
            },
        });
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<p>控制台：</p>
<pre><code class="hljs js">vm.type=<span class="hljs-number">1</span>
vm.type=<span class="hljs-string">'D'</span>
vm.type=<span class="hljs-string">'E'</span>
vm.type=<span class="hljs-string">'A'</span></code></pre>

<h2 id="3-v-for-列表渲染"><a href="#3-v-for-列表渲染" class="headerlink" title="3. v-for 列表渲染"></a>3. v-for 列表渲染</h2><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment"> * @Author: your name</span>
<span class="hljs-comment"> * @Date: 2020-10-06 16:48:08</span>
<span class="hljs-comment"> * @LastEditTime: 2020-10-06 22:52:08</span>
<span class="hljs-comment"> * @LastEditors: Please set LastEditors</span>
<span class="hljs-comment"> * @Description: In User Settings Edit</span>
<span class="hljs-comment"> * @FilePath: \Vue\chapter-1\demo1.html</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- v-for="数组元素 in 源数据数组" --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in items"</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- 通过遍历变量来访问 --&gt;</span>
            {{item.message}} - {{index}}
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span>
<span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span>
<span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>
<span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>
            data: {
                items: [
<span class="actionscript">                    {message: <span class="hljs-string">'Melody'</span>},</span>
<span class="actionscript">                    {message: <span class="hljs-string">'Jerry'</span>},</span>
                ]
            },
        });
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<blockquote>
<p>其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的<strong>别名</strong>。</p>
</blockquote>
<h2 id="4-v-on-绑定事件"><a href="#4-v-on-绑定事件" class="headerlink" title="4. v-on 绑定事件"></a>4. v-on 绑定事件</h2><ul>
<li>可以用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</li>
</ul>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"sayHi"</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The button above has been clicked {{counter}} times.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span>
<span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span>
<span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>
<span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>
            data: {
                counter: 0,
<span class="actionscript">                message: <span class="hljs-string">"你点我干啥呢？我叫你点，你就点啊？"</span>,</span>
            },
<span class="actionscript">            methods: {  <span class="hljs-comment">//方法必须定义在Vue的methods对象中, v-on绑定事件</span></span>
<span class="actionscript">                sayHi: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event)</span> </span>{</span>
<span class="actionscript">                    <span class="hljs-comment">// 这个this指的是当前的Vue实例对象</span></span>
<span class="actionscript">                    <span class="hljs-keyword">this</span>.counter += <span class="hljs-number">1</span>,</span>
<span class="actionscript">                    alert(<span class="hljs-keyword">this</span>.message)</span>
                }
            },
        });
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<blockquote>
<p>事件有<code>Vue</code>的事件、和前端页面本身的一些事件！</p>
<p>这里的<code>click</code>是vue的事件，可以绑定到Vue中的<code>methods</code>中的方法事件！</p>
<p><a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/events.html</a></p>
</blockquote>
<h2 id="5-v-model-Vue双向绑定"><a href="#5-v-model-Vue双向绑定" class="headerlink" title="5. v-model Vue双向绑定"></a>5. v-model Vue双向绑定</h2><h3 id="5-1-什么是双向绑定"><a href="#5-1-什么是双向绑定" class="headerlink" title="5.1 什么是双向绑定"></a>5.1 什么是双向绑定</h3><p><code>Vue.js</code>是一个<code>MVVM</code>框架，即<strong>数据双向绑定</strong>，即：</p>
<ul>
<li><p>当数据发生变化的时候，视图也就发生变化，</p>
</li>
<li><p><strong>当视图发生变化的时候，数据也会跟着同步变化。</strong></p>
<p><em>这也算是Vue.js的精髓之处了。</em></p>
</li>
</ul>
<blockquote>
<p>值得注意的是，<strong>我们所说的数据双向绑定，一定是对于UI控件来说的，非UI控件不会涉及到数据双向绑定。</strong></p>
</blockquote>
<blockquote>
<p>单向数据绑定是使用状态管理工具的前提。</p>
</blockquote>
<blockquote>
<p>如果我们使用vuex，那么数据流也是单项的，这时就会和双向数据绑定有冲突。</p>
</blockquote>
<h3 id="5-2-为什么要实现数据的双向绑定"><a href="#5-2-为什么要实现数据的双向绑定" class="headerlink" title="5.2 为什么要实现数据的双向绑定"></a>5.2 为什么要实现数据的双向绑定</h3><p>在Vue.js 中，如果使用vuex ，实际上数据还是单向的，之所以说是数据双向绑定，这是用的UI控件来说，对于我们处理表单，Vue.js的双向数据绑定用起来就特别舒服了。</p>
<ul>
<li>即两者并不互斥，在全局性数据流使用单项，方便跟踪；</li>
<li>局部性数据流使用双向，简单易操作。</li>
</ul>
<h3 id="5-3-在表单中使用双向数据绑定"><a href="#5-3-在表单中使用双向数据绑定" class="headerlink" title="5.3 在表单中使用双向数据绑定"></a>5.3 在表单中使用双向数据绑定</h3><ul>
<li>你可以用<code>v-model</code>指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及<code>&lt;select&gt;</code> 元素上创建双向数据绑定。</li>
</ul>
<p>它会根据控件类型自动选取正确的方法来更新元素。</p>
<p>尽管有些神奇，但<code>v-model</code>本质上不过是<code>语法糖</code>。</p>
<p>它<strong>负责监听户的输入事件以更新数据</strong>，并<strong>对一些极端场景进行一些特殊处理</strong>。</p>
<blockquote>
<p>注意：<code>v-model</code>会忽略所有元素的<code>value</code>、<code>checked</code>、<code>selected</code>特性的初始值而总是将Vue实例的数据作为数据来源，<strong>你应该通过<code>JavaScript</code>在组件的<code>data</code>选项中声明。</strong></p>
</blockquote>
<h3 id="5-4-文本域"><a href="#5-4-文本域" class="headerlink" title="5.4 文本域"></a>5.4 文本域</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
            输入的文本：<span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
            双向数据绑定： {{message}}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span>
<span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span>
<span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>
<span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>
            data: {
<span class="actionscript">                message: <span class="hljs-string">"初始文本"</span>,</span>
            },
        });
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<h3 id="5-5-单选框"><a href="#5-5-单选框" class="headerlink" title="5.5 单选框"></a>5.5 单选框</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
        性别：
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">" 男"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"MelodyJerry"</span>&gt;</span> 男
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">" 女"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"MelodyJerry"</span>&gt;</span> 女
            <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
            MelodyJerry.sex：{{MelodyJerry}}
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span>
<span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span>
<span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>
<span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>
            data: {
<span class="actionscript">                MelodyJerry: <span class="hljs-string">''</span>,</span>
            },
        });
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<h3 id="5-6-下拉框"><a href="#5-6-下拉框" class="headerlink" title="5.6 下拉框"></a>5.6 下拉框</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
        下拉框：
        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"selected"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span> <span class="hljs-attr">disabled</span>&gt;</span>--请选择--<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>D<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
        选中的值： {{selected}}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span>
<span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span>
<span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>
<span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>
            data: {
<span class="actionscript">                selected: <span class="hljs-string">''</span>,</span>
            },
        });
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<blockquote>
<p><strong>注意</strong>：如果 <code>v-model</code> 表达式的初始值未能匹配任何选项， 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项：<code>value="" disabled</code>。</p>
</blockquote>
<h3 id="5-7-复选框"><a href="#5-7-复选框" class="headerlink" title="5.7 复选框"></a>5.7 复选框</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    单复选框：
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"checked"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
    选中的值： {{checked}}

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span>
<span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span>
<span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>
<span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>
            data: {
<span class="actionscript">                checked : <span class="hljs-literal">false</span>,</span>
            },
        });
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<h1 id="九、Vue组件"><a href="#九、Vue组件" class="headerlink" title="九、Vue组件"></a>九、Vue组件</h1><blockquote>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">组件基础</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/components-registration.html" target="_blank" rel="noopener">深入了解组件</a></li>
</ul>
</blockquote>
<h2 id="1-什么是组件"><a href="#1-什么是组件" class="headerlink" title="1. 什么是组件"></a>1. 什么是组件</h2><ul>
<li>组件是可复用的<code>Vue</code>实例，说白了就是一组可以重复使用的模板，跟JSTL的自定义标签、Thymeleaf的<code>th:fragment</code> 等框架有着异曲同工之妙。</li>
</ul>
<p>通常一个应用会以<code>一棵嵌套的组件树</code>的形式来组织：</p>
<p><img src="https://s1.ax1x.com/2020/10/07/0dyw0e.png" srcset="/blog/img/loading.gif" alt="0dyw0e.png"></p>
<blockquote>
<p>例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。</p>
<p>为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。</p>
<p>这里有两种组件的注册类型：</p>
<ul>
<li><strong>全局注册</strong></li>
<li><strong>局部注册</strong></li>
</ul>
<p>至此，我们的组件都只是通过 <code>Vue.component</code> 全局注册的：</p>
<pre><code class="hljs js">Vue.component(<span class="hljs-string">'my-component-name'</span>, {
  <span class="hljs-comment">// ... options ...</span>
})</code></pre>

<p>全局注册的组件可以用在其被注册之后的任何 (通过 <code>new Vue</code>) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。</p>
<p>到目前为止，关于组件注册你需要了解的就这些了，如果你阅读完本页内容并掌握了它的内容，我们会推荐你再回来把<a href="https://cn.vuejs.org/v2/guide/components-registration.html" target="_blank" rel="noopener">组件注册</a>读完。</p>
</blockquote>
<h2 id="2-第一个vue组件"><a href="#2-第一个vue组件" class="headerlink" title="2. 第一个vue组件"></a>2. 第一个vue组件</h2><ul>
<li><em>先注册组件</em>，定义一个Vue组件component<ul>
<li><code>Vue.component()</code>：注册组件</li>
<li><code>my-component-name</code>：自定义组件的名字</li>
<li><code>template</code>：组件的模板</li>
</ul>
</li>
<li><em>再实例化 Vue</em></li>
</ul>
<blockquote>
<p><code>组件名必须全小写</code>，一旦有大写，就会注册错误</p>
</blockquote>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- &lt;li&gt; Hello, MelodyJerry! &lt;/li&gt; --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">melodyjerry</span>&gt;</span> Hello, MelodyJerry! <span class="hljs-tag">&lt;/<span class="hljs-name">melodyjerry</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">        <span class="hljs-comment">//先注册组件，定义一个Vue组件component</span></span>
<span class="actionscript">        Vue.component(<span class="hljs-string">"melodyjerry"</span>,{ <span class="hljs-comment">//组件名必须全小写，一旦有大写，就会注册错误</span></span>
<span class="handlebars"><span class="xml">            template: '<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span> This is a Vue-Component. <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>'</span></span>
        });

<span class="actionscript">        <span class="hljs-comment">//再实例化Vue</span></span>
<span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span>
<span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>
        });
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<h2 id="3-prop-传递参数"><a href="#3-prop-传递参数" class="headerlink" title="3. prop 传递参数"></a>3. prop 传递参数</h2><blockquote>
<p><strong>注意</strong>：默认规则下 <code>props</code> 属性里的值不能为大写。</p>
</blockquote>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-的大小写-camelCase-vs-kebab-case" target="_blank" rel="noopener">Prop 的大小写</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-类型" target="_blank" rel="noopener">Prop 类型</a></li>
<li>传递静态或动态 Prop<ul>
<li><a href="https://cn.vuejs.org/v2/guide/components-props.html#传入一个数字" target="_blank" rel="noopener">传入一个数字</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/components-props.html#传入一个布尔值" target="_blank" rel="noopener">传入一个布尔值</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/components-props.html#传入一个数组" target="_blank" rel="noopener">传入一个数组</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/components-props.html#传入一个对象" target="_blank" rel="noopener">传入一个对象</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/components-props.html#传入一个对象的所有-property" target="_blank" rel="noopener">传入一个对象的所有 property</a></li>
</ul>
</li>
<li><a href="https://cn.vuejs.org/v2/guide/components-props.html#单向数据流" target="_blank" rel="noopener">单向数据流</a></li>
<li>Prop 验证<ul>
<li><a href="https://cn.vuejs.org/v2/guide/components-props.html#类型检查" target="_blank" rel="noopener">类型检查</a></li>
</ul>
</li>
<li>非 Prop 的 Attribute<ul>
<li><a href="https://cn.vuejs.org/v2/guide/components-props.html#替换-合并已有的-Attribute" target="_blank" rel="noopener">替换/合并已有的 Attribute</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/components-props.html#禁用-Attribute-继承" target="_blank" rel="noopener">禁用 Attribute 继承</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/360minitao/p/11850269.html" target="_blank" rel="noopener">博客园</a>、<a href="https://cn.vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">官方文档</a></p>
</blockquote>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- &lt;li&gt; Hello, MelodyJerry! &lt;/li&gt; --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">melodyjerry</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">v-bind:prop</span>=<span class="hljs-string">"item"</span>&gt;</span> Hello, MelodyJerry! <span class="hljs-tag">&lt;/<span class="hljs-name">melodyjerry</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">        <span class="hljs-comment">//先注册组件，定义一个Vue组件component</span></span>
<span class="actionscript">        Vue.component(<span class="hljs-string">"melodyjerry"</span>,{ <span class="hljs-comment">//组件名必须全小写，一旦有大写，就会注册错误</span></span>
<span class="actionscript">            <span class="hljs-comment">//prop:传递参数</span></span>
<span class="actionscript">            props: [<span class="hljs-string">'prop'</span>],  <span class="hljs-comment">//通过循环的遍历prop，v-bind:prop绑定属性，此属性‘prop’作为媒介，传递给模板</span></span>
<span class="actionscript">            <span class="hljs-comment">//组件的模板</span></span>
<span class="handlebars"><span class="xml">            template: '<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span> </span><span class="hljs-template-variable">{{prop}}</span><span class="xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>'</span></span>
        }); 

<span class="actionscript">        <span class="hljs-comment">//再实例化Vue</span></span>
<span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span>
<span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>
            data: {
<span class="actionscript">                items: [<span class="hljs-string">"Java"</span>, <span class="hljs-string">"Python"</span>, <span class="hljs-string">"Vue"</span>]</span>
            },
        });
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<h1 id="十、Axios异步通信"><a href="#十、Axios异步通信" class="headerlink" title="十、Axios异步通信"></a>十、Axios异步通信</h1><h2 id="1-什么是Axios"><a href="#1-什么是Axios" class="headerlink" title="1. 什么是Axios"></a>1. 什么是Axios</h2><p>Axios 是一个开源的可以用在浏览器端和 <code>NodeJS</code> 的异步通信框架，她的主要作用就是实现 AJAX 异步通信，其功能特点如下：</p>
<ul>
<li>从浏览器中创建 <code>XMLHttpRequests</code></li>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API [JS中链式编程]</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 XSRF（跨站请求伪造）</li>
</ul>
<blockquote>
<p>GitHub：<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p>
</blockquote>
<blockquote>
<p>中文文档：<a href="http://www.axios-js.com/" target="_blank" rel="noopener">http://www.axios-js.com/</a></p>
</blockquote>
<h2 id="2-为什么要使用Axios"><a href="#2-为什么要使用Axios" class="headerlink" title="2. 为什么要使用Axios"></a>2. 为什么要使用Axios</h2><p>由于<code>Vue.js</code>是一个<strong>视图层框架</strong>且作者(尤雨溪) 严格准守<code>SoC (关注度分离原则)</code>，所以<code>Vue.js</code>并不包含Ajax的通信功能，为了解决通信问题，作者单独开发了一个名为<code>vue-resource</code>的插件，不过在进入2.0 版本以后停止了对该插件的维护并推荐了<code>Axios</code> 框架。少用<code>jQuery</code>，因为它操作<code>Dom</code>太频繁 !</p>
<h2 id="3-导入Axios"><a href="#3-导入Axios" class="headerlink" title="3. 导入Axios"></a>3. 导入Axios</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<h2 id="4-实例-demo"><a href="#4-实例-demo" class="headerlink" title="4. 实例 demo"></a>4. 实例 demo</h2><p>咱们开发的接口大部分都是采用 JSON 格式，可以先在项目里模拟一段 JSON 数据，数据内容如下：创建一个名为 <code>data.json</code> 的文件并填入上面的内容，放在项目的根目录下。</p>
<pre><code class="hljs json">{
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"MelodyJerry"</span>,
    <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://melodyhub.ltd/"</span>,
    <span class="hljs-attr">"page"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">"isNonProfit"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"address"</span>: {
      <span class="hljs-attr">"street"</span>: <span class="hljs-string">"广州"</span>,
      <span class="hljs-attr">"city"</span>: <span class="hljs-string">"广东"</span>,
      <span class="hljs-attr">"country"</span>: <span class="hljs-string">"中国"</span>
    },
    <span class="hljs-attr">"links"</span>: [
      {
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"博客园"</span>,
        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://www.cnblogs.com/melodyjerry/"</span>
      },
      {
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"GitHub"</span>,
        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"melodyhub.ltd"</span>
      },
      {
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Gitee"</span>,
        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://melodyjerry.gitee.io/"</span>
      }
    ]
  }</code></pre>

<p>新建一个demo.html，来试试<code>Axios</code>的异步通信：</p>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>

    <span class="hljs-comment">&lt;!--v-clock 解决闪烁问题--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
<span class="css">        <span class="hljs-selector-attr">[v-clock]</span> {</span>
            display: none;
        }
    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"vue"</span> <span class="hljs-attr">v-clock</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>名称：{{info.name}} <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>地址：{{info.address.country}}-{{info.address.city}}-{{info.address.street}} <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>博客：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">"info.url"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span>{{info.url}}<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-comment">&lt;!--导入axios--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.bootcdn.net/ajax/libs/axios/0.19.2/axios.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span>
<span class="actionscript">            el: <span class="hljs-string">"#vue"</span>,</span>
            data: {
<span class="actionscript">                items: [<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>,<span class="hljs-string">'Php'</span>]</span>
            },
<span class="actionscript">            <span class="hljs-comment">//data   : vm的属性</span></span>
<span class="actionscript">            <span class="hljs-comment">//data() : vm方法</span></span>
            data(){
<span class="actionscript">                <span class="hljs-keyword">return</span>{</span>
<span class="actionscript">                    <span class="hljs-comment">//请求的返回参数,必须和json字符串一样</span></span>
                   info:{
<span class="actionscript">                       name: <span class="hljs-literal">null</span>,</span>
<span class="actionscript">                       url: <span class="hljs-literal">null</span>,</span>
                       address: {
<span class="actionscript">                           street: <span class="hljs-literal">null</span>,</span>
<span class="actionscript">                           city: <span class="hljs-literal">null</span>,</span>
<span class="actionscript">                           country: <span class="hljs-literal">null</span></span>
                       }
                   }
                }
            },
<span class="actionscript">            <span class="hljs-comment">//钩子函数，链式编程，ES6新特性</span></span>
            mounted(){
<span class="javascript">                axios.get(<span class="hljs-string">"../data.json"</span>).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> (<span class="hljs-keyword">this</span>.info = response.data))</span>
<span class="javascript">                axios.get(<span class="hljs-string">"../data.json"</span>).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> (<span class="hljs-built_in">console</span>.log(response.data)))</span>
            }
        })
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<blockquote>
<ul>
<li><p><code>data</code>   : vm的属性</p>
</li>
<li><p><code>data()</code> : vm方法</p>
<ul>
<li><code>return{}</code> : 请求的返回参数,必须和json字符串一样</li>
</ul>
</li>
<li><p><code>mounted(){}</code> :  钩子函数，链式编程，ES6新特性</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>说明:</p>
<ol>
<li>在这里使用了 <code>v-bind</code> 将 <code>a:href</code> 的属性值<strong>与 Vue 实例中的数据进行绑定</strong></li>
<li>使用 Axios 框架的 get 方法请求 <code>AJAX</code> 并<strong>自动将数据封装进了 Vue 实例的数据对象中</strong></li>
<li>我们在data中的数据结构必须要和<code>Ajax</code>响应回来的<strong>数据格式匹配</strong>！</li>
<li>关于代码中的<code>v-clock 解决闪烁问题</code>，可参考 <a href="https://www.cnblogs.com/melodyjerry/p/13781358.html" target="_blank" rel="noopener">Vue指令：v-clock解决页面闪烁问题</a></li>
</ol>
</blockquote>
<h1 id="十一、计算属性"><a href="#十一、计算属性" class="headerlink" title="十一、计算属性"></a>十一、计算属性</h1><blockquote>
<p>文档：<a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/computed.html</a></p>
</blockquote>
<h2 id="1-什么是计算属性"><a href="#1-什么是计算属性" class="headerlink" title="1. 什么是计算属性"></a>1. 什么是计算属性</h2><ul>
<li>计算属性的重点突出在 <code>属性</code> 两个字上（属性是名词），首先它是个 <code>属性</code> 其次这个属性有 <code>计算</code>的能力（计算是动词），这里的 <code>计算</code> 就是个函数；</li>
<li>简单点说，它就是<strong>一个能够将计算结果缓存起来的属性（将行为转化成了静态的属性）</strong>，仅此而已；可以想象为缓存！</li>
</ul>
<h2 id="2-实例-demo"><a href="#2-实例-demo" class="headerlink" title="2. 实例 demo"></a>2. 实例 demo</h2><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 调用methods里的方法,得用() --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>currentTime1: {{currentTime1()}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 调用计算属性computed的方法,不能用() --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>currentTime2: {{currentTime2}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span>
<span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>
            data: {
<span class="actionscript">                message: <span class="hljs-string">"hello,melodyjerry."</span></span>
            },
            methods: {
<span class="actionscript">                currentTime1: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</span>
<span class="javascript">                    <span class="hljs-keyword">var</span> Xmas95 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"December 25, 1995 23:15:30"</span>);</span>
<span class="actionscript">                    <span class="hljs-keyword">return</span> Xmas95.getDay(); <span class="hljs-comment">//1;返回数值代表星期几：0代表星期日,1代表星期一,2代表星期二</span></span>
                },
            },

<span class="actionscript">            <span class="hljs-comment">//计算属性</span></span>
<span class="actionscript">            computed: { <span class="hljs-comment">//methods、computed中的方法名不能重名;重名后，只会调用methods中的方法</span></span>
<span class="actionscript">                currentTime2: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</span>
<span class="actionscript">                <span class="hljs-comment">//currentTime1: function() {</span></span>
<span class="javascript">                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">//返回一个时间戳</span></span>
                },
            },
        })
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<blockquote>
<p>说明：以下为自己学习时发现的<a href="https://www.cnblogs.com/melodyjerry/p/13782663.html" target="_blank" rel="noopener">踩坑记录</a>，不一定正确！！！</p>
<ul>
<li>调用<code>methods</code>里的方法,<code>得用()</code><ul>
<li><code>methods</code>是<code>方法</code></li>
</ul>
</li>
<li>调用<code>computed</code>的方法,<code>不能用()</code><ul>
<li><code>computed</code>是<code>计算属性</code>，是<code>属性</code></li>
</ul>
</li>
<li><code>methods</code>、<code>computed</code>中的方法名<code>不能重名</code>;重名后，<code>只会调用methods</code>中的方法</li>
</ul>
</blockquote>
<h2 id="3-进阶"><a href="#3-进阶" class="headerlink" title="3. 进阶"></a>3. 进阶</h2><p><code>currentTime2</code>里加个<code>this.message;</code>试试：</p>
<pre><code class="hljs js"><span class="hljs-comment">//计算属性</span>
computed: { <span class="hljs-comment">//methods、computed中的方法名不能重名;重名后，只会调用methods中的方法</span>
    currentTime2: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//currentTime1: function() {</span>
        <span class="hljs-keyword">this</span>.message;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">//返回一个时间戳</span>
    },
},</code></pre>

<p>到控制台里分别试试：</p>
<p><img src="https://s1.ax1x.com/2020/10/08/00j2KP.png" srcset="/blog/img/loading.gif" alt="00j2KP.png"></p>
<h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h2><p><code>调用方法时，每次都需要进行计算</code>，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢？</p>
<ul>
<li>此时就可以考虑<code>将这个结果缓存起来</code>，采用计算属性可以很方便的做到这一点，<strong>计算属性的<code>主要特性就是为了将不经常变化的计算结果进行缓存</code>，以节约我们的系统开销。</strong></li>
</ul>
<h1 id="十二、插槽slot：内容分发"><a href="#十二、插槽slot：内容分发" class="headerlink" title="十二、插槽slot：内容分发"></a>十二、插槽slot：内容分发</h1><blockquote>
<p>文档：<a href="https://cn.vuejs.org/v2/guide/components-slots.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/components-slots.html</a></p>
</blockquote>
<h2 id="1-什么是插槽"><a href="#1-什么是插槽" class="headerlink" title="1. 什么是插槽"></a>1. 什么是插槽</h2><p>Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="noopener">Web Components 规范草案</a>，将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口。</p>
<p>它允许你像这样合成组件：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/profile"</span>&gt;</span>
  Your Profile
<span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span></code></pre>

<p>然后你在 <code>&lt;navigation-link&gt;</code> 的模板中可能会写为：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span></span>
<span class="hljs-tag">  <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">"url"</span></span>
<span class="hljs-tag">  <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-link"</span></span>
<span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre>

<p>当组件渲染的时候，<code>&lt;slot&gt;&lt;/slot&gt;</code> 将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/profile"</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 添加一个 Font Awesome 图标 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-user"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  Your Profile
<span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span></code></pre>

<p>甚至其它的组件：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/profile"</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 添加一个图标的组件 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">font-awesome-icon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">font-awesome-icon</span>&gt;</span>
  Your Profile
<span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span></code></pre>

<p>如果 <code>&lt;navigation-link&gt;</code> 的 <code>template</code> 中<strong>没有</strong>包含一个 <code>&lt;slot&gt;</code> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。</p>
<h2 id="2-内容分发"><a href="#2-内容分发" class="headerlink" title="2. 内容分发"></a>2. 内容分发</h2><p>在 <code>Vue.js</code> 中我们使用 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口，作者称其为 插槽，可以应用在组合组件的场景中。</p>
<h2 id="3-实例-demo-1"><a href="#3-实例-demo-1" class="headerlink" title="3. 实例 demo"></a>3. 实例 demo</h2><ul>
<li>需求</li>
</ul>
<p>比如准备制作一个待办事项组件（todo），该组件由待办标题（todo-title）和待办内容（todo-items）组成，但这三个组件又是相互独立的，该如何操作呢？</p>
<ul>
<li>第一步: 定义一个待办事项的组件</li>
</ul>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 组件：todo --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>"&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">todo</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">todo</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
              
<span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">    Vue.component(<span class="hljs-string">'todo'</span>, {</span>
<span class="handlebars"><span class="xml">        template: '<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\</span></span>
<span class="handlebars"><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>待办事项<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\</span></span>
<span class="handlebars"><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\</span></span>
<span class="handlebars"><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Linux<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\</span></span>
<span class="handlebars"><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\</span></span>
<span class="handlebars"><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\</span></span>
<span class="handlebars"><span class="xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\</span></span>
<span class="handlebars"><span class="xml">                   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>'</span></span>
    });
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<ul>
<li>第二步: 我们需要让,待办事项的标题和值实现动态绑定,怎么做呢? 我们可以留出一个插槽!</li>
</ul>
<ol>
<li>将上面的代码留出一个插槽,即<code>&lt;slot&gt;</code>：</li>
</ol>
<pre><code class="hljs html">Vue.component('todo', {
    template: '<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\
                    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"todo-title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>\
                    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\
                        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"todo-items"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>\
                    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\
               <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>'
});</code></pre>

<ol start="2">
<li>定义一个名为 <code>todo-title</code> 的待办标题组件 和 <code>todo-items</code> 的待办内容组件：</li>
</ol>
<pre><code class="hljs js">Vue.component(<span class="hljs-string">'todo-title'</span>, {
    props: [<span class="hljs-string">'title'</span>],
    template: <span class="hljs-string">'&lt;div&gt;{{title}}&lt;/div&gt;'</span>
});
Vue.component(<span class="hljs-string">'todo-items'</span>, {
    <span class="hljs-comment">//这里的index,就是数组的下标,使用for循环遍历的时候,可以循环出来!</span>
    props: [<span class="hljs-string">'index'</span>, <span class="hljs-string">'item'</span>],
    template: <span class="hljs-string">'&lt;li&gt;{{index + 1}}. {{item}}&lt;/li&gt;'</span>,
});</code></pre>

<ol start="3">
<li>实例化 Vue 并初始化数据：</li>
</ol>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({
    el: <span class="hljs-string">'#app'</span>,
    data: {
        todoTitle: <span class="hljs-string">'Jerry学JavaWeb'</span>,
        todoItems: [<span class="hljs-string">'Linux'</span>, <span class="hljs-string">'Spring Boot'</span>, <span class="hljs-string">'Vue'</span>],
    }
});</code></pre>

<ol start="4">
<li>将这些值，通过插槽插入：</li>
</ol>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 组件：todo --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>"&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">todo</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">todo-title</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"todo-title"</span> </span>
<span class="hljs-tag">            <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"todoTitle"</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">todo-title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">todo-items</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"todo-items"</span> </span>
<span class="hljs-tag">            <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in todoItems"</span> </span>
<span class="hljs-tag">            <span class="hljs-attr">v-bind:item</span>=<span class="hljs-string">"item"</span> </span>
<span class="hljs-tag">            <span class="hljs-attr">v-bind:index</span>=<span class="hljs-string">"index"</span><span class="hljs-attr">:key</span>=<span class="hljs-string">"index"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">todo-items</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">todo-items</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">todo</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>

<blockquote>
<p>说明：</p>
<p>我们的 <code>todo-title</code> 和 <code>todo-items</code> 组件分别被分发到了 <code>todo</code> 组件的 <code>todo-title</code> 和 <code>todo-items</code> 插槽中。</p>
</blockquote>
<h1 id="十三、自定义事件"><a href="#十三、自定义事件" class="headerlink" title="十三、自定义事件"></a>十三、自定义事件</h1><blockquote>
<p>文档：<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/components-custom-events.html</a></p>
</blockquote>
<h2 id="1-什么是自定义事件"><a href="#1-什么是自定义事件" class="headerlink" title="1. 什么是自定义事件"></a>1. 什么是自定义事件</h2><p>通过上面”插槽slot：内容分发”的代码不难发现，数据项在Vue的实例中，但删除操作要在组件中完成，那么组件如何才能删除Vue实例中的数据呢？</p>
<p>此时就涉及到参数传递与事件分发了，Vue为我们提供了自定义事件的功能很好的帮助我们解决了这个问题：</p>
<ul>
<li>使用<code>this.$emit ('自定义事件名',参数)</code></li>
<li><img src="https://s1.ax1x.com/2020/10/09/0Dcjld.png" srcset="/blog/img/loading.gif" alt="0Dcjld.png"></li>
</ul>
<blockquote>
<pre><code class="hljs js"><span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'myEvent'</span>)</code></pre>

<p>则监听这个名字的 kebab-case 版本是不会有任何效果的：</p>
<pre><code class="hljs js">&lt;!-- 没有效果 --&gt;
&lt;my-component v-on:my-event=<span class="hljs-string">"doSomething"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span></span></code></pre>

<p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p>
<p>因此，我们推荐你<strong>始终使用 kebab-case 的事件名</strong>。</p>
</blockquote>
<h2 id="2-自定义组件的v-model"><a href="#2-自定义组件的v-model" class="headerlink" title="2. 自定义组件的v-model"></a>2. 自定义组件的v-model</h2><blockquote>
<blockquote>
<p>2.2.0+ 新增</p>
</blockquote>
<p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value" target="_blank" rel="noopener">不同的目的</a>。<code>model</code> 选项可以用来避免这样的冲突：</p>
<pre><code class="hljs js">Vue.component(<span class="hljs-string">'base-checkbox'</span>, {
  model: {
    prop: <span class="hljs-string">'checked'</span>,
    event: <span class="hljs-string">'change'</span>
  },
  props: {
    checked: <span class="hljs-built_in">Boolean</span>
  },
  template: <span class="hljs-string">`</span>
<span class="hljs-string">    &lt;input</span>
<span class="hljs-string">      type="checkbox"</span>
<span class="hljs-string">      v-bind:checked="checked"</span>
<span class="hljs-string">      v-on:change="$emit('change', $event.target.checked)"</span>
<span class="hljs-string">    &gt;</span>
<span class="hljs-string">  `</span>
})</code></pre>

<p>现在在这个组件上使用 <code>v-model</code> 的时候：</p>
<pre><code class="hljs js">&lt;base-checkbox v-model=<span class="hljs-string">"lovingVue"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">base-checkbox</span>&gt;</span></span></code></pre>

<p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的 property 将会被更新。</p>
<p>注意你仍然需要在组件的 <code>props</code> 选项里声明 <code>checked</code> 这个 prop。</p>
</blockquote>
<h2 id="3-实例-demo-2"><a href="#3-实例-demo-2" class="headerlink" title="3. 实例 demo"></a>3. 实例 demo</h2><ol>
<li>在vue的实例中,增加了 <code>methods</code> 对象并定义了一个名为 <code>removeTodoItems</code> 的方法：</li>
</ol>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({
    el: <span class="hljs-string">'#app'</span>,
    data: {
        todoTitle: <span class="hljs-string">'Jerry学JavaWeb'</span>,
        todoItems: [<span class="hljs-string">'Linux'</span>, <span class="hljs-string">'Spring Boot'</span>, <span class="hljs-string">'Vue'</span>],
    },
    methods: {
        <span class="hljs-comment">//该方法可以被模板中自定义事件触发</span>
        removeTodoItems: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"删除 "</span> + <span class="hljs-keyword">this</span>.todoItems[index] + <span class="hljs-string">" 成功"</span>);
            <span class="hljs-comment">// splice():方法 向/从 数组中 添加/删除 项目，然后返回被删除的项目，其中 index 为 添加/删除 项目的位置，1 表示删除的数量</span>
            <span class="hljs-keyword">this</span>.todoItems.splice(index, <span class="hljs-number">1</span>);
        }
    },
});</code></pre>

<ol start="2">
<li>修改 <code>todo-items</code>待办内容组件的代码，增加一个删除按钮，并且绑定事件：</li>
</ol>
<pre><code class="hljs js">Vue.component(<span class="hljs-string">'todo-items'</span>, {
    <span class="hljs-comment">//这里的index,就是数组的下标,使用for循环遍历的时候,可以循环出来!</span>
    props: [<span class="hljs-string">'index'</span>, <span class="hljs-string">'item'</span>],
    <span class="hljs-comment">// “:” 是指令 “v-bind”的缩写，“@”是指令“v-on”的缩写；“.”是修饰符</span>
    <span class="hljs-comment">//只能绑定当前组件的方法</span>
    template: <span class="hljs-string">'&lt;li&gt;&lt;button @click="remove_component"&gt;删除&lt;/button&gt; {{index + 1}}. {{item}}  &lt;/li&gt;'</span>,
    methods: {
        remove_component: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>{
            <span class="hljs-comment">//这里的 remove 是自定义事件的名称，需要在 HTML 中使用 v-on:remove 的方式指派</span>
            <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'remove'</span>, index);
        }
    }
});</code></pre>

<ol start="3">
<li>修改 <code>todo-items</code> 待办内容组件的 HTML 代码,增加一个自定义事件,比如叫 <code>remove</code>,可以和组件的方法绑定,然后绑定到vue的方法中：</li>
</ol>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!--增加了 v-on:remove="removeTodoItems(index)" 自定义事件，该事件会调用 Vue 实例中定义的名为 removeTodoItems 的方法--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">todo-items</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"todo-items"</span> </span>
<span class="hljs-tag">    <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in todoItems"</span> </span>
<span class="hljs-tag">    <span class="hljs-attr">v-bind:item</span>=<span class="hljs-string">"item"</span> </span>
<span class="hljs-tag">    <span class="hljs-attr">v-bind:index</span>=<span class="hljs-string">"index"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">v-on:remove</span>=<span class="hljs-string">"removeTodoItems(index)"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">todo-items</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">todo-items</span>&gt;</span></code></pre>

<ul>
<li>完整代码：</li>
</ul>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 组件：todo --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>"&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">todo</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">todo-title</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"todo-title"</span> </span>
<span class="hljs-tag">                <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"todoTitle"</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">todo-title</span>&gt;</span>

            <span class="hljs-comment">&lt;!--增加了 v-on:remove="removeTodoItems(index)" 自定义事件，该事件会调用 Vue 实例中定义的名为 removeTodoItems 的方法--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">todo-items</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"todo-items"</span> </span>
<span class="hljs-tag">                <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in todoItems"</span> </span>
<span class="hljs-tag">                <span class="hljs-attr">v-bind:item</span>=<span class="hljs-string">"item"</span> </span>
<span class="hljs-tag">                <span class="hljs-attr">v-bind:index</span>=<span class="hljs-string">"index"</span></span>
<span class="hljs-tag">                <span class="hljs-attr">v-on:remove</span>=<span class="hljs-string">"removeTodoItems(index)"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">todo-items</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">todo-items</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">todo</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="actionscript">        Vue.component(<span class="hljs-string">'todo'</span>, {</span>
<span class="handlebars"><span class="xml">            template: '<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\</span></span>
<span class="handlebars"><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"todo-title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>\</span></span>
<span class="handlebars"><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\</span></span>
<span class="handlebars"><span class="xml">                            <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"todo-items"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>\</span></span>
<span class="handlebars"><span class="xml">                        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\</span></span>
<span class="handlebars"><span class="xml">                       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>'</span></span>
        });
<span class="actionscript">        Vue.component(<span class="hljs-string">'todo-title'</span>, {</span>
<span class="actionscript">            props: [<span class="hljs-string">'title'</span>], <span class="hljs-comment">//props传递参数不能使用驼峰命名法则，不然数据没法渲染到页面上</span></span>
<span class="handlebars"><span class="xml">            template: '<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">{{title}}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>'</span></span>
        });
<span class="actionscript">        Vue.component(<span class="hljs-string">'todo-items'</span>, {</span>
<span class="actionscript">            <span class="hljs-comment">//这里的index,就是数组的下标,使用for循环遍历的时候,可以循环出来!</span></span>
<span class="actionscript">            props: [<span class="hljs-string">'index'</span>, <span class="hljs-string">'item'</span>],</span>
<span class="actionscript">            <span class="hljs-comment">// “:” 是指令 “v-bind”的缩写，“@”是指令“v-on”的缩写；“.”是修饰符</span></span>
<span class="actionscript">            <span class="hljs-comment">//只能绑定当前组件的方法</span></span>
<span class="handlebars"><span class="xml">            template: '<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"remove_component"</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> </span><span class="hljs-template-variable">{{index + 1}}</span><span class="xml">. </span><span class="hljs-template-variable">{{item}}</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>',</span></span>
            methods: {
<span class="actionscript">                remove_component: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index)</span> </span>{</span>
<span class="actionscript">                    <span class="hljs-comment">//这里的 remove 是自定义事件的名称，需要在 HTML 中使用 v-on:remove 的方式指派</span></span>
<span class="actionscript">                    <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'remove'</span>, index);</span>
                }
            }
        });
        
<span class="actionscript">        <span class="hljs-comment">//再实例化</span></span>
<span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span>
<span class="actionscript">            el: <span class="hljs-string">'#app'</span>,</span>
            data: {
<span class="actionscript">                todoTitle: <span class="hljs-string">'Jerry学JavaWeb'</span>,</span>
<span class="actionscript">                todoItems: [<span class="hljs-string">'Linux'</span>, <span class="hljs-string">'Spring Boot'</span>, <span class="hljs-string">'Vue'</span>],</span>
            },
            methods: {
<span class="actionscript">                <span class="hljs-comment">//该方法可以被模板中自定义事件触发</span></span>
<span class="actionscript">                removeTodoItems: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index)</span> </span>{</span>
<span class="javascript">                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"删除 "</span> + <span class="hljs-keyword">this</span>.todoItems[index] + <span class="hljs-string">" 成功"</span>);</span>
<span class="actionscript">                    <span class="hljs-comment">// splice():方法 向/从 数组中 添加/删除 项目，然后返回被删除的项目，其中 index 为 添加/删除 项目的位置，1 表示删除的数量</span></span>
<span class="actionscript">                    <span class="hljs-keyword">this</span>.todoItems.splice(index, <span class="hljs-number">1</span>);</span>
                }
            },
        });
    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<h1 id="十四、入门小结"><a href="#十四、入门小结" class="headerlink" title="十四、入门小结"></a>十四、入门小结</h1><ul>
<li><p>Vue遵循<code>Soc关注度分离原则</code></p>
</li>
<li><p>是<code>纯粹的视图层框架</code></p>
</li>
<li><p>并<code>不包含AJAX之类的通信功能</code></p>
<ul>
<li>为了解决通信问题，需要<code>使用Axios框架做异步通信</code></li>
</ul>
</li>
<li><p>Vue 的<code>核心库只关注视图层</code>，方便与第三方库或既有项目整合</p>
</li>
<li><p>HTML + CSS + JS : 视图： <code>给用户看，刷新后台给的数据</code></p>
</li>
</ul>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li>数据驱动</li>
<li>组件化</li>
<li>虚拟DOM</li>
</ul>
<h2 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h2><ul>
<li>借鉴了<code>AngulaJS</code>的<code>模块化</code>开发</li>
<li>借鉴了<code>React</code>的<code>虚拟DOM</code><ul>
<li><code>虚拟DOM</code>：把DOM操作放到内存中执行</li>
</ul>
</li>
</ul>
<h2 id="常用的属性"><a href="#常用的属性" class="headerlink" title="常用的属性"></a>常用的属性</h2><ul>
<li><code>v-if</code><ul>
<li><code>v-else-if</code></li>
<li><code>v-else</code></li>
</ul>
</li>
<li><code>v-for</code></li>
<li><code>v-on</code> : 绑定事件 , 简写为<code>@</code></li>
<li><code>v-model</code> : 数据双向绑定</li>
<li><code>v-bind</code> : 给组件绑定参数，简写为 <code>:</code></li>
</ul>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><ul>
<li>组合组件 <code>slot</code> ：插槽</li>
<li>组件内部绑定事件需要使用到 <code>this.$emit("事件名",参数);</code></li>
<li><code>计算属性</code>的特色：<code>缓存计算数据</code></li>
</ul>
<h2 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h2><blockquote>
<p>图源：<a href="https://blog.csdn.net/github_37516320/article/details/78321391" target="_blank" rel="noopener">https://blog.csdn.net/github_37516320/article/details/78321391</a></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/10/12/0Wttk8.png" srcset="/blog/img/loading.gif" alt="0Wttk8.png"></p>
<h2 id="SoC-关注度分离原则"><a href="#SoC-关注度分离原则" class="headerlink" title="SoC 关注度分离原则"></a>SoC 关注度分离原则</h2><blockquote>
<p>内容摘自：<a href="https://www.cnblogs.com/wenhongyu/archive/2017/12/06/7992028.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenhongyu/archive/2017/12/06/7992028.html</a></p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>关注点分离（Separation of concerns，SOC）是对只与“特定概念、目标”(关注点)相关联的软件组成部分进行“标识、封装和操纵”的能力，即标识、封装和操纵关注点的能力。</p>
</li>
<li><p>是处理复杂性的一个原则。由于关注点混杂在一起会导致复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。</p>
</li>
<li><p>关注点分离是面向方面的程序设计的核心概念。分离关注点使得解决特定领域问题的代码从业务逻辑中独立出来。</p>
</li>
<li><p>业务逻辑的代码中不再含有针对特定领域问题代码的调用(将针对特定领域问题代码抽象化成较少的程式码，例如将代码封装成function或是class)，业务逻辑同特定领域问题的关系通过侧面来封装、维护，这样原本分散在整个应用程序中的变动就可以很好的管理起来。</p>
</li>
</ul>
<h3 id="具体说明（概念比较难理解）"><a href="#具体说明（概念比较难理解）" class="headerlink" title="具体说明（概念比较难理解）"></a>具体说明（概念比较难理解）</h3><ol>
<li>好的架构设计必须把变化点错落有致地封装到软件系统的不同部分。要做到这一点，必须进行关注点分离。</li>
<li>好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。</li>
<li>即使需要改变，也能够清晰地识别出那些部分需要改变。</li>
<li>如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。</li>
</ol>
<h3 id="上述论述中的四句话总结"><a href="#上述论述中的四句话总结" class="headerlink" title="上述论述中的四句话总结"></a>上述论述中的四句话总结</h3><ul>
<li>“系统中的一个部分发生了变化，不会影响其他部分。”</li>
<li>“即使需要改变，也能够清晰地识别出那些部分需要改变。”</li>
<li>“如果需要扩展架构，将影响最小化，已经可以工作的每个部分都将继续工作。”</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/10/09/0rgeq1.png" srcset="/blog/img/loading.gif" alt="0rgeq1.png"></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>关注点分离原则不仅体现在问题求解、算法设计、软件设计等设计方法中，同时也体现在软件开发过程、软件项目管理以及软件开发方法学等诸多方。</li>
<li>在某种意义上，正是对软件开发不同关注点的分离视角和关注重点的差别，导致了软件开发技术和开发方法的演变和发展。</li>
</ul>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><p>大神们说，Vue的实际开发都是：</p>
<ul>
<li>基于 <code>NodeJS</code></li>
<li>实际采用 <code>vue-cli</code>脚手架</li>
<li>网络通信 ： <code>axios</code></li>
<li>页面跳转、路由用 <code>vue-router</code></li>
<li>状态管理用 <code>vuex</code></li>
<li>UI 界面<ul>
<li><code>Element UI</code>（饿了么出品）</li>
<li><code>ICE</code>（阿里巴巴出品）</li>
</ul>
</li>
</ul>
<h1 id="十五、Vue生命周期"><a href="#十五、Vue生命周期" class="headerlink" title="十五、Vue生命周期"></a>十五、Vue生命周期</h1><blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">官方文档</a></p>
<p><a href="https://segmentfault.com/a/1190000020173042" target="_blank" rel="noopener">参考文章</a>：<a href="https://segmentfault.com/a/1190000020173042" target="_blank" rel="noopener">①</a>、<a href="https://blog.csdn.net/qq_15766181/article/details/73549933" target="_blank" rel="noopener">②</a>、<a href="https://blog.csdn.net/Meuan/article/details/104765843" target="_blank" rel="noopener">③带注释</a></p>
</blockquote>
<p>​    Vue 实例有一个完整的生命周期，也就是<code>从开始创建、初始化数据、编译模板、挂载 DOM、渲染→更新→渲染、卸载等一系列过程</code>，我们称这是 <code>Vue 的生命周期</code>。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。</p>
<p>​    在 Vue 的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册 JS 方法，可以让我们用自己注册的 JS 方法控制整个大局，在这些事件响应方法中的 this 直接指向的是 Vue 的实例。</p>
<ul>
<li><img src="https://s1.ax1x.com/2020/10/08/0wh48e.png" srcset="/blog/img/loading.gif" alt="0wh48e.png"></li>
</ul>
<ul>
<li><img src="https://s1.ax1x.com/2020/10/08/0w4Kq1.png" srcset="/blog/img/loading.gif" alt="0w4Kq1.png"></li>
</ul>
<h1 id="十六、Vue-CLI-脚手架"><a href="#十六、Vue-CLI-脚手架" class="headerlink" title="十六、Vue CLI 脚手架"></a>十六、Vue CLI 脚手架</h1><blockquote>
<p>🛠️ Vue.js 开发的标准工具</p>
</blockquote>
<h2 id="1-什么是vue-cli"><a href="#1-什么是vue-cli" class="headerlink" title="1. 什么是vue-cli"></a>1. 什么是vue-cli</h2><ul>
<li>官方提供的一个脚手架，用于快速生成一个 vue 的项目模板</li>
</ul>
<blockquote>
<p>预先定义好的目录结构及基础代码，就好比咱们在创建 Maven 项目时可以选择创建一个骨架项目，这个骨架项目就是脚手架，我们的开发更加的快速。</p>
</blockquote>
<h2 id="2-主要功能特点"><a href="#2-主要功能特点" class="headerlink" title="2. 主要功能特点"></a>2. 主要功能特点</h2><ul>
<li>统一的目录结构</li>
<li>本地调试</li>
<li>热部署</li>
<li>单元测试</li>
<li>集成打包上线</li>
<li>功能丰富</li>
<li>易于扩展</li>
<li>无需 Eject</li>
</ul>
<h2 id="3-环境安装"><a href="#3-环境安装" class="headerlink" title="3. 环境安装"></a>3. 环境安装</h2><ul>
<li><p>Node.js：<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></p>
<ul>
<li><p>新版本都自带<code>npm</code></p>
</li>
<li><p>npm：一个软件包管理工具，类似于Linux的<code>apt</code></p>
</li>
<li><blockquote>
<p><em>npm</em> 是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。通过 <em>npm</em> 可以安装、共享、分发代码,管理项目依赖关系。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Git：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p>
<ul>
<li>淘宝镜像：<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/git-for-windows/</a></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>检查Node.js安装是否成功：<ul>
<li>cmd 下输入 <code>node -v</code>,打印出版本号即可!</li>
<li>cmd 下输入 <code>npm-v</code>,打印出版本号即可!</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>安装 Node.js 淘宝镜像加速器（cnpm）:<ul>
<li>提高下载速度</li>
</ul>
</li>
</ul>
<pre><code class="hljs bash"><span class="hljs-comment"># -g 就是全局安装</span>
npm install cnpm -g

<span class="hljs-comment"># 若安装失败，则将源npm源换成淘宝镜像</span>
<span class="hljs-comment"># 因为npm安装插件是从国外服务器下载，受网络影响大</span>
npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org

<span class="hljs-comment"># 然后再执行</span>
npm install cnpm -g</code></pre>

<blockquote>
<p>一般的安装的位置：C:\Users\Administrator\AppData\Roaming\npm</p>
</blockquote>
<h2 id="4-安装vue-cli"><a href="#4-安装vue-cli" class="headerlink" title="4. 安装vue-cli"></a>4. 安装vue-cli</h2><ul>
<li>三选一：</li>
</ul>
<pre><code class="hljs bash"><span class="hljs-comment"># 安装了cnpm</span>
cnpm install vue-cli -g
<span class="hljs-comment"># 没安装cnpm</span>
npm install -g @vue/cli
<span class="hljs-comment"># 或者</span>
yarn global add @vue/cli</code></pre>

<ul>
<li>查看是否安装成功<pre><code class="hljs bash"><span class="hljs-comment"># 查看是否安装成功</span>
vue list</code></pre>

</li>
</ul>
<hr>
<h3 id="安装版本的问题"><a href="#安装版本的问题" class="headerlink" title="安装版本的问题"></a>安装版本的问题</h3><p><img src="https://s1.ax1x.com/2020/10/11/0goO2j.png" srcset="/blog/img/loading.gif" alt="0goO2j.png"></p>
<p>按照提示的信息：</p>
<pre><code class="hljs bash"><span class="hljs-comment"># 先卸载当前版本</span>
npm uninstall -g vue-cli

<span class="hljs-comment"># 安装新的包</span>
npm install -g @vue/cli</code></pre>

<pre><code class="hljs bash"><span class="hljs-comment"># 检查版本</span>
vue --version
❯ @vue/cli 4.5.7</code></pre>

<hr>
<p><strong>为什么呢？</strong></p>
<p>因为根据官方文档，需要升级Vue CLI的版本到3以上。</p>
<blockquote>
<p><a href="https://cli.vuejs.org/zh/guide/installation.html" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/installation.html</a></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/10/11/0gT3zd.png" srcset="/blog/img/loading.gif" alt="0gT3zd.png"></p>
<h2 id="5-第一个vue-cli程序"><a href="#5-第一个vue-cli程序" class="headerlink" title="5. 第一个vue-cli程序"></a>5. 第一个vue-cli程序</h2><ol>
<li>使用两种不同方式去创建<code>vue-cli</code>项目：</li>
</ol>
<ul>
<li><code>vue create name</code></li>
<li><code>vue init webpack name</code>：基于<code>WebPage</code>模板</li>
</ul>
<blockquote>
<ul>
<li><p><code>ES5 (全浏览器支持)</code></p>
</li>
<li><p><code>ES6 (常用，当前主流版本: webpack打包成为ES5支持! )</code></p>
</li>
</ul>
</blockquote>
<p>不管是哪种创建方式，都先是安装环境依赖<code>npm install</code>，最后运行的命令都是：</p>
<ul>
<li><code>npm run dev</code></li>
</ul>
<blockquote>
<p><code>npm run dev</code>不行，就试试<code>npm run serve</code>或<code>npm run start</code></p>
<p>至于为什么，看这篇文章：<a href="https://www.cnblogs.com/melodyjerry/p/13801535.html" target="_blank" rel="noopener">npm run dev 报错：missing script:dev</a></p>
</blockquote>
<h3 id="5-1-vue-create"><a href="#5-1-vue-create" class="headerlink" title="5.1 vue create"></a>5.1 vue create</h3><ol>
<li>终端使用命令，直接创建第一个vue-cli项目：</li>
</ol>
<pre><code class="hljs bash">vue create myvue</code></pre>

<ol start="2">
<li>然后，会被提示选取一个 preset：</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/10/11/0g7UXR.png" srcset="/blog/img/loading.gif" alt="0g7UXR.png"></p>
<blockquote>
<p>你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。甚至是最新的Vue 3.0 beta。</p>
<p>这个默认的设置非常适合快速创建一个新项目的原型，而手动设置则提供了更多的选项，它们是面向生产的项目更加需要的。</p>
<p><img src="https://s1.ax1x.com/2020/10/11/0gHt58.png" srcset="/blog/img/loading.gif" alt="0gHt58.png"></p>
</blockquote>
<ol start="3">
<li>选择Vue 2的默认配置选项：</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/10/11/0g7c1H.png" srcset="/blog/img/loading.gif" alt="0g7c1H.png"></p>
<hr>
<ol start="4">
<li>初始化并执行：</li>
</ol>
<pre><code class="hljs bash"><span class="hljs-built_in">cd</span> myvue
npm install
npm run dev <span class="hljs-comment">#不行就npm run serve</span></code></pre>

<p><img src="https://s1.ax1x.com/2020/10/12/0R6hz6.png" srcset="/blog/img/loading.gif" alt="0R6hz6.png"></p>
<h3 id="5-2-vue-init-webpack"><a href="#5-2-vue-init-webpack" class="headerlink" title="5.2 vue init webpack"></a>5.2 vue init webpack</h3><ol>
<li>终端使用命令，直接创建第一个vue-cli（基于<code>WebPage</code>模板）项目：</li>
</ol>
<pre><code class="hljs bash">vue init webpack mywebpack</code></pre>

<table>
<thead>
<tr>
<th>提示</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Project name</td>
<td>项目名称，默认 回车 即可</td>
</tr>
<tr>
<td>Project description</td>
<td>项目描述，默认 回车 即可</td>
</tr>
<tr>
<td>Author</td>
<td>项目作者，默认 回车 即可</td>
</tr>
<tr>
<td>Runtime + Compiler</td>
<td>运行时编译</td>
</tr>
<tr>
<td>Install vue-router</td>
<td>是否安装 vue-router？选择 n 不安装（后期需要再手动添加）</td>
</tr>
<tr>
<td>Use ESLint to lint your code</td>
<td>是否使用 ESLint 做代码检查？选择 n 不安装（后期需要再手动添加）</td>
</tr>
<tr>
<td>Set up unit tests</td>
<td>单元测试相关，选择 n 不安装（后期需要再手动添加）</td>
</tr>
<tr>
<td>Setup e2e tests with Nightwatch</td>
<td>单元测试相关，选择 n 不安装（后期需要再手动添加）</td>
</tr>
<tr>
<td>Should we run npm install for you after the project has been created</td>
<td>创建完成后直接初始化？选择 n，我们手动执行</td>
</tr>
</tbody></table>
<blockquote>
<p>一路选择 n ，主要是自己手动实践去完成这些模块。</p>
</blockquote>
<hr>
<ol start="2">
<li>初始化并执行：</li>
</ol>
<pre><code class="hljs bash"><span class="hljs-built_in">cd</span> mywebpack
npm install (or <span class="hljs-keyword">if</span> using yarn: yarn)
npm run dev</code></pre>

<p><img src="https://s1.ax1x.com/2020/10/12/0Rgy59.png" srcset="/blog/img/loading.gif" alt="0Rgy59.png"></p>
<h3 id="5-3-执行运行"><a href="#5-3-执行运行" class="headerlink" title="5.3 执行运行"></a>5.3 执行运行</h3><ol>
<li>不管是哪种创建方式，都先是安装环境依赖<code>npm install</code>；</li>
<li>最后运行的命令都是：</li>
</ol>
<ul>
<li><code>npm run dev</code></li>
</ul>
<blockquote>
<p><code>npm run dev</code>不行，就试试<code>npm run serve</code>或<code>npm run start</code></p>
<p>至于为什么，看这篇文章：<a href="https://www.cnblogs.com/melodyjerry/p/13801535.html" target="_blank" rel="noopener">npm run dev 报错：missing script:dev</a></p>
</blockquote>
<blockquote>
<p>Vue CLI在安装模块依赖的时候，会有些警告或报错，都会有提示为什么，然后使用什么命令去修复。</p>
<p><img src="https://s1.ax1x.com/2020/10/12/0R2NIH.png" srcset="/blog/img/loading.gif" alt="0R2NIH.png"></p>
</blockquote>
<ol start="3">
<li>访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>  ：</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/10/12/0RWUgI.png" srcset="/blog/img/loading.gif" alt="0RWUgI.png"></p>
<h2 id="6-Vue-cli目录结构"><a href="#6-Vue-cli目录结构" class="headerlink" title="6. Vue-cli目录结构"></a>6. Vue-cli目录结构</h2><blockquote>
<p>后面的文章<strong>主要是介绍了<code>src</code>文件夹的内容</strong>，<em>其他目录结构，搭配视频食用：</em><a href="https://www.bilibili.com/video/BV18E411a7mC?p=13" target="_blank" rel="noopener">https://www.bilibili.com/video/BV18E411a7mC?p=13</a></p>
</blockquote>
<p>先看看两种方式创建的项目目录结构：</p>
<p><img src="https://s1.ax1x.com/2020/10/12/0WEIc4.png" srcset="/blog/img/loading.gif" alt="0WEIc4.png"></p>
<h3 id="6-1-结构说明"><a href="#6-1-结构说明" class="headerlink" title="6.1 结构说明"></a>6.1 结构说明</h3><ul>
<li><code>build</code>和 <code>config</code>：WebPack 配置文件</li>
<li><code>node_modules</code>：用于存放 npm install 安装的依赖文件</li>
<li><code>src</code>： 项目源码目录</li>
<li><code>static</code>：静态资源文件</li>
<li><code>.babelrc</code>：Babel 配置文件，主要作用是将 ES6 转换为 ES5</li>
<li><code>.editorconfig</code>：编辑器配置</li>
<li><code>eslintignore</code>：需要忽略的语法检查配置文件</li>
<li><code>.gitignore</code>：git 忽略的配置文件</li>
<li><code>.postcssrc.js</code>：css 相关配置文件，其中内部的 module.exports 是 NodeJS 模块化语法</li>
<li><code>index.html</code>：首页，仅作为模板页，实际开发时不使用</li>
<li><code>package.json</code>：项目的配置文件<ul>
<li><code>name</code>：项目名称</li>
<li><code>version</code>：项目版本</li>
<li><code>description</code>：项目描述</li>
<li><code>author</code>：项目作者</li>
<li><code>scripts</code>：封装常用命令</li>
<li><code>dependencies</code>：生产环境依赖</li>
<li><code>devDependencies</code>：开发环境依赖</li>
</ul>
</li>
</ul>
<h3 id="6-2-src源码目录"><a href="#6-2-src源码目录" class="headerlink" title="6.2 src源码目录"></a>6.2 src源码目录</h3><p>上述两种创建方式，初始化创建的src源码文件夹中文件全是一样的，都含有这三个关键的文件：<code>main.js</code>、<code>App.vue</code>、<code>HelloWorld.vue</code>。但是内容会有小些不同。</p>
<ul>
<li><code>src</code> 目录是项目的源码目录，所有代码都会写在这里<ul>
<li>图片等资源文件都存放在<code>assets</code>文件夹</li>
<li>所有自定义组件都存放在<code>component</code>文件夹</li>
</ul>
</li>
</ul>
<blockquote>
<p>VUE中assets与static的区别：</p>
<p><a href="https://www.jianshu.com/p/8341edbc7436" target="_blank" rel="noopener">https://www.jianshu.com/p/8341edbc7436</a></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/10/12/0WVmvQ.png" srcset="/blog/img/loading.gif" alt="0WVmvQ.png"></p>
<hr>
<p>下面主要介绍的是WebPack项目的<code>main.js</code>、<code>App.vue</code>、<code>HelloWorld.vue</code>文件。</p>
<h4 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h4><ul>
<li>项目的入口文件，我们知道所有的程序都会有一个入口</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// The Vue build version to load with the `import` command</span>
<span class="hljs-comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span>
<span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>

Vue.config.productionTip = <span class="hljs-literal">false</span>

<span class="hljs-comment">/* eslint-disable no-new */</span>
<span class="hljs-keyword">new</span> Vue({
  el: <span class="hljs-string">'#app'</span>,
  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)
})
<span class="hljs-comment">/*</span>
<span class="hljs-comment">new Vue({</span>
<span class="hljs-comment">  render: h =&gt; h(App),</span>
<span class="hljs-comment">}).$mount('#app')</span>
<span class="hljs-comment">*/</span></code></pre>

<ul>
<li><code>import Vue from 'vue'</code>：ES6 写法，会被转换成 <code>require(“vue”);</code> （<code>require</code> 是 <code>NodeJS</code> 提供的模块加载器）</li>
<li><code>import App from './App'</code>：意思同上，但是指定了查找路径，<code>./</code> 为当前目录</li>
<li><code>Vue.config.productionTip = false</code>：关闭浏览器控制台关于环境的相关提示</li>
<li><code>new Vue({...})</code>：实例化 Vue</li>
<li><code>el: '#app'</code>：查找 <code>index.html</code> 中 <code>id</code> 为 <code>app</code> 的元素</li>
<li><code>render: h =&gt; h(App)</code>：<code>render</code>是一个方法，自带一个形参<code>createElement</code><em>（就是h,一个形参，没有具体意义，可以随意改变书写）</em>，这个参数也是一个方法，是用来创建<code>vue 节点</code>的，也就是<code>html模板</code>的，然后<code>渲染(render)到指定的节点上</code>。<ul>
<li>跟 <code>template</code> 一样都是创建 html 模板的；</li>
<li>但是有些场景中用 <code>template</code> 实现起来代码冗长繁琐而且有大量重复，这时候就可以用 <code>render 函数</code>。</li>
<li>详见：<a href="https://cn.vuejs.org/v2/api/#render" target="_blank" rel="noopener">官方文档</a>和<a href="https://blog.csdn.net/playboyanta123/article/details/99675795" target="_blank" rel="noopener">文章①</a>和<a href="https://blog.csdn.net/sansan_7957/article/details/83014838" target="_blank" rel="noopener">文章②</a></li>
</ul>
</li>
<li><code>.$mount('#app')</code>：<code>手动挂载</code>，挂载到制定的页面节点（<code>index.html</code> 中 <code>id</code> 为 <code>app</code> 的元素）。在项目中可用于延时挂载（例如在挂载之前要进行一些其他操作、判断等），之后要手动挂载上。<code>new Vue</code>时，<code>el</code>和<code>$mount</code><strong>并没有本质上的不同。</strong></li>
</ul>
<blockquote>
<p>可能有的其他参数信息：</p>
<ul>
<li><p><code>template: '&lt;App/&gt;'</code>：模板，模板将会<strong>替换</strong>挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。</p>
</li>
<li><p><code>components: { App }</code>：引入组件，使用的是 <code>import App from './App'</code> 定义的 App 组件</p>
</li>
</ul>
</blockquote>
<h4 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h4><pre><code class="hljs vue">&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;img alt="Vue logo" src="./assets/logo.png"&gt;
    &lt;HelloWorld msg="Welcome to Your Vue.js App"/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import HelloWorld from './components/HelloWorld.vue'

export default {
  name: 'App',
  components: {
    HelloWorld
  }
}
&lt;/script&gt;

&lt;style&gt;
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
&lt;/style&gt;</code></pre>

<ul>
<li><code>template</code>：模板，将会<strong>替换</strong>挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。</li>
<li><code>import HelloWorld from './components/HelloWorld.vue'</code>：引入 HelloWorld 组件，用于替换 template 中的 HelloWorld 标签</li>
<li><code>export default {…}</code>：导出 NodeJS 对象，作用是可以通过 import 关键字导入<ul>
<li><code>name: 'App'</code>：定义组件的名称</li>
<li><code>components: { HelloWorld }</code>：定义子组件</li>
</ul>
</li>
</ul>
<h4 id="component-HelloWorld-vue"><a href="#component-HelloWorld-vue" class="headerlink" title="component/HelloWorld.vue"></a>component/HelloWorld.vue</h4><ul>
<li>定义了<code>&lt;HelloWorld&gt;</code>组件</li>
<li>所有自定义组件都存放在<code>component</code>文件夹</li>
</ul>
<pre><code class="hljs vue">&lt;template&gt;
  &lt;div class="hello"&gt;
    &lt;h1&gt;{{ msg }}&lt;/h1&gt;
    &lt;p&gt;
      For a guide and recipes on how to configure / customize this project,&lt;br&gt;
      check out the
      &lt;a href="https://cli.vuejs.org" target="_blank" rel="noopener"&gt;vue-cli documentation&lt;/a&gt;.
    &lt;/p&gt;
    &lt;h3&gt;Installed CLI Plugins&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href="https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-babel" target="_blank" rel="noopener"&gt;babel&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-eslint" target="_blank" rel="noopener"&gt;eslint&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;Essential Links&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href="https://vuejs.org" target="_blank" rel="noopener"&gt;Core Docs&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="https://forum.vuejs.org" target="_blank" rel="noopener"&gt;Forum&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="https://chat.vuejs.org" target="_blank" rel="noopener"&gt;Community Chat&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="https://twitter.com/vuejs" target="_blank" rel="noopener"&gt;Twitter&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="https://news.vuejs.org" target="_blank" rel="noopener"&gt;News&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;Ecosystem&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href="https://router.vuejs.org" target="_blank" rel="noopener"&gt;vue-router&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="https://vuex.vuejs.org" target="_blank" rel="noopener"&gt;vuex&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="https://github.com/vuejs/vue-devtools#vue-devtools" target="_blank" rel="noopener"&gt;vue-devtools&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="https://vue-loader.vuejs.org" target="_blank" rel="noopener"&gt;vue-loader&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="https://github.com/vuejs/awesome-vue" target="_blank" rel="noopener"&gt;awesome-vue&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'HelloWorld',
  props: {
    msg: String
  }
}
&lt;/script&gt;

&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;
&lt;style scoped&gt;
h3 {
  margin: 40px 0 0;
}
ul {
  list-style-type: none;
  padding: 0;
}
li {
  display: inline-block;
  margin: 0 10px;
}
a {
  color: #42b983;
}
&lt;/style&gt;</code></pre>

<h1 id="十七、Webpack"><a href="#十七、Webpack" class="headerlink" title="十七、Webpack"></a>十七、Webpack</h1><p><img src="https://s1.ax1x.com/2020/10/13/0hxIp9.png" srcset="/blog/img/loading.gif" alt="0hxIp9.png"></p>
<p>从图中我们可以看出，<code>Webpack</code> 可以将多种静态资源 <code>js</code>、<code>css</code>、<code>less</code> 转换成一个静态文件，减少了页面的请求。</p>
<h2 id="1-什么是Webpack"><a href="#1-什么是Webpack" class="headerlink" title="1. 什么是Webpack"></a>1. 什么是Webpack</h2><ul>
<li><code>Webpack</code> 是一款<code>模块加载器兼打包工具</code>，它能把各种资源，如 JS、JSX、ES6、SASS、LESS、图片等都<code>作为模块</code>来处理和使用。</li>
</ul>
<p>​        <code>本质上，webpack是一个现代JavaScript应用程序的静态模块打包器(module bundler)</code>。当webpack处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)<em>（类似于Maven）</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个<code>bundle</code>。</p>
<blockquote>
<p>​        Webpack是当下最热门的前端资源模块化管理和打包工具，它可以将许多松散耦合的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分离，等到实际需要时再异步加载。通过<code>loader</code>转换，任何形式的资源都可以当做模块，比如CommonsJS、AMD、ES6、 CSS、JSON、CoffeeScript、LESS等;<br>     伴随着移动互联网的大潮，当今越来越多的网站已经从网页模式进化到了WebApp模式。它们运行在现代浏览器里，使用HTML5、CSS3、ES6 等新的技术来开发丰富的功能，网页已经不仅仅是完成浏览器的基本需求; WebApp通常是一个SPA (单页面应用) ，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的JS代码，这给前端的开发流程和资源组织带来了巨大挑战。<br>     前端开发和其他开发工作的主要区别，首先是前端基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器的，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。</p>
</blockquote>
<h2 id="2-模块化的演进"><a href="#2-模块化的演进" class="headerlink" title="2. 模块化的演进"></a>2. 模块化的演进</h2><h3 id="2-1-Script标签"><a href="#2-1-Script标签" class="headerlink" title="2.1 Script标签"></a>2.1 Script标签</h3><pre><code class="hljs js">&lt;script src = <span class="hljs-string">"module1.js"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
&lt;script src = <span class="hljs-string">"module2.js"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
&lt;script src = <span class="hljs-string">"module3.js"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre>

<p>​        这是最原始的JavaScript文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在window对象中，不同模块的调用都是一个作用域。</p>
<p><strong>缺点</strong>：</p>
<p>这种原始的加载方式暴露了一些显而易见的弊端：</p>
<ul>
<li>全局作用域下容易造成变量冲突</li>
<li>文件只能按照<code>&lt;script&gt;</code>的书写顺序进行加载</li>
<li>开发人员必须主观解决模块和代码库的依赖关系</li>
<li>在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪</li>
</ul>
<h3 id="2-2-CommonsJS"><a href="#2-2-CommonsJS" class="headerlink" title="2.2 CommonsJS"></a>2.2 CommonsJS</h3><p>服务器端的NodeJS遵循CommonsJS规范，该规范核心思想是允许模块通过require方法来同步加载所需依赖的其它模块，然后通过exports或module.exports来导出需要暴露的接口。</p>
<pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">"module"</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">"../module.js"</span>);
<span class="hljs-keyword">export</span>.doStuff = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{};
<span class="hljs-built_in">module</span>.exports = someValue;</code></pre>

<p><strong>优点：</strong></p>
<ul>
<li>服务器端模块便于重用</li>
<li>NPM中已经有超过45万个可以使用的模块包</li>
<li>简单易用</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的</li>
<li>不能非阻塞的并行加载多个模块</li>
</ul>
<p><strong>实现：</strong></p>
<ul>
<li>服务端的NodeJS</li>
<li>•Browserify，浏览器端的CommonsJS实现，可以使用NPM的模块，但是编译打包后的文件体积较大</li>
<li>modules-webmake，类似Browserify，但不如Browserify灵活</li>
<li>wreq，Browserify的前身</li>
</ul>
<h3 id="2-3-AMD"><a href="#2-3-AMD" class="headerlink" title="2.3 AMD"></a>2.3 AMD</h3><p>Asynchronous Module Definition规范其实主要一个主要接口define(id?,dependencies?,factory);它要在声明模块的时候指定所有的依赖dependencies，并且还要当做形参传到factory中，对于依赖的模块提前执行。</p>
<pre><code class="hljs javascript">define(<span class="hljs-string">"module"</span>,[<span class="hljs-string">"dep1"</span>,<span class="hljs-string">"dep2"</span>],functian(d1,d2){
	<span class="hljs-keyword">return</span> someExportedValue;
});
<span class="hljs-built_in">require</span>（[<span class="hljs-string">"module"</span>,<span class="hljs-string">"../file.js"</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module，file</span>)</span>{});</code></pre>

<p><strong>优点：</strong></p>
<ul>
<li>适合在浏览器环境中异步加载模块</li>
<li>可以并行加载多个模块</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不畅</li>
<li>不符合通用的模块化思维方式，是一种妥协的实现</li>
</ul>
<p><strong>实现：</strong></p>
<ul>
<li>RequireJS</li>
<li>curl</li>
</ul>
<h3 id="2-4-CMD"><a href="#2-4-CMD" class="headerlink" title="2.4 CMD"></a>2.4 CMD</h3><p>Commons Module Definition规范和AMD很相似，尽保持简单，并与CommonsJS和NodeJS的Modules规范保持了很大的兼容性。</p>
<pre><code class="hljs javascript">define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require,exports,module</span>)</span>{
	<span class="hljs-keyword">var</span> $=<span class="hljs-built_in">require</span>(<span class="hljs-string">"jquery"</span>);
	<span class="hljs-keyword">var</span> Spinning = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./spinning"</span>);
	exports.doSomething = ...;
	<span class="hljs-built_in">module</span>.exports=...;
});</code></pre>

<p><strong>优点：</strong></p>
<ul>
<li>依赖就近，延迟执行</li>
<li>可以很容易在NodeJS中运行缺点</li>
<li>依赖SPM打包，模块的加载逻辑偏重</li>
</ul>
<p><strong>实现：</strong></p>
<ul>
<li>Sea.js</li>
<li>coolie</li>
</ul>
<h3 id="2-5-ES6模块"><a href="#2-5-ES6模块" class="headerlink" title="2.5 ES6模块"></a>2.5 ES6模块</h3><p>EcmaScript 6标准增加了JavaScript语言层面的模块体系定义。ES 6模块的设计思想， 是尽量静态化， 使编译时就能确定模块的依赖关系， 以及输入和输出的变量。Commons JS和AMD模块，都只能在运行时确定这些东西。</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">"jquery"</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doStuff</span>(<span class="hljs-params"></span>)</span>{}
<span class="hljs-built_in">module</span> <span class="hljs-string">"localModule"</span>{}</code></pre>

<p><strong>优点：</strong></p>
<ul>
<li>容易进行静态分析</li>
<li>面向未来的EcmaScript标准</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>原生浏览器端还没有实现该标准</li>
<li>全新的命令，新版的Node JS才支持</li>
</ul>
<p><strong>实现：</strong></p>
<ul>
<li>Babel</li>
</ul>
<p><strong>大家期望的模块：</strong><br>  系统可以兼容多种模块风格， 尽量可以利用已有的代码， 不仅仅只是JavaScript模块化， 还有CSS、图片、字体等资源也需要模块化。</p>
<h2 id="3-安装Webpack"><a href="#3-安装Webpack" class="headerlink" title="3. 安装Webpack"></a>3. 安装Webpack</h2><ul>
<li>使用<code>npm</code>安装<code>Webpack</code>：</li>
</ul>
<pre><code class="hljs bash">npm install webpack -g
npm install webpack-cli -g</code></pre>

<ul>
<li>测试安装结果：</li>
</ul>
<pre><code class="hljs bash">webpack -v
webpack-cli -v

<span class="hljs-comment"># webpack-cli 4.0.0</span>
<span class="hljs-comment"># webpack 4.44.2</span></code></pre>

<h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h2><p>创建 <code>webpack.config.js</code>配置文件</p>
<ul>
<li><code>entry</code>：入口文件， 指定Web Pack用哪个文件作为项目的入口</li>
<li><code>output</code>：输出， 指定WebPack把处理完成的文件放置到指定路径</li>
<li><code>module</code>：模块， 用于处理各种类型的文件</li>
<li><code>plugins</code>：插件， 如：热更新、代码重用等</li>
<li><code>resolve</code>：设置路径指向</li>
<li><code>watch</code>：监听， 用于设置文件改动后直接打包</li>
</ul>
<pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-comment">//入口文件,指定用哪个文件作为项目的入口</span>
    entry: <span class="hljs-string">"./modules/main.js"</span>,

    <span class="hljs-comment">//输出</span>
	output: {
		path: <span class="hljs-string">""</span>,
        <span class="hljs-comment">//把处理完成的文件放置到指定路径</span>
		filename: <span class="hljs-string">"./js/bundle.js"</span>
    },

    <span class="hljs-comment">//模块,用于处理各种类型的文件</span>
	<span class="hljs-built_in">module</span>: {
		loaders: [
			<span class="hljs-comment">/* {test:/\.js$/,;\loade:""} */</span>
		]
    }, 

    <span class="hljs-comment">//插件,如：热更新、代码重用等</span>
    plugins: {},

    <span class="hljs-comment">//路径指向</span>
    resolve: {},

    <span class="hljs-comment">//监听,用于设置文件改动后直接打包</span>
	watch: <span class="hljs-literal">true</span>
}

<span class="hljs-comment">/* ES6模块</span>
<span class="hljs-comment">export const entry = "./modules/main.js";</span>
<span class="hljs-comment">export const output = {</span>
<span class="hljs-comment">    path: "",</span>
<span class="hljs-comment">    filename: "./js/bundle.js"</span>
<span class="hljs-comment">};</span>
<span class="hljs-comment">export const module = {</span>
<span class="hljs-comment">    loaders: [</span>
<span class="hljs-comment">        {test:/\.js$/,;\loade:""}</span>
<span class="hljs-comment">    ]</span>
<span class="hljs-comment">};</span>
<span class="hljs-comment">export const plugins = {};</span>
<span class="hljs-comment">export const resolve = {};</span>
<span class="hljs-comment">export const watch = true;</span>
<span class="hljs-comment">*/</span></code></pre>

<h2 id="5-使用"><a href="#5-使用" class="headerlink" title="5. 使用"></a>5. 使用</h2><ul>
<li>直接运行<code>webpack</code>命令，进行打包</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/10/16/0bxdXD.png" srcset="/blog/img/loading.gif" alt="0bxdXD.png"></p>
<ul>
<li>运行<code>webpack --watch</code>命令，<em>用于监听变化</em>，<strong>实现热部署</strong></li>
</ul>
<p><img src="https://s1.ax1x.com/2020/10/16/0bzSE9.png" srcset="/blog/img/loading.gif" alt="0bzSE9.png"></p>
<h2 id="6-实例demo"><a href="#6-实例demo" class="headerlink" title="6. 实例demo"></a>6. 实例demo</h2><ol>
<li><p>创建空白项目文件夹<code>myvue</code></p>
</li>
<li><p>创建一个名为<code>modules</code>的目录，用于放置JS模块等资源文件</p>
</li>
<li><p>在<code>modules</code>下创建模块文件，如<code>hello.js</code>，用于编写JS模块相关代码：</p>
</li>
</ol>
<pre><code class="hljs js"><span class="hljs-comment">//暴露一个方法</span>

<span class="hljs-comment">//ES5模块</span>
exports.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-comment">// export function sayHi() { //ES6模块 </span>
    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">"&lt;li&gt;Hello Webpack&lt;/li&gt;"</span>);
}</code></pre>

<ol start="4">
<li>在<code>modules</code>下创建一个名为<code>main.js</code>的入口文件，用于打包时设置<code>entry</code>属性：</li>
</ol>
<pre><code class="hljs js"><span class="hljs-comment">//require 导入一个模块，就可以调用这个模块中的方法了</span>

<span class="hljs-comment">//ES5模块</span>
<span class="hljs-keyword">var</span> hello = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./hello"</span>); 
<span class="hljs-comment">// import "./hello"; //ES6模块</span>

hello.sayHi();</code></pre>

<ol start="5">
<li>在项目根目录下创建<code>webpack.config.js</code>配置文件：</li>
</ol>
<pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-comment">//入口文件,,指定用哪个文件作为项目的入口</span>
    entry: <span class="hljs-string">"./modules/main.js"</span>,

    <span class="hljs-comment">//输出</span>
	output: {
        <span class="hljs-comment">//把处理完成的文件放置到指定路径</span>
		filename: <span class="hljs-string">"./js/bundle.js"</span>
    },

    <span class="hljs-comment">//监听,用于设置文件改动后直接打包</span>
	<span class="hljs-comment">// watch: true</span>
}</code></pre>

<ol start="6">
<li>使用<code>webpack</code>命令打包</li>
<li>在项目根目录下创建HTML页面，如<code>index.html</code>，导入<code>webpack</code>打包后的JS文件：</li>
</ol>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Webpack Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 前端的模块化开发 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./dist/js/bundle.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<h2 id="7-热部署"><a href="#7-热部署" class="headerlink" title="7. 热部署"></a>7. 热部署</h2><ul>
<li>运行<code>webpack --watch</code>命令，<em>用于监听变化</em>，<strong>实现热部署</strong><ul>
<li>参数 <code>--watch</code> 用于<strong>监听变化</strong></li>
</ul>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/10/16/0bzSE9.png" srcset="/blog/img/loading.gif" alt="0bzSE9.png"></p>
<h1 id="十八、vue-router路由"><a href="#十八、vue-router路由" class="headerlink" title="十八、vue-router路由"></a>十八、vue-router路由</h1><blockquote>
<p>视频：<a href="https://www.bilibili.com/video/BV18E411a7mC?p=15" target="_blank" rel="noopener">https://www.bilibili.com/video/BV18E411a7mC?p=15</a></p>
</blockquote>
<h2 id="1-什么是vue-router"><a href="#1-什么是vue-router" class="headerlink" title="1. 什么是vue-router"></a>1. 什么是vue-router</h2><p><code>Vue Router</code>是Vue.js官方的<strong>路由管理器</strong>（路径跳转）。它和Vue.js的核心深度集成，让<code>构建单页面应用</code>变得易如反掌。包含的功能有:</p>
<ul>
<li>嵌套的路由/视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于Vue.js过渡系统的视图过渡效果</li>
<li>细粒度的导航控制</li>
<li>带有自动激活的CSS class的链接</li>
<li>HTML5历史模式或hash模式，在IE9中自动降级</li>
<li>自定义的滚动条行为</li>
</ul>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><blockquote>
<p>先查看<code>node_modules</code>中是否存在 <code>vue-router</code>。</p>
</blockquote>
<ul>
<li><code>vue-router</code>是一个<strong>插件包</strong>，所以我们还是需要用 <code>npm</code>或<code>cnpm</code> 来进行安装的：</li>
</ul>
<pre><code class="hljs bash">npm install vue-router --save-dev</code></pre>

<ul>
<li>安装完之后去<code>node_modules</code>路径看看是否有<code>vue-router</code>信息，有的话则表明安装成功。</li>
</ul>
<blockquote>
<p>如果在一个<code>模块化工程</code>中使用它，必须要通过 <code>Vue.use()</code> 明确地安装路由功能：</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>

Vue.use(VueRouter);</code></pre>
</blockquote>
<h2 id="3-实例demo"><a href="#3-实例demo" class="headerlink" title="3. 实例demo"></a>3. 实例demo</h2><ol>
<li><p>项目文件夹中主要存在三个文件：</p>
<ul>
<li><code>./src/App.vue</code></li>
<li><code>./src/main.js</code></li>
<li><code>./index.html</code></li>
</ul>
<blockquote>
<p>这三个文件的关系是 <code>index.html</code> 调用<code>main.js</code> 调用<code>App.vue</code>。</p>
<ul>
<li><code>index.html</code></li>
</ul>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width,initial-scale=1.0"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>myvue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- built files will be auto injected --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

<ul>
<li><code>main.js</code></li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>

Vue.config.productionTip = <span class="hljs-literal">false</span>

<span class="hljs-keyword">new</span> Vue({
  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),
}).$mount(<span class="hljs-string">'#app'</span>)</code></pre>

<ul>
<li><code>App.vue</code></li>
</ul>
<pre><code class="hljs vue">&lt;template&gt;
  &lt;div id="app"&gt;

  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  name: 'App'
}
&lt;/script&gt;

&lt;style&gt;
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
&lt;/style&gt;</code></pre>
</blockquote>
</li>
<li><p>在<code>main.js</code>中导入<code>vue-router</code>路由插件：</p>
</li>
</ol>
<pre><code class="hljs js"><span class="hljs-comment">// 导入路由插件</span>
<span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span></code></pre>

<ol start="3">
<li>在<code>main.js</code>中<code>显示声明使用VueRouter</code>：</li>
</ol>
<pre><code class="hljs js"><span class="hljs-comment">//显示声明使用vue-router路由</span>
Vue.use(VueRouter)</code></pre>

<ol start="4">
<li><code>components</code>目录下，定义一个<code>Content</code>组件和<code>Main</code>组件：</li>
</ol>
<ul>
<li><code>Content</code>组件：</li>
</ul>
<pre><code class="hljs vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;内容页&lt;/h1&gt;
    &lt;h3&gt;学科&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li&gt;Linux&lt;/li&gt;
      &lt;li&gt;Java&lt;/li&gt;
      &lt;li&gt;Vue&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;怎么学&lt;/h3&gt;
    &lt;ol&gt;
      &lt;li&gt;看文档&lt;/li&gt;
      &lt;li&gt;看视频&lt;/li&gt;
      &lt;li&gt;做笔记&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    name: "Content"
  }

&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;</code></pre>

<ul>
<li><code>Main</code>组件：</li>
</ul>
<pre><code class="hljs vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;个人介绍&lt;/h1&gt;
    &lt;ul&gt;
      个人主页:
      &lt;a href="http://melodyhub.ltd"&gt;melodyhub.ltd&lt;/a&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    name: "Main"
  }

&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;</code></pre>

<ol start="5">
<li><p>创建<code>src/router</code>目录，专门存放路由。</p>
</li>
<li><p>创建<code>src/router/index.js</code>主配置文件：</p>
</li>
</ol>
<ul>
<li><code>index.js</code>：Vue官方命名规则，主配置文件，实现全局配置<ul>
<li><code>path</code>：路由路径,类似<code>Spring</code>中的<code>@RequestMapping</code></li>
<li><code>name</code>：路由名称</li>
<li><code>component</code>：跳转到组件</li>
</ul>
</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-comment">//导入路由插件</span>
<span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>;
<span class="hljs-comment">//导入自定义组件</span>
<span class="hljs-keyword">import</span> Content <span class="hljs-keyword">from</span> <span class="hljs-string">'../components/Content.vue'</span>;
<span class="hljs-keyword">import</span> Main <span class="hljs-keyword">from</span> <span class="hljs-string">'../components/Main.vue'</span>;

<span class="hljs-comment">//安装路由</span>
Vue.use(VueRouter);

<span class="hljs-comment">//配置导出路由</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter({
  routes: [
    {
      <span class="hljs-comment">//路由路径,类似Spring中的@RequestMapping</span>
      path: <span class="hljs-string">"/content"</span>,
      <span class="hljs-comment">//路由名称</span>
      name: <span class="hljs-string">"content"</span>,
      <span class="hljs-comment">//跳转到组件</span>
      component: Content,

    }, {
      <span class="hljs-comment">//路由路径</span>
      path: <span class="hljs-string">"/main"</span>,
      <span class="hljs-comment">//路由名称</span>
      name: <span class="hljs-string">"main"</span>,
      <span class="hljs-comment">//跳转到组件</span>
      component: Main,
    }
  ]
})</code></pre>

<ol start="7">
<li>第6步只是配置了路由，但未启用路由，在<code>main.js</code>中启用上述配置的路由：</li>
</ol>
<ul>
<li><code>router</code>：全局唯一</li>
<li>通过<code>router/index.js</code>主配置文件，实现全局配置</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>

<span class="hljs-comment">//导入路由配置目录,自动扫描里面的路由配置</span>
<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span>

<span class="hljs-comment">//来关闭生产模式下给出的提示</span>
Vue.config.productionTip = <span class="hljs-literal">false</span>

<span class="hljs-keyword">new</span> Vue({
  <span class="hljs-comment">//配置路由</span>
  router,
  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),
}).$mount(<span class="hljs-string">'#app'</span>)</code></pre>

<ol start="8">
<li>在<code>App.vue</code>中使用路由：</li>
</ol>
<pre><code class="hljs vue">&lt;template&gt;
  &lt;div id="app"&gt;
  &lt;h1&gt;vue-router Demo&lt;/h1&gt;
    &lt;router-link to="/main"&gt;首页&lt;/router-link&gt;
    &lt;router-link to="/content"&gt;内容页&lt;/router-link&gt;
    &lt;!-- 控制路由页面展示 --&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  name: 'App',
}
&lt;/script&gt;

&lt;style&gt;
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
&lt;/style&gt;</code></pre>

<ol start="9">
<li>运行<code>npm run dev</code>，测试、查看效果。</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/10/17/0qhMDK.png" srcset="/blog/img/loading.gif" alt="0qhMDK.png"></p>
<h1 id="十九、Element-UI"><a href="#十九、Element-UI" class="headerlink" title="十九、Element UI"></a>十九、Element UI</h1><h2 id="1-什么是Element"><a href="#1-什么是Element" class="headerlink" title="1. 什么是Element"></a>1. 什么是Element</h2><p><code>Element</code> 是饿了么前端开源维护的 Vue UI 组件库，组件齐全，基本涵盖后台所需的所有组件，文档讲解详细，例子也很丰富。<strong>主要用于开发 PC 端的页面，是一个质量比较高的 Vue UI 组件库。</strong></p>
<ul>
<li><a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener">官网地址</a></li>
<li>Github：<a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">vue-element-admin</a></li>
</ul>
<blockquote>
<p>备注：属于前端主流框架，选型时可以考虑使用，<strong>主要特点是桌面端支持较多</strong></p>
</blockquote>
<h2 id="2-实战"><a href="#2-实战" class="headerlink" title="2. 实战"></a>2. 实战</h2><ol>
<li>创建一个工程<code>vue-element</code>：</li>
</ol>
<pre><code class="hljs bash">vue init webpack vue-element</code></pre>

<ol start="2">
<li>安装依赖，需要4个插件，分别为： <code>vue-router</code>、<code>element-ui</code>、<code>sass-loader</code> 和<code>node-sass</code> ：</li>
</ol>
<pre><code class="hljs bash"><span class="hljs-comment"># 进入工程目录</span>
<span class="hljs-built_in">cd</span> vue-element
<span class="hljs-comment"># 安装 vue-router</span>
npm install vue-router --save-dev
<span class="hljs-comment"># 安装 element-ui</span>
npm i element-ui -S
<span class="hljs-comment"># 安装依赖</span>
npm install
<span class="hljs-comment"># 安装 SASS 加载器,直接一句命令安装两个依赖插件</span>
npm install sass-loader node-sass --save-dev
<span class="hljs-comment"># 启动测试</span>
npm run dev</code></pre>

<blockquote>
<p><code>npm</code> 命令解释：</p>
<ul>
<li><code>npm install moduleName</code>：安装模块到项目目录下</li>
<li><code>npm install -g moduleName</code>：<code>-g</code> 的意思是将模块安装到全局，具体安装到磁盘的哪个位置，要看 <code>npm config prefix</code>的位置</li>
<li><code>npm install moduleName -save</code>：<code>–save</code>的意思是将模块安装到项目目录下，并在<code>package</code>文件的<code>dependencies</code>节点写入依赖，<code>-S</code>为该命令的缩写</li>
<li><code>npm install moduleName -save-dev</code>：<code>–save-dev</code>的意思是将模块安装到项目目录下，并在<code>package</code>文件的<code>devDependencies</code>节点写入依赖，<code>-D</code>为该命令的缩写</li>
</ul>
</blockquote>
<ol start="3">
<li>删除assets、components中的文件，并创建文件夹<code>view</code>、<code>router</code>分别存放<code>视图</code>、<code>路由</code>。</li>
<li>在<code>views</code>中创建<code>Main.vue</code>：</li>
</ol>
<pre><code class="hljs vue">&lt;template&gt;
  &lt;h1&gt;首页&lt;/h1&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: "Main"
}
&lt;/script&gt;

&lt;style&gt;

&lt;/style&gt;</code></pre>

<ol start="5">
<li>在<code>views</code>中创建<code>Login.vue</code>：</li>
</ol>
<pre><code class="hljs vue">&lt;template&gt;
  &lt;div&gt;
    &lt;!--el-form一个表单，两个输入框--&gt;
    &lt;el-form ref="loginForm" :model="form" :rules="rules"  label-width="80px" class="login-box"&gt;
      &lt;center&gt;&lt;h3 class="login-title"&gt;欢迎登陆&lt;/h3&gt;&lt;/center&gt;
      &lt;el-form-item label="账号" prop="username"&gt;
        &lt;el-input type="text" placeholder="请输入账号" v-model="form.username"/&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label="密码" prop="password"&gt;
        &lt;el-input type="password" placeholder="请输入密码" v-model="form.password"/&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item&gt;
        &lt;!--登陆按钮绑定了一个onSubmit事件--&gt;
        &lt;el-button type="primary" v-on:click="onSubmit('loginForm')"&gt;登陆&lt;/el-button&gt;
      &lt;/el-form-item&gt;
    &lt;/el-form&gt;
    &lt;!--提示窗--&gt;
    &lt;el-dialog
      title="温馨提示"
      :visible.sync="dialogVisible"
      width="30%"
      :before-close="handleClose"&gt;
      &lt;span&gt;请输入账号和密码&lt;/span&gt;
      &lt;span slot="footer" class="dialog-footer"&gt;
        &lt;el-button type="primary" @click="dialogVisible = false"&gt;确定&lt;/el-button&gt;
      &lt;/span&gt;
    &lt;/el-dialog&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    name:"Login",
    data(){
      return{
        form:{
          username:'',
          password:''
        },

        // 表单验证，需要在 el-form-item 元素中增加 prop 属性
        rules:{
          username: [
            {required:true,message:'账号不可为空',trigger:'blur'}
          ],
          password: [
            {required:true,message:'密码不可为空',trigger:'blur'}
          ]
        },

        // 对话框显示和隐藏
        dialogVisible:false

      }
    },
    methods:{
      onSubmit(formName){
        // 为表单绑定验证功能
        this.$refs[formName].validate((valid)=&gt;{
          if(valid){
            /*使用 vue-router 路由到指定页面,如果引用成功了,会去router中push到main，这种方式称为编程式导航*/
            this.$router.push("/main");
          }else {
            this.dialogVisible=true;
            return false;

          }
        });
      }
    }
  }
&lt;/script&gt;

&lt;style scoped&gt;
.login-box {
  border: 1px solid #dcdfe6;
  width: 350px;
  margin: 180px auto;
  padding: 35px 35px 15px 35px;
  border-radius: 5px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  box-shadow: 0 0 25px #909399;
}

.login-title {
  text-align: center;
  margin: 0 auto 40px auto;
  color: #303133;
}
&lt;/style&gt;</code></pre>

<ol start="6">
<li>在<code>router</code>中创建<code>index.js</code>：</li>
</ol>
<pre><code class="hljs js"><span class="hljs-comment">//导入vue</span>
<span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>;
<span class="hljs-comment">//导入组件</span>
<span class="hljs-keyword">import</span> Main <span class="hljs-keyword">from</span> <span class="hljs-string">"../views/Main"</span>;
<span class="hljs-keyword">import</span> Login <span class="hljs-keyword">from</span> <span class="hljs-string">"../views/Login"</span>;
<span class="hljs-comment">//使用</span>
Vue.use(VueRouter);
<span class="hljs-comment">//导出</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter({
  routes: [
    {
      <span class="hljs-comment">//登录页</span>
      path: <span class="hljs-string">'/main'</span>,
      component: Main
    },
    <span class="hljs-comment">//首页</span>
    {
      path: <span class="hljs-string">'/login'</span>,
      component: Login
    },
  ]
})</code></pre>

<ol start="7">
<li>在<code>main.js</code>中导入相关配置：</li>
</ol>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>
<span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">"vue-router"</span>;
<span class="hljs-comment">//扫描路由配置</span>
<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">"./router"</span>
<span class="hljs-comment">//导入Element UI</span>
<span class="hljs-keyword">import</span> ElementUI <span class="hljs-keyword">from</span> <span class="hljs-string">"element-ui"</span>
<span class="hljs-comment">//导入element css,样式文件需要单独引入</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'element-ui/lib/theme-chalk/index.css'</span>
<span class="hljs-comment">//使用</span>
Vue.use(VueRouter)
Vue.use(ElementUI)
Vue.config.productionTip = <span class="hljs-literal">false</span>

<span class="hljs-keyword">new</span> Vue({
  <span class="hljs-comment">//el: '#app', //同.$mount('#app')</span>
  <span class="hljs-comment">//配置路由</span>
  router,
  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),<span class="hljs-comment">//ElementUI规定这样使用</span>
}).$mount(<span class="hljs-string">'#app'</span>)</code></pre>

<ol start="8">
<li>在<code>App.vue</code>中使用路由并展示视图：</li>
</ol>
<pre><code class="hljs vue">&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;router-link to="/main"&gt;首页&lt;/router-link&gt;
    &lt;router-link to="/login"&gt;注册&lt;/router-link&gt;

    &lt;!--展示视图--&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    name: 'App',
  }
&lt;/script&gt;</code></pre>

<ol start="9">
<li>运行测试 <code>http://localhost:8080/#/login</code> ：</li>
</ol>
<pre><code class="hljs bash">npm run dev</code></pre>

<blockquote>
<ul>
<li>如果出现错误: 可能是因为<code>sass-loader</code>的版本导致的编译错误，可以切换到当前最高版本10.0.3，或尝试退回到7.3.1 ：<ul>
<li>去<code>package.json</code>文件里面的<code>"sass-loader"</code>的版本更换成10.0.3，然后重新<code>npm install</code>就可以了。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/10/21/BP2Lb4.png" srcset="/blog/img/loading.gif" alt="BP2Lb4.png"></p>
<h1 id="二十、路由嵌套"><a href="#二十、路由嵌套" class="headerlink" title="二十、路由嵌套"></a>二十、路由嵌套</h1><h2 id="1-什么是路由嵌套"><a href="#1-什么是路由嵌套" class="headerlink" title="1. 什么是路由嵌套"></a>1. 什么是路由嵌套</h2><ul>
<li><code>嵌套路由</code>，又称<code>子路由</code>。</li>
<li>在实际应用中，通常<code>由多层嵌套的组件组合而成</code>。</li>
</ul>
<h2 id="2-实战-1"><a href="#2-实战-1" class="headerlink" title="2. 实战"></a>2. 实战</h2><ol>
<li>创建用户信息组件，在 <code>views/user</code> 目录下创建一个名为 <code>Profile.vue</code> 的视图组件：</li>
</ol>
<pre><code class="hljs vue">&lt;template&gt;
  &lt;h1&gt;个人信息&lt;/h1&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    name: "UserProfile"
  }
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;</code></pre>

<ol start="2">
<li>创建用户列表组件，在 <code>views/user</code> 目录下创建一个名为 <code>List.vue</code> 的视图组件：</li>
</ol>
<pre><code class="hljs vue">&lt;template&gt;
  &lt;h1&gt;用户列表&lt;/h1&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    name: "UserList"
  }
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;</code></pre>

<ol start="3">
<li>修改 <code>Main.vue</code> 首页视图，使用 <code>Element UI</code> 布局容器组件：</li>
</ol>
<pre><code class="hljs vue">&lt;template&gt;
  &lt;div&gt;
    &lt;el-container&gt;
      &lt;el-aside width="200px"&gt;
        &lt;el-menu :default-openeds="['1']"&gt;
          &lt;el-submenu index="1"&gt;
            &lt;template slot="title"&gt;&lt;i class="el-icon-caret-right"&gt;&lt;/i&gt;用户管理&lt;/template&gt;
            &lt;el-menu-item-group&gt;
              &lt;el-menu-item index="1-1"&gt;
                &lt;!--插入的地方--&gt;
                &lt;router-link to="/user/profile"&gt;个人信息&lt;/router-link&gt;
              &lt;/el-menu-item&gt;
              &lt;el-menu-item index="1-2"&gt;
                &lt;!--插入的地方--&gt;
                &lt;router-link to="/user/list"&gt;用户列表&lt;/router-link&gt;
              &lt;/el-menu-item&gt;
            &lt;/el-menu-item-group&gt;
          &lt;/el-submenu&gt;
          &lt;el-submenu index="2"&gt;
            &lt;template slot="title"&gt;&lt;i class="el-icon-caret-right"&gt;&lt;/i&gt;内容管理&lt;/template&gt;
            &lt;el-menu-item-group&gt;
              &lt;el-menu-item index="2-1"&gt;分类管理&lt;/el-menu-item&gt;
              &lt;el-menu-item index="2-2"&gt;内容列表&lt;/el-menu-item&gt;
            &lt;/el-menu-item-group&gt;
          &lt;/el-submenu&gt;
          &lt;el-submenu index="3"&gt;
            &lt;template slot="title"&gt;&lt;i class="el-icon-caret-right"&gt;&lt;/i&gt;系统管理&lt;/template&gt;
            &lt;el-menu-item-group&gt;
              &lt;el-menu-item index="3-1"&gt;用户设置&lt;/el-menu-item&gt;
            &lt;/el-menu-item-group&gt;
          &lt;/el-submenu&gt;
        &lt;/el-menu&gt;
      &lt;/el-aside&gt;

      &lt;el-container&gt;
        &lt;el-header style="text-align: right; font-size: 12px"&gt;
          &lt;el-dropdown&gt;
            &lt;i class="el-icon-setting" style="margin-right: 15px"&gt;&lt;/i&gt;
            &lt;el-dropdown-menu slot="dropdown"&gt;
              &lt;el-dropdown-item&gt;个人信息&lt;/el-dropdown-item&gt;
              &lt;el-dropdown-item&gt;退出登录&lt;/el-dropdown-item&gt;
            &lt;/el-dropdown-menu&gt;
          &lt;/el-dropdown&gt;
        &lt;/el-header&gt;
        &lt;el-main&gt;
          &lt;!--在这里展示视图--&gt;
          &lt;router-view /&gt;
        &lt;/el-main&gt;
      &lt;/el-container&gt;
    &lt;/el-container&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    name: "Main"
  }
&lt;/script&gt;
&lt;style scoped&gt;
  .el-header {
    background-color: #B3C0D1;
    color: #333;
    line-height: 60px;
  }
  .el-aside {
    color: #333;
  }
&lt;/style&gt;</code></pre>

<ol start="4">
<li>使用<code>children</code>配置<code>嵌套路由</code>，修改<code>router/index.js</code>主路由配置文件：</li>
</ol>
<pre><code class="hljs js"><span class="hljs-comment">//导入vue</span>
<span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>;
<span class="hljs-comment">//导入组件</span>
<span class="hljs-keyword">import</span> Main <span class="hljs-keyword">from</span> <span class="hljs-string">"../views/Main"</span>;
<span class="hljs-keyword">import</span> Login <span class="hljs-keyword">from</span> <span class="hljs-string">"../views/Login"</span>;
<span class="hljs-comment">//导入子模块</span>
<span class="hljs-keyword">import</span> UserList <span class="hljs-keyword">from</span> <span class="hljs-string">"../views/user/List"</span>;
<span class="hljs-keyword">import</span> UserProfile <span class="hljs-keyword">from</span> <span class="hljs-string">"../views/user/Profile"</span>;

<span class="hljs-comment">//使用</span>
Vue.use(VueRouter);
<span class="hljs-comment">//导出</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter({
  routes: [
    {
      <span class="hljs-comment">//登录页</span>
      path: <span class="hljs-string">'/main'</span>,
      component: Main,
      <span class="hljs-comment">//  写入子模块</span>
      children: [
        {
          path: <span class="hljs-string">'/user/profile'</span>,
          component: UserProfile,
        }, {
          path: <span class="hljs-string">'/user/list'</span>,
          component: UserList,
        },
      ]
    },
    <span class="hljs-comment">//首页</span>
    {
      path: <span class="hljs-string">'/login'</span>,
      component: Login

    },
  ]
})</code></pre>

<h1 id="二十一、参数传递"><a href="#二十一、参数传递" class="headerlink" title="二十一、参数传递"></a>二十一、参数传递</h1><ul>
<li><code>Vue-Router</code>中的``path`传值问题</li>
</ul>
<blockquote>
<p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。</p>
<p>例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。此时我们就需要传递参数了。</p>
</blockquote>
<h2 id="不使用props"><a href="#不使用props" class="headerlink" title="不使用props"></a>不使用props</h2><ol>
<li>修改<code>src/router/index.js</code>路由配置：</li>
</ol>
<ul>
<li>主要在<code>path</code>属性中增加<code>:id</code>占位符</li>
</ul>
<pre><code class="hljs js">{
  path: <span class="hljs-string">'/user/profile/:id'</span>,
  name: <span class="hljs-string">'UserProfile'</span>,
  component: UserProfile,
}</code></pre>

<ol start="2">
<li>前端传递参数：</li>
</ol>
<ul>
<li>在<code>Main.vue</code>，给<code>to</code>绑定对象<code>v-bind:to</code>或<code>:to</code>（<code>:</code>就是<code>v-bind</code>的省略）</li>
<li><code>router-link</code> 中的 <code>name</code> 属性名称 一定要和 <code>路由配置</code>中的 <code>name</code> 属性名称 <code>匹配</code>，因为这样 <code>Vue</code> 才能找到对应的路由路径。</li>
<li>利用<code>params</code>来<code>传递参数</code>。</li>
</ul>
<pre><code class="hljs vue">&lt;!--name：传组件名 params：传递参数，需要绑定对象：v-bind--&gt;
&lt;router-link v-bind:to="{name: 'UserProfile', params: {id: 123}}"&gt;个人信息&lt;/router-link&gt;</code></pre>

<ol start="3">
<li>目标组件<code>Profile.vue</code>中接收参数，并在视图中展示：</li>
</ol>
<pre><code class="hljs vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;个人信息&lt;/h1&gt;
    {{ $route.params.id }}
  &lt;/div&gt;
&lt;/template
&lt;script&gt;
  export default {
    name: "UserProfile"
  }
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;</code></pre>

<blockquote>
<p><code></code>一定要用<code>标签</code>包围起来，不然会报错！！！</p>
<p><img src="https://s1.ax1x.com/2020/11/01/Bwwt00.png" srcset="/blog/img/loading.gif" alt="Bwwt00.png"></p>
</blockquote>
<ol start="4">
<li>试试 <code>http://localhost:8080/#/user/profile/123</code>：</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/11/01/Bw0724.png" srcset="/blog/img/loading.gif" alt="Bw0724.png"></p>
<h2 id="使用props"><a href="#使用props" class="headerlink" title="使用props"></a>使用props</h2><ol>
<li>修改<code>src/router/index.js</code>路由配置，增加<code>props:true</code>属性：</li>
</ol>
<pre><code class="hljs js">{
  path: <span class="hljs-string">'/user/profile/:id'</span>,
  name: <span class="hljs-string">'UserProfile'</span>,
  component: UserProfile,
  props: <span class="hljs-literal">true</span>,
}</code></pre>

<ol start="2">
<li>目标组件<code>Profile.vue</code>中接收参数的方式有些变化：</li>
</ol>
<pre><code class="hljs vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;个人信息&lt;/h1&gt;
      {{id}}
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    name: "UserProfile",
    //传递参数
    props: ['id']
  }
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;</code></pre>

<ol start="3">
<li>试试<code>http://localhost:8080/#/user/profile/123456</code>：</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/11/01/Bw062Q.png" srcset="/blog/img/loading.gif" alt="Bw062Q.png"></p>
<h2 id="实例demo"><a href="#实例demo" class="headerlink" title="实例demo"></a>实例demo</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul>
<li>通过登陆页面成功登陆后，在首页右上角展示用户名</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol>
<li><code>Login.vue</code>的<code>methods</code>中获取当前用户名：</li>
</ol>
<pre><code class="hljs vue">methods:{
  onSubmit(formName){
    this.$refs[formName].validate((valid)=&gt;{
      if(valid){
        /*获取当前用户的用户名*/
        this.$router.push("/main"+"/"+this.form.username);
      }else {
        this.dialogVisible=true;
        return false;
      }
    });
  }
}</code></pre>

<ol start="2">
<li>修改<code>src/router/index.js</code>路由配置，<code>/main</code>路由接收<code>name</code>参数：</li>
</ol>
<pre><code class="hljs js">{
	path: <span class="hljs-string">'/main/:name'</span>,
	component: Main,
	props: <span class="hljs-literal">true</span>,
}</code></pre>

<ol start="3">
<li><code>Main.vue</code>中接收参数，</li>
</ol>
<pre><code class="hljs vue">&lt;script&gt;
  export default {
    name: "Main",
    props: ['name'],
  }
&lt;/script&gt;</code></pre>

<p>然后展示数据，</p>
<pre><code class="hljs vue">&lt;/el-dropdown&gt;
  &lt;span&gt;{{name}}&lt;/span&gt;
&lt;/el-header&gt;</code></pre>

<ol start="4">
<li>试试效果：</li>
</ol>
<p><img src="https://i.loli.net/2020/11/01/562xUAJhIZF4Co9.gif" srcset="/blog/img/loading.gif" alt="gif.gif"></p>
<h1 id="二十二、组件重定向"><a href="#二十二、组件重定向" class="headerlink" title="二十二、组件重定向"></a>二十二、组件重定向</h1><ul>
<li>重定向，顾名思义。</li>
<li>但是 <code>Vue</code> 中的<code>重定向</code>是<code>作用在路径不同但组件相同的情况下</code>。</li>
</ul>
<ol>
<li>修改<code>src/router/index.js</code>路由配置，增加重定向路由<code>redirect</code>属性：</li>
</ol>
<pre><code class="hljs js"><span class="hljs-comment">//重定向</span>
}
  path: <span class="hljs-string">'/goLogin'</span>,
  redirect: <span class="hljs-string">'/login'</span>
},
<span class="hljs-comment">//登录页</span>
{
  path: <span class="hljs-string">'/login'</span>,
  component: Login
},</code></pre>

<blockquote>
<p><strong>说明：</strong></p>
<p>这里定义了两个路径，一个是 ``/login<code>，一个是</code>/goLogin<code>，其中</code>/goLogin<code>重定向到了</code>/login` 路径，由此可以看出重定向不需要定义组件。</p>
</blockquote>
<ol start="2">
<li><code>Main.vue</code>中重定向路由组件：</li>
</ol>
<pre><code class="hljs vue">&lt;el-menu-item index="1-3"&gt;
  &lt;!--组件重定向--&gt;
  &lt;router-link to="/goLogin"&gt;回到登录页&lt;/router-link&gt;
&lt;/el-menu-item&gt;</code></pre>

<ol start="3">
<li>刷新页面，点击“回到登录页”试试</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/11/01/Bwh06P.gif" srcset="/blog/img/loading.gif" alt="Bwh06P.gif"></p>
<h1 id="二十三、路由模式"><a href="#二十三、路由模式" class="headerlink" title="二十三、路由模式"></a>二十三、路由模式</h1><p> <strong>路由模式有两种</strong>：</p>
<ul>
<li><code>hash</code>：<ul>
<li>路径带 <code>#</code> 符号</li>
<li>如 <code>http://localhost/#/login</code></li>
</ul>
</li>
<li><code>history</code>：<ul>
<li>路径不带 <code>#</code> 符号</li>
<li>如 <code>http://localhost/login</code></li>
</ul>
</li>
</ul>
<h2 id="修改路由配置"><a href="#修改路由配置" class="headerlink" title="修改路由配置"></a>修改路由配置</h2><ul>
<li>在我们的路由配置文件<code>src/router/index.js</code>中指定路由模式<code>mode</code>：</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router({
  mode: <span class="hljs-string">'history'</span>,
  routes: [
  ]
});</code></pre>

<h1 id="二十四、404"><a href="#二十四、404" class="headerlink" title="二十四、404"></a>二十四、404</h1><ol>
<li>新建<code>src/views/NotFound.vue</code>：</li>
</ol>
<pre><code class="hljs vue">&lt;template&gt;
    &lt;div&gt;
      &lt;h1&gt;哇~404,你的页面走丢了🤣&lt;/h1&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        name: "NotFound"
    }
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;</code></pre>

<ol start="2">
<li>在路由配置文件<code>src/router/index.js</code>中配置路由：</li>
</ol>
<pre><code class="hljs js"><span class="hljs-comment">//导入组件</span>
<span class="hljs-keyword">import</span> NotFound <span class="hljs-keyword">from</span> <span class="hljs-string">"../views/NotFound.vue"</span>;

routes: [
  {
    path: <span class="hljs-string">"*"</span>,
    component: NotFound
  }
]</code></pre>

<ol start="3">
<li>试试访问<code>http://localhost:8080/#/abv</code>：</li>
</ol>
<blockquote>
<p>使用了<code>history</code>路由模式的话，访问<code>http://localhost:8080/abv</code>。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/11/01/BwqilQ.png" srcset="/blog/img/loading.gif" alt="BwqilQ.png"></p>
<h1 id="二十五、路由钩子与异步请求"><a href="#二十五、路由钩子与异步请求" class="headerlink" title="二十五、路由钩子与异步请求"></a>二十五、路由钩子与异步请求</h1><blockquote>
<p>官方文档：<a href="https://cn.vuejs.org/v2/guide/custom-directive.html#钩子函数" target="_blank" rel="noopener">钩子函数及参数 — Vue.js</a></p>
</blockquote>
<p>回顾<a href="https://www.cnblogs.com/melodyjerry/p/13768594.html#十五、vue生命周期" target="_blank" rel="noopener">十五、Vue生命周期</a>中的两张图，其中就涉及到了<strong>钩子</strong>。</p>
<p><img src="https://s1.ax1x.com/2020/11/01/BwLGvQ.png" srcset="/blog/img/loading.gif" alt="BwLGvQ.png"></p>
<h2 id="1-什么是钩子函数"><a href="#1-什么是钩子函数" class="headerlink" title="1.什么是钩子函数"></a>1.什么是钩子函数</h2><ul>
<li><code>钩子函数</code>：钩子函数是在一个事件触发的时候，在系统级捕获到了他，然后做一些操作。<strong>一段用以处理系统消息的程序。</strong>“钩子”就是在某个阶段给你一个做某些处理的机会。<ul>
<li><ol>
<li>是个函数，在系统消息触发时被系统调用</li>
</ol>
</li>
<li><ol start="2">
<li>不是用户自己触发的</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>钩子函数的名称是确定的，当系统消息触发，自动会调用。</p>
<p>例如<code>react</code>的<code>componentWillUpdate</code>函数，用户只需要编写<code>componentWillUpdate</code>的函数体，当组件状态改变要更新时，系统就会调用<code>componentWillUpdate</code>。</p>
</blockquote>
<blockquote>
<p>常见的钩子函数：</p>
<ul>
<li>react的生命周期函数</li>
<li>vue的生命周期函数</li>
<li>vue的自定义指令</li>
<li>……</li>
</ul>
</blockquote>
<blockquote>
<p>解释来源于：<a href="https://www.cnblogs.com/8080zh/p/11164277.html" target="_blank" rel="noopener">理解什么是钩子函数</a></p>
</blockquote>
<h2 id="2-路由钩子"><a href="#2-路由钩子" class="headerlink" title="2.路由钩子"></a>2.路由钩子</h2><ul>
<li><code>beforeRouteEnter</code>：在进入路由前执行</li>
<li><code>beforeRouteLeave</code>：在离开路由前执行</li>
<li><code>beforeRouteUpdate</code>： Vue2.2 新增，用于相同路由组件的的参数更新</li>
</ul>
<blockquote>
<ul>
<li><p>是<code>时机函数</code>，在页面加载前，可以在这两个函数里面做一些事情， 比如发送<code>异步请求</code>。</p>
</li>
<li><p>类似<code>过滤器</code>，或者<code>拦截器</code>的环绕。</p>
</li>
<li><p>它们是和<code>data</code>, <code>methods</code>平级的：</p>
</li>
</ul>
<pre><code class="hljs vue">beforeRouteLeave(to, from, next) {
    next()
},
beforeRouteEnter(to, from, next) {
    next()
},
beforeRouteUpdate(to, from, next) { 
    next()
},
data: {},
method: {}</code></pre>
</blockquote>
<h3 id="2-1-参数说明"><a href="#2-1-参数说明" class="headerlink" title="2.1 参数说明"></a>2.1 参数说明</h3><ul>
<li><code>to</code> 路由将要跳转的路径信息</li>
<li><code>from</code> 路径跳转前的路径信息</li>
<li><code>next</code> 路由的控制参数，<strong>必须存在一种<code>next</code>方法</strong><ul>
<li><code>next()</code> 跳入下一个页面，</li>
<li><code>next('/path')</code> 改变路由的跳转方向，跳到下一个页面</li>
<li><code>next(false)</code> 返回原来的页面</li>
<li><code>next((vm) =&gt; {})</code> 只能在<code>beforeRouteEnter</code> 中可用，<code>vm</code>是组件实例</li>
</ul>
</li>
</ul>
<pre><code class="hljs vue">// 两个钩子函数,类似过滤器或拦截器的环绕
beforeRouteEnter: (to, from, next) =&gt; {
    console.log('进入路由之前...');
    next() // 必写
},
beforeRouteLeave: (to, from, next) =&gt; {
    console.log('离开路由之前...')
    next() // 必写
}</code></pre>

<blockquote>
<p>到控制台试试  <em>进入、离开路由前</em>  是否会打印日志信息？</p>
</blockquote>
<h2 id="3-在钩子函数中使用异步请求"><a href="#3-在钩子函数中使用异步请求" class="headerlink" title="3. 在钩子函数中使用异步请求"></a>3. 在钩子函数中使用异步请求</h2><blockquote>
<p>官方文档：<a href="http://www.axios-js.com/zh-cn/docs/vue-axios.html" target="_blank" rel="noopener">vue-axios|axios中文网</a></p>
</blockquote>
<ol>
<li>安装<code>Axios</code>：</li>
</ol>
<pre><code class="hljs bash">npm install --save vue-axios</code></pre>

<ol start="2">
<li><code>main.js</code>引入<code>Axios</code>：</li>
</ol>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>
<span class="hljs-keyword">import</span> VueAxios <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-axios'</span>

<span class="hljs-comment">//使用</span>
Vue.use(VueAxios, axios)</code></pre>

<ol start="3">
<li>准备测试数据，新建<code>static/mock/data.json</code>：</li>
</ol>
<blockquote>
<p><em>静态数据存放的位置</em>：<code>static</code>文件夹下的<code>mock</code>文件夹</p>
</blockquote>
<pre><code class="hljs json">{
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"MelodyJerry"</span>,
    <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://melodyhub.ltd/"</span>,
    <span class="hljs-attr">"page"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">"isNonProfit"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"address"</span>: {
      <span class="hljs-attr">"street"</span>: <span class="hljs-string">"广州"</span>,
      <span class="hljs-attr">"city"</span>: <span class="hljs-string">"广东"</span>,
      <span class="hljs-attr">"country"</span>: <span class="hljs-string">"中国"</span>
    },
    <span class="hljs-attr">"links"</span>: [
      {
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"博客园"</span>,
        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://www.cnblogs.com/melodyjerry/"</span>
      },
      {
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"GitHub"</span>,
        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"melodyhub.ltd"</span>
      },
      {
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Gitee"</span>,
        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://melodyjerry.gitee.io/"</span>
      }
    ]
  }</code></pre>

<ol start="4">
<li>运行<code>npm run dev</code>，访问<code>http://localhost:8080/static/mock/data.json</code>，获取json数据：</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/11/01/B0UgaT.png" srcset="/blog/img/loading.gif" alt="B0UgaT.png"></p>
<ol start="5">
<li>在 <code>beforeRouteEnter</code>中进行异步请求：</li>
</ol>
<pre><code class="hljs vue">&lt;script&gt;
  export default {
    name: "UserProfile",
    //传递参数
    props: ['id'],
    beforeRouteEnter (to, from, next) {
      console.log("进入路由之前...");
      //加载数据
      next(vm =&gt; { //发送异步请求并放行
        vm.getDatd(); //进入路由之前执行getData方法
      }); //必写
    },
    beforeRouteLeave (to, from, next) {
      console.log("进入路由之后...");
      next(); //必写
    },
    methods: {
      getDatd: function () {
        this.axios({
          methods: 'get',
          url: 'http://localhost:8080/static/mock/data.json'
        }).then(function (respone) {
          console.log(respone);
        })
      }
    },
  }
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;</code></pre>

<ol start="6">
<li>运行<code>npm run dev</code>，打开控制台：</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/11/01/B0wJq1.png" srcset="/blog/img/loading.gif" alt="B0wJq1.png"></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>[0] <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">Vue.js 官方文档</a></p>
<p>[1] <a href="https://blog.csdn.net/u010510187/article/details/100356624" target="_blank" rel="noopener">关于template标签用法总结(含vue中的用法总结)</a></p>
<p>[2] <a href="https://blog.csdn.net/weixin_43343144/article/details/86164858?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">Vue2 模板template的四种写法总结（很重要）</a></p>
<p>[3] <a href="https://blog.csdn.net/crazywoniu/article/details/80942642" target="_blank" rel="noopener">vue-router传递参数的几种方式</a></p>
<p>[4] <a href="https://www.jianshu.com/p/8341edbc7436" target="_blank" rel="noopener">VUE中assets与static的区别</a></p>
<p>[5] <a href="https://www.cnblogs.com/totoro-cat/p/12912891.html" target="_blank" rel="noopener">【VUE】2.渲染组件&amp;重定向路由</a></p>
<p>[6] <a href="https://blog.csdn.net/hbiao68/article/details/107250272" target="_blank" rel="noopener">Vue2.x 自定义重定向路由route组件</a></p>
<p>[7] <a href="https://www.cnblogs.com/8080zh/p/11164277.html" target="_blank" rel="noopener">理解什么是钩子函数</a></p>
<p>[8] <a href="https://www.cnblogs.com/lhl66/p/9195901.html" target="_blank" rel="noopener">vue组件独享守卫钩子函数参数详解（beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave）</a></p>
<p>[9] <a href="https://blog.csdn.net/ddr66288/article/details/102119947" target="_blank" rel="noopener">vue路由钩子拦截器beforeEach和afterEach及页面路由变化路由监听</a></p>
<p>[10] <a href="https://blog.csdn.net/qq_44783283/article/details/108808029" target="_blank" rel="noopener">beforeRouteEnter，beforeRouteLeave函数</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/blog/categories/uncategorized/">uncategorized</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E7%AC%94%E8%AE%B0/">笔记</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/Vue/">Vue</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E5%89%8D%E7%AB%AF/">前端</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/blog/2020/10/06/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">IDEA离线安装插件</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/blog/2020/10/04/IDEA%E6%90%AD%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE%E6%8F%90%E7%A4%BAconnect%20timed%20out%E9%94%99%E8%AF%AF/">
                        <span class="hidden-mobile">IDEA新建SpringBoot项目提示connect timed out错误</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "UNKL0FXJFAFOKRM1mGyL3Y2s-gzGzoHsz",
          app_key: "HjUUcTY42RErTnIt7O58GhvH",
          placeholder: "( ͡° ͜ʖ ͡°)✧ 来啊~",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: true,
          recordIP: true,
          serverURLs: "https://unkl0fxj.lc-cn-n1-shared.com",
          
           // 设置Bilibili表情包地址
    emojiCDN: '//i0.hdslb.com/bfs/emote/', 
    // 表情title和图片映射
    emojiMaps: {
        "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
        "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
        "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
        "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
        "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
        "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
        "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
        "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
        "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
        "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
        "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
        "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
        "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
        "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
        "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
        "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
        "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
        "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
        "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
        "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
        "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
        // ... 更多表情
    } 
          
        });
      });
    }
    createObserver(loadValine, 'vcomments');
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-md">
    <div class="container custom post-content mx-auto">
      <img src="https://i.loli.net/2020/02/11/lMEgBFV2OdnCLN7.png" srcset="/blog/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  





<!--动态线条背景-->
<script type="text/javascript"
color="255,0,0" opacity='1' zIndex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>

<!-- 天气挂件 -->
<!-- <div id="tp-weather-widget"></div>
  <script>
    (function(a,h,g,f,e,d,c,b){b=function(){d=h.createElement(g);c=h.getElementsByTagName(g)[0];d.src=e;d.charset="utf-8";d.async=1;c.parentNode.insertBefore(d,c)};a["SeniverseWeatherWidgetObject"]=f;a[f]||(a[f]=function(){(a[f].q=a[f].q||[]).push(arguments)});a[f].l=+new Date();if(a.attachEvent){a.attachEvent("onload",b)}else{a.addEventListener("load",b,false)}}(window,document,"script","SeniverseWeatherWidget","//cdn.sencdn.com/widget2/static/js/bundle.js?t="+parseInt((new Date().getTime() / 100000000).toString(),10)));
    window.SeniverseWeatherWidget('show', {
      flavor: "bubble",
      location: "WS0E9D8WN298",
      geolocation: true,
      language: "zh-Hans",
      unit: "c",
      theme: "auto",
      token: "5fd5b254-57fe-4f8a-8a13-f92485efeb0b",
      hover: "enabled",
      container: "tp-weather-widget"
    })
  </script>-->
  
<div id="tp-weather-widget"></div>
  <script>
    (function(a,h,g,f,e,d,c,b){b=function(){d=h.createElement(g);c=h.getElementsByTagName(g)[0];d.src=e;d.charset="utf-8";d.async=1;c.parentNode.insertBefore(d,c)};a["SeniverseWeatherWidgetObject"]=f;a[f]||(a[f]=function(){(a[f].q=a[f].q||[]).push(arguments)});a[f].l=+new Date();if(a.attachEvent){a.attachEvent("onload",b)}else{a.addEventListener("load",b,false)}}(window,document,"script","SeniverseWeatherWidget","//cdn.sencdn.com/widget2/static/js/bundle.js?t="+parseInt((new Date().getTime() / 100000000).toString(),10)));
    window.SeniverseWeatherWidget('show', {
      flavor: "bubble",
      location: "WS0E9D8WN298",
      geolocation: true,
      language: "zh-Hans",
      unit: "c",
      theme: "auto",
      token: "5fd5b254-57fe-4f8a-8a13-f92485efeb0b",
      hover: "disabled",
      container: "tp-weather-widget"
    })
  </script>
  
  
<!--浏览器搞笑标题-->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@3.0.6/js/FunnyTitle.js"></script>

<!--fancybox-->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<!--樱花瓣飘落-->
<script src="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-love109.cn@2.0.6/js/sakura.js"></script>

<!--速度优化脚本-->
<script src="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.6/js/instantclick-1.2.2.js" type="module"></script>

<!--热门标签，旋转，来自https://arlxn.xyz/-->
<!--tagcloud.ejs-->
<script src="https://createdestruction.github.io/js/tagcanvas.js"></script>
<script src="https://createdestruction.github.io/js/tagcloud.js"></script>






  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


    

    
      <!-- cnzz Analytics Icon -->
      <span id="cnzz_stat_icon_1278597820" style="display: none"></span>
    <script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1278597820'%3E%3C/span%3E%3Cscript src='https://s4.cnzz.com/z_stat.php%3Fid%3D1278597820%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
    
  </div>
  
  
  
<!--放大图片-->
<link rel="stylesheet" type="text/css" href="https://blog-static.cnblogs.com/files/zouwangblog/zoom.css">
<script src="https://cdn.bootcss.com/jquery/1.8.3/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/bootstrap/3.2.0/js/transition.js"></script>
<script src="https://blog-static.cnblogs.com/files/zouwangblog/zoom.js"></script>
<script type='text/javascript'>$('#cnblogs_post_body img').attr('data-action', 'zoom');</script>
<!--放大图片end-->

<!--宅音乐播放器 https://player.ilt.me/admin-->
<script id="ilt" src="https://player.ilt.me/player/js/player.js" key="992f0d81b6b74b93b6bbdb56f57a6c58"></script>

<!--闲聊么http://www.xianliao.me/faq<script>var xlm_wid='15920';var xlm_url='https://www.xianliao.me/';</script><script type="text/javascript" charset="UTF-8" src="https://www.xianliao.me/embed.js"></script>--> 
 
<center>
<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11"></script> 



<div style="text-align: center;font-weight: bold;color: #1BC3FB;">
      <span id="subtitle1">没有伞的孩子必须努力奔跑！</span><span class="typed-cursor typed-cursor--blink">|</span>
      <span id="typed-cursor"></span>
</div>
<!-- 打字特效（蓝色字体） -->  
<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11"></script> 
<script>var typed = new Typed("#subtitle1", { strings: ["Live a good life, write some good code !!!", "愿自己的努力终将获得回报。", "花开不是为了花落，而是为了开的更加灿烂。", "没有伞的孩子必须努力奔跑！", "欲望以提升热忱，毅力以磨平高山。", "如果放弃太早，你永远都不知道自己会错过什么。", "没有礁石，就没有美丽的浪花；没有挫折，就没有壮丽的人生。"], startDelay: 1000, typeSpeed: 100, loop: !0, backSpeed: 60, backDelay: 2000, showCursor: !0 })</script>



<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("11/06/2019 17:38:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "小站勉强运行了 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒 ( ͡° ͜ʖ ͡°)✧ "; 
    } 
setInterval("createtime()",250);
</script><div>
    <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span></div><!--网站访客地理信息-->
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5eqiqb8vl6p&m=2&c=ff0000&cr1=ffffff&f=arial&l=33&z=17&rx=-40&lx=-540&ly=520&hi=60" async="async"></script>
</center>

<!--cnzz-->
<center>
<script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1278597820'%3E%3C/span%3E%3Cscript src='https://s4.cnzz.com/z_stat.php%3Fid%3D1278597820%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</center>


  
  
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/blog/js/debouncer.js" ></script>
<script  src="/blog/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/blog/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/blog/js/clipboard-use.js" ></script>



  <script defer>
  (function () {
    // 查询存储的记录
    function getRecord(Counter, target) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({target})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {target, time: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    }

    // 发起自增请求
    function increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    }

    // 构建自增请求体
    function buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "time": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    }

    // 校验是否为有效的 UV
    function validUV() {
      var key = 'LeanCloud_UV_Flag';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    }

    function addCount(Counter) {
      var enableIncr = 'true' === 'true' && window.location.hostname !== 'localhost';
      var getterArr = [];
      var incrArr = [];

      // 请求 PV 并自增
      var pvCtn = document.querySelector('#leancloud-site-pv-container');
      if (pvCtn || enableIncr) {
        var pvGetter = getRecord(Counter, 'site-pv').then((record) => {
          incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-pv');
          if (ele) {
            ele.innerText = record.time + 1;
            if (pvCtn) {
              pvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#leancloud-site-uv-container');
      if (uvCtn || enableIncr) {
        var uvGetter = getRecord(Counter, 'site-uv').then((record) => {
          var vuv = validUV();
          vuv && incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-uv');
          if (ele) {
            ele.innerText = record.time + (vuv ? 1 : 0);
            if (uvCtn) {
              uvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(uvGetter);
      }

      // 如果是文章，请求文章的浏览数，并自增
      if ('true' === 'true') {
        var viewCtn = document.querySelector('#leancloud-post-views-container');
        if (viewCtn || enableIncr) {
          var target = decodeURI('/blog/2020/10/04/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/');
          var viewGetter = getRecord(Counter, target).then((record) => {
            incrArr.push(buildIncrement(record.objectId))
            if (viewCtn) {
              var ele = document.querySelector('#leancloud-post-views');
              if (ele) {
                ele.innerText = (record.time || 0) + 1;
                viewCtn.style.display = 'inline';
              }
            }
          });
          getterArr.push(viewGetter);
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && increment(Counter, incrArr);
        })
      }
    }

    var app_id = 'UNKL0FXJFAFOKRM1mGyL3Y2s-gzGzoHsz'
    var app_key = 'HjUUcTY42RErTnIt7O58GhvH'
    var server_url = 'https://unkl0fxj.lc-cn-n1-shared.com'

    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': app_id,
            'X-LC-Key': app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };

      addCount(Counter);
    }

    var api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${ app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(resp => resp.json())
        .then(({api_server}) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>






  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 2,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Vue快速入门学习笔记(更新ing)&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: true,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "§"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/blog/js/local-search.js" ></script>
  <script>
    var path = "/blog/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script>

  



  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  



  <script>(function (i, s, o, g, r, a, m) {
      i['DaoVoiceObject'] = r;
      i[r] = i[r] ||
        function () {
          (i[r].q = i[r].q || []).push(arguments);
        };
      i[r].l = 1 * new Date();
      a = s.createElement(o);
      m = s.getElementsByTagName(o)[0];
      a.async = 1;
      a.src = g;
      a.charset = 'utf-8';
      m.parentNode.insertBefore(a, m);
    })(window, document, 'script', ('https:' === document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/87b73b33.js", 'daovoice');
    daovoice('init', {
      app_id: "87b73b33",
    });
    daovoice('update');
  </script>






  <script  src="https://cdn.staticfile.org/mermaid/8.5.0/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?3ec76546d2bce23889863e13f01a5b5f";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  
    <!-- cnzz Analytics -->
    <script defer src="//s4.cnzz.com/z_stat.php?id=1278597820&show=pic"
            type="text/javascript"></script>
  





<script src="/blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/blog/live2dw/assets/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"tagMode":false,"debug":false,"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body>
</html>
