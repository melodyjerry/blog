<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MelodyHub</title>
  
  <subtitle>你用走 可是我用跑</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-29T17:14:55.054Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Melody Jerry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中的&lt;&lt;、&gt;&gt;和&gt;&gt;&gt;</title>
    <link href="http://yoursite.com/2019/11/30/Java%E4%B8%AD%E7%9A%84%E3%80%81-%E5%92%8C/"/>
    <id>http://yoursite.com/2019/11/30/Java中的、-和/</id>
    <published>2019-11-29T16:33:38.000Z</published>
    <updated>2019-11-29T17:14:55.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h1><ul><li><strong>左移运算符</strong> <strong><code>&lt;&lt;</code></strong> </li><li>👉使指定值的所有位都左移规定的次数</li><li>左移m&lt;&lt;n，代表把数字m在无溢出的前提下<strong>乘以2的n次方</strong>　 </li></ul><h1 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h1><ul><li><strong>右移运算符</strong> <strong><code>&gt;&gt;</code></strong></li><li>👉 使指定值的所有位都右移规定的次数</li><li>右移m&gt;&gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数</li><li>注意，如果是单数，也就是二进制末位为1，则结果是<strong>将m除以2的n次方的整数商</strong> </li></ul><h1 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h1><p>  <strong>无符号右移运算符</strong> <strong><code>&gt;&gt;&gt;</code></strong></p><p>👉<strong>同右移，但是结果全变正数</strong></p><a id="more"></a><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/30/MGCsdqjI5b4Y3iN.png" alt="栗子" title="">                </div>                <div class="image-caption">栗子</div>            </figure><hr><p>以下内容转载于 <a href="https://www.cnblogs.com/chuijingjing/p/9405598.html" target="_blank" rel="noopener">Java中的&lt;&lt; 和 &gt;&gt; 和 &gt;&gt;&gt; 详细分析</a> </p><h1 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h1><p><strong>&lt;&lt;表示左移，不分正负数，低位补0；</strong>　</p><p>注：以下数据类型默认为byte-8位</p><p>左移时不管正负，低位补0</p><p>正数：<font color="blue"><strong>r = 20 &lt;&lt; 2</strong></font></p><p>　　20的二进制补码：<strong>0001 0100</strong></p><p>　　向左移动两位后：<strong>0101 0000</strong></p><p>　　　　  　　结果：<strong>r = 80</strong></p><p>负数：<font color="blue"><strong>r = -20 &lt;&lt; 2</strong></font></p><p>　　-20 的二进制原码 ：<strong>1001 0100</strong></p><p>　　-20 的二进制反码 ：<strong>1110 1011</strong></p><p>　　-20 的二进制补码 ：<strong>1110 1100</strong></p><p>　　左移两位后的补码：<strong>1011 0000</strong></p><p>　　　　　　　　反码：<strong>1010 1111</strong></p><p>　　　　　　　　原码：<strong>1101 0000</strong></p><p>　　　　　　　　结果：<strong>r = -80</strong></p><p><strong>&gt;&gt;表示右移，如果该数为正，则高位补0，若为负数，则高位补1；</strong></p><p>注：以下数据类型默认为byte-8位</p><p>正数：<font color="blue"><strong>r = 20 &gt;&gt; 2</strong></font></p><p>　　20的二进制补码：<strong>0001 0100</strong></p><p>　　向右移动两位后：<strong>0000 0101</strong></p><p>　　　　　　　结果：<strong>r = 5</strong></p><p>负数：<font color="blue"><strong>r = -20 &gt;&gt; 2</strong></font></p><p>　　-20 的二进制原码 ：<strong>1001 0100</strong></p><p>　　-20 的二进制反码 ：<strong>1110 1011</strong></p><p>　　-20 的二进制补码 ：<strong>1110 1100</strong> </p><p>　　右移两位后的补码：<strong>1111 1011</strong> </p><p>　　　　　　　　反码：<strong>1111 1010</strong></p><p>　　　　　　　　原码：<strong>1000 0101</strong></p><p>　　　　　　　　结果：<strong>r = -5</strong></p><p><strong>&gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</strong></p><p>正数：　<font color="blue"><strong>r = 20 &gt;&gt;&gt; 2</strong></font></p><p>　　　　的结果与 r = 20 &gt;&gt; 2 相同；</p><p>负数：　<font color="blue"><strong>r = -20 &gt;&gt;&gt; 2</strong></font></p><p>注：以下数据类型默认为int 32位</p><p>　　-20:源码：<strong>10000000 00000000 00000000 00010100</strong></p><p>　　　　反码：<strong>11111111 11111111  11111111  11101011</strong></p><p>　　　　补码：<strong>11111111 11111111  11111111  11101100</strong></p><p>　　　　右移：<strong>00111111 11111111  11111111  11111011</strong></p><p>　　　　结果：<strong>r = 1073741819</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;左移&quot;&gt;&lt;a href=&quot;#左移&quot; class=&quot;headerlink&quot; title=&quot;左移&quot;&gt;&lt;/a&gt;左移&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;左移运算符&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;👉使指定值的所有位都左移规定的次数&lt;/li&gt;
&lt;li&gt;左移m&amp;lt;&amp;lt;n，代表把数字m在无溢出的前提下&lt;strong&gt;乘以2的n次方&lt;/strong&gt;　 &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;右移&quot;&gt;&lt;a href=&quot;#右移&quot; class=&quot;headerlink&quot; title=&quot;右移&quot;&gt;&lt;/a&gt;右移&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;右移运算符&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;👉 使指定值的所有位都右移规定的次数&lt;/li&gt;
&lt;li&gt;右移m&amp;gt;&amp;gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数&lt;/li&gt;
&lt;li&gt;注意，如果是单数，也就是二进制末位为1，则结果是&lt;strong&gt;将m除以2的n次方的整数商&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;无符号右移&quot;&gt;&lt;a href=&quot;#无符号右移&quot; class=&quot;headerlink&quot; title=&quot;无符号右移&quot;&gt;&lt;/a&gt;无符号右移&lt;/h1&gt;&lt;p&gt;  &lt;strong&gt;无符号右移运算符&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;👉&lt;strong&gt;同右移，但是结果全变正数&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java用最有效率的方法计算2乘以8</title>
    <link href="http://yoursite.com/2019/11/30/Java%E2%80%94%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%972%E4%B9%98%E4%BB%A58/"/>
    <id>http://yoursite.com/2019/11/30/Java—用最有效率的方法计算2乘以8/</id>
    <published>2019-11-29T16:24:00.000Z</published>
    <updated>2019-11-29T17:27:51.995Z</updated>
    
    <content type="html"><![CDATA[<p>最有效率的方法 👉 2 &lt;&lt; 3</p><blockquote><p>其中，左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方</p></blockquote><p>再比如，31 * num </p><p>等价于( num &lt;&lt; 5 ) – num</p><blockquote><p>左移5位相当于乘以2的5次方（32），再减去自身（-1），这一过程就相当于乘以31</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最有效率的方法 👉 2 &amp;lt;&amp;lt; 3&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中，左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再比如，31 * num &lt;/p&gt;
&lt;p&gt;等价于( num &amp;lt;&amp;lt; 
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记—static关键字</title>
    <link href="http://yoursite.com/2019/11/28/Java%E7%AC%94%E8%AE%B0%E2%80%94static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/11/28/Java笔记—static关键字/</id>
    <published>2019-11-28T09:24:41.000Z</published>
    <updated>2019-11-29T17:43:43.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h1><p><strong>修饰目标 (成员数据/方法/成员内部类/代码块)属于类的</strong></p><table><thead><tr><th>静态类</th><th>静态块</th><th>静态方法</th><th>静态变量</th></tr></thead><tbody><tr><td>static 成员内部类</td><td><font color="red">static 代码块</font></td><td>static 成员方法</td><td>static 成员变量</td></tr><tr><td>直接通过类就可以访问。所有对象共享该类</td><td>只能出现在类中不能出现方法体中，<font color="red">类加载后初始化时被执行一次</font>。<font color="sapphire">注意:区分构造代码块，每次构造都被执行</font></td><td>直接通过<font color="orange">类</font>就可以<font color="orange">调用</font>。不用等创建了实例后</td><td>类加载时在Java<font color="blue">方法区分配空间，所有对象共享</font></td></tr></tbody></table><p>区别：<strong>无static关键字成员属于具体的对象实例： <font color="green"> 实例变量、实例方法</font>(只能通过对象调用)、实例成员内部类(只能通过对象引用)</strong></p><h3 id="static-成员的访问格式"><a href="#static-成员的访问格式" class="headerlink" title="static 成员的访问格式"></a>static 成员的访问格式</h3><p>一般要通过 *<em>“  类名  ” *</em>来访问</p><table><thead><tr><th>静态变量</th><th>静态方法</th><th>静态成员内部类</th></tr></thead><tbody><tr><td>类名 . 静态变量</td><td>类名 . 静态方法</td><td>类名 . 静态成员内部类</td></tr></tbody></table><p>注意两点：</p><p>🔺 static成员方法/代码块：<strong>方法体 <font color="red" size="5"> 只能</font> 使用静态成员变量(或内部类)或调用静态方法。（老师称： <font color="blue"> 静者恒静</font>）</strong></p><p>🔺 static成员方法/代码块：<strong>方法体中不能出现this(当前对象)或super(基类对象)</strong></p><a id="more"></a><h3 id="Demo：类内使用"><a href="#Demo：类内使用" class="headerlink" title="Demo：类内使用"></a>Demo：类内使用</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*; <span class="comment">//静态导入静态方法或对象 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDemo1</span> </span>{ </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">3</span>, b, i = <span class="number">0</span>; <span class="comment">// 静态变量 </span></span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'Y'</span>; <span class="comment">// 实例变量 </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">meth</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="comment">// 静态方法 </span></span><br><span class="line">        out.println(<span class="string">"x = "</span> + x); </span><br><span class="line">        <span class="comment">//out.println("ch = " + ch);//【1】Error! </span></span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">static</span> { <span class="comment">// 静态代码块-类加载时只执行1次 </span></span><br><span class="line">        out.println(<span class="string">"静态块初始化：仅1次"</span>);</span><br><span class="line">        b = a * <span class="number">4</span>; </span><br><span class="line">        <span class="comment">//out.println("ch = " + ch);//【1】Error! </span></span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        meth(<span class="number">42</span>); <span class="comment">//静态方法调用静态方法 </span></span><br><span class="line">        <span class="keyword">new</span> StaticDemo1(); <span class="comment">//创建匿名对象1 </span></span><br><span class="line">        <span class="keyword">new</span> StaticDemo1(); <span class="comment">//创建匿名对象2 } </span></span><br><span class="line">        { </span><br><span class="line">            out.println(<span class="string">"ch = "</span> + ch);<span class="comment">//【2】OK! </span></span><br><span class="line">            out.printf(<span class="string">"构造代码块：第%d次构造第%1$d次执行\n"</span>, (++i)); </span><br><span class="line">} </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：</p><p>🔺特别注意：类的静态代码块仅在类在加载后初始化时被执行1次</p><p>🔺第一次new一个类时才加载该类</p><p>🔺静态方法、静态块不能访问非静态的成员（即，静者恒静）。如上述代码中的注释【1】</p><p>🔺静态块初始化：仅1次</p><h3 id="Demo：类外使用和静态块执行时机"><a href="#Demo：类外使用和静态块执行时机" class="headerlink" title="Demo：类外使用和静态块执行时机"></a>Demo：类外使用和静态块执行时机</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyD</span></span>{</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>{ <span class="comment">// 静态代码块【2】</span></span><br><span class="line">m = n = <span class="number">0</span>;</span><br><span class="line">out.println(<span class="string">"仅1次"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callMe</span><span class="params">()</span></span>{</span><br><span class="line">out.printf(<span class="string">"m=%d,n=%d"</span>, m, n);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDemo2</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">MyD d; <span class="comment">//【0】MyD被加载，但未主动使用</span></span><br><span class="line">d = <span class="keyword">new</span> MyD(); <span class="comment">//【1】这里才【主动使用】MyD，于是执行其静态代码块【2】</span></span><br><span class="line">MyD.n++; <span class="comment">//最佳：类名.静态变量</span></span><br><span class="line">MyD.callMe(); <span class="comment">//最佳：类名.静态方法</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>特别留意：</p><p>🔺用一个类声明一个类对象变量，至多会加载该类，但还未主动使用<br>🔺老师说：【主动使用】，是一个比较高级的专题，暂不深入</p><hr><p><font size="1">注：前面的几篇Java笔记中也有提到static，后来上课老师再小结static关键词，结合前面的笔记食用效果更佳。</font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;static-关键字&quot;&gt;&lt;a href=&quot;#static-关键字&quot; class=&quot;headerlink&quot; title=&quot;static 关键字&quot;&gt;&lt;/a&gt;static 关键字&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;修饰目标 (成员数据/方法/成员内部类/代码块)属于类的&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;静态类&lt;/th&gt;
&lt;th&gt;静态块&lt;/th&gt;
&lt;th&gt;静态方法&lt;/th&gt;
&lt;th&gt;静态变量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;static 成员内部类&lt;/td&gt;
&lt;td&gt;&lt;font color=&quot;red&quot;&gt;static 代码块&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;static 成员方法&lt;/td&gt;
&lt;td&gt;static 成员变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;直接通过类就可以访问。所有对象共享该类&lt;/td&gt;
&lt;td&gt;只能出现在类中不能出现方法体中，&lt;font color=&quot;red&quot;&gt;类加载后初始化时被执行一次&lt;/font&gt;。&lt;font color=&quot;sapphire&quot;&gt;注意:区分构造代码块，每次构造都被执行&lt;/font&gt;&lt;/td&gt;
&lt;td&gt;直接通过&lt;font color=&quot;orange&quot;&gt;类&lt;/font&gt;就可以&lt;font color=&quot;orange&quot;&gt;调用&lt;/font&gt;。不用等创建了实例后&lt;/td&gt;
&lt;td&gt;类加载时在Java&lt;font color=&quot;blue&quot;&gt;方法区分配空间，所有对象共享&lt;/font&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;区别：&lt;strong&gt;无static关键字成员属于具体的对象实例： &lt;font color=&quot;green&quot;&gt; 实例变量、实例方法&lt;/font&gt;(只能通过对象调用)、实例成员内部类(只能通过对象引用)&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;static-成员的访问格式&quot;&gt;&lt;a href=&quot;#static-成员的访问格式&quot; class=&quot;headerlink&quot; title=&quot;static 成员的访问格式&quot;&gt;&lt;/a&gt;static 成员的访问格式&lt;/h3&gt;&lt;p&gt;一般要通过 *&lt;em&gt;“  类名  ” *&lt;/em&gt;来访问&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;静态变量&lt;/th&gt;
&lt;th&gt;静态方法&lt;/th&gt;
&lt;th&gt;静态成员内部类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;类名 . 静态变量&lt;/td&gt;
&lt;td&gt;类名 . 静态方法&lt;/td&gt;
&lt;td&gt;类名 . 静态成员内部类&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;注意两点：&lt;/p&gt;
&lt;p&gt;🔺 static成员方法/代码块：&lt;strong&gt;方法体 &lt;font color=&quot;red&quot; size=&quot;5&quot;&gt; 只能&lt;/font&gt; 使用静态成员变量(或内部类)或调用静态方法。（老师称： &lt;font color=&quot;blue&quot;&gt; 静者恒静&lt;/font&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🔺 static成员方法/代码块：&lt;strong&gt;方法体中不能出现this(当前对象)或super(基类对象)&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记—this关键字</title>
    <link href="http://yoursite.com/2019/11/28/Java%E7%AC%94%E8%AE%B0%E2%80%94this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/11/28/Java笔记—this关键字/</id>
    <published>2019-11-28T09:11:18.000Z</published>
    <updated>2019-11-29T17:36:57.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><p>三个形式上的用途，但本质上就两个：</p><ul><li><font color="red">调用重载的其他构造方法</font>：放置在构造方法体首行的this()或this(实参列表)</li><li>作为当前对象，<font color="red">引用成员</font>（数据、方法等）：区分同名变量等</li><li>作为当前对象，方法返回当前对象的引用，形成<font color="red">链式调用</font></li></ul><a id="more"></a><p>案 例 ：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisDemo</span> </span>{ </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"good"</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisDemo</span><span class="params">()</span></span>{ </span><br><span class="line">        System.out.println(<span class="string">"无参构造子"</span> + <span class="keyword">this</span>); </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisDemo</span><span class="params">(<span class="keyword">int</span> a, String name)</span></span>{ </span><br><span class="line">        <span class="keyword">this</span>(); <span class="comment">// 【1】调用无参构造子 </span></span><br><span class="line">        <span class="keyword">this</span>.a = a; <span class="comment">// 【2】当前对象，引用成员 </span></span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThisDemo <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span></span>{ </span><br><span class="line">        <span class="keyword">this</span>.a = a; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 【3】返回当前对象 </span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThisDemo <span class="title">setName</span><span class="params">(String name)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThisDemo <span class="title">inc</span><span class="params">()</span></span>{</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ThisDemo t1 = <span class="keyword">new</span> ThisDemo();</span><br><span class="line">        t1.setA(<span class="number">100</span>).setName(<span class="string">"guo"</span>).inc().inc();</span><br><span class="line">        System.out.println(t1.i);</span><br><span class="line">        ThisDemo t2 = <span class="keyword">new</span> ThisDemo(<span class="number">2</span>, <span class="string">"Tom"</span>);</span><br><span class="line">        t2.inc().setA(<span class="number">8</span>).inc().inc(); <span class="comment">//【4】链式调用</span></span><br><span class="line">        System.out.println(t2.i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>特别注意，案例中的【3】和【4】。</p><hr><p><font size="1">注：前面的几篇Java笔记中也有提到this，后来上课老师再小结this关键词，结合前面的笔记食用效果更佳。</font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;this-关键字&quot;&gt;&lt;a href=&quot;#this-关键字&quot; class=&quot;headerlink&quot; title=&quot;this 关键字&quot;&gt;&lt;/a&gt;this 关键字&lt;/h1&gt;&lt;p&gt;三个形式上的用途，但本质上就两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;调用重载的其他构造方法&lt;/font&gt;：放置在构造方法体首行的this()或this(实参列表)&lt;/li&gt;
&lt;li&gt;作为当前对象，&lt;font color=&quot;red&quot;&gt;引用成员&lt;/font&gt;（数据、方法等）：区分同名变量等&lt;/li&gt;
&lt;li&gt;作为当前对象，方法返回当前对象的引用，形成&lt;font color=&quot;red&quot;&gt;链式调用&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>对SQL的触发器的浅理解</title>
    <link href="http://yoursite.com/2019/11/26/%E6%B5%85%E8%B0%88SQLServer%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://yoursite.com/2019/11/26/浅谈SQLServer触发器/</id>
    <published>2019-11-26T05:08:18.000Z</published>
    <updated>2019-11-28T11:22:43.203Z</updated>
    
    <content type="html"><![CDATA[<h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>如果需要做一些特定的增删改操作，就可以使用触发器。</p><p><font size="6">触发</font> ，当做了某种预设的操作时才会执行触发器的命令。</p><h3 id="栗子："><a href="#栗子：" class="headerlink" title="栗子："></a>栗子：</h3><p>假设现在有个员工基础信息表，里面有员工的身份证号码，手机等基本信息。那么，当你换了身份证或手机，需要修改号码的时候，肯定是去修改员工的基础资料表。假设你现在有别的地方，比如人事档案啊之类的，同样使用了员工的手机等信息，难道还要再去修改一次档案表么？那么如果还有其他地方使用了呢？而在这种时候有触发器就好解决了。如果设置一个触发器来判断，如果修改了基础表的信息，那么就同步把其他使用了基础表的关联信息也更改成最新的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;个人理解&quot;&gt;&lt;a href=&quot;#个人理解&quot; class=&quot;headerlink&quot; title=&quot;个人理解&quot;&gt;&lt;/a&gt;个人理解&lt;/h3&gt;&lt;p&gt;如果需要做一些特定的增删改操作，就可以使用触发器。&lt;/p&gt;
&lt;p&gt;&lt;font size=&quot;6&quot;&gt;触发&lt;/font&gt; ，当做了
      
    
    </summary>
    
    
    
      <category term="SQL Server" scheme="http://yoursite.com/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>G.E.M.邓紫棋《句号》MV首播！</title>
    <link href="http://yoursite.com/2019/11/25/G.E.M.%E9%82%93%E7%B4%AB%E6%A3%8B%E3%80%8A%E5%8F%A5%E5%8F%B7%E3%80%8BMV%E9%A6%96%E6%92%AD%EF%BC%81/"/>
    <id>http://yoursite.com/2019/11/25/G.E.M.邓紫棋《句号》MV首播！/</id>
    <published>2019-11-25T14:21:12.000Z</published>
    <updated>2019-11-29T04:53:27.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="G-E-M-邓紫棋《句号》MV首播！"><a href="#G-E-M-邓紫棋《句号》MV首播！" class="headerlink" title=" G.E.M.邓紫棋《句号》MV首播！"></a><font size="5" color="red"> G.E.M.邓紫棋《句号》MV首播！</font></h1><img src="https://i.loli.net/2019/11/25/RTwEij64JmDkUOz.png" alt="UTOOLS1574691446957.png" style="zoom:67%;"><p>🧡点击破亿『全创作天后』G.E.M.邓紫棋和过去告别，向未来大步迈开，开启音乐版图新起点的一个<font size="4" color="blue">“句号”</font>。 这是华语乐坛前所未见的真实披露之作，她用&lt;句号&gt;这首歌，预告了全新的音乐篇章，翻页之后，就要开始。 </p><h1 id="榜单Top-1"><a href="#榜单Top-1" class="headerlink" title="榜单Top 1"></a><font size="5" color="red">榜单Top 1</font></h1><p> 💗邓紫棋新歌《句号》上线颇有波折，国内几大音乐平台推迟上线，但在<strong>唯一上线的Apple Music平台</strong>，已经<strong>超过霉霉新歌《lover》</strong>，一举拿下  <strong><font size="6" color="orange">榜单 Top1！</font></strong></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=76560081&amp;page=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><p>官方MV视频第一发布于微博： <a href="https://weibo.com/gemtang?refer_flag=1005055014_" target="_blank" rel="noopener">GEM鄧紫棋</a>  </p><p>2019.11.28更换 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 网页视频源：    <a href="https://www.bilibili.com/video/av76560081?from=search&amp;seid=5278800382046148117" target="_blank" rel="noopener">B站官方合作发布</a> </p><a id="more"></a><h1 id="͡°-͜ʖ-͡°-✧"><a href="#͡°-͜ʖ-͡°-✧" class="headerlink" title="( ͡° ͜ʖ ͡°)✧"></a><strong><font size="5" color="gree">( ͡° ͜ʖ ͡°)✧</font></strong></h1><p>我已经 <font size="5" color="red">循环</font> MV几天了，等待网易云上架。</p><p><font size="6" color="blue">听说</font> <strong><font size="4" color="orane">“连Siri都被圈粉？有网友发现现在向Siri提出“播放世界第一的歌曲”，结果直接是《句号》”</font></strong> 有iPhone的，赶紧试试看吧 <strong>( ͡° ͜ʖ ͡°)✧</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/25/zgBwfClXivtFAG9.png" alt="@芒果捞小白.png" title="">                </div>                <div class="image-caption">@芒果捞小白.png</div>            </figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><font size="1">第一次发这篇文章的第二天发现视频链接失效，研究了一下，发现微博视频用的是临时链接，就是生命周期只有1天的临时链接，于是我改由B站的视频</font></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;G-E-M-邓紫棋《句号》MV首播！&quot;&gt;&lt;a href=&quot;#G-E-M-邓紫棋《句号》MV首播！&quot; class=&quot;headerlink&quot; title=&quot; G.E.M.邓紫棋《句号》MV首播！&quot;&gt;&lt;/a&gt;&lt;font size=&quot;5&quot; color=&quot;red&quot;&gt; G.E.M.邓紫棋《句号》MV首播！&lt;/font&gt;&lt;/h1&gt;&lt;img src=&quot;https://i.loli.net/2019/11/25/RTwEij64JmDkUOz.png&quot; alt=&quot;UTOOLS1574691446957.png&quot; style=&quot;zoom:67%;&quot;&gt;

&lt;p&gt;🧡点击破亿『全创作天后』G.E.M.邓紫棋和过去告别，向未来大步迈开，开启音乐版图新起点的一个&lt;font size=&quot;4&quot; color=&quot;blue&quot;&gt;“句号”&lt;/font&gt;。 这是华语乐坛前所未见的真实披露之作，她用&amp;lt;句号&amp;gt;这首歌，预告了全新的音乐篇章，翻页之后，就要开始。 &lt;/p&gt;
&lt;h1 id=&quot;榜单Top-1&quot;&gt;&lt;a href=&quot;#榜单Top-1&quot; class=&quot;headerlink&quot; title=&quot;榜单Top 1&quot;&gt;&lt;/a&gt;&lt;font size=&quot;5&quot; color=&quot;red&quot;&gt;榜单Top 1&lt;/font&gt;&lt;/h1&gt;&lt;p&gt; 💗邓紫棋新歌《句号》上线颇有波折，国内几大音乐平台推迟上线，但在&lt;strong&gt;唯一上线的Apple Music平台&lt;/strong&gt;，已经&lt;strong&gt;超过霉霉新歌《lover》&lt;/strong&gt;，一举拿下  &lt;strong&gt;&lt;font size=&quot;6&quot; color=&quot;orange&quot;&gt;榜单 Top1！&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=76560081&amp;amp;page=0&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;p&gt;官方MV视频第一发布于微博： &lt;a href=&quot;https://weibo.com/gemtang?refer_flag=1005055014_&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GEM鄧紫棋&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;2019.11.28更换 &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 网页视频源：    &lt;a href=&quot;https://www.bilibili.com/video/av76560081?from=search&amp;amp;seid=5278800382046148117&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;B站官方合作发布&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="音乐" scheme="http://yoursite.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记—包</title>
    <link href="http://yoursite.com/2019/11/23/Java%E7%AC%94%E8%AE%B0%E2%80%94%E5%8C%85/"/>
    <id>http://yoursite.com/2019/11/23/Java笔记—包/</id>
    <published>2019-11-23T05:54:59.000Z</published>
    <updated>2019-11-29T17:36:24.562Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java笔记——包"><a href="#Java笔记——包" class="headerlink" title="Java笔记——包"></a>Java笔记——包</h3><p>创建时间：2019.11.23</p><p>说明：持续更新ing</p><hr><ol><li><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3></li></ol><p><font color="red" size="5">包(package)</font></p><p> 为了更好地组织<font color="blue" size="3"><strong>类</strong></font>，Java 提供了包机制，用于区别类名的命名空间。 </p><p>✔ 用来组织和管理类、接口、枚举和注解<br>✔ 有三方面作用：1)便于<font color="orange">组织</font>,比如按功能、按团队等；2)<font color="orange">解决命名冲突</font>；3)进行访问<font color="orange">权限控制</font>(<font color="rorange">同包可用，包外不可见等</font>)</p><blockquote><p>如同类似OS的文件夹(或目录或路径)一样，包也采用了树形目录的存储方式。</p></blockquote><a id="more"></a><hr><ol start="2"><li><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3></li></ol><ul><li>1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li><li>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li><li>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li></ul><p>🔺 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 </p><blockquote><p>同一个包中类名字是不同的，不同包中类的名字可以相同，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 </p></blockquote><hr><ol start="3"><li><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>包名</span><br><span class="line">或</span><br><span class="line"><span class="keyword">package</span> 父包名[.子包名][.孙包名][.层次下去]</span><br></pre></td></tr></tbody></table></figure><p>🔸<strong>包名符合标识符命名规范</strong>，一般由<u><font color="rorange">小写字母</font></u>组成<br>🔹必须出现在源文件的<u><font color="rorange">第一行</font></u>(忽略注释语句)<br>🔸每个源文件<font color="rorange"><u><strong>至多只能出现一个</strong></u>package语句</font><br>🔹如果没有package语句，那就使用<u><font color="orange">无名包</font>(或称默认包:所在的当前目录)<br>🔸包的背后对应着操作系统的路径名称</u></p><u><ul><li><p>示例：</p>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch08.web.sample; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{ </span><br><span class="line">    String name; </span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//省略部分代码 </span></span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{ </span><br><span class="line">    String name; </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  🔺<code>package ch08.web.sample;</code> 这个层级的文件夹必须先存在：即ch08/web/sample</p><p>  <img src="https://i.loli.net/2019/11/23/e3XLTSaWmiuhEvR.png" alt="来自课件《8.类的更多探讨》.png"></p></li></ul><hr><ol start="4"><li><h3 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h3></li></ol><p>🔺<strong>import 关键字</strong></p><blockquote><p>为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。</p><p>为了使用另外一个包中的成员(主要是类)，可以明确import该成员。</p><p> <font color="blue">避免重复使用完整路径的类名</font>。</p></blockquote><ul><li><p>语法格式：</p>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package1[.package2…].(classname|*);</span><br></pre></td></tr></tbody></table></figure></li><li><p>注意：</p><ol><li><p>必须紧跟在package语句之后(若有的话，若无package，则import出现在源文件头部)。</p></li><li><p>可以使用 <strong><code>*</code></strong> 来表示导入当前一层包中的所有类。但是<strong><code>*</code></strong> 不可以连续使用。</p> <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.*.*; <span class="comment">// Error!</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>不表示可以继续导入当前包的子包</strong>。如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。 </p></li><li><p><strong>类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。</strong> </p></li></ol></li></ul><hr><ol start="5"><li><h3 id="Java常用包"><a href="#Java常用包" class="headerlink" title="Java常用包"></a>Java常用包</h3></li></ol><p>🔵JavaAPI的类库也是按照包的方式组织的</p><table><thead><tr><th>包名</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>Java.lang</td><td>Java语言进行程序设计的基础类(核心类库)，它是<font color="red">默认导入</font>的包</td><td>Runnable接口和<font color="blue">Object、Math、String、StringBuffer、System</font>、Thread、Throwable类</td></tr><tr><td>Java.util</td><td>实用工具类包</td><td>定义系统特性、随机数、日期时间、日历、集合类等</td></tr><tr><td>Java.io</td><td>IO类包</td><td>包含能提供多种输入输出的文件读写类</td></tr><tr><td>Java.net</td><td>网络编程API</td><td></td></tr><tr><td>Java.sql</td><td>数据库操作包</td><td></td></tr><tr><td>Java.text</td><td>文本处理相关类</td><td>包含了一些用来处理文本、数字和消息的类和接口</td></tr><tr><td>Java.awt</td><td>提供创建界面和绘制图形图像的所有类</td><td></td></tr><tr><td>Javax.asing</td><td>awt上封装的GUI包</td><td></td></tr></tbody></table></u><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java笔记——包&quot;&gt;&lt;a href=&quot;#Java笔记——包&quot; class=&quot;headerlink&quot; title=&quot;Java笔记——包&quot;&gt;&lt;/a&gt;Java笔记——包&lt;/h3&gt;&lt;p&gt;创建时间：2019.11.23&lt;/p&gt;
&lt;p&gt;说明：持续更新ing&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;font color=&quot;red&quot; size=&quot;5&quot;&gt;包(package)&lt;/font&gt;&lt;/p&gt;
&lt;p&gt; 为了更好地组织&lt;font color=&quot;blue&quot; size=&quot;3&quot;&gt;&lt;strong&gt;类&lt;/strong&gt;&lt;/font&gt;，Java 提供了包机制，用于区别类名的命名空间。 &lt;/p&gt;
&lt;p&gt;✔ 用来组织和管理类、接口、枚举和注解&lt;br&gt;✔ 有三方面作用：1)便于&lt;font color=&quot;orange&quot;&gt;组织&lt;/font&gt;,比如按功能、按团队等；2)&lt;font color=&quot;orange&quot;&gt;解决命名冲突&lt;/font&gt;；3)进行访问&lt;font color=&quot;orange&quot;&gt;权限控制&lt;/font&gt;(&lt;font color=&quot;rorange&quot;&gt;同包可用，包外不可见等&lt;/font&gt;)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如同类似OS的文件夹(或目录或路径)一样，包也采用了树形目录的存储方式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>推荐3款文本编辑器</title>
    <link href="http://yoursite.com/2019/11/22/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://yoursite.com/2019/11/22/文本编辑器/</id>
    <published>2019-11-22T02:34:04.000Z</published>
    <updated>2019-11-29T17:38:00.468Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天作者推荐两款文本编辑器。</p><p>我先后使用的Notepad 3、Sublime、Atom、VS Code、Vim。</p><p>这里作者就只推荐<strong>Notepad 3、Sublime和Atom</strong>。</p><p>关于VS Code和Vim，文末有两篇教程供大家入手。</p> <a id="more"></a>  //截断文章<h3 id="Notepad-3"><a href="#Notepad-3" class="headerlink" title="Notepad 3"></a>Notepad 3</h3><blockquote><p> 虽然 Windows 操作系统在过去几年中有了显著变化，但是，默认的 Windows 记事本却鲜有更新。如果您需要一个简单且适于编程的文本编辑器，Notepad3 将是一个不错的选择！</p></blockquote><blockquote><p> Notepad3是一款轻便快捷的基于 Scintilla 的文本编辑器，具有语法高亮、代码折叠、括号匹配、自动缩进、编码转换、换行格式转换、多次撤销或重做、书签、基于正则表达式的查找和替换等实用功能。它占用的内存很小，但功能强大，足以处理大多数编程工作。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20191031213142427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Notepad 3 的界面 可能 是我见过所有主流文本编辑器里最最最简单清爽的吧？</p><p>蓝奏云：<a href="https://www.lanzous.com/b821830" target="_blank" rel="noopener">下载链接</a>（作者提供了已经汉化过的便携版本）</p><p> （注意：Notepad 3和Notepad++没有关系 ） </p><h3 id="Sublime"><a href="#Sublime" class="headerlink" title="Sublime"></a>Sublime</h3><p><a href="http://www.sublimetext.cn/" target="_blank" rel="noopener">官方</a>的介绍简单又粗暴</p><blockquote><p><em>一款用于代码、标记和散文的精致文本编辑器</em></p></blockquote><p>Sublime支持 Windows 、Mac 平台。<br>插件是程序员的灵魂，Sublime不失这点。<br>类似于 Eclipse，IDEA，它有着丰富的插件系统，完全可以满足各种开发编辑需求。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031180340340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>1）安装</p><p><img src="https://img-blog.csdnimg.cn/20191031180945945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">官网关于Sublime的介绍语下就是win版的下载入口<br>或者点击<a href="https://download.sublimetext.com/Sublime%20Text%20Build%203207%20x64%20Setup.exe" target="_blank" rel="noopener">这里</a>快速下载最新版==Sublime Text 3 (Build 3207)==</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031181222467.png" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>下载得到的是<em>exe</em>，双击开始<em>安装</em>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031182801147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>安装导向界面，点击【Next】继续安装。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031182659507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>选择Sublime Text 3安装位置，您可以点击【Next】，软件会自动安装。或者您可以单击【Browse】，在弹出的安装位置窗口中，您可以自己选择Sublime Text安装位置，选择完成后点击【Next】。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031181142946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>这里可选择    <em>添加到资源管理器上下文菜单</em>  。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031182552911.png" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>安装完后可以在桌面或者开始菜单中找到Sublime。</p><p>2）使用<br><strong><em>Sublime的界面特别简洁，让人看着很舒服。</em></strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031183010233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>这里，作者已经汉化过了。初始语言是English。</p><p>3）汉化</p><blockquote><p>sublime 的插件的强大之处，sublime 通过 package control来统一管理安装的插件。现版本sublime 3自带package control功能。</p></blockquote><p>将English变成Chinese，也可以通过Sublime的插件实现。</p><p>作者已经汉化过。为了教程，故在win7虚拟机上教大家如何实现汉化。</p><ol><li><p>官网下载，并安装好, 刚安装好的是没有 Package Control 选项</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031202515113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li><p>找到  Tools-&gt;Install Package Control  选项，即可调出 Package Contro</p></li><li><p>不能直接找到 Install Package Control，去找“Tools-&gt;Command Palette…”选项</p></li><li><p>输入 ipc ,点击 Install Package Control，即可调出 Package Control</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031202906101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li><p>等待完成</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031203048139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li><p>找到  Preferences-&gt;Package Control</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031203441795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li><p>选项弹出命令行输入框，输入ip，点击“install Package</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031203509845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li><p>弹出命令行输入框，输入clz，点击“ChineseLocalizations”</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/2019103120320989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li><p>搞定，设置成中文了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031203530411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li><p>开开心心地食用汉化地Sublime吧    o(<em>￣▽￣</em>)o</p></li></ol><h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><blockquote><p>Atom 是 Github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持CSS，HTML，JavaScript等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。</p></blockquote><p>官网在<a href="https://atom.io/" target="_blank" rel="noopener">这里</a>👈</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031204039143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>友情链接：<br><a href="https://www.w3cschool.cn/atom/" target="_blank" rel="noopener">w3school之Atom教程</a><br><a href="https://atom-china.org/" target="_blank" rel="noopener">Atom 中文社区</a></p><p>1）安装</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031204609113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>官网地Downloa或者点击<a href="https://atom-installer.github.com/v1.41.0/AtomSetup-x64.exe?s=1571754161&amp;ext=.exe" target="_blank" rel="noopener">这里</a>快速下载最新版==Atom (1.41.0)==</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031205131795.png" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>下载得到exe，双击开始安装。<br>安装过程很简单，直接省略。</p><p>2）使用<br><strong><em>Atom 的界面也比较简洁。<br>Atom提供了侧栏、标签栏，可提高效率。<br>Atom还能链接到GitHub，这真是GitHub用户的<a href="https://www.jianshu.com/p/4c68bb302969" target="_blank" rel="noopener">福利</a>。(当然，Atom本来就是Github推出的hhhh)</em></strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031205823193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>3）汉化<br>Atom的汉化有两种方法：</p><p><strong>方法一</strong></p><ol><li>打开软件后，点击 File&gt; Settings&gt; install <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031210904530.png" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li></ol><ol start="2"><li>搜索 chinese，安装两个插件<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031210703975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li>重启软件<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031211026850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure>因为插件托管在国外，可能因为网速原因，会非常慢，因此推荐下载中文插件包，请看方法二👇</li></ol><p><strong>方法二</strong></p><ol><li>打开<a href="https://atom.io/packages/" target="_blank" rel="noopener">https://atom.io/packages/</a>去官网下载中文包，搜索【Chinese】，找到【atom-simplified-chinese-menu】点击进入主页（如上图），然后再点【Verions】，之后，找到最新版本，点【zip】包下载即可。。<br>作者在这已经准备好中文包了，点击<a href="http://down-ww3.7down.net/pcdown/soft/xiazai/atomchs_chinese.rar" target="_blank" rel="noopener">这里</a>下载<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031211522938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li>将下载好了的压缩包解压到 C:/user/&lt;用户名&gt;/.atom/packages/目录下面<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031211810975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li>打开Atom，发现已经Chinese了。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20191031211915728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzODA1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li></ol><h2 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h2><h3 id="主流的文本编辑器有很多。每个人的需求不一样，找到合适自己的才是好的。"><a href="#主流的文本编辑器有很多。每个人的需求不一样，找到合适自己的才是好的。" class="headerlink" title="主流的文本编辑器有很多。每个人的需求不一样，找到合适自己的才是好的。"></a><font color="red">主流的文本编辑器有很多。每个人的需求不一样，找到合适自己的才是好的。</font></h3><p>Notepad 3、Sublime、Atom、VS Code、Vim、<del>Notepad++（前段时间闹事，作者不方便再提）</del></p><ul><li>VS Code：<a href="https://www.jianshu.com/p/0187d02434eb" target="_blank" rel="noopener">传送门</a></li><li>Vim：<a href="https://blog.csdn.net/Alisebeast/article/details/79868694" target="_blank" rel="noopener">传送门</a> </li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天作者推荐两款文本编辑器。&lt;/p&gt;
&lt;p&gt;我先后使用的Notepad 3、Sublime、Atom、VS Code、Vim。&lt;/p&gt;
&lt;p&gt;这里作者就只推荐&lt;strong&gt;Notepad 3、Sublime和Atom&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;关于VS Code和Vim，文末有两篇教程供大家入手。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记—继承</title>
    <link href="http://yoursite.com/2019/11/21/Java%E7%AC%94%E8%AE%B0%E2%80%94%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2019/11/21/Java笔记—继承/</id>
    <published>2019-11-21T09:54:59.000Z</published>
    <updated>2019-11-29T17:36:14.410Z</updated>
    
    <content type="html"><![CDATA[<p><font size="5"> Java笔记——继承</font></p><p>创建时间：2019.11.21</p><p>说明：持续更新ing</p><hr><ol><li><h3 id="继承源于自然"><a href="#继承源于自然" class="headerlink" title="继承源于自然"></a>继承源于自然</h3><p><img src="https://i.loli.net/2019/11/23/UcXixmHJRBgnzrA.png" alt="UTOOLS1574477223867.png"></p></li></ol><blockquote><p>就比如：<br><br>兔子和羊属于食草动物类，狮子和豹属于食肉动物类。<br><br>食草动物和食肉动物又是属于动物类。<br><br>虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以 <strong>子类会具有父类的一般特性也会具有自身的特性</strong>。</p></blockquote><a id="more"></a>     //截断文章<hr><ol start="2"><li><h3 id="概念、目的、本质、特性"><a href="#概念、目的、本质、特性" class="headerlink" title="概念、目的、本质、特性"></a>概念、目的、本质、特性</h3></li></ol><ul><li>概念<blockquote><p><strong>它允许创建分等级层次的类</strong>。</p></blockquote></li></ul><p>继承就是<font color="red">子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为</font>。</p><p>其主要作用在于，<font color="red">在已有基础上继续进行功能的扩充。</font>（即，<font color="oreign">以存在的类为基础定义新的类，新类即拥有基类的数据成员和成员方法</font>）</p><ul><li>目的</li></ul><p>继承的目的是<font color="blue" size="5">代码重用</font></p><ul><li>本质</li></ul><p>描述了自然界中广泛存在的一种关系——<font color="brown" size="5">类属关系（is-a）</font>，对应还有一种has-a关系即组合（聚合）关系。</p><ul><li><p>特性</p><table><thead><tr><th align="center">Java 继承的特性</th></tr></thead><tbody><tr><td align="center">子类拥有父类非private的属性，方法</td></tr><tr><td align="center">子类可以拥有自己的属性和方法，即子类可以对父类进行扩展</td></tr><tr><td align="center">子类可以用自己的方式实现父类的方法</td></tr><tr><td align="center">Java的继承是单继承，【但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性】</td></tr><tr><td align="center">提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）</td></tr></tbody></table></li></ul><hr><ol start="3"><li><h3 id="继承的关键字"><a href="#继承的关键字" class="headerlink" title="继承的关键字"></a>继承的关键字</h3></li></ol><blockquote><p> <font size="1">继承可以使用 <font color="red" size="3">extends</font>(单继承) 和 <font color="red" size="3">implements</font>（变相的多继承）， 这两个关键字来实现继承，而且所有的类都是继承于 <strong>java.lang.Object</strong>，当一个类没有继承的两个关键字，则<strong>默认继承object</strong>（这个类在 java.lang 包中，所以不需要 import）祖先类。 </font></p></blockquote><p>（1）<strong>extends</strong>关键字</p><ul><li><p><font color="blue"><strong>Java只支持单继承</strong></font>，即：一个子类只能有一个父类.但可以有多个间接祖先类。</p></li><li><p>语法格式：</p>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 <span class="class"><span class="keyword">class</span> 父类名 </span>{</span><br><span class="line">    <span class="comment">//父类体</span></span><br><span class="line">}</span><br><span class="line">权限修饰符 <span class="class"><span class="keyword">class</span> 子类名 <span class="keyword">extends</span> 父类名 </span>{</span><br><span class="line">    <span class="comment">//子类体</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>实例：</p>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{ </span><br><span class="line">    <span class="keyword">private</span> String name;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String myName, String myid)</span> </span>{ </span><br><span class="line">        <span class="comment">//初始化属性值</span></span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{  <span class="comment">//吃东西方法的具体实现  } </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>{ <span class="comment">//睡觉方法的具体实现  } </span></span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span>  <span class="keyword">extends</span>  <span class="title">Animal</span></span>{ </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>—————————————————————— 我 是 分 割 线 ———————————————————————</p><p>（2）<strong>implements</strong>关键字</p><ul><li><p>变相地使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 </p></li><li><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;}<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;}<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span> </span>{}&lt;!--￼<span class="number">2</span>--&gt;执行结果：&lt;!--￼<span class="number">3</span>--&gt;</code></pre></li></ul><p>—————————————————————— 我 是 分 割 线 ———————————————————————</p><p>（4）<strong>this</strong>关键字</p><ul><li><p>指向<strong>”自己的引用“</strong>。</p></li><li><p>实例：</p>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"animal : eat"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"dog : eat"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eatTest</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.eat();   <span class="comment">// this 调用自己的方法</span></span><br><span class="line">    <span class="keyword">super</span>.eat();  <span class="comment">// super 调用父类方法</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">    a.eat();</span><br><span class="line">    Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">    d.eatTest();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  输出结果：</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animal : eat</span><br><span class="line">dog : eat</span><br><span class="line">animal : eat</span><br></pre></td></tr></tbody></table></figure><p>  ——————————————————————————— 我 是 分 割 线 ————————————————————————————</p></li></ul><p>（5）<strong>final</strong>关键字</p><ul><li>声明类可以把类定义为不能继承的，即<strong>最终类</strong>；或者用于修饰方法，<strong>该方法不能被子类重写</strong>。 </li></ul><hr><ol start="4"><li><h3 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h3></li></ol><p><strong>Java 不支持多继承，但支持多重继承 （ 一般不会超过三层 ）。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.runoob.com/wp-content/uploads/2013/12/types_of_inheritance-1.png" alt="继承类型" title="">                </div>                <div class="image-caption">继承类型</div>            </figure><hr><ol start="5"><li><h3 id="继承的限制"><a href="#继承的限制" class="headerlink" title="继承的限制"></a>继承的限制</h3><p>  🔺 Java只允许单继承、不允许多继承（一个子类继承一个父类）。</p><p>  🔺 子类对象在进行实例化前首先调用父类构造方法，再调用子类构造方法实例化子类对象。 </p><p>  🔺 在继承时，子类会继承父类的所有结构。</p><blockquote><p> 在进行继承的时候，子类会继承父类的所有结构（包括私有属性、构造方法、普通方法）<br><strong>显示继承</strong>：所有非私有操作属于显示继承（可以直接调用）。<br><strong>隐式继承</strong>：所有私有操作属于隐式继承（不可以直接调用，需要通过其它形式调用（get或者set））。 </p><p> <font color="red"><strong>子类能够使用的是所有非private操作，而所有的private操作无法被直接使用</strong></font>，所以称为隐式继承。 </p></blockquote></li></ol><hr><ol start="6"><li>继承中<strong>“域的隐藏”</strong></li></ol><ul><li><p>在子类中重新定义<u><font color="red">( <strong>同 名</strong> )</font></u>继承自父类的域.</p><p>  🔺子类继承父类非私域。<br>  🔺子类定义与从父类继承下来的同名域，在子类中用该名直接访问就只能访问到子类定义的域，即隐藏了同名的继承下来的父类域。<br>  🔺如果要访问同名父类域：通过父类方法，或者使用“<font color="red" size="5">*<em>super . *</em></font>”</p></li><li><p>实例：</p>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> v2 = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getV1</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="keyword">return</span> v1;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span></span>{</span><br><span class="line">    <span class="keyword">int</span> v1 = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">int</span> v2 = <span class="number">22</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        out.println(v1);</span><br><span class="line">        <span class="comment">//out.println(super.v1);</span></span><br><span class="line">        out.println(getV1());</span><br><span class="line">        out.println(v2);</span><br><span class="line">        out.println(<span class="keyword">super</span>.v2);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FHTest</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">new</span> Sub().show();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><hr><ol start="7"><li>继承情况的构造</li></ol><ul><li>首先🔺类初始化时,继承链上(包括当前类)的<font color="red">全部</font>静态代码块最先执行一次。<font color="blue">之后不再执行，除非程序又重启</font>。(<font color="red">按链序和声明序且仅1次</font>)</li><li>其次🔺创建子类实例时,会先进行父类的构造(<font color="red">要么显式进行，要么隐式用super()进行</font>)</li><li>最后🔺类的构造顺序：构造代码块(<font color="red">按声明序</font>) ➡ 构造方法</li><li>总体🔺<u>父类静态块 ➡ 子类静态块</u> ➡ 父类构造块 ➡ 父类构造子 ➡ 子类构造块 ➡ 子类构造子（下划线”__”部分， <font color="orange"> 仅执行一次</font>）</li></ul><hr><ol start="8"><li><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li></ol><p><strong>1、为什么使用继承</strong></p><p>从已有的类派生出新的类，称为继承。</p><p>在不同的类中也可能会有共同的特征和动作，可以把这些共同的特征和动作放在一个类中，让其它类共享。</p><p>因此可以定义一个通用类，然后将其扩展为其它多个特定类，这些特定类继承通用类中的特征和动作。</p><p>继承是 Java 中实现软件重用的重要手段，避免重复，易于维护，易于理解。</p><p><strong>2、父类和子类</strong></p><p>如果类 B 从类 A 派生，或者说类 B 扩展自类 A，或者说类 B 继承类 A，</p><p>则称类 A 为”父类”，也称为超类、基类；</p><p>称类 B 为”子类”，也称为次类、扩展类、派生类。</p><p>子类从它的父类中继承可访问的数据域和方法，也可以添加新的数据域和新的方法。</p><p>定义继承的语法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 子类名 <span class="keyword">extends</span> 父类名</span></span><br></pre></td></tr></tbody></table></figure><p>例如：Shape 类是父类，其子类可以有 Circle 类、Rectangle 类、Triangle 类，等等。</p><p>继承的注意点：</p><ul><li>子类不是父类的子集，子类一般比父类包含更多的数据域和方法。</li><li>父类中的 private 数据域在子类中是不可见的，因此在子类中不能直接使用它们。</li><li>继承是为”是一个”的关系建模的，父类和其子类间必须存在”是一个”的关系，否则不能用继承。<br>  但也并不是所有”是一个”的关系都应该用继承。例如，正方形是一个矩形，但不能让 Square 类来继承 Rectangle 类，因为正方形不能从矩形扩展得到任何东西。正确的继承关系是 Square 类继承 Shape 类</li><li>Java 只允许单一继承（即一个子类只能有一个直接父类），C++ 可以多重继承（即一个子类有多个直接父类）。</li></ul><p><strong>3、super 关键字</strong></p><p>super 表示使用它的类的父类。super 可用于：</p><ul><li>调用父类的构造方法；</li><li>调用父类的方法（子类覆盖了父类的方法时）；</li><li>访问父类的数据域（可以这样用但没有必要这样用）。</li></ul><p>调用父类的构造方法语法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>();  </span><br><span class="line"></span><br><span class="line">或   </span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(参数列表);</span><br></pre></td></tr></tbody></table></figure><p>注意：super 语句必须是子类构造方法的第一条语句。不能在子类中使用父类构造方法名来调用父类构造方法。 父类的构造方法不被子类继承。调用父类的构造方法的唯一途径是使用 super 关键字，如果子类中没显式调用，则编译器自动将 super(); 作为子类构造方法的第一条语句。这会形成一个构造方法链。</p><p>静态方法中不能使用 super 关键字。</p><p>调用父类的方法语法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.方法名(参数列表);</span><br></pre></td></tr></tbody></table></figure><p>如果是继承的方法，是没有必要使用 super 来调用，直接即可调用。但如果子类覆盖或重写了父类的方法，则只有使用 super 才能在子类中调用父类中的被重写的方法。</p><p><strong>4、this 关键字</strong></p><p>this 关键字表示当前对象。可用于：</p><ul><li>调用当前类的构造方法，并且必须是方法的第一条语句。如：this(); 调用默认构造方法。this(参数); 调用带参构造方法。</li><li>限定当前对象的数据域变量。一般用于方法内的局部变量与对象的数据域变量同名的情况。如 this.num = num。this.num 表示当前对象的数据域变量 num，而 num 表示方法中的局部变量。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font size=&quot;5&quot;&gt; Java笔记——继承&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;创建时间：2019.11.21&lt;/p&gt;
&lt;p&gt;说明：持续更新ing&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;继承源于自然&quot;&gt;&lt;a href=&quot;#继承源于自然&quot; class=&quot;headerlink&quot; title=&quot;继承源于自然&quot;&gt;&lt;/a&gt;继承源于自然&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/23/UcXixmHJRBgnzrA.png&quot; alt=&quot;UTOOLS1574477223867.png&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;就比如：&lt;br&gt;&lt;br&gt;兔子和羊属于食草动物类，狮子和豹属于食肉动物类。&lt;br&gt;&lt;br&gt;食草动物和食肉动物又是属于动物类。&lt;br&gt;&lt;br&gt;虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以 &lt;strong&gt;子类会具有父类的一般特性也会具有自身的特性&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记—数组</title>
    <link href="http://yoursite.com/2019/11/20/Java%E7%AC%94%E8%AE%B0%E2%80%94%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/11/20/Java笔记—数组/</id>
    <published>2019-11-20T04:54:46.000Z</published>
    <updated>2019-11-29T17:36:21.566Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java笔记——数组"><a href="#Java笔记——数组" class="headerlink" title="Java笔记——数组"></a>Java笔记——数组</h3><p>创建时间：2019.11.20</p><p>说明：持续更新ing</p><p>——————————————————————————— 我 是 分 割 线 ————————————————————————————</p><p><font size="5" color="blue">数组</font></p><hr><ol><li><font size="5" color="blue">数组</font>是一组<strong>相同类型的变量（元素）的集合</strong>。可以用来存放一组相同类型的数据。数组的学习涉及数组的定义、赋值和使用。再扩展一点就是二维数组的应用。<strong>数组既是一种重要的数据类型，也是一种重要的数据结构。</strong></li></ol><hr><ol start="2"><li><p><font size="5" color="red">数组（array）</font>————一组相同类型的变量(元素)集合</p><ul><li><p><strong>相同</strong>的<strong>任意类型</strong> <em>(包括基本类型、类类型等)</em></p></li><li><p>这组变量被<strong>连续地</strong>存放在Java<strong>堆区</strong>的内存空间</p></li><li><p>数组是一种<strong>引用类型</strong>，数组名是一个地址的别名</p></li><li><p>数组需要创建（new），否则不会被分配<strong>堆</strong>空间</p></li><li><p>数组名对应的地址单元中存放上述连续堆区空间的首地址 </p><p>🔺 对程序员而言, 数组总体有三样东西：<font size="3" color="oreign">数组名+数组长度+数组元素</font></p><a id="more"></a></li></ul></li></ol><hr><ol start="3"><li><font size="5" color="green">“声明、创建、初始化、访问”数组</font></li></ol><p><font size="4" color="bron">声明数组：</font></p><pre><code>🔺只给数组变量(由数组名描述)分配空间，而不会给数组按要存放的元素的多少来分配空间。</code></pre><ul><li>有两种形式——&gt;推荐第一种：    <font size="3" color="ydasd">数据类型[]    数组名</font></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据类型[]数组名</span></span><br><span class="line"><span class="keyword">int</span>[]a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据类型数组名[]</span></span><br><span class="line"><span class="keyword">int</span>a[];</span><br></pre></td></tr></tbody></table></figure><p> ——————————————————————————— 我 是 分 割 线 ———————————————————————————— </p><p><font size="4" color="bron">创建数组：</font>用<strong>new运算符</strong>，同对象的创建。</p><ul><li>有两种形式——&gt;</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先声明，后创建</span></span><br><span class="line"><span class="keyword">int</span>[] a; <span class="comment">//声明存放int型数据的数组a</span></span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//在Java堆区中创建10个int型元素空间(共40个字节)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明和创建合一</span></span><br><span class="line"><span class="keyword">int</span>[]test = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];</span><br></pre></td></tr></tbody></table></figure><p>注意：</p><ol><li><p>🔺声明数组，仅仅创建数组变量<br>🔺创建数组，才在堆区中分配空间</p></li><li><p><code>[ ]</code>中必须是<strong>非负整数</strong>，否则执行时异常。可以是字面常量、也可以是变量，只要保证其值是<strong>非负整数</strong>。</p></li><li><p>创建数组之后，各元素的默认初始值是：<strong>数值型为0(0.0)；字符型’\0’；引用类型null；布尔型false</strong></p></li></ol><p> ——————————————————————————— 我 是 分 割 线 ———————————————————————————— </p><p><font size="4" color="bron">初始化数组：</font>在创建好的数组元素空间中存放初始值.否则按默认值初始化。</p><p>🔺数组<font color="orange">创建时（即new时使用）</font>初始化器语法：<strong>{元素值列表}</strong>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明存放int型数据的数组aMonth并初始化</span></span><br><span class="line"><span class="keyword">int</span>[] aMonth = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>};</span><br></pre></td></tr></tbody></table></figure><p>注意：</p><ul><li><p>使用了初始化器之后<strong>不能显式指定长度</strong></p><p>  即 <code>new int[12]{…}</code> ，不对</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a; <span class="comment">//先声明数组a</span></span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]{<span class="number">1</span>,<span class="number">2</span>}; <span class="comment">// Error,不能显式指明长度[2]</span></span><br><span class="line">a = {<span class="number">1</span>,<span class="number">2</span>}; <span class="comment">// Error</span></span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>,<span class="number">2</span>}; <span class="comment">// OK!</span></span><br><span class="line"><span class="keyword">int</span>[] b = {<span class="number">1</span>, <span class="number">2</span>}; <span class="comment">// OK!此方式用得最多</span></span><br></pre></td></tr></tbody></table></figure><p>——————————————————————————— 我 是 分 割 线 ———————————————————————————— </p><p><font size="4" color="bron">访问数组：</font></p><p>🔺数组元素：数组中的每一个变量，也被称为<strong>下标变量</strong>，索引变量</p><p>🔺下标从0开始：用<code>[ ]</code>运算符访问元素，即 <strong><code>数组名 [ 数组下标 ]</code></strong></p><p>🔺既然是变量，所以数组元素可以作为左值也可以作为右值，比如<code>a[i]++</code>、<code>b[0]=5;</code>、<code>a=b[0]+2;</code>等等。</p><hr><ol start="4"><li><font size="5" color="orange">数组长度属性</font></li></ol><p>🔺数组唯一的一个 <font color="red">只读</font> 属性：<strong>length</strong> 存有数组<strong>元素个数值</strong>。</p><p>🔺*<em><code>数组名.length</code> *</em></p><hr><ol start="5"><li><font size="5" color="oragan">遍历数组</font></li></ol><p>🔺增强版for语句：<strong>foreach语句</strong>（JDK5开始提供）</p><p>🔺适用于<strong>遍历数组、集合元素</strong>等形式</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 遍历变量x : 遍历对象obj){ <span class="comment">//x是自定义遍历变量名</span></span><br><span class="line">    引用了x的Java语句; <span class="comment">//循环体 </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：</p><ol><li>foreach语句是for的简化,任何foreach语句都可以改用for语句，<strong>反之不行</strong>。</li><li>foreach语句<strong>不关注下标</strong>。</li><li>用foreach的遍历变量<strong>不能修改元素值</strong>。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{ </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{ </span><br><span class="line">         <span class="keyword">int</span>[] a = {<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>}; </span><br><span class="line">        <span class="comment">/* 循环输出a */</span> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : a){ <span class="comment">// 利用变量n遍历数组a </span></span><br><span class="line">            System.out.printf(<span class="string">"%4d "</span>, n); <span class="comment">// n表示数组a的每一个元素值 </span></span><br><span class="line">    } </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><ol start="6"><li><font size="5" color="blue">二维数组、多维数组</font></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/hwLPKbXz8HZvNUf.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/Z4k5HJdKWUuj38z.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/Xv2VPuHh5zEJTi4.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/sYbASXVNvBitrhw.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><hr><ol start="7"><li><font size="5" color="oreia">Arrays 类</font></li></ol><p>主要功能：</p><p>🔺<strong>java.util.Arrays类： 数组操作实用类,它提供了一系列静态方法</strong></p><ul><li><strong>equals()</strong>方法:比较两个数组长度是否相同和对应索引上的元素值是否相同.</li><li>fill()方法:向数组中填充数据.</li><li><strong>copyOf()</strong>方法:复制一个数组的部分元素并生成一个新的数组返回</li><li><strong>sort()</strong>方法:若是基本类型则把数组元素按自然顺序<strong>升序</strong>排列.若是引用类型,<strong>其该实现了Comparable接口才能调用sort方法</strong>,否则报异常.</li><li>binarySearch()方法:对已排序数组使用二分查找算法查找指定元素.</li><li><strong>asList()</strong>方法:返回数组的List对象形式.</li><li><strong>toString()</strong>方法:返回包含所有元素信息的字符串</li><li>parallelSort()方法:开启多线程的排序.</li><li>deepEquals()方法:深度比较两个数组是否相同.适于任何深度的多维(嵌套)数组.</li></ul><hr><ol start="8"><li>问：数组可以作为方法的参数或返回值吗？</li></ol><blockquote><p> 当然是可以的 。答案来源 m<a href="https://blog.csdn.net/Luojun13Class/article/details/83020293" target="_blank" rel="noopener">博客</a></p></blockquote><ol><li><strong>数组作为方法参数</strong></li></ol><p>🔺数组作为方法参数传递，传递的参数是<strong>数组内存的地址</strong>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[] arr = {<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>};</span><br><span class="line">    System.out.println(<span class="string">"1位置: "</span> + arr);</span><br><span class="line">    printArray(arr);  <span class="comment">// 数组作为方法参数传递，传递的参数是数组内存的地址</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"2位置: "</span> + arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20181011225148487?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1b2p1bjEzQ2xhc3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><ol start="2"><li><strong>数组作为方法返回值</strong></li></ol><p>🔺数组作为方法的返回值，返回的是<strong>数组的内存地址</strong>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="comment">//调用方法，接收数组的返回值</span></span><br><span class="line">    <span class="comment">//接收到的是数组的内存地址</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = getArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">System.out.println(arr[i]);        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  创建方法，返回值是数组类型</span></span><br><span class="line"><span class="comment">  return返回数组的地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getArray() {</span><br><span class="line">    <span class="keyword">int</span>[] arr = { <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> };</span><br><span class="line">    <span class="comment">//返回数组的地址，返回到调用者</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">}</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20181011225223723?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1b2p1bjEzQ2xhc3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>该博主的延伸阅读： <a href="https://blog.csdn.net/Luojun13Class/article/details/83020011" target="_blank" rel="noopener">Java–数组的定义和访问</a>、<a href="https://blog.csdn.net/Luojun13Class/article/details/83020086" target="_blank" rel="noopener">Java–数组原理内存图</a>、<a href="https://blog.csdn.net/Luojun13Class/article/details/83020199" target="_blank" rel="noopener">Java–数组的常见操作</a> </p><hr><ol start="9"><li>判断： Java中数组可以动态改变长度？</li></ol><blockquote><p>错误。 Java中的数组的定义就是相同类型，固定长度的一组数据，一旦被初始化，长度不可更改。 </p></blockquote><hr><p>10. </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java笔记——数组&quot;&gt;&lt;a href=&quot;#Java笔记——数组&quot; class=&quot;headerlink&quot; title=&quot;Java笔记——数组&quot;&gt;&lt;/a&gt;Java笔记——数组&lt;/h3&gt;&lt;p&gt;创建时间：2019.11.20&lt;/p&gt;
&lt;p&gt;说明：持续更新ing&lt;/p&gt;
&lt;p&gt;——————————————————————————— 我 是 分 割 线 ————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;font size=&quot;5&quot; color=&quot;blue&quot;&gt;数组&lt;/font&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;font size=&quot;5&quot; color=&quot;blue&quot;&gt;数组&lt;/font&gt;是一组&lt;strong&gt;相同类型的变量（元素）的集合&lt;/strong&gt;。可以用来存放一组相同类型的数据。数组的学习涉及数组的定义、赋值和使用。再扩展一点就是二维数组的应用。&lt;strong&gt;数组既是一种重要的数据类型，也是一种重要的数据结构。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;font size=&quot;5&quot; color=&quot;red&quot;&gt;数组（array）&lt;/font&gt;————一组相同类型的变量(元素)集合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;相同&lt;/strong&gt;的&lt;strong&gt;任意类型&lt;/strong&gt; &lt;em&gt;(包括基本类型、类类型等)&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这组变量被&lt;strong&gt;连续地&lt;/strong&gt;存放在Java&lt;strong&gt;堆区&lt;/strong&gt;的内存空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数组是一种&lt;strong&gt;引用类型&lt;/strong&gt;，数组名是一个地址的别名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数组需要创建（new），否则不会被分配&lt;strong&gt;堆&lt;/strong&gt;空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数组名对应的地址单元中存放上述连续堆区空间的首地址 &lt;/p&gt;
&lt;p&gt;🔺 对程序员而言, 数组总体有三样东西：&lt;font size=&quot;3&quot; color=&quot;oreign&quot;&gt;数组名+数组长度+数组元素&lt;/font&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>教会你怎么安装和使用 Visio 哦 ~ ~</title>
    <link href="http://yoursite.com/2019/11/19/Visio%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/11/19/Visio教程/</id>
    <published>2019-11-19T01:34:04.000Z</published>
    <updated>2019-11-29T17:38:35.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>很多学生会在编程、设计或其他时候可能使用到【制图工具】。最好用的莫不过【微软的Visio】了。<del>但是很多学生不会使用Visio，甚至不会安装Visio。</del>   &gt;    </p></blockquote><p>Visio 这么好的工具，一定要会用。    </p><p>今天，作者写一份教程，教会大家了解如何<strong>安装和使用 ==Visio==</strong>。    </p><p>在正式教程之前，我们先介绍 Visio。  </p><blockquote><p>Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。  &gt; Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。    </p></blockquote><p><img src="https://i.loli.net/2019/11/23/QzMuCJyZ8ibGc6h.png" alt="UTOOLS1574501389810.png"></p><a id="more"></a>  //截断文章<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1. 【下载资源】  网上也有很多资源，但是包是不完整的。版本也很多，要激活也不容易。  作者在这里已经打包好“Visio 2019”和“激活工具”了，点击<a href="https://pan.baidu.com/s/1VQUlOEQw8lEAM_odBLaSyA" target="_blank" rel="noopener">这里</a>(提取码: rwtr)开始下载。  由于现在的笔记本都是预装win10的，所以不用担心Visio 2019合不合适。毕竟Visio 2019在win7上是安装不了的。<br>2. 【解压】  下载得到压缩包，解压，打开文件夹。  </p><p><img src="https://i.loli.net/2019/11/23/wgxJfyOmkVYnC15.png" alt="UTOOLS1574501412392.png"></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/23/1c4N9J7TSPkxMGs.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><p>3. 【打开Setup】  打开“Visio 2019”，右键“Setup”选中“以管理员身份运行”。（似乎不用管理员也行？？？）  </p><p><img src="https://i.loli.net/2019/11/23/oWOfUzdiTlA1a7y.png" alt="UTOOLS1574501422677.png"></p><p>  4. 【正在安装】  等待就好，很快的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/23/goK85rHYGkOeyWL.png" alt="UTOOLS1574501447151.png" title="">                </div>                <div class="image-caption">UTOOLS1574501447151.png</div>            </figure>  <p>5. 【安装完成】  安装结束，点击“关闭”。  </p><p><img src="https://i.loli.net/2019/11/23/dPhLSBmC2MTHNEA.png" alt="UTOOLS1574501453578.png"></p><p>6. 【激活】  <strong>Visio 2019是==必须激活==才可以使用的。</strong>  <em>否则，会一直弹窗提示激活的。</em>  激活工具在另一个文件夹里。 </p><p> <img src="https://i.loli.net/2019/11/23/FE6GecDvBdyq1YQ.png" alt="UTOOLS1574501477474.png"></p><blockquote><p>补充一些关于KMS：  KMS（全称:Key Management Service），这个是微软的一种新型产品激活机制，目的是为了Microsoft更好的遏制非法软件授权行为(盗版)。 </p></blockquote><p><strong>当然作者不提倡破解、或盗版。  对于有能力的人，还是支持正版。但是学生嘛，能用就好了。</strong>    </p><p>使用激活工具前，作者建议：    </p><p>==最好关闭杀毒软件，如果有的话。==    </p><p>作者没安装360那些，很流畅地激活成功。    </p><p>==激活工具无毒的。不关闭的话，可能被误报。==    </p><p>1).【打开】  界面如下：    </p><p><img src="https://i.loli.net/2019/11/23/IzwFjHaUQ7AtN63.png" alt="image.png"></p><p>  <del>这个激活工具还可以xxxxxx。（你懂的）</del> 我啥都没说哦hh    </p><p>2).【激活】  简单一按，等待激活成功就好。 </p><p> <img src="https://i.loli.net/2019/11/23/uRYEzqUIs32DmOb.png" alt="UTOOLS1574501487906.png"></p><h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>可能有的电脑打开软件时会提示这个。解决很简单，安装框架就好。   </p><p><img src="https://i.loli.net/2019/11/23/w14CX8z9alB7fTv.png" alt="image.png"></p><p>（1）打开“控制面板”。<br>（2）找到并点击“程序和功能”项，在打开的页面中，点击“启用或关闭Windows功能”。<br>（3）在打开的“Windows功能”对话框中，找到并勾选“Microsoft.Net Framework”服务，单击“确定”即可。    </p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>激活后，就可以安安心心、大大方方地使用 Visio 了。o(<em>￣▽￣</em>)o    </p><p>【打开】  </p><p><img src="https://i.loli.net/2019/11/23/GKdWZOSMe2nhUay.png" alt="UTOOLS1574501547116.png"></p><p>【新建】<br>新建页面，有一些初始模板可以使用。<br>一般选择“基本框图”就好，然后“新建”。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/23/Y1y69UqocWkJvLT.png" alt="UTOOLS1574501515942.png" title="">                </div>                <div class="image-caption">UTOOLS1574501515942.png</div>            </figure><p>【制图】    </p><p>左侧可以选择很多官方自带的形状，当然还可以自己建立自己的模型。<br> 右侧可以对图形自定义，包括颜色、线条、端点等等。  </p><p><img src="https://i.loli.net/2019/11/23/MxrPbFt8IpTQhK4.png" alt="UTOOLS1574501554468.png"></p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>使用 Visio 来制图真的很爽。<br>但是，如果只是临时制图使用 Visio ，还得安装确实不太方便。<br>因此 作者还<strong>收藏了几个线上制图的网站，在这提供给大家临时使用。</strong></p><p>1. <a href="https://www.draw.io/" target="_blank" rel="noopener">https://www.draw.io/</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/23/tXvca7DgsR4bMpo.png" alt="UTOOLS1574501571713.png" title="">                </div>                <div class="image-caption">UTOOLS1574501571713.png</div>            </figure>   <p> 2. <a href="https://zh.numberempire.com/graphingcalculator.php" target="_blank" rel="noopener">https://zh.numberempire.com/graphingcalculator.php</a>  </p><p><img src="https://i.loli.net/2019/11/23/Q2EDKNdeMhcimgq.png" alt="UTOOLS1574501583347.png"></p><p>3. <a href="https://www.processon.com" target="_blank" rel="noopener">https://www.processon.com</a> </p><p><img src="https://i.loli.net/2019/11/23/tZAV7qwN2hfDomO.png" alt="image.png">      </p><p>4. 当然用电脑自带的【画图】也是可以的，你看。 </p> <img src="https://i.loli.net/2019/11/23/N5Uvxj9peCQbsR7.png" alt="UTOOLS1574501608879.png" title="UTOOLS1574501608879.png"><p>  emmm只是好难看啊hhhh。    </p><h4 id="这就是结尾：如果教程上有什么不足的或者有问题的，可以私信我。谢谢你的阅读！"><a href="#这就是结尾：如果教程上有什么不足的或者有问题的，可以私信我。谢谢你的阅读！" class="headerlink" title="这就是结尾：如果教程上有什么不足的或者有问题的，可以私信我。谢谢你的阅读！"></a>这就是结尾：如果教程上有什么不足的或者有问题的，可以私信我。谢谢你的阅读！</h4><hr><p><font size="1">本博客第一次发表于【简书】： <a href="https://www.jianshu.com/p/32648bcc6f1c" target="_blank" rel="noopener">https://www.jianshu.com/p/32648bcc6f1c</a>  。现转载到作者的网站上。谢谢阅读！</font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;很多学生会在编程、设计或其他时候可能使用到【制图工具】。最好用的莫不过【微软的Visio】了。&lt;del&gt;但是很多学生不会使用Visio，甚至不会安装Visio。&lt;/del&gt;   &amp;gt;    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Visio 这么好的工具，一定要会用。    &lt;/p&gt;
&lt;p&gt;今天，作者写一份教程，教会大家了解如何&lt;strong&gt;安装和使用 ==Visio==&lt;/strong&gt;。    &lt;/p&gt;
&lt;p&gt;在正式教程之前，我们先介绍 Visio。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Visio 是office软件系列中的负责绘制流程图和示意图的软件，是一款便于IT和商务人员就复杂信息、系统和流程进行可视化处理、分析和交流的软件。使用具有专业外观的 Office Visio 图表，可以促进对系统和流程的了解，深入了解复杂信息并利用这些知识做出更好的业务决策。  &amp;gt; Microsoft Office Visio帮助您创建具有专业外观的图表，以便理解、记录和分析信息、数据、系统和过程。    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/11/23/QzMuCJyZ8ibGc6h.png&quot; alt=&quot;UTOOLS1574501389810.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>百合</title>
    <link href="http://yoursite.com/2019/11/16/%E7%99%BE%E6%97%A5/"/>
    <id>http://yoursite.com/2019/11/16/百日/</id>
    <published>2019-11-16T12:54:59.000Z</published>
    <updated>2019-11-25T12:23:15.221Z</updated>
    
    <content type="html"><![CDATA[<p>2019.11.16    星期六    晴天</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=35470766&amp;auto=0&amp;height=66"></iframe><br><img src="https://i.loli.net/2019/11/24/oyFDXs9narNzQJM.png" alt="百合花.png" style="zoom: 25%;"><a id="more"></a><p>💙汪曾祺老人的散文《活着多好呀》中“活着多好呀”为汪老一句名言。这位老人不管遇到什么环境，永远不消沉沮丧，守护心中的热情与生机，兴致盎然地生活。<br>💛时光机，这个世界不存在的理想物品。可是我多希望有这东西，真是可惜无法回到两三年前，“时间就是让人猝不及防的东西”……<br>💜有段时间，喜欢黑暗安静的环境。肚子一个人发呆，内室里一个窗户也不开，杜绝所有来往。但已经走出来那段抑郁期，今后不知道，但是现在我挺好的。恍惚发现，最好掩盖哭的方式，除了偷偷一个人，就是洗澡的时候。<br>💚或记日记或写随笔或向月亮倾诉或对空气说说，~生活不易，但也没那么糟糕。<br>柏拉图说：没有什么比健康更快乐的了，虽然在他们生病之前并不曾觉得那是最大的快乐。<br>💗“谢谢你的不告而别”。下辈子，我们再会 !</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019.11.16    星期六    晴天&lt;/p&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;amp;id=35470766&amp;amp;auto=0&amp;amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
&lt;img src=&quot;https://i.loli.net/2019/11/24/oyFDXs9narNzQJM.png&quot; alt=&quot;百合花.png&quot; style=&quot;zoom: 25%;&quot;&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>解除课程中心看视频时的“ 窗口获取焦点事件 ”</title>
    <link href="http://yoursite.com/2019/11/16/%E8%A7%A3%E9%99%A4%E8%AF%BE%E7%A8%8B%E4%B8%AD%E5%BF%83%E7%9C%8B%E8%A7%86%E9%A2%91%E6%97%B6%E7%9A%84%E2%80%9C%20%E7%AA%97%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6%20%E2%80%9D/"/>
    <id>http://yoursite.com/2019/11/16/解除课程中心看视频时的“ 窗口获取焦点事件 ”/</id>
    <published>2019-11-16T09:54:59.000Z</published>
    <updated>2019-11-23T02:16:39.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，在观看课程中心的马克思视频，因为要<strong>至少看到80%以上</strong>。</p><h2 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h2><p>那我挂着刷不就得了？偏偏。。。。。</p><p>发现这个课程中心存在某个机制——<strong>一定要使视频一直处于“置顶”的状态，否者会自动暂停视频</strong>。</p><a id="more"></a>  //截断文章<p>就像下图这样：</p><p>操作鼠标前——&gt;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/jAVgqoWRcBYCbNx.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><p>操作鼠标后——&gt;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/zH3BSiqobAepMtw.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><p>你会注意到，视频的播放状态跟鼠标的行为有关，准确来说是==和鼠标点击的位置（焦点）有关==。</p><p>第一时间想到“这不就是windows的<strong>“窗口获取焦点”</strong>吗？</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>先补充补充什么是<strong>窗口获取焦点</strong>？</p><blockquote><ul><li><p>在你浏览其他窗口页面、或是浏览器最小化、又或是点击了程序窗口时，等等都算是浏览器窗口失去焦点，这时候 <strong><code>window.onblur</code></strong> 事件就会触发。 </p></li><li><p>当然，当你的页面获得焦点的时候一样也会触发<strong><code>window.onfocus</code></strong>。</p></li><li><p>应该有人会注意到过，当你点击不同窗口时，窗口栏会有不同的颜色反馈，就比如win 10的资源管理器，前置窗口和后置窗口的窗口颜色是不是不一样？</p>  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/LSU5XReK4Pzylaj.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure></li></ul></blockquote><h2 id="寻找"><a href="#寻找" class="headerlink" title="寻找"></a>寻找</h2><p>直接按下<code>F12</code>，打开控制台，查看Elements……</p><p>emmmmmm结果，没找到对应的代码（或许我没仔细去挖hh）</p><h2 id="再试"><a href="#再试" class="headerlink" title="再试"></a>再试</h2><p>那我直接Console。不就是当前窗口获取了焦点吗？？？？直接暴力敲下代码，并Enter，嘿嘿……</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript:<span class="built_in">window</span>.onblur=<span class="literal">null</span>;<span class="keyword">void</span> <span class="number">0</span><span class="comment">//有无`void 0`，都可以</span></span><br></pre></td></tr></tbody></table></figure><h2 id="当我Enter时，诶，成功了hhh"><a href="#当我Enter时，诶，成功了hhh" class="headerlink" title="当我Enter时，诶，成功了hhh"></a>当我Enter时，诶，成功了hhh</h2><p>效果就是这样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/EyMkej7OPU2dTaQ.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>测试了一段时间后，成功率基本达97%左右。后来就分享到班群，让更多人试试效果。两天刷完所有马克思的视频哈哈有木有？</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li><p><strong>一次最多同时两个视频在看</strong>，因为后台有个计时器再加上我不会写自动播放、自动静音的脚本hhhhh（有时间再去琢磨哈）</p></li><li><p><strong><em>一旦刷新页面，就得重新Enter脚本</em></strong></p></li><li><p>极小几率会失败，原因我也不清楚，失败重新Enter即可。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，在观看课程中心的马克思视频，因为要&lt;strong&gt;至少看到80%以上&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;发现&quot;&gt;&lt;a href=&quot;#发现&quot; class=&quot;headerlink&quot; title=&quot;发现&quot;&gt;&lt;/a&gt;发现&lt;/h2&gt;&lt;p&gt;那我挂着刷不就得了？偏偏。。。。。&lt;/p&gt;
&lt;p&gt;发现这个课程中心存在某个机制——&lt;strong&gt;一定要使视频一直处于“置顶”的状态，否者会自动暂停视频&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记—对象、类</title>
    <link href="http://yoursite.com/2019/11/15/Java%E7%AC%94%E8%AE%B0%E2%80%94%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/11/15/Java笔记—对象、类/</id>
    <published>2019-11-15T04:54:59.000Z</published>
    <updated>2019-11-29T17:36:11.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java笔记——对象、类"><a href="#Java笔记——对象、类" class="headerlink" title="Java笔记——对象、类"></a>Java笔记——对象、类</h3><p>创建时间：2019.11.11</p><p>说明：持续更新ing</p><hr><ol><li><strong><code>对象</code></strong>和<strong><code>类</code></strong>的概念。</li></ol><ul><li><blockquote><p><code>对象</code>：对象是类的一个实例（实实在在存在的个体），有<strong>属性（状态）</strong>和<strong>行为</strong>。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</p><p>属性(property)： 静态特征<br>行为(behavior)： 动态特征</p></blockquote></li><li><blockquote><p><code>类</code>：类是对现实生活中事物的描述。类是一个模板，它描述一类对象的行为和状态。<strong>同种类型对象共性的抽象</strong></p></blockquote></li></ul><a id="more"></a><ul><li><p>用老师的话来说，就是下面这样——&gt;</p>  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/fB95MSm8EWJD6IV.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure></li><li><p>下图中<strong>男孩（boy）</strong>、<strong>女孩（girl）</strong>为<strong>类（class）</strong>，而具体的每个人为该类的<strong>对象（object）</strong>：</p>  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/12/P8M5LWHdIcs42yB.png" alt="菜鸟教程.png" title="">                </div>                <div class="image-caption">菜鸟教程.png</div>            </figure></li></ul><hr><ol start="2"><li>【定义类】</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\丶Melody\AppData\Roaming\Typora\typora-user-images\image-20191116135106458.png" alt="image-20191116135106458" title="">                </div>                <div class="image-caption">image-20191116135106458</div>            </figure><hr><ol start="3"><li></li></ol><ul><li>Java中的类<br>  类可以看成是创建Java对象的模板。<br>  通过下面一个简单的类来理解下Java中类的定义：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> id; </span><br><span class="line">    String name; </span><br><span class="line">    <span class="keyword">double</span> score1, score2, score3; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.id = id; </span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAverageScore</span><span class="params">()</span> </span>{ </span><br><span class="line">        <span class="keyword">return</span> (score1 ＋ score2 + score3) / <span class="number">3</span>; </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一个类可以包含以下类型变量：</p><blockquote><p><code>局部变量</code>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。<br><code>成员变量</code>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。<br><code>类变量</code>：类变量也声明在类中，方法体之外，但必须声明为static类型。<br>一个类可以拥有多个方法。</p></blockquote><ul><li>Java中的对象<br>现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。<br>拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。<br>对比现实对象和软件对象，它们之间十分相似。</li></ul><p><strong><em>软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。<br>在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</em></strong></p><ul><li><p>创建对象——&gt;</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*有两种基本形式*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.对象声明和创建*/</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line">Student xiaoming = <span class="keyword">new</span> Student ();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.先声明,后创建*/</span></span><br><span class="line">类名 对象名; <span class="comment">// 类(对象)变量</span></span><br><span class="line">对象名 = <span class="keyword">new</span> 类名(); <span class="comment">//实例化</span></span><br><span class="line">Student xiaobai ;</span><br><span class="line">xiaobai = <span class="keyword">new</span> Student();</span><br></pre></td></tr></tbody></table></figure></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/ZPBq1pyImXLnwvV.png" alt="java对象内存映射像示意.png" title="">                </div>                <div class="image-caption">java对象内存映射像示意.png</div>            </figure></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/OaWtx2fr4o53ZwH.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure></li></ul><hr><ol start="4"><li>类和对象的关系：<strong>类是具有相同==属性和方法==的集合，是对对象的抽象描述。</strong></li></ol><ul><li><p>现实生活中的对象：张三、李四。</p></li><li><p>【想要描述】提取对象中的共性内容。<strong>对具体的抽象。</strong></p></li><li><p>【描述时】这些对象的共性有：姓名、学号、年龄、性别、学习Java等等。（即<strong>定义类：描述事物的属性和行为，就是在定义属性和行为。<em>属性和行为共同成为类中的成员（成员变量和成员方法）。</em></strong>）</p></li><li><p>映射到Java中，<strong>描述就是class定义的类，具体对象就是new建立的实体</strong>。</p></li><li><p>这些描述在Java当中是用类的形式来体现的。而对象是通过Java的new操作符所产生的一个实体，这个的实体存在于==堆内存==当中。</p>  <img src="https://i.loli.net/2019/11/13/znyBu9gp1jtdEFs.png" alt="image.png" style="zoom:80%;">  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类，就是描述事物，就是在定义属性和行为。属性和行为共同成为类中的成员（成员变量和成员方法）。</span></span><br><span class="line"><span class="comment">//需求：描述车汽车（颜色，轮胎数）。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span><span class="title">Car</span> </span>{</span><br><span class="line">    <span class="comment">//描述颜色</span></span><br><span class="line">    String color = <span class="string">"red"</span>;</span><br><span class="line">    <span class="comment">//描述轮胎数</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//运行行为。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(color+<span class="string">".."</span>+num);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span><span class="title">CarDemo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        <span class="comment">//生产汽车：在Java中通过new操作符来完成。</span></span><br><span class="line">        <span class="comment">//其实就是在堆内存中产生一个实体。</span></span><br><span class="line">        Car c = <span class="keyword">new</span> Car();<span class="comment">//c就是一个【类类型】变量。记住：类类型变量只想对象。</span></span><br><span class="line">        <span class="comment">//需求：将已有车的颜色的颜色改成蓝色。指定该对象做使用。</span></span><br><span class="line">        <span class="comment">//在Java指挥方式是：【对象.对象成员】</span></span><br><span class="line">        c.color = <span class="string">"blue"</span>;</span><br><span class="line">        <span class="comment">//需求：想要车运行起来。</span></span><br><span class="line">        c.run();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p><code>Car c = new Car();</code>在内存中的示意图——&gt;</p><img src="https://i.loli.net/2019/11/13/1X4VFtqIwDN5Epx.png" alt="image.png" style="zoom:80%;"><p><code>c.run();</code>——&gt;输出这个车的颜色“蓝色”和轮胎数“4”。</p><p>(1)倘若在<code>c.run();</code>后加入<code>Car c1=new Car();c1.run();</code>——&gt;</p><img src="https://i.loli.net/2019/11/13/9TSkMDwUR2z4ILe.png" alt="image.png" style="zoom:80%;"><p>(2)若main的代码块改为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span><span class="title">CarDemo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">Car c = <span class="keyword">new</span> Car();</span><br><span class="line">c.num = <span class="number">5</span>;</span><br><span class="line">Car c1 = c;</span><br><span class="line">c1.color = <span class="string">"green"</span>;</span><br><span class="line">c.run();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在内存中的示意图——&gt;</p><img src="C:\Users\丶Melody\AppData\Roaming\Typora\typora-user-images\image-20191113105054592.png" alt="image-20191113105054592" style="zoom:80%;"><blockquote><p>对对象调用的基本概念：用new建立对象，在堆内存中产生对象。那么<strong>对象的特点在于封装数据，数据包含属性和行为</strong>。想要操作对象中的内容就指挥对象做事，指挥哪个对象要明确，操作什么也要明确，用<strong><code>对象.xyz</code></strong>的形式就能完成。</p></blockquote><p>【注意】：<br>如下图，</p><img src="https://i.loli.net/2019/11/13/PkjShzpB5GDg3On.png" alt="image.png" style="zoom:80%;"><p>以前定义在函数里面，现在定义在函数外面                 </p><hr><ol start="5"><li><p>【方法】<br> 方法的定义：</p><ul><li><p><strong>方法是类或对象的行为特征的抽象。</strong></p></li><li><p>Java中的方法不能独立存在，所有的方法必须定义在类中。</p></li><li><p>使用 “类名.方法” 或 “对象.方法” 的形式调用。</p></li><li><p>语法格式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符　返回值类型　方法名（参数类型　参数名<span class="number">1</span>,参数类型　参数名<span class="number">2</span>,...） {</span><br><span class="line"><span class="comment">// 方法体</span></span><br><span class="line">方法语句序列<span class="comment">//当返回类型非void时,最后一条被执行语句必须是return语句,返回对应类型的值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>访问权限/权限修饰符（4P权限）：</p><table><thead><tr><th align="center">访问权限</th><th align="center">类内</th><th align="center">包层内</th><th align="center">子类</th><th align="center">包层外</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">package （缺省）</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p><code>return</code>语句：</p></li><li><p>结束方法调用，并返回值。</p></li><li><table><thead><tr><th>return 表达式;</th><th>return;</th></tr></thead><tbody><tr><td>🔺方法被调用时,执行到方法内的return语句,则不论方法里是否还有语句未执行,立即结束方法的调用,并将return 后的表达式的值返回方法调用者<br>🔺利用return 语句返回值，仅能返回一个值<br>🔺return语句仅结束方法的执行</td><td>🔺void型方法</td></tr></tbody></table><p>方法分类：</p></li><li><p>无参数无返回值</p></li><li><p>有参数无返回值</p></li><li><p>无参数有返回值</p></li><li><p>有参数有返回值</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aMethod</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"无参数无返回值的方法"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bMethod</span><span class="params">(<span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"有参数无返回值的方法"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cMethod</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"无参数有返回值的方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dMethod</span><span class="params">(<span class="keyword">int</span> d)</span> </span>{</span><br><span class="line">       System.out.println(<span class="string">"有参数有返回值的方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ret;　　　　　<span class="comment">// 创建Method类的对象</span></span><br><span class="line">       Method md = <span class="keyword">new</span> Method();　　　　　<span class="comment">// 通过对象.方法调用</span></span><br><span class="line">        md.aMethod();</span><br><span class="line">       md.bMethod(<span class="number">10</span>);</span><br><span class="line">        ret = md.cMethod();</span><br><span class="line">       ret = md.dMethod(<span class="number">10</span>);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>方法的参数：</p></li><li><p>方法可以没有参数，或者有多个参数，参数类型可以是任意类型</p></li><li><p>方法参数也是局部变量</p><p>  参数为<a href="https://www.cnblogs.com/wuxinyiwu/p/8588420.html" target="_blank" rel="noopener">引用数据类型</a><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>时：</p></li><li><p>当对象实例作为参数传递给方法时，传递的是对象的引用，为地址传递，接受参数的方法可以改变参数的值。</p><p>参数为简单数据类型时：</p></li><li><p>传递的是参数的副本，为值传递，接受参数的方法中不会改变参数的值。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodParam</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方法的参数为基本数据类型时，传递的是值的副本（值拷贝）</span></span><br><span class="line"><span class="comment">     * 方法中不会改变元参数的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{<span class="comment">//a, b为形参</span></span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">100</span>, y = <span class="number">200</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法的参数为引用数据类型时，传递的对象的引用（传地址）</span></span><br><span class="line"><span class="comment">     * 方法中可以改变参数的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap2</span><span class="params">(MethodParam mp)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> tmp = mp.x;</span><br><span class="line">        mp.x = mp.y;</span><br><span class="line">        mp.y = tmp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MethodParam mp = <span class="keyword">new</span> MethodParam();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10</span>, n = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">"交换前：a = "</span>+m+<span class="string">",b = "</span>+n);</span><br><span class="line">        mp.swap(m, n);<span class="comment">// m,n为实参</span></span><br><span class="line">        System.out.println(<span class="string">"交换后：a = "</span>+m+<span class="string">",b = "</span>+n);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"交换前：x = "</span>+mp.x+<span class="string">",y = "</span>+mp.y);</span><br><span class="line">        mp.swap2(mp);</span><br><span class="line">        System.out.println(<span class="string">"交换后：x = "</span>+mp.x+<span class="string">",y = "</span>+mp.y);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>普通方法调用——&gt;</p><p><img src="https://i.loli.net/2019/11/16/28HpyTLnKOVsFQY.png" alt="image.png"></p><p>成员方法和成员变量的关系——&gt;</p><p><img src="https://i.loli.net/2019/11/16/gceJWarS2Puqz9w.png" alt="image.png"></p></li></ul></li></ol><hr><ol start="6"><li><p>【成员方法】和【构造方法】</p><p> 【成员方法】</p></li></ol><pre><code>——————————————————————————— 我 是 分 割 线 ————————————————————————————【构造方法】构造方法需满足以下三个条件 ：</code></pre><ul><li><p>1、方法名与类名<strong>同名</strong></p></li><li><p>2、在方法中不能使用  <strong><code>return</code></strong>  语句，即无返回值 </p></li><li><p>3、在方法名的前面*<em>没有返回值的类型声明 *</em><br>  （有看到“ 构造方法无返回值也不可以加void，但其实返回的是首地址 ”这话还得去证实，先放在这里）</p></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/qIK3BjS4wrtvgMi.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure></li><li><blockquote><p>==老师推荐==：<strong><em>显式无参构造子,作为一种良好实践,定义了其他构造子，那就准备一个无参构造子</em></strong></p></blockquote></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me;</span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>{</span><br><span class="line">    <span class="keyword">private</span>  String name; <span class="comment">//成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Me</span><span class="params">(String name)</span></span>{ <span class="comment">//构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{ <span class="comment">//成员方法</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{<span class="comment">//成员方法</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> 我如果我在添加一age 如下 添加方法依然是成员方法 , </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me;</span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>{</span><br><span class="line">    <span class="keyword">private</span>  String name; <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String age; <span class="comment">//成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Me</span><span class="params">(String name)</span></span>{ <span class="comment">//构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{ <span class="comment">//成员方法</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{<span class="comment">//成员方法</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>{<span class="comment">//成员方法</span></span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>{<span class="comment">//成员方法</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>个人理解：无论多少方法，==除了构造方法外，其余都是成员方法==，当然这样理解可能有点偏见..</p><p>它们的区别：</p><ul><li><p>构造方法一般是给对象的数据进行初始化,没有返回值</p></li><li><p>成员方法一般实现对类中成员变量的操作，提供某些功能,有返回类型，可以为void类型</p></li></ul><p>成员方法与构造方法调用的区别</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>{    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{        </span><br><span class="line">        Me me = <span class="keyword">new</span> Me(<span class="string">"张三"</span>);<span class="comment">//构造方法调用    </span></span><br><span class="line">        System.out.println(me);         </span><br><span class="line">        me.setName(<span class="string">"李四"</span>);<span class="comment">//成员方法调用       </span></span><br><span class="line">        System.out.println(me.getName());     </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从上面的demo中可以看出，<strong>==构造方法通过new运算符调用==</strong>，<strong>==成员方法通过对象调用==</strong>。</p><p><strong>注意：类中除了构造方法以外的方法都是成员方法。原因是在类中，除了变量外的基本都是成员方法。</strong></p><p>——————————————————————————— 我 是 分 割 线 ————————————————————————————</p><p>【this 关键字】</p><p><a href="https://i.loli.net/2019/11/16/49d7AMODXhKbsuy.png" target="_blank" rel="noopener">https://i.loli.net/2019/11/16/49d7AMODXhKbsuy.png</a> </p><p>——————————————————————————— 我 是 分 割 线 ————————————————————————————</p><p>【重载构造方法之间的调用】</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/6qrpXmf5a3bhojz.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/pXLMjyKFzgal1oB.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><p>【含对象成员的构造方法调用】</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/Awpe2iSNX4OnvaQ.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><p></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/49d7AMODXhKbsuy.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure> <p>【无继承情况下的对象初始化顺序】</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/AO3z8orS9aXvWCd.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><p></p><hr><ol start="7"><li>【创建对象】</li></ol><p>对象是根据类创建的。在Java中，使用<strong>关键字new</strong></p><ul><li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li><li><strong>实例化</strong>：使用关键字new来创建一个对象。</li><li><strong>初始化</strong>：使用new创建对象时，会调用构造方法初始化对象。</li></ul><p>下面是一个创建对象的例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>{   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>{      </span><br><span class="line">        <span class="comment">//这个构造器仅有一个参数：name      </span></span><br><span class="line">        System.out.println(<span class="string">"小狗的名字是 : "</span> + name );    </span><br><span class="line">    }   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{      </span><br><span class="line">        <span class="comment">// 下面的语句将创建一个Puppy对象      </span></span><br><span class="line">        Puppy myPuppy = <span class="keyword">new</span> Puppy( <span class="string">"tommy"</span> );   </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译并运行上面的程序，会打印出下面的结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小狗的名字是 : tommy</span><br></pre></td></tr></tbody></table></figure><p>——————————————————————————— 我 是 分 割 线 ————————————————————————————</p><p>【访问实例变量和方法】</p><p>通过已创建的对象来访问成员变量和成员方法，如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 实例化对象 */</span> </span><br><span class="line">Object referenceVariable = <span class="keyword">new</span> Constructor(); </span><br><span class="line"><span class="comment">/* 访问类中的变量 */</span> </span><br><span class="line">referenceVariable.variableName; </span><br><span class="line"><span class="comment">/* 访问类中的方法 */</span> </span><br><span class="line">referenceVariable.methodName();</span><br></pre></td></tr></tbody></table></figure><p>——————————————————————————— 我 是 分 割 线 ————————————————————————————</p><p>【访问实例变量】和【调用成员方法】：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>{   </span><br><span class="line">    <span class="keyword">int</span> puppyAge;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>{      </span><br><span class="line">        <span class="comment">// 这个构造器仅有一个参数：name      </span></span><br><span class="line">        System.out.println(<span class="string">"小狗的名字是 : "</span> + name );    </span><br><span class="line">    }    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">( <span class="keyword">int</span> age )</span></span>{       </span><br><span class="line">        puppyAge = age;   </span><br><span class="line">    }    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">( )</span></span>{       </span><br><span class="line">        System.out.println(<span class="string">"小狗的年龄为 : "</span> + puppyAge );        <span class="keyword">return</span> puppyAge;   </span><br><span class="line">    }   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{     </span><br><span class="line">        <span class="comment">/* 创建对象 */</span>      </span><br><span class="line">        Puppy myPuppy = <span class="keyword">new</span> Puppy( <span class="string">"tommy"</span> );      </span><br><span class="line">        <span class="comment">/* 通过方法来设定age */</span>    </span><br><span class="line">        myPuppy.setAge( <span class="number">2</span> );      </span><br><span class="line">        <span class="comment">/* 调用另一个方法获取age */</span>    </span><br><span class="line">        myPuppy.getAge( );     </span><br><span class="line">        <span class="comment">/*你也可以像下面这样访问成员变量 */</span>   </span><br><span class="line">        System.out.println(<span class="string">"变量值 : "</span> + myPuppy.puppyAge );   </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译并运行上面的程序，产生如下结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小狗的名字是 : tommy</span><br><span class="line">小狗的年龄为 : <span class="number">2</span></span><br><span class="line">变量值 : <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><hr><ol start="8"><li><p>【方法重载，重构，覆盖，重写的区别】</p><p><strong>方法重载</strong>还是比较好理解的，就是在类的内部，定义多个方法，这些方法的方法名字相同，参数类型、参数顺序、参数个数不同，注意，返回值类型并不能区分重载 。</p></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> b)</span></span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">double</span> c)</span></span>{</span><br><span class="line"></span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">show</span><span class="params">(<span class="keyword">double</span> d)</span></span>{</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">}   <span class="comment">//报错，方法已经定义了</span></span><br></pre></td></tr></tbody></table></figure><p> <strong>方法重写（<code>override</code>)</strong><br>方法重写和方法覆盖都是一个道理，发生在子类继承父类或者实现接口的类，要求的是：</p><blockquote><p>1.方法名字相同，<br>2.参数个数不同，<br>3.返回值类型不同 ，</p></blockquote><p>代码： </p><img src="https://i.loli.net/2019/11/14/hMWBc8wnbZr7PtG.png" alt="image.png"><img src="https://i.loli.net/2019/11/14/5bCilLKw1uFWEGy.png" alt="image.png"><p> <strong>方法重构</strong></p><blockquote><p>定义：在不改变外界外界访问的情况下对代码进行修改，但是不改变原方法的效果，提高其性能，使程序更加易读，可维护。<br>重构是在不改变软件可观察行为的前提下改善其内部结构<br>重构通常不是一次性的，它贯穿软件的整个生命周期，只要觉得不合理都是重构的时机。 </p></blockquote><hr><ol start="9"><li></li></ol><p><strong>题目：</strong>下面说法中，错误的有（  ）</p><p>​            A. Java面向对象语言容许单独的过程与函数存在；</p><p>​            B. Java面向对象语言容许单独的方法存在；</p><p>​            C. Java语言中的方法属于类中的成员（member）；</p><p>​            D. Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同。</p><p> 答案：ABC</p><p> 解释：</p><blockquote><p>方法与函数：这两个概念不严格区分，就是一个东西，通过对象调用的，就是方法，直接调用，就是函数；</p><p>在java中，everything is object 所以，方法，函数，必须隶属于某一个类或对象， java中没有过程。（类中的代码块不知道算不算，就算代码块是过程，也是必须在类中才有的）</p><p>对于C选项，方法分为静态方法和非静态方法，静态方法属于类成员，非静态方法属于实例成员。</p></blockquote><hr><ol start="10"><li></li></ol><ul><li><p>类其实一种类型，它封装了数据和操作。</p></li><li><p>对象是类的实例</p></li><li><p>一个对象比属于某个类</p></li><li><p>一个类可以声明多个对象</p></li></ul><hr><ol start="11"><li>问：构造方法可以调用本类的其他方法吗？</li></ol><blockquote><p>1,构造方法可以调用本类的其他方法。既然可以调用本类的属性,那么也就可以调用属于本类的其他方法。</p></blockquote><blockquote><p>2,需要注意的是,如果要在构造方法里调用一个非静态方法时,应该将该方法声明为private。<br>因为如果这个类被其他类继承成为父类时,这个方法不是private的又被子类所重载，这样在实际创建子类的过程中递归调用到了父类的构造器时，父类构造器对这个方法的调用就会由于多态而实际上调用了子类的方法，当这个子类方法需要用到子类中实例变量<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的时候，就会由于变量没有初始化而出现异常（子类中的实例变量没有初始化这种情况还是会遇见的），这是Java不想看到的情况。 </p></blockquote><hr><ol start="12"><li>一个类的构造方法有多个，在其他类中是否可以被调用？</li></ol><blockquote><p> 只要不是私有的构造函数，在其他类中就可以调用。 传对应的参数就行了 。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>` `<span class="title">A</span></span>{</span><br><span class="line">  ``<span class="keyword">public</span>` `A(String s){}</span><br><span class="line">  ``<span class="keyword">public</span>` `A(``<span class="keyword">int</span>` `n){}</span><br><span class="line">  ``<span class="keyword">public</span>` `A(String s, ``<span class="keyword">int</span>` `n){}</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span>` `<span class="title">B</span></span>{</span><br><span class="line">  ``A a1 = ``<span class="keyword">new</span>` `A(``<span class="string">"abc"</span>``);</span><br><span class="line">  ``A a2 = ``<span class="keyword">new</span>` `A(``<span class="number">1</span>``);</span><br><span class="line">  ``A a3 = ``<span class="keyword">new</span>` `A(``<span class="string">"aaa"</span>``,``<span class="number">2</span>``);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><hr><ol start="13"><li>类是一种<strong>引用类型</strong>。</li></ol><p>Java的引用类型只有三种，分别是</p><ul><li><p><strong>类(class)</strong></p></li><li><p><strong>接口(interface)</strong></p></li><li><p><strong>数组</strong></p><p>  <a href="https://blog.csdn.net/aEzreal/article/details/80822062" target="_blank" rel="noopener">参考资料</a></p></li></ul><hr><ol start="14"><li>问：方法一定是在类内部被定义的？</li></ol><blockquote><p> 所有方法必须写在类体里，也包括构造方法<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>的。</p><p> static方法同样属于类，叫类方法或静态方法，它与类一同被加载时，处于内存的公共代码区中，无需创建实例来调用，只需用类名引用即可。<br> static方法既可以通过类名来调用，也可以通过类的实例调用。</p><p> Java一切都是以类的形式存在，方法是类的一部分，需要通过类才能进行方法的调用。<br> 从内存存储角度来说，java中找对应方法时，都是先找对应类实例，类实例是根据类来初始化内存的。如果方法在类外部，则无法找到该方法。<br> 所以方法必须在类体里。 </p><p> 注意： 可以在其他类里使用这个类的方法（在不同的包下就要引ltem这个类），继承就是一个类从另一个类继承通过关键字extends 来实现 </p></blockquote><hr><ol start="15"><li>问：构造方法中可不可以有return语句呢?</li></ol><blockquote><p> （这个解释有问题？）可以。而是我们写成这个样子就OK了：<code>return;</code><br> 其实，在任何的<strong>void类型的方法</strong>的最后你都可以写上：<code>return;</code></p></blockquote><hr><ol start="16"><li>问：非构造方法的一般成员方法必须有return语句？</li></ol><blockquote><p>错。 （待补充……）</p></blockquote><hr><ol start="17"><li>问：类中的数据成员可以按需选择任意类型，包括类本身？</li></ol><blockquote><p>可以。可以参考下图，图源于<a href="https://blog.csdn.net/weixin_38088772/article/details/91041309" target="_blank" rel="noopener">陈三千的博客</a></p></blockquote><img src="https://img-blog.csdnimg.cn/20190606111353386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODA4ODc3Mg==,size_16,color_FFFFFF,t_70" alt="举例.png"><hr><ol start="18"><li>问：Java中构造函数的权限可以是private吗？</li></ol><blockquote><p> 可以，这个类就不能再外部被new了，如果需要这个类的实例化对象，就只能在类内部提供静态方法生产这个类的对象了。 </p></blockquote><hr><ol start="19"><li>问：构造方法能不能被重载，构造方法能不能被重写？</li></ol><blockquote><p>在回答这两个问题之前，首先先回顾：<strong>什么是构造方法？构造方法的特点是什么？</strong></p><blockquote><p>概述：构造方法存在于类中，给对象数据（属性）初始化；</p><p>特点：方法名与类名一样；无返回值无void;</p><p>默认构造方法：我们不创建一个构造方法时，系统默认提供一个无参构造；当我们创建一个构造方法时，系统不再提供无参构造，所以在实际项目中，全部手动给出无参构造</p></blockquote><p>其次<strong><em>\</em>什么是重载？什么是重写？**</strong> </p><blockquote><p>重载：存在于在一个类中，方法名相同，方法参数的类型或个数不同</p><p>重写：存在于子父类中，方法名、方法参数、返回值全部相同</p></blockquote><p>所以：<strong>构造方法可以重载，不能重写</strong></p><p>在一个类中，可以有多个构造方法（方法参数不同） ，即重载，来实现对象属性不同的初始化；</p><p>但是子类中不能定义一个方法无void无返回值的方法，编译错误，即子类无法继承构造方法，但是子类的构造器中可以调用父类的构造方法（默认自动调用无参构造）</p></blockquote><p>注意：回答来源于 <a href="https://blog.csdn.net/cherry_11qianqian/article/details/82785893" target="_blank" rel="noopener">CSDN博客</a></p><hr><ol start="20"><li>Java中可以定义一个<strong>空类</strong>（即没有数据成员和成员方法） 。</li></ol><hr><ol start="21"><li>问： 下面这个类有几个构造方法？ </li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classA{}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>1个。（待补充……）</p></blockquote><hr><ol start="22"><li><p>问：Java 类可以作为（ C ）</p><p>A．类型定义机制                                 B．数据封装机制</p><p>C．类型定义机制和数据封装机制      D．上述都不对</p></li></ol><hr><ol start="23"><li>用于定义类头的修饰符可以是public、abstract、final或者是默认(friendly) </li></ol><hr><ol start="24"><li>题目：下列说法错误的有（ CD ）<br>　　A． 在类方法中可用this来调用本类的类方法<pre><code>B． 在类方法中调用本类的类方法时可直接调用</code></pre>　　C． 在类方法中只能调用本类中的类方法<br>　　D． 在类方法中绝对不能调用实例方法 </li></ol><blockquote><p> C：类方法可以调用外部其他类的方法。<br>D：只要实力化对象，也是可以调用实例方法的。</p></blockquote><hr><ol start="25"><li>判断： 只有基本类型的参数传递使用值传递。 </li></ol><blockquote><p>错误。</p><p>引用类型参数的传递，依然是值传递。但因为是地址值，所以会指向同一个对象实例。</p></blockquote><hr><ol start="26"><li>Java中方法的参数传递是<strong>值传递（pass by value）</strong>，并且为<strong>单向传递</strong>。</li></ol><hr><ol start="27"><li>《Java 变量参数传入方法，修改后是否影响外面的值》。参考   <a href="https://blog.csdn.net/fenglllle/article/details/81389286" target="_blank" rel="noopener">博客</a></li></ol><hr><ol start="28"><li>《某个变量当作函数的参数传递后，函数内部修改了。到底这个变量是否受影响》。参考 <a href="https://blog.csdn.net/wem603947175/article/details/81206177" target="_blank" rel="noopener">博客</a></li></ol><hr><ol start="29"><li><p>问：类设计get方法和set方法的作用是什么？</p><blockquote><p>答1：一般类的成员变量被设置为private（私有的），这样设置安全性比较高，但是设置为私有的后其他的类和对象则无法调用该对象了，所以会有get和set方法，这两个方法一般设置为public，在其他的类中通过对象调用set或get方法即可操作私有的变量，增强程序的安全性，set为给对象赋值的方法，而get则是取得变量值的方法！</p></blockquote><blockquote><p>答2：get set常用在自定义类，类创建了一个实例对象后，用set设置对象的某一个属性，get得到对象某一属性。如果不使用get set，你就得用点，点出来还得是个方法。其实就是给get set换个名而已。而且get set作为内部方法，可以访问私有数据</p></blockquote><blockquote><p>答3：别说的那么专业化了，理解都要半天。<br>就这么理解吧，面向对象中，想对类的成员变量设置访问一些权限，于是，就将该字段设置为private的，这样别的类就不能访问了，然后在该内定义两个方法，一个专门用于获取，一个用于修改，这样，在你不想让别人乱动该字段的时候，就在该方法内写一些限制条件。<br>而为了规范起见（团队开发需要嘛），就根据人家老外的习惯，将方法名设置为set+字段名，get+字段名（名字乱改没问题），既然规范了，那就是别人都叫这名了，于是，有些框架给对象赋值就有方法了，方法名称由get或set开始的又有private变量名的，就找出来调用。hibernate1框架就这样弄得，至于后面的版本是不是这样就不大清楚了。<br>JavaBean就是一个JAVA类，既然是JAVA类就不需要什么组件了，这玩意直接深入到虚拟机了的</p></blockquote><p><img src="https://i.loli.net/2019/11/16/4pmW9kbx6tvFeGU.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/11/16/maOenK4ryJWhFGI.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/11/16/QKyFju219pVgP6l.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/11/16/3Sa6uLv4QGhB2n8.png" alt="image.png"></p><p><img src="https://i.loli.net/2019/11/16/yReDOpbWKHPd8Lg.png" alt="image.png"></p></li></ol><hr><ol start="30"><li><p>Java的包装类：</p><p>【包装类的概念】</p><p><img src="https://i.loli.net/2019/11/16/xceTj6DX23hzkwi.png" alt="image.png"></p><p>【Integer类的用法】</p><p><img src="https://i.loli.net/2019/11/16/VN1psGdfXIbwjMH.png" alt="image.png"></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/hwZ1jA6agmVn374.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><p>【自动装箱机制和自动拆箱机制】</p><p><img src="https://i.loli.net/2019/11/16/qI9VgpAnHw3jvao.png" alt="image.png"></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/16/YKXwTL9SGduN2cI.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure></li></ol><hr><ol start="31"><li>匿名对象：</li></ol><p>使用方法：</p><ol><li>当对对象的方法只调用一次，可以使用匿名对象来完成，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。</li><li>可以将匿名对象作为实际参数进行传递。</li><li></li></ol><hr><ol start="32"><li></li></ol><hr><ol start="33"><li></li></ol><hr><hr><hr><hr><hr><hr><hr><hr><hr><h3 id="注脚："><a href="#注脚：" class="headerlink" title="注脚："></a>注脚：</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.jianshu.com/p/08562e95ed49" target="_blank" rel="noopener">实例变量（全局变量）</a>、<a href="https://www.cnblogs.com/huangzs/p/9961703.html" target="_blank" rel="noopener">成员变量、实例变量、属性</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.jianshu.com/p/773a8e5e199c" target="_blank" rel="noopener">java的构造方法</a>、<a href="https://blog.csdn.net/qq_40393000/article/details/82866470" target="_blank" rel="noopener">java的构造方法</a>、<a href="https://blog.csdn.net/weixin_30455365/article/details/95613213" target="_blank" rel="noopener">Java入门：构造方法</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">来创建一个新的对象。创建对象需要以下三步：</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://blog.csdn.net/weixin_42227243/article/details/82805945" target="_blank" rel="noopener">java之new的用处</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.cnblogs.com/wuxinyiwu/p/8588420.html" target="_blank" rel="noopener">JAVA中基本数据类型和引用数据类型区别</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java笔记——对象、类&quot;&gt;&lt;a href=&quot;#Java笔记——对象、类&quot; class=&quot;headerlink&quot; title=&quot;Java笔记——对象、类&quot;&gt;&lt;/a&gt;Java笔记——对象、类&lt;/h3&gt;&lt;p&gt;创建时间：2019.11.11&lt;/p&gt;
&lt;p&gt;说明：持续更新ing&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;对象&lt;/code&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;code&gt;类&lt;/code&gt;&lt;/strong&gt;的概念。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;对象&lt;/code&gt;：对象是类的一个实例（实实在在存在的个体），有&lt;strong&gt;属性（状态）&lt;/strong&gt;和&lt;strong&gt;行为&lt;/strong&gt;。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。&lt;/p&gt;
&lt;p&gt;属性(property)： 静态特征&lt;br&gt;行为(behavior)： 动态特征&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;类&lt;/code&gt;：类是对现实生活中事物的描述。类是一个模板，它描述一类对象的行为和状态。&lt;strong&gt;同种类型对象共性的抽象&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记—面向对象</title>
    <link href="http://yoursite.com/2019/11/13/Java%E7%AC%94%E8%AE%B0%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/11/13/Java笔记—面向对象/</id>
    <published>2019-11-13T04:54:46.000Z</published>
    <updated>2019-11-29T17:35:40.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java笔记——面向对象"><a href="#Java笔记——面向对象" class="headerlink" title="Java笔记——面向对象"></a>Java笔记——面向对象</h3><p>创建时间：2019.11.11</p><p>说明：持续更新ing</p><hr><ol><li><p><strong>Java作为一种面向对象语言</strong>。支持以下基本概念：<br> <strong><code>多态</code></strong> | <strong><code>继承</code></strong> | <strong><code>封装</code></strong> | <strong><code>抽象</code></strong><br>  <strong><code>类</code></strong>  | <strong><code>对象</code></strong> | <strong><code>实例</code></strong> | <strong><code>方法</code></strong> | <strong><code>重载</code></strong></p></li><li><p>“面向对象”和“面向过程”的区别：</p></li></ol><ul><li><code>面向过程</code>：如 C/C++</li></ul><blockquote><p>例子：冰箱装大象。1、打开冰箱门；2、放进大象；3、关上冰箱门。<br>强调过程，“打开”、“存储”、“关闭”三个动作。<br><strong>注重过程，注重的是过程涉及的行为（即功能）。</strong></p></blockquote><ul><li><code>面向对象</code>：如 Java</li></ul><blockquote><p><strong>将功能封装进对象，强调具备了功能的对象。</strong></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/11/7WFrJqdjnfpTa4c.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><ul><li><blockquote><p><strong><em><code>面向对象</code>是基于<code>面向过程</code>的。</em></strong></p></blockquote></li></ul><a id="more"></a> <ol start="3"><li>使用不同思想，对“冰箱装大象”的理解——&gt;</li></ol><p>问：“人开冰箱”事件，其中人、冰箱都是实物（对象），开是动作。若使用面向对象思维，“开”的这个动作是属于“人”还是属于“冰箱”？</p><blockquote><p>答：属于“冰箱”，“人”只是调用了“冰箱”的“开”的方法（或功能），用力作用了门一下并将门打开了。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">人开门：名词提炼法。</span><br><span class="line">/*</span><br><span class="line">人{</span><br><span class="line">    开门（门）{</span><br><span class="line">        门.开（）;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">门{</span><br><span class="line">    开（）{</span><br><span class="line">        操作门轴;</span><br><span class="line">        ……等等;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>面向对象的三个特征：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。<br> 以后开发：<code>其实就是找对象使用，没有对象就创建一个对象</code>。<br> <strong><em>找对象，建立对象，使用对象，维护对象的关系。</em></strong></li><li></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java笔记——面向对象&quot;&gt;&lt;a href=&quot;#Java笔记——面向对象&quot; class=&quot;headerlink&quot; title=&quot;Java笔记——面向对象&quot;&gt;&lt;/a&gt;Java笔记——面向对象&lt;/h3&gt;&lt;p&gt;创建时间：2019.11.11&lt;/p&gt;
&lt;p&gt;说明：持续更新ing&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Java作为一种面向对象语言&lt;/strong&gt;。支持以下基本概念：&lt;br&gt; &lt;strong&gt;&lt;code&gt;多态&lt;/code&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;code&gt;继承&lt;/code&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;code&gt;封装&lt;/code&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;code&gt;抽象&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;  &lt;strong&gt;&lt;code&gt;类&lt;/code&gt;&lt;/strong&gt;  | &lt;strong&gt;&lt;code&gt;对象&lt;/code&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;code&gt;实例&lt;/code&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;code&gt;方法&lt;/code&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;code&gt;重载&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“面向对象”和“面向过程”的区别：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;面向过程&lt;/code&gt;：如 C/C++&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;例子：冰箱装大象。1、打开冰箱门；2、放进大象；3、关上冰箱门。&lt;br&gt;强调过程，“打开”、“存储”、“关闭”三个动作。&lt;br&gt;&lt;strong&gt;注重过程，注重的是过程涉及的行为（即功能）。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;面向对象&lt;/code&gt;：如 Java&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;将功能封装进对象，强调具备了功能的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://i.loli.net/2019/11/11/7WFrJqdjnfpTa4c.png&quot; alt=&quot;image.png&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;image.png&lt;/div&gt;
            &lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;code&gt;面向对象&lt;/code&gt;是基于&lt;code&gt;面向过程&lt;/code&gt;的。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记—语法</title>
    <link href="http://yoursite.com/2019/11/13/Java%E7%AC%94%E8%AE%B0%E2%80%94%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/13/Java笔记—语法/</id>
    <published>2019-11-13T04:54:20.000Z</published>
    <updated>2019-11-29T17:36:18.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java笔记——语法"><a href="#Java笔记——语法" class="headerlink" title="Java笔记——语法"></a>Java笔记——语法</h3><p>创建时间：2019.11.11<br>说明：持续更新ing</p><hr><ol><li>单引号’’中存放一个字符，不能存放字符串。双引号””中存放字符串。</li><li><strong>Java是强类型语言。对于每一种数据都定义了明确的具体数据类型，在内存中总分配了不同的内存空间。</strong></li><li>布尔型常量只有2个值：true、false</li><li>标识符由字母：26个，大小写；数字：0-  8；符号：$ _  组成。</li><li>标识符不能数字开头、不能使用关键字</li><li>main不是关键字，但是是被JVM识别的名字，是程序的入口</li><li>Java中的名称规范：</li></ol><ul><li><p>包名：多单词组成，全为小写</p><blockquote><p>xxxyyyy</p></blockquote></li><li><p>类名接口： 多单词组成，所有单词的首字母大写</p><blockquote><p>XxxYyyZzz</p></blockquote></li><li><p>变量名和函数名：多单词组成时，第一个单词的首字母小写，其余首字母大写</p><blockquote><p>xxxYyyZzz</p></blockquote></li><li><p>常量名：所有字母都大写。每个单词用_隔开</p><blockquote><p>XXX_YYY_ZZZ</p></blockquote></li></ul><a id="more"></a>  //截断文章<ol start="8"><li>注释，写在代码前面</li><li>对于整数：Java有三种表现形式。<br>· 十进制：0-9，满10进1<br>· 八进制：0-7，满8进1，<strong>用0开头表示</strong><br>· 十六进制：0-9，A-F或a-f（A\a是10，B\b是11…F\f是15），满16进1，<strong>用0x开头表示</strong></li><li>null常量：只有一个值null。在对象、引用数据类型时会用上。</li><li>二进制。一个字节8位0、1组合。</li><li>八进制：3位二进制位代表1位八进制位；十六进制：4位二进制位代表1位十六进制位。<br><strong>进制转换：进制越大，表示越短，更方便地表示数据。</strong></li><li>二进制计算：<br><code>5 + 4 = 9</code><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/11/hP5DS9bqTnHLZkw.png" alt="十进制转二进制.png" title="">                </div>                <div class="image-caption">十进制转二进制.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/11/arJOKCdRLm6wfXZ.png" alt="进制之间转换.png" title="">                </div>                <div class="image-caption">进制之间转换.png</div>            </figure></li><li>负数地二进制表现形式：<strong>对应的整数二进制取反加1</strong>。<br><code>负数的最高位都是1</code><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/11/53E4DtdvXCkjQLz.png" alt="负数的二进制.png" title="">                </div>                <div class="image-caption">负数的二进制.png</div>            </figure></li><li></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java笔记——语法&quot;&gt;&lt;a href=&quot;#Java笔记——语法&quot; class=&quot;headerlink&quot; title=&quot;Java笔记——语法&quot;&gt;&lt;/a&gt;Java笔记——语法&lt;/h3&gt;&lt;p&gt;创建时间：2019.11.11&lt;br&gt;说明：持续更新ing&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;单引号’’中存放一个字符，不能存放字符串。双引号””中存放字符串。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java是强类型语言。对于每一种数据都定义了明确的具体数据类型，在内存中总分配了不同的内存空间。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;布尔型常量只有2个值：true、false&lt;/li&gt;
&lt;li&gt;标识符由字母：26个，大小写；数字：0-  8；符号：$ _  组成。&lt;/li&gt;
&lt;li&gt;标识符不能数字开头、不能使用关键字&lt;/li&gt;
&lt;li&gt;main不是关键字，但是是被JVM识别的名字，是程序的入口&lt;/li&gt;
&lt;li&gt;Java中的名称规范：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;包名：多单词组成，全为小写&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xxxyyyy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类名接口： 多单词组成，所有单词的首字母大写&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;XxxYyyZzz&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;变量名和函数名：多单词组成时，第一个单词的首字母小写，其余首字母大写&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xxxYyyZzz&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常量名：所有字母都大写。每个单词用_隔开&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;XXX_YYY_ZZZ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>博客v1.4上线</title>
    <link href="http://yoursite.com/2019/11/08/%E5%8D%9A%E5%AE%A2v1.4/"/>
    <id>http://yoursite.com/2019/11/08/博客v1.4/</id>
    <published>2019-11-08T14:30:21.000Z</published>
    <updated>2019-11-29T17:39:13.419Z</updated>
    
    <content type="html"><![CDATA[<p>搞了半天时间，优化一些模板上的问题后，新博客1.4版本上线了</p><a id="more"></a>  //截断文章<h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><ul><li><ol><li>主页动画，点击体验效果（<a href="https://melodyhub.ltd/" target="_blank" rel="noopener">这里</a>）</li></ol></li><li><ol start="2"><li>文字跳动（menu、head中的文字均可跳动）,比如顶部的“你用走，可是我用跑”……</li></ol></li><li><ol start="3"><li>新增<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine评论</a>（可以使用表情；发送前浏览）。想用别的，但是暂时先着Valine。可以试着来骚扰我（滑稽~~</li></ol></li><li><ol start="4"><li>有评论，邮件提示(还未测试)。接入Leancloud（<a href="https://leancloud.cn/docs/" target="_blank" rel="noopener">文档</a>）。</li></ol></li><li><ol start="5"><li>底部开启鼠标滑动渲染</li></ol></li><li><ol start="6"><li>开启“一言”api。menu中作者名（Melody Jerry）下面随机显示一句话。同时，使用文字扭曲动画。</li></ol></li></ul><hr><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><ul><li>1.重写三个按钮（menu、搜索、回到顶部）的代码，现在可以正常使用了。</li><li><ol start="2"><li>更新menu的Github的url</li></ol></li><li><ol start="3"><li>修复移动端提示证书错误的问题（移动端重定向太多次了，难怪hhh）</li></ol></li><li><ol start="4"><li>主页和首页分仓（也不算是修复，不知道写哪而已）</li></ol></li></ul><hr><h3 id="已知问题（加粗的为重要问题）"><a href="#已知问题（加粗的为重要问题）" class="headerlink" title="已知问题（加粗的为重要问题）"></a>已知问题（加粗的为重要问题）</h3><ul><li><ol><li><strong>menu中的“分类”、“标签”、“关于”，仍然无法正常使用（原因未知）</strong></li></ol></li><li><ol start="2"><li>menu的Email仍旧无法mailto</li></ol></li><li><ol start="3"><li><strong>文章增加标签或类名，无法被tags或categories绑定</strong></li></ol></li><li><ol start="4"><li>浏览人数、浏览次数，无法使用（接口有问题？）</li></ol></li><li><ol start="5"><li><strong>文字截断，异常。（原因位置）</strong></li></ol></li><li><ol start="6"><li>等待发现</li></ol></li></ul><hr><h3 id="未来加入"><a href="#未来加入" class="headerlink" title="未来加入"></a>未来加入</h3><ul><li><ol><li>音乐控件（自动？手动？浮窗？嵌入？音源线上还是本地？）</li></ol></li><li><ol start="2"><li>实时颜色</li></ol></li><li><ol start="3"><li>加载网页时、侧栏、搜索、进度条等动画</li></ol></li><li><ol start="4"><li>留言板？</li></ol></li><li><ol start="5"><li>友情链接？快速导航？</li></ol></li><li><ol start="6"><li>嵌入播放（这个很想要，链接一些学习视频）</li></ol></li><li><ol start="7"><li>天气控件</li></ol></li><li><ol start="8"><li>等待脑洞大开</li></ol></li></ul><hr><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>从早上9点搞到下午4点，午饭还没吃hh，就一直坐在电脑前。<br><del>找模板中的问题代码、修改代码，还是很麻烦的。</del><br>最后分享一首今天网易日推的英文歌（版权原因，没法生成外联播放器）<br><a href="https://music.163.com/#/song?id=555931250" target="_blank" rel="noopener">I’ll Be There-Jess Glynne</a><br>对于我的博客有问题或建议，欢迎在评论或邮件中告诉我。<br>谢谢每一位读者。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搞了半天时间，优化一些模板上的问题后，新博客1.4版本上线了&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>网页视频测试</title>
    <link href="http://yoursite.com/2019/11/08/%E7%BD%91%E9%A1%B5%E8%A7%86%E9%A2%91%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/11/08/网页视频测试/</id>
    <published>2019-11-07T16:00:00.000Z</published>
    <updated>2019-11-25T14:12:49.754Z</updated>
    
    <content type="html"><![CDATA[<p>浏览测试效果👇</p><a id="more"></a><p>video大窗口</p><!--全属性--><p><video src="//f.video.weibocdn.com/000cbp8Elx07yOInQ0wU01041209MBbv0E040.mp4?label=mp4_720p&amp;template=1280x720.25.0&amp;trans_finger=1f0da16358befad33323e3a1b7f95fc9&amp;Expires=1574694219&amp;ssig=teAXjHmR3d&amp;KID=unistore,video" type="video/mp4" poster="http://wx3.sinaimg.cn/orj480/8e2d6e12gy1g989bsg7uaj20u00gw4c7.jpg" controls="controls" loop="-1"><!--需要自动播放，加上controls="controls"即可--><br></video></p><p>video小窗口</p><!--优雅降级--><video width="320" height="240" controls="">    <!--兼容IE9+、Chrome和Safari-->    <source src="//f.video.weibocdn.com/000cbp8Elx07yOInQ0wU01041209MBbv0E040.mp4?label=mp4_720p&amp;template=1280x720.25.0&amp;trans_finger=1f0da16358befad33323e3a1b7f95fc9&amp;Expires=1574694219&amp;ssig=teAXjHmR3d&amp;KID=unistore,video" type="video/mp4">    <!--兼容Firefox、Opera和Chrome-->    <source src="movie.ogg" type="video/ogg">    <!--兼容Firefox、Opera和Chrome-->    <source src="movie.webm" type="video/webm">    <object data="movie.mp4" width="320" height="240">        <embed src="movie.swf" width="320" height="240">    </object> </video><p>embed窗口<br><embed src="//f.video.weibocdn.com/000cbp8Elx07yOInQ0wU01041209MBbv0E040.mp4?label=mp4_720p&amp;template=1280x720.25.0&amp;trans_finger=1f0da16358befad33323e3a1b7f95fc9&amp;Expires=1574694219&amp;ssig=teAXjHmR3d&amp;KID=unistore,video" type="video/mp4"> <br>iframe窗口</p><iframe frameborder="0" src="//f.video.weibocdn.com/000cbp8Elx07yOInQ0wU01041209MBbv0E040.mp4?label=mp4_720p&amp;template=1280x720.25.0&amp;trans_finger=1f0da16358befad33323e3a1b7f95fc9&amp;Expires=1574694219&amp;ssig=teAXjHmR3d&amp;KID=unistore,video" allowfullscreen=""></iframe><iframe src="//player.bilibili.com/player.html?aid=76560081&amp;cid=130958803&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><br>测试完毕<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览测试效果👇&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo+GitHub建站</title>
    <link href="http://yoursite.com/2019/11/07/Hexo+GitHub/"/>
    <id>http://yoursite.com/2019/11/07/Hexo+GitHub/</id>
    <published>2019-11-07T11:24:01.000Z</published>
    <updated>2019-11-23T11:49:16.133Z</updated>
    
    <content type="html"><![CDATA[<p>前言： 使用CSDN平台撰写博客似乎是一件美事，只不过个人觉得太过于依赖他人平台，不如就自己搭建一个属于自己的博客。</p><a id="more"></a>  //截断文章<hr><h1 id="安装篇"><a href="#安装篇" class="headerlink" title="安装篇"></a>安装篇</h1><hr><h2 id="一、安装-【hexo】-前的准备"><a href="#一、安装-【hexo】-前的准备" class="headerlink" title="一、安装 【hexo】 前的准备"></a>一、安装 【hexo】 前的准备</h2><h3 id="安装hexo前的必要工作"><a href="#安装hexo前的必要工作" class="headerlink" title="安装hexo前的必要工作"></a>安装hexo前的必要工作</h3><h4 id="1-安装以下两个程序："><a href="#1-安装以下两个程序：" class="headerlink" title="1).安装以下两个程序："></a>1).安装以下两个程序：</h4><table><thead><tr><th>程序</th><th>下载地址</th><th>说明</th></tr></thead><tbody><tr><td>Git</td><td><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git - Downloads</a></td><td>网速的同学，可以自行百度移步到国内镜像</td></tr><tr><td>Node.js</td><td><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js - Downloads</a></td><td>有LTS和Current两个版本，安装 LTS 版即可</td></tr></tbody></table><p>注意：关于Git和Node.js的安装可能会有问题，尤其是Git的安装。这里贴上几张安装界面的截图（来源见水印，作者GroovRain）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/07/bUgMBmks7VwjPIe.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/07/9OkM4l2Szbe5RQs.png" alt="f3e0287f.png" title="">                </div>                <div class="image-caption">f3e0287f.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/07/PKTDE54qpkQ1S8J.png" alt="774cdfb9.png" title="">                </div>                <div class="image-caption">774cdfb9.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/07/8RYLQNsVoCZpxqB.png" alt="2e023781.png" title="">                </div>                <div class="image-caption">2e023781.png</div>            </figure><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/07/pFcNrU8QYBVROGw.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><h4 id="2-配置（可以在未来部署，并非一定现在）"><a href="#2-配置（可以在未来部署，并非一定现在）" class="headerlink" title="2).配置（可以在未来部署，并非一定现在）"></a>2).配置（<em>可以在未来部署，并非一定现在</em>）</h4><blockquote><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p></blockquote><pre><code>$ git config --global user.name  "your name"`$ git config --global user.email "your Email"</code></pre><h2 id="二、正式安装【hexo】"><a href="#二、正式安装【hexo】" class="headerlink" title="二、正式安装【hexo】"></a>二、正式安装【hexo】</h2><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。——官方</p></blockquote><p>准备工作完成后，来安装hexo框架吧！<br> <strong>== 主要根据hexo官方的<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">文档</a>来安装hexo ==</strong></p><p>==使用 npm 安装 Hexo==</p><p><code>$ npm install -g hexo-cli</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/07/BZIuA2XzYeaDQ8k.png" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><p>这样,【hexo】就安装完成了。</p><!-- more --><!-- more --><!-- more --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言： 使用CSDN平台撰写博客似乎是一件美事，只不过个人觉得太过于依赖他人平台，不如就自己搭建一个属于自己的博客。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>博客文章太长？截断！</title>
    <link href="http://yoursite.com/2019/11/06/%E6%96%87%E7%AB%A0%E6%88%AA%E6%96%AD/"/>
    <id>http://yoursite.com/2019/11/06/文章截断/</id>
    <published>2019-11-06T08:49:56.000Z</published>
    <updated>2019-11-23T11:49:29.633Z</updated>
    
    <content type="html"><![CDATA[<p>写的md文章太长，担心放到首页上浏览效果不好，怎么办？</p><p>那就直接截断文章。</p><p><strong>截断按钮文字不是通过配置文件_config.yml实现的，而是在文章内容里实现</strong>。</p><p>只要在需要被截断的文章位置加上：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></tbody></table></figure><p>就可以了！</p><p>效果就像下面的这个按钮</p><p>可以点点看哦👇</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写的md文章太长，担心放到首页上浏览效果不好，怎么办？&lt;/p&gt;
&lt;p&gt;那就直接截断文章。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;截断按钮文字不是通过配置文件_config.yml实现的，而是在文章内容里实现&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;只要在需要被截断的文章位置加上：&lt;/p&gt;
      
    
    </summary>
    
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
