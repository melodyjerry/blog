<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MelodyHub</title>
  
  <subtitle>你用走 可是我用跑</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://melodyjerry.github.io/blog/"/>
  <updated>2020-10-09T05:45:27.610Z</updated>
  <id>https://melodyjerry.github.io/blog/</id>
  
  <author>
    <name>Melody Jerry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue指令：v-clock解决页面闪烁问题</title>
    <link href="https://melodyjerry.github.io/blog/2020/10/08/Vue%E6%8C%87%E4%BB%A4%EF%BC%9Av-clock%E8%A7%A3%E5%86%B3%E9%A1%B5%E9%9D%A2%E9%97%AA%E7%83%81%E9%97%AE%E9%A2%98/"/>
    <id>https://melodyjerry.github.io/blog/2020/10/08/Vue%E6%8C%87%E4%BB%A4%EF%BC%9Av-clock%E8%A7%A3%E5%86%B3%E9%A1%B5%E9%9D%A2%E9%97%AA%E7%83%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-08T06:47:11.000Z</published>
    <updated>2020-10-09T05:45:27.610Z</updated>
    
    <content type="html"><![CDATA[<p>如果网速慢，而该标签内容是变量没有请求响应回来的时候，页面上先不显示该标签（vue给该标签加了css样式），当响应回来的时候改标签默认将css样式去除。</p><ul><li>此指令可以解决使用插值表达式页面闪烁问题。</li></ul><p>将该指令加在html标签中时，可以在该文件中加<code>style</code>属性为<code>display：none</code>，例子如下：</p><pre><code class="hljs css">&lt;!<span class="hljs-selector-tag">--v-clock</span> 解决闪烁问题<span class="hljs-selector-tag">--</span>&gt;&lt;<span class="hljs-selector-tag">style</span>&gt;    <span class="hljs-selector-attr">[v-clock]</span> {        <span class="hljs-attribute">display</span>: none;    }&lt;/style&gt;</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"#app"</span> <span class="hljs-attr">v-clock</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{name}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果网速慢，而该标签内容是变量没有请求响应回来的时候，页面上先不显示该标签（vue给该标签加了css样式），当响应回来的时候改标签默认将css样式去除。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此指令可以解决使用插值表达式页面闪烁问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将该指令加在html标签中时，可以在该文件中加&lt;code&gt;style&lt;/code&gt;属性为&lt;code&gt;display：none&lt;/code&gt;，例子如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs css&quot;&gt;&amp;lt;!&lt;span class=&quot;hljs-selector-tag&quot;&gt;--v-clock&lt;/span&gt; 解决闪烁问题&lt;span class=&quot;hljs-selector-tag&quot;&gt;--&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;style&lt;/span&gt;&amp;gt;
    &lt;span class=&quot;hljs-selector-attr&quot;&gt;[v-clock]&lt;/span&gt; {
        &lt;span class=&quot;hljs-attribute&quot;&gt;display&lt;/span&gt;: none;
    }
&amp;lt;/style&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;hljs html&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#app&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;v-clock&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;{{name}}&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="笔记" scheme="https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="https://melodyjerry.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://melodyjerry.github.io/blog/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue踩坑记录</title>
    <link href="https://melodyjerry.github.io/blog/2020/10/06/Vue%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://melodyjerry.github.io/blog/2020/10/06/Vue%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2020-10-06T13:47:11.000Z</published>
    <updated>2020-10-09T05:45:27.609Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="组件名必须全小写"><a href="#组件名必须全小写" class="headerlink" title="组件名必须全小写"></a>组件名必须全小写</h1><p>官方文档没有声明<strong>组件名必须全小写</strong></p><pre><code class="hljs js">Vue.component(<span class="hljs-string">'my-component-name'</span>, {  <span class="hljs-comment">// ... options ...</span>})</code></pre><p>但是我的第一个Vue组件踩了这个坑</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- &lt;li&gt; Hello, MelodyJerry! &lt;/li&gt; --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">melody</span>&gt;</span> Hello, MelodyJerry! <span class="hljs-tag">&lt;/<span class="hljs-name">melody</span>&gt;</span>        <span class="hljs-comment">&lt;!-- &lt;MelodyJerry&gt; Hello, MelodyJerry! &lt;/MelodyJerry&gt; --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-comment">//先注册组件，定义一个Vue组件component</span></span><span class="actionscript">        Vue.component(<span class="hljs-string">"melody"</span>,{ <span class="hljs-comment">//组件名必须全小写，一旦有大写，就会注册错误</span></span><span class="actionscript">        <span class="hljs-comment">// Vue.component("MelodyJerry",{ </span></span><span class="handlebars"><span class="xml">            template: '<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span> This is a Vue-Component. <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>'</span></span>        }); <span class="actionscript">        <span class="hljs-comment">//再实例化Vue</span></span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>        });    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>错误显示：</p><pre><code class="hljs autohotkey"><span class="hljs-built_in">Hello,</span> MelodyJerry!</code></pre><p>正确显示，应该是：</p><pre><code class="hljs mercury">· This <span class="hljs-keyword">is</span> a Vue-Component.</code></pre><h1 id="methods和computed里调用方法要不要"><a href="#methods和computed里调用方法要不要" class="headerlink" title="methods和computed里调用方法要不要()"></a>methods和computed里调用方法要不要()</h1><ul><li>调用<code>methods</code>里的方法,<code>得用()</code><ul><li><code>methods</code>是<code>方法</code></li></ul></li><li>调用<code>computed</code>的方法,<code>不能用()</code><ul><li><code>computed</code>是<code>计算属性</code>，是<code>属性</code></li></ul></li></ul><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 调用methods里的方法,得用() --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>currentTime1: {{currentTime1()}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 调用计算属性computed的方法,不能用() --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>currentTime2: {{currentTime2}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>            data: {<span class="actionscript">                message: <span class="hljs-string">"hello,melodyjerry."</span></span>            },            methods: {<span class="actionscript">                currentTime1: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</span><span class="javascript">                    <span class="hljs-keyword">var</span> Xmas95 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"December 25, 1995 23:15:30"</span>);</span><span class="actionscript">                    <span class="hljs-keyword">return</span> Xmas95.getDay(); <span class="hljs-comment">//1;返回数值代表星期几：0代表星期日,1代表星期一,2代表星期二</span></span>                },            },<span class="actionscript">            <span class="hljs-comment">//计算属性</span></span><span class="actionscript">            computed: { <span class="hljs-comment">//methods、computed中的方法名不能重名;重名后，只会调用methods中的方法</span></span><span class="actionscript">                currentTime2: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</span><span class="actionscript">                <span class="hljs-comment">//currentTime1: function() {</span></span><span class="javascript">                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">//返回一个时间戳</span></span>                },            },        })    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h1 id="methods、computed中的方法名不能重名"><a href="#methods、computed中的方法名不能重名" class="headerlink" title="methods、computed中的方法名不能重名"></a>methods、computed中的方法名不能重名</h1><ul><li>重名后，只会调用methods中的方法</li></ul><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 调用方法得用() --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>currentTime1: {{currentTime1()}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>currentTime1: {{currentTime1}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>            data: {<span class="actionscript">                message: <span class="hljs-string">"hello,melodyjerry."</span></span>            },            methods: {<span class="actionscript">                currentTime1: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</span><span class="javascript">                    <span class="hljs-keyword">var</span> Xmas95 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"December 25, 1995 23:15:30"</span>);</span><span class="actionscript">                    <span class="hljs-keyword">return</span> Xmas95.getDay(); <span class="hljs-comment">//1;返回数值代表星期几：0代表星期日,1代表星期一,2代表星期二</span></span>                },            },<span class="actionscript">            <span class="hljs-comment">//计算属性</span></span><span class="actionscript">            computed: { <span class="hljs-comment">//methods、computed中的方法名不能重名;重名后，只会调用methods中的方法</span></span><span class="actionscript">                currentTime1: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</span><span class="javascript">                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">//返回一个时间戳</span></span>                },            },        })    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>页面显示：</p><pre><code class="hljs http"><span class="hljs-attribute">currentTime1</span>: 1<span class="hljs-attribute">currentTime1</span>: function () { [native code] }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;组件名必须全小写&quot;&gt;&lt;a href=&quot;#组件名必须全小写&quot; class=&quot;headerlink&quot; title=&quot;组件名必须全小写&quot;&gt;&lt;/a&gt;组件名必须全小写&lt;/h1&gt;&lt;p&gt;官方文档没有声明&lt;strong&gt;组件名必须全小写&lt;/s
      
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="笔记" scheme="https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="https://melodyjerry.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://melodyjerry.github.io/blog/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>js中[]、{}、()的区别</title>
    <link href="https://melodyjerry.github.io/blog/2020/10/06/js%E4%B8%AD[]%E3%80%81%7B%7D%E3%80%81()%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://melodyjerry.github.io/blog/2020/10/06/js%E4%B8%AD[]%E3%80%81%7B%7D%E3%80%81()%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-10-06T12:47:11.000Z</published>
    <updated>2020-10-07T15:10:11.130Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>{}</code>：表示对象</li><li><code>[]</code>：表示对象的属性、方法</li><li><code>()</code>：如果用在方法名后面，代表调用</li></ul><p><img src="https://s1.ax1x.com/2020/10/06/0Uybp6.png" srcset="/blog/img/loading.gif" alt="0Uybp6.png"></p><a id="more"></a><p>一、<code>{ }</code> 大括号，表示<strong>定义一个对象</strong>，大部分情况下要有成对的属性和值，或是函数体。</p><pre><code class="hljs js">如：<span class="hljs-keyword">var</span> LangShen = {<span class="hljs-string">"Name"</span>:<span class="hljs-string">"Langshen"</span>,<span class="hljs-string">"AGE"</span>:”<span class="hljs-number">28</span>”}; 上面声明了一个名为“LangShen”的对象，多个属性或函数用,（逗号）隔开，因为是对象的属性， 所以访问时，应该用.（点）来层层访问：LangShen.Name、LangShen.AGE，当然我们也可以用数组的方式来访问，如：LangShen[<span class="hljs-string">"Name"</span>]、LangShen[<span class="hljs-string">"AGE"</span>]，结果是一样的。<span class="hljs-keyword">var</span> LangShen = {     Name : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{         <span class="hljs-keyword">return</span> <span class="hljs-string">"LangShen"</span>;     },     Age : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{         <span class="hljs-keyword">return</span> <span class="hljs-string">"28"</span>;     } } 调用 LangShen.Name()</code></pre><p>二、<code>[ ]</code>中括号，表示<strong>一个数组，也可以理解为一个数组对象</strong>。</p><pre><code class="hljs js">如：<span class="hljs-keyword">var</span> LangShen = [ <span class="hljs-string">"Name"</span>,<span class="hljs-string">"LangShen"</span>,<span class="hljs-string">"AGE"</span>,<span class="hljs-string">"28"</span> ]; 很明显，每个值或函数，都是独立的，多个值之间只用,（逗号）隔开，因为是数组对象，所以它等于： <span class="hljs-keyword">var</span> LangShen = <span class="hljs-built_in">Array</span>( <span class="hljs-string">"Name"</span>,<span class="hljs-string">"LangShen"</span>,<span class="hljs-string">"AGE"</span>,<span class="hljs-string">"28"</span> ); 访问时，也是和数组一样，alert( LangShen[<span class="hljs-number">0</span>] )</code></pre><p>三、<code>{ }</code> 和<code>[ ]</code>一起使用，<code>{ }</code> 是一个对象，<code>[ ]</code> 是一个数组，我们可以组成一个对象数组。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> LangShen = {     <span class="hljs-string">"Name"</span>:<span class="hljs-string">"Langshen"</span>,     <span class="hljs-string">"MyWife"</span>:[ <span class="hljs-string">"LuLu"</span>,<span class="hljs-string">"26"</span> ],     <span class="hljs-string">"MySon"</span>:[{<span class="hljs-string">"Name"</span>:<span class="hljs-string">"Son1"</span>},{<span class="hljs-string">"Name"</span>:<span class="hljs-string">"Son2"</span>},{<span class="hljs-string">"Name"</span>:<span class="hljs-string">"Son3"</span>}] } 从上面的结构来看，是一个对象里面的第一项是个属性，第二项是一个数组，第三个是包含有多个对象的数组。调用起来，也是一层一层访问，对象的属性用.（点）叠加，数组用 [下标] 来访问。如：alert( LangShen.MySon[<span class="hljs-number">1</span>].Name ) ；<span class="hljs-keyword">var</span> LangShen=[    {“name”：“wangwu”},    {“name”：“lieu”}];这是一个对象数组</code></pre><p>四、<code>()</code>多表示参数、<code>{}</code>表示函数体 <code>()</code>要看它放在什么位置才能知道它起什么作用，因为它有多种用法。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span>(<span class="hljs-params">name</span>)</span>{    Alert(name);}es6中，<span class="hljs-keyword">let</span> show=<span class="hljs-function">(<span class="hljs-params">name</span>)=&gt;</span>{    alert(name);}在es6中如果参数只有一个，或者函数体只有一个话，可以省略（）、{},如<span class="hljs-keyword">let</span> show=<span class="hljs-function"><span class="hljs-params">name</span>=&gt;</span>alert(name);</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt;：表示对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt;：表示对象的属性、方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;()&lt;/code&gt;：如果用在方法名后面，代表调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/06/0Uybp6.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;0Uybp6.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="笔记" scheme="https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="https://melodyjerry.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>npm-安装模块时出现rollbackFailedOptional</title>
    <link href="https://melodyjerry.github.io/blog/2020/10/06/npm-%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97%E6%97%B6%E5%87%BA%E7%8E%B0rollbackFailedOptional/"/>
    <id>https://melodyjerry.github.io/blog/2020/10/06/npm-%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97%E6%97%B6%E5%87%BA%E7%8E%B0rollbackFailedOptional/</id>
    <published>2020-10-06T12:47:11.000Z</published>
    <updated>2020-10-06T16:22:38.065Z</updated>
    
    <content type="html"><![CDATA[<p>出现以上原因是设置代理的错误，我们可以采用以下方式</p><pre><code class="hljs bash">npm config rm proxynpm config rm https-proxy</code></pre><p>然后你可以安装淘宝的cnpm，这样你下载东西的速度可能提升很多，毕竟是国内的</p><pre><code class="hljs bash">npm install -g cnpm --registry=[https://registry.npm.taobao.org](https://link.jianshu.com/?t=https%3A%2F%2Fregistry.npm.taobao.org)</code></pre><p>然后你用cnpm安装包</p><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;出现以上原因是设置代理的错误，我们可以采用以下方式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;npm config rm proxy
npm config rm https-proxy&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后你可以安装淘宝的cnpm，这样你下载东西的速度可能提升很多，毕竟是国内的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;npm install -g cnpm --registry=[https://registry.npm.taobao.org](https://link.jianshu.com/?t=https%3A%2F%2Fregistry.npm.taobao.org)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后你用cnpm安装包&lt;/p&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="npm" scheme="https://melodyjerry.github.io/blog/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>VS Code建立代码模板vue</title>
    <link href="https://melodyjerry.github.io/blog/2020/10/06/VS-Code%E5%BB%BA%E7%AB%8B%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BFvue/"/>
    <id>https://melodyjerry.github.io/blog/2020/10/06/VS-Code%E5%BB%BA%E7%AB%8B%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BFvue/</id>
    <published>2020-10-06T12:47:11.000Z</published>
    <updated>2020-10-07T15:10:11.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装Vetur插件"><a href="#1-安装Vetur插件" class="headerlink" title="1. 安装Vetur插件"></a>1. 安装Vetur插件</h1><h1 id="2-新建用户代码片段"><a href="#2-新建用户代码片段" class="headerlink" title="2.新建用户代码片段"></a>2.新建用户代码片段</h1><p><code>文件</code>–&gt;<code>首选项</code>–&gt;<code>用户代码片段</code>–&gt;<code>点击新建代码片段</code>–取名<code>vue.json</code></p><pre><code class="hljs jso">{  "Print to console": {    "prefix": "vue",    "body": [      "&lt;!-- $0 --&gt;",      "&lt;template&gt;",      "  &lt;div&gt;&lt;/div&gt;",      "&lt;/template&gt;",      "",      "&lt;script&gt;",      "export default {",      "  data () {",      "    return {",      "    };",      "  },",      "",      "  components: {},",      "",      "  computed: {},",      "",      "  mounted: {},",      "",      "  methods: {}",      "}",      "",      "&lt;/script&gt;",      "&lt;style lang='scss' scoped&gt;",      "&lt;/style&gt;"  ],    "description": "Log output to console"  }}</code></pre><blockquote><p>上面代码中的 </p><ul><li><code>"prefix": "vue"</code>, 就是快捷键,表示生成对应预设代码的命令；</li><li><code>$0</code> 表示你希望生成代码后光标的位置 ; </li></ul></blockquote><h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h1><p>新建<code>.vue</code>结尾的文件试试，编辑区输入<code>vue</code>，按<code>Tab</code>键</p><p><img src="https://s1.ax1x.com/2020/10/07/0dhVMR.png" srcset="/blog/img/loading.gif" alt="0dhVMR.png"></p><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-安装Vetur插件&quot;&gt;&lt;a href=&quot;#1-安装Vetur插件&quot; class=&quot;headerlink&quot; title=&quot;1. 安装Vetur插件&quot;&gt;&lt;/a&gt;1. 安装Vetur插件&lt;/h1&gt;&lt;h1 id=&quot;2-新建用户代码片段&quot;&gt;&lt;a href=&quot;#2-新建用户代码片段&quot; class=&quot;headerlink&quot; title=&quot;2.新建用户代码片段&quot;&gt;&lt;/a&gt;2.新建用户代码片段&lt;/h1&gt;&lt;p&gt;&lt;code&gt;文件&lt;/code&gt;–&amp;gt;&lt;code&gt;首选项&lt;/code&gt;–&amp;gt;&lt;code&gt;用户代码片段&lt;/code&gt;–&amp;gt;&lt;code&gt;点击新建代码片段&lt;/code&gt;–取名&lt;code&gt;vue.json&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs jso&quot;&gt;{
  &quot;Print to console&quot;: {
    &quot;prefix&quot;: &quot;vue&quot;,
    &quot;body&quot;: [
      &quot;&amp;lt;!-- $0 --&amp;gt;&quot;,
      &quot;&amp;lt;template&amp;gt;&quot;,
      &quot;  &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&quot;,
      &quot;&amp;lt;/template&amp;gt;&quot;,
      &quot;&quot;,
      &quot;&amp;lt;script&amp;gt;&quot;,
      &quot;export default {&quot;,
      &quot;  data () {&quot;,
      &quot;    return {&quot;,
      &quot;    };&quot;,
      &quot;  },&quot;,
      &quot;&quot;,
      &quot;  components: {},&quot;,
      &quot;&quot;,
      &quot;  computed: {},&quot;,
      &quot;&quot;,
      &quot;  mounted: {},&quot;,
      &quot;&quot;,
      &quot;  methods: {}&quot;,
      &quot;}&quot;,
      &quot;&quot;,
      &quot;&amp;lt;/script&amp;gt;&quot;,
      &quot;&amp;lt;style lang=&#39;scss&#39; scoped&amp;gt;&quot;,
      &quot;&amp;lt;/style&amp;gt;&quot;
  ],
    &quot;description&quot;: &quot;Log output to console&quot;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;上面代码中的 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&quot;prefix&quot;: &quot;vue&quot;&lt;/code&gt;, 就是快捷键,表示生成对应预设代码的命令；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$0&lt;/code&gt; 表示你希望生成代码后光标的位置 ; &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;3-测试&quot;&gt;&lt;a href=&quot;#3-测试&quot; class=&quot;headerlink&quot; title=&quot;3. 测试&quot;&gt;&lt;/a&gt;3. 测试&lt;/h1&gt;&lt;p&gt;新建&lt;code&gt;.vue&lt;/code&gt;结尾的文件试试，编辑区输入&lt;code&gt;vue&lt;/code&gt;，按&lt;code&gt;Tab&lt;/code&gt;键&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/07/0dhVMR.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;0dhVMR.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="Vue" scheme="https://melodyjerry.github.io/blog/tags/Vue/"/>
    
      <category term="VS Code" scheme="https://melodyjerry.github.io/blog/tags/VS-Code/"/>
    
  </entry>
  
  <entry>
    <title>IDEA离线安装插件</title>
    <link href="https://melodyjerry.github.io/blog/2020/10/06/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/"/>
    <id>https://melodyjerry.github.io/blog/2020/10/06/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/</id>
    <published>2020-10-06T09:00:00.000Z</published>
    <updated>2020-10-07T15:10:11.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>IDEA发抽了，居然找不到任何插件，估计是IDEA网络的问题。</p><p><img src="https://s1.ax1x.com/2020/10/06/0NfI6P.png" srcset="/blog/img/loading.gif" alt="0NfI6P.png"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>劳资直接开大招，自己离线安装！！！</p><p><strong>通过浏览器进入idea官网下载离线插件，然后由idea工具导入我们所下载的插件即可！</strong></p><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//plugins.jetbrains.com/</span></code></pre><p><img src="https://s1.ax1x.com/2020/10/06/0N42RA.png" srcset="/blog/img/loading.gif" alt="0N42RA.png"></p><p>然后IDEA中选择刚下载的压缩包<code>.zip</code>，安装即可。</p><p><img src="https://s1.ax1x.com/2020/10/06/0N4bGj.png" srcset="/blog/img/loading.gif" alt="0N4bGj.png"></p><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;IDEA发抽了，居然找不到任何插件，估计是IDEA网络的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/06/0NfI6P.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;0NfI6P.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;解决&quot;&gt;&lt;a href=&quot;#解决&quot; class=&quot;headerlink&quot; title=&quot;解决&quot;&gt;&lt;/a&gt;解决&lt;/h1&gt;&lt;p&gt;劳资直接开大招，自己离线安装！！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过浏览器进入idea官网下载离线插件，然后由idea工具导入我们所下载的插件即可！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs dts&quot;&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;http:&lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//plugins.jetbrains.com/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/06/0N42RA.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;0N42RA.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后IDEA中选择刚下载的压缩包&lt;code&gt;.zip&lt;/code&gt;，安装即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/06/0N4bGj.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;0N4bGj.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="IDEA" scheme="https://melodyjerry.github.io/blog/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Vue入门学习笔记</title>
    <link href="https://melodyjerry.github.io/blog/2020/10/04/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://melodyjerry.github.io/blog/2020/10/04/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-04T12:47:11.000Z</published>
    <updated>2020-10-09T05:45:27.229Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 的核心库只关注视图层，方便与第三方库或既有项目整合。</p><p>HTML + CSS + JS : 视图 ： <code>给用户看，刷新后台给的数据</code></p><p>网络通信 ： <code>axios</code></p><p>页面跳转 ： <code>vue-router</code></p><p>状态管理：<code>vuex</code></p><p>Vue-UI : <code>ICE</code>、 <code>Element UI</code></p><h1 id="一、VUE-概述"><a href="#一、VUE-概述" class="headerlink" title="一、VUE 概述"></a>一、VUE 概述</h1><p><code>Vue</code>(读音<code>/vju/</code>, 类似于view)是<strong>一套用于构建用户界面的渐进式框架</strong>，发布于2014年2月。</p><p>与其它大型框架不同的是，<strong>Vue被设计为可以自底向上逐层应用。</strong></p><p><strong>Vue的核心库只关注视图层</strong>，不仅易于上手，还便于与第三方库(如: <code>vue-router</code>: 跳转，<code>vue-resource</code>: 通信，<code>vuex</code>:管理)或既有项目整合。</p><a id="more"></a><h1 id="二、前端核心知识分析"><a href="#二、前端核心知识分析" class="headerlink" title="二、前端核心知识分析"></a>二、前端核心知识分析</h1><h2 id="1-前端三要素"><a href="#1-前端三要素" class="headerlink" title="1. 前端三要素"></a>1. 前端三要素</h2><ul><li><code>HTML</code><strong>(结构层)</strong> : 超文本标记语言(Hyper Text Markup Language) ，决定网页的结构和内容</li><li><code>CSS</code><strong>(表现层)</strong> : 层叠样式表(Cascading Style sheets) ，设定网页的表现样式</li><li><code>JavaScript</code><strong>(行为层)</strong> : 是一种弱类型脚本语言，其源代码不需经过编译，而是由浏览器解释运行,用于控制网页的行为</li></ul><h3 id="1-1-CSS-预处理器有"><a href="#1-1-CSS-预处理器有" class="headerlink" title="1.1 CSS 预处理器有"></a>1.1 CSS 预处理器有</h3><ul><li>SASS：基于Ruby，通过服务端处理，功能强大。解析效率稿。需要学习 Ruby 语言，上手难度高于LESS。</li><li><code>LESS</code>：基于 NodeJS，通过客户端处理，使用简单。功能比 SASS 简单，解析效率也低于 SASS，但<strong>在实际开发中足够了，所以后台人员如果需要的话，建议使用 LESS。</strong></li></ul><h3 id="1-2-Native原生JS开发"><a href="#1-2-Native原生JS开发" class="headerlink" title="1.2 Native原生JS开发"></a>1.2 Native原生JS开发</h3><p>原生JS开发，也就是让我们按照【<strong>ECMAScript</strong>】标准的开发方式，简称是ES,特点是所有浏览器都支持。截止到当前博客发布时间，ES标准已发布如下版本:</p><ul><li><p>ES3</p></li><li><p>ES4 (内部,未正式发布)</p></li><li><p><code>ES5 (全浏览器支持)</code></p></li><li><p><code>ES6 (常用，当前主流版本: webpack打包成为ES5支持! )</code></p></li><li><p>ES7</p></li><li><p>ES8</p></li><li><p>ES9 (草案阶段)</p></li></ul><blockquote><p>区别就是逐步增加新特性。</p></blockquote><h3 id="1-3-TypeScript微软的标准"><a href="#1-3-TypeScript微软的标准" class="headerlink" title="1.3 TypeScript微软的标准"></a>1.3 TypeScript微软的标准</h3><p>TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。由安德斯海尔斯伯格（C#、Delphi、TypeScript 之父； .NET 创立者）主导。</p><p>该语言的特点就是除了具备 ES 的特性之外还纳入了许多不在标准范围内的新特性，所以会导致很多浏览器不能直接支持 TypeScript 语法，需要编译后（编译成 JS ）才能被浏览器正确执行。</p><h2 id="2-JavaScript框架"><a href="#2-JavaScript框架" class="headerlink" title="2. JavaScript框架"></a>2. JavaScript框架</h2><p><font color="blue">前端三大框架：Angular、React、Vue</font></p><ul><li><strong>jQuery</strong>: 大家熟知的JavaScript框架，优点是简化了DOM操作，缺点是DOM操作太频繁,影响前端性能;在前端眼里使用它仅仅是为了兼容IE6、7、8。</li><li><strong>Angular</strong>: Google收购的前端框架，由一群Java程序员开发，其<code>特点是将后台的MVC模式搬到了前端并增加了模块化开发的理念</code>，与微软合作，采用TypeScript语法开发;对后台程序员友好，对前端程序员不太友好;最大的缺点是版本迭代不合理(如: 1代-&gt; 2代，除了名字，基本就是两个东西;截止发表博客时已推出了Angular6)。</li><li><strong>React</strong>: Facebook出品，一款高性能的JS前端框架;<code>特点是提出了新概念[虚拟DOM]用于减少真实DOM操作，在内存中模拟DOM操作，有效的提升了前端渲染效率</code>;缺点是使用复杂，因为需要额外学习一门[JSX] 语言。</li><li><strong>Vue</strong>:一款渐进式JavaScript框架，<strong>所谓渐进式就是逐步实现新特性的意思</strong>，如实现模块化开发、路由、状态管理等新特性。<strong>其特点是综合了Angular (模块化)和React (虚拟DOM)的优点;</strong>。</li><li><strong>Axios</strong> :<strong>前端通信框架</strong>；因为Vue 的边界很明确，就是为了处理DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用jQuery提供的AJAX通信功能。</li></ul><h2 id="3-UI框架"><a href="#3-UI框架" class="headerlink" title="3. UI框架"></a>3. UI框架</h2><ul><li>Ant-Design:阿里巴巴出品，基于React的UI框架</li><li><strong>ElementUI、 iview、 ice</strong>: 饿了么出品，基于Vue的UI框架</li><li><strong>Bootstrap</strong>: Twitter推出的一个用于前端开发</li><li>AmazeUI:又叫”妹子UI”，一款HTML5跨屏前端框架</li></ul><h2 id="4-JavaScript构建工具"><a href="#4-JavaScript构建工具" class="headerlink" title="4. JavaScript构建工具"></a>4. JavaScript构建工具</h2><ul><li>Babel: JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript</li><li><strong>WebPack</strong>: <em>模块打包器，主要作用是打包、压缩、合并及按序加载</em></li></ul><blockquote><p>前端开发主要使用<code>WebPack</code>。</p></blockquote><h2 id="5-三端合一"><a href="#5-三端合一" class="headerlink" title="5. 三端合一"></a>5. 三端合一</h2><h3 id="5-1-混合开发（Hybid-App）"><a href="#5-1-混合开发（Hybid-App）" class="headerlink" title="5.1 混合开发（Hybid App）"></a>5.1 混合开发（Hybid App）</h3><p>主要目的是实现一套代码三端统一(PC、Android:.apk、iOS:.ipa )并能备够调用到底层件(如:传感器、GPS、 摄像头等)，打包方式主要有以下两种:</p><ul><li>云打包: <strong>HBuild -&gt; HBuildX， DCloud出品; API Cloud</strong></li><li>本地打包: <strong>Cordova</strong> (前身是PhoneGap)</li></ul><h3 id="5-2-微信小程序"><a href="#5-2-微信小程序" class="headerlink" title="5.2 微信小程序"></a>5.2 微信小程序</h3><p>详见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">微信小程序官网</a>，这里就只介绍一个方便小程序开发的框架：</p><ul><li>WeUI</li></ul><h2 id="6-后端技术"><a href="#6-后端技术" class="headerlink" title="6. 后端技术"></a>6. 后端技术</h2><p>前端人员为了方便开发也需要掌握一定的后端技术， 但我们Java后台人员知道后台知识体系极其庞大复杂，所以为了方便前端人员开发后台应用，就出现了<code>NodeJS</code>这样的技术。</p><p>NodeJS的作者已经声称放弃NodeJS (说是架构做的不好再加上笨重的node_ modules，可能让作者不爽了吧)，开始开发全新架构的Deno</p><p>既然是后台技术，那肯定也需要框架和项目管理工具，<code>NodeJS</code>框架及项目管理工具如下:</p><ul><li>Express: NodeJS框架</li><li>Koa: Express简化版</li><li><code>NPM</code>: 项目综合管理工具，类似于Maven</li><li><code>YARN</code>: NPM的替代方案，类似于Maven和Gradle的关系</li></ul><h2 id="7-主流前端框架"><a href="#7-主流前端框架" class="headerlink" title="7. 主流前端框架"></a>7. 主流前端框架</h2><ul><li><strong>Vue.js</strong></li></ul><h3 id="7-1-iView"><a href="#7-1-iView" class="headerlink" title="7.1 iView"></a>7.1 iView</h3><p>iview 是一个强大的基于 Vue 的 UI 库，有很多实用的基础组件比 elementui 的组件更丰富，主要服务于 PC 界面的中后台产品。使用单文件的 Vue 组件化开发模式基于 npm + webpack + babel 开发，支持 ES2015 高质量、功能丰富友好的 API，自由灵活地使用空间。</p><ul><li><a href="https://iviewui.com/" target="_blank" rel="noopener">官网地址</a></li><li><a href="https://github.com/view-design/ViewUI" target="_blank" rel="noopener">Github</a></li><li><a href="https://gitee.com/icarusion/iview-admin" target="_blank" rel="noopener">iview-admin</a></li></ul><blockquote><p>备注：属于前端主流框架，选型时可以考虑使用，主要特点是移动端支持较多</p></blockquote><h3 id="7-2-ElementUI"><a href="#7-2-ElementUI" class="headerlink" title="7.2 ElementUI"></a>7.2 ElementUI</h3><p><code>Element</code> 是饿了么前端开源维护的 Vue UI 组件库，组件齐全，基本涵盖后台所需的所有组件，文档讲解详细，例子也很丰富。<strong>主要用于开发 PC 端的页面，是一个质量比较高的 Vue UI 组件库。</strong></p><ul><li><a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener">官网地址</a></li><li>Github：<a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">vue-element-admin</a></li></ul><blockquote><p>备注：属于前端主流框架，选型时可以考虑使用，<strong>主要特点是桌面端支持较多</strong></p></blockquote><h3 id="7-3-ICE"><a href="#7-3-ICE" class="headerlink" title="7.3 ICE"></a>7.3 ICE</h3><p>飞冰 是阿里巴巴团队基于 React/Angular/Vue 的中后台应用解决方案，在阿里巴巴内部，已经有270多个来自几乎所有 BU 的项目在使用。飞冰包含了一条从设计端到开发端的完整链路，帮助用户快速搭建属于自己的中后台应用。</p><blockquote><p>备注:主要组件还是以 React 为主，截止 2019 年 02 月 17 日更新博客前对 Vue 的支持还不太完善，目前尚处于观望阶段</p></blockquote><h3 id="7-4-VantUI"><a href="#7-4-VantUI" class="headerlink" title="7.4 VantUI"></a>7.4 VantUI</h3><p>Vant UI 是有赞前端团队基于有赞统一的规范实现的 Vue 组件库,提供了一整套 UI 基础组件和业务组件。通过 Vant，可以快速搭建出风格统一的页面， 提升开发效率。</p><h3 id="7-5-AtUI"><a href="#7-5-AtUI" class="headerlink" title="7.5 AtUI"></a>7.5 AtUI</h3><p>at-ui是一款基于 Vue 2.x 的前端UI组件库,主要用于快速开发PC网站产品。它提供了一套 npm + webpack + babel 前端开发工作流程，CSS 样式独立，即使采用不同的框架实现都能保持统一的UI风格。</p><h3 id="7-6-CubeUI"><a href="#7-6-CubeUI" class="headerlink" title="7.6 CubeUI"></a>7.6 CubeUI</h3><p>cube-ui 是滴滴团队开发的基于 Vue.js 实现的精致移动端组件库。支持按需引入和后编译，轻量灵活；扩展性强，可以方便地基于现有组件实现二次开发。</p><h3 id="混合开发"><a href="#混合开发" class="headerlink" title="混合开发"></a>混合开发</h3><h4 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h4><p>Flutter是谷歌的移动端UI框架，可在极短的时间内构建Android 和iOs.上高质量的原生级应用。Flutter 可与现有代码一起工作,它被世界各地的开发者和组织使用,并且Flutter是免费和开源的。</p><blockquote><p>备注: Google出品，主要特点是快速构建原生APP应用程序，如做混合应用该框架为必选框架</p></blockquote><h4 id="lonic"><a href="#lonic" class="headerlink" title="lonic"></a>lonic</h4><p>lonic 既是一个 CSS 框架也是一个 Javascript UI 库，lonic 是目前最有潜力的一款 HTML5 手机应用开发框架。通过 SASS 构建应用程序，它提供了很多 UI 组件来帮助开发者开发强大的应用。它使用 JavaScript MVVM框架和 AngularJS/Vue 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动开发者的共同选择。</p><h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><h4 id="mpvue"><a href="#mpvue" class="headerlink" title="mpvue"></a>mpvue</h4><p>mpvue 是美团开发的一一个使用 <code>Vue.js</code> 开发小程序的前端框架，目前支持微信小程序、百度智能小程序，头条小程序和支付宝小程序。框架基于 <code>Vue.js</code> ，修改了的运行时框架 <code>runt ime</code> 和代码编译器 <code>compiler</code> 实现，使其可运行在小程序环境中，从而为小程序开发引入了 <code>Vue.js</code> 开发体验。</p><blockquote><p>备注:完备的Vue开发体验，并且支持多平台的小程序开发，推荐使用</p></blockquote><h4 id="WeUl"><a href="#WeUl" class="headerlink" title="WeUl"></a>WeUl</h4><p>WeUI 是一套同微信原生视觉体验一致的基础样式库， 由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。包含 button、cell、 dialog、toast、article、 icon 等各式元素。</p><h1 id="三、了解前后端分离的演变史"><a href="#三、了解前后端分离的演变史" class="headerlink" title="三、了解前后端分离的演变史"></a>三、了解前后端分离的演变史</h1><h2 id="1-后端为主的-MVC-时代"><a href="#1-后端为主的-MVC-时代" class="headerlink" title="1 后端为主的 MVC 时代"></a>1 后端为主的 MVC 时代</h2><p>为了降低开发的复杂度，以后端为出发点,比如：Struts、 SpringMVC 等框架的使用，就是后端的MVC时代；</p><p>以 <code>Spring MVC</code> 的流程为例：</p><p><img src="https://s1.ax1x.com/2020/10/04/0JmdxA.png" srcset="/blog/img/loading.gif" alt="0JmdxA.png"></p><ul><li>发起请求到前端控制器( <code>DispatcherServlet</code> )</li><li>前端控制器请求 <code>HandlerMapping</code> 查找 <code>Handler</code>, 可以根据 <code>xml</code> 配置、注解进行查找</li><li>处理器映射器 <code>HandlerMapping</code> 向前端控制器返回 <code>Handler</code></li><li>前端控制器调用处理器适配器去执行Handler</li><li>处理器适配器去执行 <code>Handler</code></li><li><code>Handler</code> 执行完成给适配器返回 <code>ModelAndView</code></li><li>处理器适配器向前端控制器返回 <code>ModelAndView</code> ，<code>Mode lAndView</code> 是 <code>SpringMVC</code> 框架的一一个底层对象，包括 <code>Model</code> 和 <code>View</code></li><li>前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图( <code>JSP</code> )</li><li>视图解析器向前端控制器返回 <code>View</code></li><li>前端控制器进行视图渲染，视图渲染将模型数据（在 <code>ModelAndView</code> 对象中）填充到 <code>request</code> 域</li><li>前端控制器向用户响应结果</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>MVC是一个非常好的协作模式，能够有效降低代码的耦合度,从架构上能够让开发者明白代码应该写在哪里。</li><li>为了让View更纯粹,还可以使用Thymeleaf、Freemarker 等模板引擎，使模板里无法写入Java代码,让前后端分工更加清晰。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>前端开发重度依赖开发环境，开发效率低，这种架构下，前后端协作有两种模式：<ul><li>第一种是前端写 DEMO，写好后，让后端去套模板。好处是 DEMO 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大；</li><li>另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。</li></ul></li><li>前后端职责纠缠不清：模板弓|擎功能强大，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 <code>Controller</code> ，页面路由等功能本应该是前端最关注的，但却是由后端来实现。<code>Controller</code> 本身与 <code>Model</code> 往往也会纠缠不清，看了让人咬牙的业务代码经常会出现在 <code>Controller</code> 层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。</li><li>对前端发挥的局限性：性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作，但由于后端框架限制，我们很难使用<strong>【Comet】</strong> 、<strong>【BigPipe】</strong> 等技术方案来优化性能。</li></ul><blockquote><p>注：在这期间（2005 年以前），包括早期的 JSP、PHP 可以称之为 Web 1.0 时代。因为时代在变、技术在变、什么都在变。</p><blockquote><p>世界著名作家、大思想家斯宾塞·约翰逊的一句话：唯一不变的是变化本身。</p></blockquote><p>一些陈旧的技术对于市场来说早就过时了，比如 JSP。</p></blockquote><h2 id="2-基于-AJAX-带来的-SPA-时代"><a href="#2-基于-AJAX-带来的-SPA-时代" class="headerlink" title="2 基于 AJAX 带来的 SPA 时代"></a>2 基于 AJAX 带来的 SPA 时代</h2><p>时间回到 2005 年 <code>AJAX</code> （Asynchronous JavaScript And XM，异步JavaScript和XML,老技术新用法）被正式提出并开始使用 <code>CDN</code> 作为静态资源存储，于是出现了JavaScript王者归来（在这之前 JS 都是用来在网页上贴狗皮膏药广告的）的 SPA （Single Page Application）单页面应用时代。</p><p><img src="https://s1.ax1x.com/2020/10/04/0JKK2Q.png" srcset="/blog/img/loading.gif" alt="0JKK2Q.png"></p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>这种模式下，<strong>前后端的分工非常清晰，前后端的关键协作点是AJAX接口</strong>。看起来是如此美妙,但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，<strong>这个时代开始出现浏览器端的分层架构</strong>：</p><p><img src="https://s1.ax1x.com/2020/10/04/0JKlKs.png" srcset="/blog/img/loading.gif" alt="0JKlKs.png"></p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>前后端接口的约定：</strong>如果后端的接口一塌糊涂,如果后端的业务模型不够稳定,那么前端开发会很痛苦；不少团队也有类似尝试，通过接口规则、接口平台等方式来做。<strong>有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发</strong>。</li><li><strong>前端开发的复杂度控制：</strong>SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。</li></ul><h2 id="3-前端为主的-MV-时代"><a href="#3-前端为主的-MV-时代" class="headerlink" title="3 前端为主的 MV* 时代"></a>3 前端为主的 MV* 时代</h2><p>此处的 MV* 模式如下：</p><ul><li>MVC （同步通信为主）：Model、View、Controller</li><li>MVP （异步通信为主）： Model、 View、 Presenter</li><li>MVVM （异步通信为主）：Model、 View、 ViewModel</li></ul><p>为了降低前端开发复杂度，涌现了大量的前端框架，比如：<code>AngularJS</code>、 <code>React</code>、 <code>Vue.js</code> 、<code>EmberJS</code>等，这些框架总的原则是先按类型分层,比如 Templates、Controllers、 Models, 然后再在层内做切分，如下图：</p><p><img src="https://s1.ax1x.com/2020/10/04/0JK3bq.png" srcset="/blog/img/loading.gif" alt="0JK3bq.png"></p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>前后端职责很清晰：</strong>前端工作在浏览器端，后端工作在服务器端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。</li><li><strong>前端开发的复杂度可控：</strong>前端代码很重，但合理分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计都有很大学位，得花一本书的厚度去说明。</li><li><strong>部署相对独立：</strong>可以快速改进产品的体验。</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。</li><li>全异步，对 SEO 不利。往往还需要服务端做同步渲染的降级方案。</li><li>性能并非最佳，特别是移动互联网环境下。</li><li>SPA 不能满足所有需求，依旧存在大量多页面应用。URL Design 需要后端配合，前端无法完全掌握。</li></ul><h2 id="4-NodeJS-代理的全栈时代"><a href="#4-NodeJS-代理的全栈时代" class="headerlink" title="4 NodeJS 代理的全栈时代"></a>4 NodeJS 代理的全栈时代</h2><p>前端为主的 MV* 模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着 NodeJS 的兴起， JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式：</p><p><img src="https://s1.ax1x.com/2020/10/04/0JKGV0.png" srcset="/blog/img/loading.gif" alt="0JKGV0.png"></p><p>在这种研发模式下，前后端的职责很清晰。对前端来说，两个UI层各司其职：</p><ul><li>Front-end UI layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互 功能，HTML 的生成也可以放在这层,具体看应用场景。</li><li>Back-end UI layer 处理路由、模板、数据获取、Cookie 等。通过路由,前端终于可以自主把控URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。</li></ul><p>通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要SEO的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。</p><p>与JSP模式相比,全栈模式看起来是一种回归，也的确是-种向原始开发模式的回归,不过是一种螺旋上升式的回归。</p><p>基于NodeJS的全栈模式，依旧面临很多挑战:</p><ul><li>需要前端对服务端编程有更进一 步的认识。比如 TCP/IP 等网络知识的掌握。</li><li>NodeJS 层与 Java 层的高效通信。NodeJS 模式下，都在服务器端，RESTful HTTP 通信未必高效,通过 SOAP 等方式通信更高效。-切需要在验证中前行。</li><li>对部署、运维层面的熟练了解，需要更多知识点和实操经验。</li><li>大量历史遗留问题如何过渡。这可能是最大最大的阻力。</li></ul><blockquote><p>注：为什么说:” 前端想学后台很难，而我们后端程序员学任何东西都很简单“；就是因为后端程序员具备相对完善的知识体系。</p></blockquote><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>综上所述，模式也好，技术也罢，没有好坏优劣之分，只有适合不适合；前后分离的开发思想主要是基于 <code>SoC（关注度分离原则）</code>，上面种种模式，都是让前后端的职责更清晰，分工更合理高效。</p><h1 id="四、MVVM模式"><a href="#四、MVVM模式" class="headerlink" title="四、MVVM模式"></a>四、MVVM模式</h1><h2 id="1-回顾MVC"><a href="#1-回顾MVC" class="headerlink" title="1 回顾MVC"></a>1 回顾MVC</h2><p>MVC 模式代表 <code>Model-View-Controller（模型-视图-控制器）</code>模式。</p><p>这种模式用于<strong>应用程序的分层开发。</strong></p><ul><li><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</li><li><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。</li><li><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</li></ul><p><img src="https://s1.ax1x.com/2020/10/06/0NQRwd.png" srcset="/blog/img/loading.gif" alt="0NQRwd.png"></p><h2 id="2-什么是MVVM？"><a href="#2-什么是MVVM？" class="headerlink" title="2 什么是MVVM？"></a>2 什么是MVVM？</h2><blockquote><p><code>MVVM (Model-View-ViewModel) 是一种软件架构设计模式</code>，由微软WPF (用于替代WinForm，以前就是用这个技术开发桌面应用程序的)和Silverlight (类似于Java Applet,简单点说就是在浏览器上运行的WPF)的架构师Ken Cooper和Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由John Gossman (同样也是WPF和Silverlight的架构师)于2005年在他的博客上发表。</p></blockquote><p><code>MVVM</code> 源自于经典的<code>MVC (ModI-View-Controller) 模式</code>。</p><p>MVVM的核心是<code>ViewModel</code>层，<strong>负责转换Model中的数据对象来让数据变得更容易管理和使用</strong>，其作用如下:</p><ul><li>该层向上与<code>View</code>层进行双向数据绑定</li><li>向下与<code>Model</code>层通过接口请求进行数据交互</li></ul><p><img src="https://s1.ax1x.com/2020/10/06/0Nlt9P.png" srcset="/blog/img/loading.gif" alt="0Nlt9P.png"></p><h2 id="3-MVVM组成部分"><a href="#3-MVVM组成部分" class="headerlink" title="3 MVVM组成部分"></a>3 MVVM组成部分</h2><p><img src="https://s1.ax1x.com/2020/10/06/0NlXuD.png" srcset="/blog/img/loading.gif" alt="0NlXuD.png"></p><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>View 是视图层，也就是用户界面。</p><p>前端主要由 <code>HTML</code> 和 <code>CSS</code> 来构建，为了更方便地展现 <code>ViewModel</code> 或者 <code>Model</code> 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Thymeleaf 等等，各大 MVVM 框架如 Vue.js，AngularJS，EJS 等也都有自己用来构建用户界面的内置模板语言。</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。</p><p>这里的难点主要在于需要和前端约定统一的 <code>接口规则</code>。</p><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p><p>需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的</p><ul><li>比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示）</li><li>页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互）</li></ul><p>视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层`。由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图。</p><blockquote><p>MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，真正实现 <code>事件驱动编程</code>。</p></blockquote><blockquote><p>View 层展现的不是 <code>Model</code> 层的数据，而是 <code>ViewModel</code> 的数据，由 <code>ViewModel</code> 负责与 <code>Model</code> 层交互，这就<strong>完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</strong></p></blockquote><h2 id="4-为什么要使用MVVM"><a href="#4-为什么要使用MVVM" class="headerlink" title="4 为什么要使用MVVM"></a>4 为什么要使用MVVM</h2><p>MVVM 模式和 MVC 模式一样，主要目的是<code>分离视图（View）和模型（Model）</code>，有几大好处</p><ul><li><strong>低耦合</strong>： 视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li><li><strong>可复用</strong>： 你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 View 重用这段视图逻辑。</li><li><strong>独立开发</strong>： 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li><li><strong>可测试</strong>： 界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li></ul><h2 id="5-MVVM框架"><a href="#5-MVVM框架" class="headerlink" title="5 MVVM框架"></a>5 MVVM框架</h2><p>当下流行的 MVVM 框架有:</p><ul><li><code>Vue.js</code></li><li><code>AngularJS</code></li><li>……</li></ul><h1 id="五、Vue-是-MVVM-模式的实现者"><a href="#五、Vue-是-MVVM-模式的实现者" class="headerlink" title="五、Vue 是 MVVM 模式的实现者"></a>五、Vue 是 MVVM 模式的实现者</h1><p><img src="https://s1.ax1x.com/2020/10/06/0NlXuD.png" srcset="/blog/img/loading.gif" alt="0NlXuD.png"></p><ul><li><code>Model</code> : 模型层，在这里表示JavaScript对象</li><li><code>View</code> : 视图层,在这里表示DOM (HTML操作的元素)</li><li><code>ViewModel</code> : 连接视图和数据的中间件，Vue.js就是MVVM中的ViewModel层的实现者在MVVM架构中，是不允许数据和视图直接通信的，只能通过ViewModel来通信，而ViewModel就是定义了一个Observer观察者<ul><li><code>ViewModel</code> 能够观察到数据的变化，并对视图对应的内容进行更新</li><li><code>ViewModel</code> 能够监听到视图的变化，并能够通知数据发生改变</li></ul></li></ul><blockquote><p>Vue.js 就是一个MVVM的实现者，他的核心就是实现了<strong>DOM监听</strong>与<strong>数据绑定</strong>。</p></blockquote><h1 id="六、为什么要使用-Vue-js"><a href="#六、为什么要使用-Vue-js" class="headerlink" title="六、为什么要使用 Vue.js"></a>六、为什么要使用 Vue.js</h1><ul><li>轻量级，体积小是一个重要指标。Vue.js 压缩后有只有 20多kb （Angular 压缩后 56kb+，React 压缩后 44kb+）</li><li>移动优先。更适合移动端，比如移动端的 Touch 事件</li><li>易上手，学习曲线平稳，文档齐全</li><li>吸取了 Angular（模块化）和 React（虚拟 DOM）的长处，并拥有自己独特的功能，如：计算属性</li><li>开源，社区活跃度高</li><li>…</li></ul><h1 id="七、第一个Vue程序"><a href="#七、第一个Vue程序" class="headerlink" title="七、第一个Vue程序"></a>七、第一个Vue程序</h1><h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h2><ul><li>IDEA 可以安装 Vue 的插件！</li></ul><blockquote><p>注意：Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。</p></blockquote><h2 id="2-下载"><a href="#2-下载" class="headerlink" title="2 下载"></a>2 下载</h2><ul><li><p>开发版本</p><ul><li>包含完整的警告和调试模式：<a href="https://vuejs.org/js/vue.js" target="_blank" rel="noopener">https://vuejs.org/js/vue.js</a></li><li>删除了警告，30.96KB min + gzip：<a href="https://vuejs.org/js/vue.min.js" target="_blank" rel="noopener">https://vuejs.org/js/vue.min.js</a></li></ul></li><li><p>CDN</p><ul><li><pre><code class="js">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>&lt;!--￼<span class="number">0</span>--&gt;</code></pre></li></ul></li></ul><h2 id="3-实例-demo"><a href="#3-实例-demo" class="headerlink" title="3 实例 demo"></a>3 实例 demo</h2><ul><li>Vue.js 就是一个MVVM的实现者，他的核心就是实现了<strong>DOM监听</strong>与<strong>数据绑定</strong>。</li></ul><p>1、新建一个HTML文件</p><p>2、导入Vue.js</p><pre><code class="hljs js">&lt;script src=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><p>3、创建一个Yue对象实例</p><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({        el: <span class="hljs-string">"#app"</span>,        <span class="hljs-comment">// Model: 数据</span>        data: {            message: <span class="hljs-string">"Hello, Vue!"</span>        },    });&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><blockquote><ul><li><code>el:"#app"</code>：绑定元素的 ID</li><li><code>data:{message: "Hello,Vue!"}</code>：数据对象中有一个名为 message 的属性，并设置了初始值”Hello,Vue!”</li></ul></blockquote><p>4、将实例绑定到页面元素</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span> {{message}} <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>只需要在绑定的元素中使用 <code>双{}</code> 将 <code>Vue</code> 创建的名为 <code>message</code>属性包裹起来，即可实现数据绑定功能，也就实现了 ViewModel 层所需的效果，是不是和 EL 表达式非常像？</p><p>5、完整代码</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span> {{message}} <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span><span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>            data: {<span class="actionscript">                message: <span class="hljs-string">"Hello, Vue!"</span></span>            },        });    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>6、viewModel双向绑定</p><p>为了能够更直观的体验 Vue 带来的双向绑定，可以直接在浏览器控制台演示一下：</p><p><img src="https://s1.ax1x.com/2020/10/06/0UeB9O.png" srcset="/blog/img/loading.gif" alt="0UeB9O.png"></p><blockquote><p>此时就可以在控制台直接输入 <code>vm.message</code> 来修改值，中间是可以省略 <code>data</code> 的，在这个操作中，并没有主动操作 <code>DOM</code>，就让页面的内容发生了变化，这就是借助了 Vue 的 数据绑定 功能实现的。</p><p><code>MVVM</code> 模式中要求 <code>ViewModel</code> 层就是使用 <code>观察者模式</code> 来实现数据的监听与绑定，以做到数据与视图的快速响应。</p></blockquote><h1 id="八、基础语法-amp-用法"><a href="#八、基础语法-amp-用法" class="headerlink" title="八、基础语法 &amp; 用法"></a>八、基础语法 &amp; 用法</h1><ul><li><p>现在数据和DOM已经被建立了关联，所有的东西都是响应式的。</p></li><li><p>我们在控制台操作对象的属性，界面可以实时更新。</p></li></ul><h2 id="1-v-bind-绑定数据和元素属性"><a href="#1-v-bind-绑定数据和元素属性" class="headerlink" title="1. v-bind 绑定数据和元素属性"></a>1. v-bind 绑定数据和元素属性</h2><p> 我们可以使用<code>v-bind</code>来 <strong>绑定数据和元素属性</strong>！</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"message"</span>&gt;</span>          鼠标悬停几秒钟查看此处动态绑定的提示信息！        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span><span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>            data: {<span class="actionscript">                message: <span class="hljs-string">"Hello, Vue!"</span></span>            },        });    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>控制台：</p><pre><code class="hljs js">vm.message=<span class="hljs-string">"wonderful U"</span></code></pre><h2 id="2-v-if-amp-v-else-条件渲染"><a href="#2-v-if-amp-v-else-条件渲染" class="headerlink" title="2. v-if &amp; v-else 条件渲染"></a>2. v-if &amp; v-else 条件渲染</h2><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- &lt;h1 v-if="ok"&gt;Yes&lt;/h1&gt;</span><span class="hljs-comment">        &lt;h1 v-else=&gt;No&lt;/h1&gt; --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"type=='A'"</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"type=='B'"</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"type=='D'"</span>&gt;</span>D<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span><span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>            data: {<span class="actionscript">                <span class="hljs-comment">// ok: true,</span></span><span class="actionscript">                type: <span class="hljs-string">'A'</span>,</span>            },        });    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>控制台：</p><pre><code class="hljs js">vm.type=<span class="hljs-number">1</span>vm.type=<span class="hljs-string">'D'</span>vm.type=<span class="hljs-string">'E'</span>vm.type=<span class="hljs-string">'A'</span></code></pre><h2 id="3-v-for-列表渲染"><a href="#3-v-for-列表渲染" class="headerlink" title="3. v-for 列表渲染"></a>3. v-for 列表渲染</h2><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><span class="hljs-comment"> * @Author: your name</span><span class="hljs-comment"> * @Date: 2020-10-06 16:48:08</span><span class="hljs-comment"> * @LastEditTime: 2020-10-06 22:52:08</span><span class="hljs-comment"> * @LastEditors: Please set LastEditors</span><span class="hljs-comment"> * @Description: In User Settings Edit</span><span class="hljs-comment"> * @FilePath: \Vue\chapter-1\demo1.html</span><span class="hljs-comment">--&gt;</span><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- v-for="数组元素 in 源数据数组" --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in items"</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 通过遍历变量来访问 --&gt;</span>            {{item.message}} - {{index}}        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span><span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>            data: {                items: [<span class="actionscript">                    {message: <span class="hljs-string">'Melody'</span>},</span><span class="actionscript">                    {message: <span class="hljs-string">'Jerry'</span>},</span>                ]            },        });    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><blockquote><p>其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的<strong>别名</strong>。</p></blockquote><h2 id="4-v-on-绑定事件"><a href="#4-v-on-绑定事件" class="headerlink" title="4. v-on 绑定事件"></a>4. v-on 绑定事件</h2><ul><li>可以用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</li></ul><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"sayHi"</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The button above has been clicked {{counter}} times.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span><span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>            data: {                counter: 0,<span class="actionscript">                message: <span class="hljs-string">"你点我干啥呢？我叫你点，你就点啊？"</span>,</span>            },<span class="actionscript">            methods: {  <span class="hljs-comment">//方法必须定义在Vue的methods对象中, v-on绑定事件</span></span><span class="actionscript">                sayHi: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event)</span> </span>{</span><span class="actionscript">                    <span class="hljs-comment">// 这个this指的是当前的Vue实例对象</span></span><span class="actionscript">                    <span class="hljs-keyword">this</span>.counter += <span class="hljs-number">1</span>,</span><span class="actionscript">                    alert(<span class="hljs-keyword">this</span>.message)</span>                }            },        });    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><blockquote><p>事件有<code>Vue</code>的事件、和前端页面本身的一些事件！</p><p>这里的<code>click</code>是vue的事件，可以绑定到Vue中的<code>methods</code>中的方法事件！</p><p><a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/events.html</a></p></blockquote><h2 id="5-v-model-Vue双向绑定"><a href="#5-v-model-Vue双向绑定" class="headerlink" title="5. v-model Vue双向绑定"></a>5. v-model Vue双向绑定</h2><h3 id="5-1-什么是双向绑定"><a href="#5-1-什么是双向绑定" class="headerlink" title="5.1 什么是双向绑定"></a>5.1 什么是双向绑定</h3><p><code>Vue.js</code>是一个<code>MVVM</code>框架，即<strong>数据双向绑定</strong>，即：</p><ul><li><p>当数据发生变化的时候，视图也就发生变化，</p></li><li><p><strong>当视图发生变化的时候，数据也会跟着同步变化。</strong></p><p><em>这也算是Vue.js的精髓之处了。</em></p></li></ul><blockquote><p>值得注意的是，<strong>我们所说的数据双向绑定，一定是对于UI控件来说的，非UI控件不会涉及到数据双向绑定。</strong></p></blockquote><blockquote><p>单向数据绑定是使用状态管理工具的前提。</p></blockquote><blockquote><p>如果我们使用vuex，那么数据流也是单项的，这时就会和双向数据绑定有冲突。</p></blockquote><h3 id="5-2-为什么要实现数据的双向绑定"><a href="#5-2-为什么要实现数据的双向绑定" class="headerlink" title="5.2 为什么要实现数据的双向绑定"></a>5.2 为什么要实现数据的双向绑定</h3><p>在Vue.js 中，如果使用vuex ，实际上数据还是单向的，之所以说是数据双向绑定，这是用的UI控件来说，对于我们处理表单，Vue.js的双向数据绑定用起来就特别舒服了。</p><ul><li>即两者并不互斥，在全局性数据流使用单项，方便跟踪；</li><li>局部性数据流使用双向，简单易操作。</li></ul><h3 id="5-3-在表单中使用双向数据绑定"><a href="#5-3-在表单中使用双向数据绑定" class="headerlink" title="5.3 在表单中使用双向数据绑定"></a>5.3 在表单中使用双向数据绑定</h3><ul><li>你可以用<code>v-model</code>指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及<code>&lt;select&gt;</code> 元素上创建双向数据绑定。</li></ul><p>它会根据控件类型自动选取正确的方法来更新元素。</p><p>尽管有些神奇，但<code>v-model</code>本质上不过是<code>语法糖</code>。</p><p>它<strong>负责监听户的输入事件以更新数据</strong>，并<strong>对一些极端场景进行一些特殊处理</strong>。</p><blockquote><p>注意：<code>v-model</code>会忽略所有元素的<code>value</code>、<code>checked</code>、<code>selected</code>特性的初始值而总是将Vue实例的数据作为数据来源，<strong>你应该通过<code>JavaScript</code>在组件的<code>data</code>选项中声明。</strong></p></blockquote><h3 id="5-4-文本域"><a href="#5-4-文本域" class="headerlink" title="5.4 文本域"></a>5.4 文本域</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>            输入的文本：<span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>            双向数据绑定： {{message}}    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span><span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>            data: {<span class="actionscript">                message: <span class="hljs-string">"初始文本"</span>,</span>            },        });    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="5-5-单选框"><a href="#5-5-单选框" class="headerlink" title="5.5 单选框"></a>5.5 单选框</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        性别：            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">" 男"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"MelodyJerry"</span>&gt;</span> 男            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">" 女"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"MelodyJerry"</span>&gt;</span> 女            <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>            MelodyJerry.sex：{{MelodyJerry}}        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span><span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>            data: {<span class="actionscript">                MelodyJerry: <span class="hljs-string">''</span>,</span>            },        });    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="5-6-下拉框"><a href="#5-6-下拉框" class="headerlink" title="5.6 下拉框"></a>5.6 下拉框</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        下拉框：        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"selected"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span> <span class="hljs-attr">disabled</span>&gt;</span>--请选择--<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>D<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>        选中的值： {{selected}}    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span><span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>            data: {<span class="actionscript">                selected: <span class="hljs-string">''</span>,</span>            },        });    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><blockquote><p><strong>注意</strong>：如果 <code>v-model</code> 表达式的初始值未能匹配任何选项， 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项：<code>value="" disabled</code>。</p></blockquote><h3 id="5-7-复选框"><a href="#5-7-复选框" class="headerlink" title="5.7 复选框"></a>5.7 复选框</h3><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    单复选框：    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"checked"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>    选中的值： {{checked}}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-comment">//viewModel 实现与Model双向绑定，动态更新视图数据</span></span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span><span class="actionscript">            <span class="hljs-comment">// Model: 数据</span></span>            data: {<span class="actionscript">                checked : <span class="hljs-literal">false</span>,</span>            },        });    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h1 id="九、Vue组件"><a href="#九、Vue组件" class="headerlink" title="九、Vue组件"></a>九、Vue组件</h1><blockquote><ul><li><a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">组件基础</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-registration.html" target="_blank" rel="noopener">深入了解组件</a></li></ul></blockquote><h2 id="1-什么是组件"><a href="#1-什么是组件" class="headerlink" title="1. 什么是组件"></a>1. 什么是组件</h2><ul><li>组件是可复用的<code>Vue</code>实例，说白了就是一组可以重复使用的模板，跟JSTL的自定义标签、Thymeleaf的<code>th:fragment</code> 等框架有着异曲同工之妙。</li></ul><p>通常一个应用会以<code>一棵嵌套的组件树</code>的形式来组织：</p><p><img src="https://s1.ax1x.com/2020/10/07/0dyw0e.png" srcset="/blog/img/loading.gif" alt="0dyw0e.png"></p><blockquote><p>例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。</p><p>为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。</p><p>这里有两种组件的注册类型：</p><ul><li><strong>全局注册</strong></li><li><strong>局部注册</strong></li></ul><p>至此，我们的组件都只是通过 <code>Vue.component</code> 全局注册的：</p><pre><code class="hljs js">Vue.component(<span class="hljs-string">'my-component-name'</span>, {  <span class="hljs-comment">// ... options ...</span>})</code></pre><p>全局注册的组件可以用在其被注册之后的任何 (通过 <code>new Vue</code>) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。</p><p>到目前为止，关于组件注册你需要了解的就这些了，如果你阅读完本页内容并掌握了它的内容，我们会推荐你再回来把<a href="https://cn.vuejs.org/v2/guide/components-registration.html" target="_blank" rel="noopener">组件注册</a>读完。</p></blockquote><h2 id="2-第一个vue组件"><a href="#2-第一个vue组件" class="headerlink" title="2. 第一个vue组件"></a>2. 第一个vue组件</h2><ul><li><em>先注册组件</em>，定义一个Vue组件component<ul><li><code>Vue.component()</code>：注册组件</li><li><code>my-component-name</code>：自定义组件的名字</li><li><code>template</code>：组件的模板</li></ul></li><li><em>再实例化 Vue</em></li></ul><blockquote><p><code>组件名必须全小写</code>，一旦有大写，就会注册错误</p></blockquote><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- &lt;li&gt; Hello, MelodyJerry! &lt;/li&gt; --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">melodyjerry</span>&gt;</span> Hello, MelodyJerry! <span class="hljs-tag">&lt;/<span class="hljs-name">melodyjerry</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-comment">//先注册组件，定义一个Vue组件component</span></span><span class="actionscript">        Vue.component(<span class="hljs-string">"melodyjerry"</span>,{ <span class="hljs-comment">//组件名必须全小写，一旦有大写，就会注册错误</span></span><span class="handlebars"><span class="xml">            template: '<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span> This is a Vue-Component. <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>'</span></span>        });<span class="actionscript">        <span class="hljs-comment">//再实例化Vue</span></span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>        });    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="3-prop-传递参数"><a href="#3-prop-传递参数" class="headerlink" title="3. prop 传递参数"></a>3. prop 传递参数</h2><blockquote><p><strong>注意</strong>：默认规则下 <code>props</code> 属性里的值不能为大写。</p></blockquote><ul><li><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-的大小写-camelCase-vs-kebab-case" target="_blank" rel="noopener">Prop 的大小写</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-类型" target="_blank" rel="noopener">Prop 类型</a></li><li>传递静态或动态 Prop<ul><li><a href="https://cn.vuejs.org/v2/guide/components-props.html#传入一个数字" target="_blank" rel="noopener">传入一个数字</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-props.html#传入一个布尔值" target="_blank" rel="noopener">传入一个布尔值</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-props.html#传入一个数组" target="_blank" rel="noopener">传入一个数组</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-props.html#传入一个对象" target="_blank" rel="noopener">传入一个对象</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-props.html#传入一个对象的所有-property" target="_blank" rel="noopener">传入一个对象的所有 property</a></li></ul></li><li><a href="https://cn.vuejs.org/v2/guide/components-props.html#单向数据流" target="_blank" rel="noopener">单向数据流</a></li><li>Prop 验证<ul><li><a href="https://cn.vuejs.org/v2/guide/components-props.html#类型检查" target="_blank" rel="noopener">类型检查</a></li></ul></li><li>非 Prop 的 Attribute<ul><li><a href="https://cn.vuejs.org/v2/guide/components-props.html#替换-合并已有的-Attribute" target="_blank" rel="noopener">替换/合并已有的 Attribute</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-props.html#禁用-Attribute-继承" target="_blank" rel="noopener">禁用 Attribute 继承</a></li></ul></li></ul><blockquote><p>参考：<a href="https://www.cnblogs.com/360minitao/p/11850269.html" target="_blank" rel="noopener">博客园</a>、<a href="https://cn.vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">官方文档</a></p></blockquote><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- &lt;li&gt; Hello, MelodyJerry! &lt;/li&gt; --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">melodyjerry</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">v-bind:prop</span>=<span class="hljs-string">"item"</span>&gt;</span> Hello, MelodyJerry! <span class="hljs-tag">&lt;/<span class="hljs-name">melodyjerry</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-comment">//先注册组件，定义一个Vue组件component</span></span><span class="actionscript">        Vue.component(<span class="hljs-string">"melodyjerry"</span>,{ <span class="hljs-comment">//组件名必须全小写，一旦有大写，就会注册错误</span></span><span class="actionscript">            <span class="hljs-comment">//prop:传递参数</span></span><span class="actionscript">            props: [<span class="hljs-string">'prop'</span>],  <span class="hljs-comment">//通过循环的遍历prop，v-bind:prop绑定属性，此属性‘prop’作为媒介，传递给模板</span></span><span class="actionscript">            <span class="hljs-comment">//组件的模板</span></span><span class="handlebars"><span class="xml">            template: '<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span> </span><span class="hljs-template-variable">{{prop}}</span><span class="xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>'</span></span>        }); <span class="actionscript">        <span class="hljs-comment">//再实例化Vue</span></span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>            data: {<span class="actionscript">                items: [<span class="hljs-string">"Java"</span>, <span class="hljs-string">"Python"</span>, <span class="hljs-string">"Vue"</span>]</span>            },        });    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h1 id="十、Axios异步通信"><a href="#十、Axios异步通信" class="headerlink" title="十、Axios异步通信"></a>十、Axios异步通信</h1><h2 id="1-什么是Axios"><a href="#1-什么是Axios" class="headerlink" title="1. 什么是Axios"></a>1. 什么是Axios</h2><p>Axios 是一个开源的可以用在浏览器端和 <code>NodeJS</code> 的异步通信框架，她的主要作用就是实现 AJAX 异步通信，其功能特点如下：</p><ul><li>从浏览器中创建 <code>XMLHttpRequests</code></li><li>从 node.js 创建 http 请求</li><li>支持 Promise API [JS中链式编程]</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF（跨站请求伪造）</li></ul><blockquote><p>GitHub：<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p></blockquote><blockquote><p>中文文档：<a href="http://www.axios-js.com/" target="_blank" rel="noopener">http://www.axios-js.com/</a></p></blockquote><h2 id="2-为什么要使用Axios"><a href="#2-为什么要使用Axios" class="headerlink" title="2. 为什么要使用Axios"></a>2. 为什么要使用Axios</h2><p>由于<code>Vue.js</code>是一个<strong>视图层框架</strong>且作者(尤雨溪) 严格准守<code>SoC (关注度分离原则)</code>，所以<code>Vue.js</code>并不包含Ajax的通信功能，为了解决通信问题，作者单独开发了一个名为<code>vue-resource</code>的插件，不过在进入2.0 版本以后停止了对该插件的维护并推荐了<code>Axios</code> 框架。少用<code>jQuery</code>，因为它操作<code>Dom</code>太频繁 !</p><h2 id="3-导入Axios"><a href="#3-导入Axios" class="headerlink" title="3. 导入Axios"></a>3. 导入Axios</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h2 id="4-实例-demo"><a href="#4-实例-demo" class="headerlink" title="4. 实例 demo"></a>4. 实例 demo</h2><p>咱们开发的接口大部分都是采用 JSON 格式，可以先在项目里模拟一段 JSON 数据，数据内容如下：创建一个名为 <code>data.json</code> 的文件并填入上面的内容，放在项目的根目录下。</p><pre><code class="hljs json">{    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"MelodyJerry"</span>,    <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://melodyhub.ltd/"</span>,    <span class="hljs-attr">"page"</span>: <span class="hljs-number">1</span>,    <span class="hljs-attr">"isNonProfit"</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">"address"</span>: {      <span class="hljs-attr">"street"</span>: <span class="hljs-string">"广州"</span>,      <span class="hljs-attr">"city"</span>: <span class="hljs-string">"广东"</span>,      <span class="hljs-attr">"country"</span>: <span class="hljs-string">"中国"</span>    },    <span class="hljs-attr">"links"</span>: [      {        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"博客园"</span>,        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://www.cnblogs.com/melodyjerry/"</span>      },      {        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"GitHub"</span>,        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"melodyhub.ltd"</span>      },      {        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Gitee"</span>,        <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://melodyjerry.gitee.io/"</span>      }    ]  }</code></pre><p>新建一个demo.html，来试试<code>Axios</code>的异步通信：</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-comment">&lt;!--v-clock 解决闪烁问题--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">        <span class="hljs-selector-attr">[v-clock]</span> {</span>            display: none;        }    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"vue"</span> <span class="hljs-attr">v-clock</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>名称：{{info.name}} <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>地址：{{info.address.country}}-{{info.address.city}}-{{info.address.street}} <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>博客：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">"info.url"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span>{{info.url}}<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!--导入axios--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.bootcdn.net/ajax/libs/axios/0.19.2/axios.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#vue"</span>,</span>            data: {<span class="actionscript">                items: [<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>,<span class="hljs-string">'Php'</span>]</span>            },<span class="actionscript">            <span class="hljs-comment">//data   : vm的属性</span></span><span class="actionscript">            <span class="hljs-comment">//data() : vm方法</span></span>            data(){<span class="actionscript">                <span class="hljs-keyword">return</span>{</span><span class="actionscript">                    <span class="hljs-comment">//请求的返回参数,必须和json字符串一样</span></span>                   info:{<span class="actionscript">                       name: <span class="hljs-literal">null</span>,</span><span class="actionscript">                       url: <span class="hljs-literal">null</span>,</span>                       address: {<span class="actionscript">                           street: <span class="hljs-literal">null</span>,</span><span class="actionscript">                           city: <span class="hljs-literal">null</span>,</span><span class="actionscript">                           country: <span class="hljs-literal">null</span></span>                       }                   }                }            },<span class="actionscript">            <span class="hljs-comment">//钩子函数，链式编程，ES6新特性</span></span>            mounted(){<span class="javascript">                axios.get(<span class="hljs-string">"../data.json"</span>).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> (<span class="hljs-keyword">this</span>.info = response.data))</span><span class="javascript">                axios.get(<span class="hljs-string">"../data.json"</span>).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> (<span class="hljs-built_in">console</span>.log(response.data)))</span>            }        })    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><blockquote><ul><li><p><code>data</code>   : vm的属性</p></li><li><p><code>data()</code> : vm方法</p><ul><li><code>return{}</code> : 请求的返回参数,必须和json字符串一样</li></ul></li><li><p><code>mounted(){}</code> :  钩子函数，链式编程，ES6新特性</p></li></ul></blockquote><blockquote><p>说明:</p><ol><li>在这里使用了 <code>v-bind</code> 将 <code>a:href</code> 的属性值<strong>与 Vue 实例中的数据进行绑定</strong></li><li>使用 Axios 框架的 get 方法请求 <code>AJAX</code> 并<strong>自动将数据封装进了 Vue 实例的数据对象中</strong></li><li>我们在data中的数据结构必须要和<code>Ajax</code>响应回来的<strong>数据格式匹配</strong>！</li><li>关于代码中的<code>v-clock 解决闪烁问题</code>，可参考 <a href="https://www.cnblogs.com/melodyjerry/p/13781358.html" target="_blank" rel="noopener">Vue指令：v-clock解决页面闪烁问题</a></li></ol></blockquote><h1 id="十一、计算属性"><a href="#十一、计算属性" class="headerlink" title="十一、计算属性"></a>十一、计算属性</h1><h2 id="1-什么是计算属性"><a href="#1-什么是计算属性" class="headerlink" title="1. 什么是计算属性"></a>1. 什么是计算属性</h2><ul><li>计算属性的重点突出在 <code>属性</code> 两个字上（属性是名词），首先它是个 <code>属性</code> 其次这个属性有 <code>计算</code>的能力（计算是动词），这里的 <code>计算</code> 就是个函数；</li><li>简单点说，它就是<strong>一个能够将计算结果缓存起来的属性（将行为转化成了静态的属性）</strong>，仅此而已；可以想象为缓存！</li></ul><h2 id="2-实例-demo"><a href="#2-实例-demo" class="headerlink" title="2. 实例 demo"></a>2. 实例 demo</h2><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- view层 模板 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 调用methods里的方法,得用() --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>currentTime1: {{currentTime1()}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 调用计算属性computed的方法,不能用() --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>currentTime2: {{currentTime2}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({</span><span class="actionscript">            el: <span class="hljs-string">"#app"</span>,</span>            data: {<span class="actionscript">                message: <span class="hljs-string">"hello,melodyjerry."</span></span>            },            methods: {<span class="actionscript">                currentTime1: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</span><span class="javascript">                    <span class="hljs-keyword">var</span> Xmas95 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"December 25, 1995 23:15:30"</span>);</span><span class="actionscript">                    <span class="hljs-keyword">return</span> Xmas95.getDay(); <span class="hljs-comment">//1;返回数值代表星期几：0代表星期日,1代表星期一,2代表星期二</span></span>                },            },<span class="actionscript">            <span class="hljs-comment">//计算属性</span></span><span class="actionscript">            computed: { <span class="hljs-comment">//methods、computed中的方法名不能重名;重名后，只会调用methods中的方法</span></span><span class="actionscript">                currentTime2: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</span><span class="actionscript">                <span class="hljs-comment">//currentTime1: function() {</span></span><span class="javascript">                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">//返回一个时间戳</span></span>                },            },        })    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><blockquote><p>说明：以下为自己学习时发现的<a href="https://www.cnblogs.com/melodyjerry/p/13782663.html" target="_blank" rel="noopener">踩坑记录</a>，不一定正确！！！</p><ul><li>调用<code>methods</code>里的方法,<code>得用()</code><ul><li><code>methods</code>是<code>方法</code></li></ul></li><li>调用<code>computed</code>的方法,<code>不能用()</code><ul><li><code>computed</code>是<code>计算属性</code>，是<code>属性</code></li></ul></li><li><code>methods</code>、<code>computed</code>中的方法名<code>不能重名</code>;重名后，<code>只会调用methods</code>中的方法</li></ul></blockquote><h2 id="3-进阶"><a href="#3-进阶" class="headerlink" title="3. 进阶"></a>3. 进阶</h2><p><code>currentTime2</code>里加个<code>this.message;</code>试试：</p><pre><code class="hljs js"><span class="hljs-comment">//计算属性</span>computed: { <span class="hljs-comment">//methods、computed中的方法名不能重名;重名后，只会调用methods中的方法</span>    currentTime2: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{    <span class="hljs-comment">//currentTime1: function() {</span>        <span class="hljs-keyword">this</span>.message;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">//返回一个时间戳</span>    },},</code></pre><p>到控制台里分别试试：</p><p><img src="https://s1.ax1x.com/2020/10/08/00j2KP.png" srcset="/blog/img/loading.gif" alt="00j2KP.png"></p><h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h2><p><code>调用方法时，每次都需要进行计算</code>，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢？</p><ul><li>此时就可以考虑<code>将这个结果缓存起来</code>，采用计算属性可以很方便的做到这一点，<strong>计算属性的<code>主要特性就是为了将不经常变化的计算结果进行缓存</code>，以节约我们的系统开销。</strong></li></ul><h1 id="十二、插槽slot：内容分发"><a href="#十二、插槽slot：内容分发" class="headerlink" title="十二、插槽slot：内容分发"></a>十二、插槽slot：内容分发</h1><blockquote><p>文档：<a href="https://cn.vuejs.org/v2/guide/components-slots.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/components-slots.html</a></p></blockquote><h2 id="1-什么是插槽"><a href="#1-什么是插槽" class="headerlink" title="1. 什么是插槽"></a>1. 什么是插槽</h2><p>Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="noopener">Web Components 规范草案</a>，将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口。</p><p>它允许你像这样合成组件：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/profile"</span>&gt;</span>  Your Profile<span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span></code></pre><p>然后你在 <code>&lt;navigation-link&gt;</code> 的模板中可能会写为：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span></span><span class="hljs-tag">  <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">"url"</span></span><span class="hljs-tag">  <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-link"</span></span><span class="hljs-tag">&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>当组件渲染的时候，<code>&lt;slot&gt;&lt;/slot&gt;</code> 将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/profile"</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 添加一个 Font Awesome 图标 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-user"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  Your Profile<span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span></code></pre><p>甚至其它的组件：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"/profile"</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 添加一个图标的组件 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">font-awesome-icon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">font-awesome-icon</span>&gt;</span>  Your Profile<span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span></code></pre><p>如果 <code>&lt;navigation-link&gt;</code> 的 <code>template</code> 中<strong>没有</strong>包含一个 <code>&lt;slot&gt;</code> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。</p><h2 id="2-内容分发"><a href="#2-内容分发" class="headerlink" title="2. 内容分发"></a>2. 内容分发</h2><p>在 <code>Vue.js</code> 中我们使用 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口，作者称其为 插槽，可以应用在组合组件的场景中。</p><h2 id="3-实例-demo-1"><a href="#3-实例-demo-1" class="headerlink" title="3. 实例 demo"></a>3. 实例 demo</h2><ul><li>需求</li></ul><p>比如准备制作一个待办事项组件（todo），该组件由待办标题（todo-title）和待办内容（todo-items）组成，但这三个组件又是相互独立的，该如何操作呢？</p><ul><li>第一步: 定义一个待办事项的组件</li></ul><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 组件：todo --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>"&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">todo</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">todo</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>              <span class="hljs-comment">&lt;!-- 1.导入Vue.js --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    Vue.component(<span class="hljs-string">'todo'</span>, {</span><span class="handlebars"><span class="xml">        template: '<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>待办事项<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Linux<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml">                   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>'</span></span>    });<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><ul><li>第二步: 我们需要让,待办事项的标题和值实现动态绑定,怎么做呢? 我们可以留出一个插槽!</li></ul><ol><li>将上面的代码留出一个插槽,即<code>&lt;slot&gt;</code>：</li></ol><pre><code class="hljs html">Vue.component('todo', {    template: '<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\                    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"todo-title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>\                    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\                        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"todo-items"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>\                    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\               <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>'});</code></pre><ol start="2"><li>定义一个名为 <code>todo-title</code> 的待办标题组件 和 <code>todo-items</code> 的待办内容组件：</li></ol><pre><code class="hljs js">Vue.component(<span class="hljs-string">'todo-title'</span>, {    props: [<span class="hljs-string">'title'</span>],    template: <span class="hljs-string">'&lt;div&gt;{{title}}&lt;/div&gt;'</span>});Vue.component(<span class="hljs-string">'todo-items'</span>, {    <span class="hljs-comment">//这里的index,就是数组的下标,使用for循环遍历的时候,可以循环出来!</span>    props: [<span class="hljs-string">'index'</span>, <span class="hljs-string">'item'</span>],    template: <span class="hljs-string">'&lt;li&gt;{{index + 1}}. {{item}}&lt;/li&gt;'</span>,});</code></pre><ol start="3"><li>实例化 Vue 并初始化数据：</li></ol><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({    el: <span class="hljs-string">'#app'</span>,    data: {        todoTitle: <span class="hljs-string">'Jerry学JavaWeb'</span>,        todoItems: [<span class="hljs-string">'Linux'</span>, <span class="hljs-string">'Spring Boot'</span>, <span class="hljs-string">'Vue'</span>],    }});</code></pre><ol start="4"><li>将这些值，通过插槽插入：</li></ol><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 组件：todo --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>"&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">todo</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">todo-title</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"todo-title"</span> </span><span class="hljs-tag">            <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"todoTitle"</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">todo-title</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">todo-items</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"todo-items"</span> </span><span class="hljs-tag">            <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in todoItems"</span> </span><span class="hljs-tag">            <span class="hljs-attr">v-bind:item</span>=<span class="hljs-string">"item"</span> </span><span class="hljs-tag">            <span class="hljs-attr">v-bind:index</span>=<span class="hljs-string">"index"</span><span class="hljs-attr">:key</span>=<span class="hljs-string">"index"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">todo-items</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">todo-items</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">todo</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><blockquote><p>说明：</p><p>我们的 <code>todo-title</code> 和 <code>todo-items</code> 组件分别被分发到了 <code>todo</code> 组件的 <code>todo-title</code> 和 <code>todo-items</code> 插槽中。</p></blockquote><h1 id="十三、自定义事件"><a href="#十三、自定义事件" class="headerlink" title="十三、自定义事件"></a>十三、自定义事件</h1><h1 id="十一、Vue生命周期"><a href="#十一、Vue生命周期" class="headerlink" title="十一、Vue生命周期"></a>十一、Vue生命周期</h1><blockquote><p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">官方文档</a>：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA</a></p><p><a href="https://segmentfault.com/a/1190000020173042" target="_blank" rel="noopener">参考文章</a>：<a href="https://segmentfault.com/a/1190000020173042" target="_blank" rel="noopener">①</a>、<a href="https://blog.csdn.net/qq_15766181/article/details/73549933" target="_blank" rel="noopener">②</a>、<a href="https://blog.csdn.net/Meuan/article/details/104765843" target="_blank" rel="noopener">③带注释</a></p></blockquote><p>​    Vue 实例有一个完整的生命周期，也就是<code>从开始创建、初始化数据、编译模板、挂载 DOM、渲染→更新→渲染、卸载等一系列过程</code>，我们称这是 <code>Vue 的生命周期</code>。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。</p><p>​    在 Vue 的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册 JS 方法，可以让我们用自己注册的 JS 方法控制整个大局，在这些事件响应方法中的 this 直接指向的是 Vue 的实例。</p><ul><li><img src="https://s1.ax1x.com/2020/10/08/0wh48e.png" srcset="/blog/img/loading.gif" alt="0wh48e.png"></li></ul><ul><li><img src="https://s1.ax1x.com/2020/10/08/0w4Kq1.png" srcset="/blog/img/loading.gif" alt="0w4Kq1.png"></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 的核心库只关注视图层，方便与第三方库或既有项目整合。&lt;/p&gt;
&lt;p&gt;HTML + CSS + JS : 视图 ： &lt;code&gt;给用户看，刷新后台给的数据&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;网络通信 ： &lt;code&gt;axios&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;页面跳转 ： &lt;code&gt;vue-router&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;状态管理：&lt;code&gt;vuex&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Vue-UI : &lt;code&gt;ICE&lt;/code&gt;、 &lt;code&gt;Element UI&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、VUE-概述&quot;&gt;&lt;a href=&quot;#一、VUE-概述&quot; class=&quot;headerlink&quot; title=&quot;一、VUE 概述&quot;&gt;&lt;/a&gt;一、VUE 概述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Vue&lt;/code&gt;(读音&lt;code&gt;/vju/&lt;/code&gt;, 类似于view)是&lt;strong&gt;一套用于构建用户界面的渐进式框架&lt;/strong&gt;，发布于2014年2月。&lt;/p&gt;
&lt;p&gt;与其它大型框架不同的是，&lt;strong&gt;Vue被设计为可以自底向上逐层应用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vue的核心库只关注视图层&lt;/strong&gt;，不仅易于上手，还便于与第三方库(如: &lt;code&gt;vue-router&lt;/code&gt;: 跳转，&lt;code&gt;vue-resource&lt;/code&gt;: 通信，&lt;code&gt;vuex&lt;/code&gt;:管理)或既有项目整合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="笔记" scheme="https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="https://melodyjerry.github.io/blog/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://melodyjerry.github.io/blog/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>IDEA新建SpringBoot项目提示connect timed out错误</title>
    <link href="https://melodyjerry.github.io/blog/2020/10/04/IDEA%E6%90%AD%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE%E6%8F%90%E7%A4%BAconnect%20timed%20out%E9%94%99%E8%AF%AF/"/>
    <id>https://melodyjerry.github.io/blog/2020/10/04/IDEA%E6%90%AD%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE%E6%8F%90%E7%A4%BAconnect%20timed%20out%E9%94%99%E8%AF%AF/</id>
    <published>2020-10-04T06:12:11.000Z</published>
    <updated>2020-10-07T15:10:10.728Z</updated>
    
    <content type="html"><![CDATA[<p>IDEA新建的SpringBoot项目时：</p><p>无法连接到<code>http://start.spring.io</code>。</p><p><img src="https://s1.ax1x.com/2020/10/04/0GKl6A.png" srcset="/blog/img/loading.gif" alt="0GKl6A.png"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>对应不同情况，可能存在不止一种解决方法。</p><h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><p>不管是网站上的，还是IDEA里集成的，都有时会提示网络异常。</p><p>多试试几次，或者更换网络环境，我用手机开热点，就解决了。</p><p><img src="https://s1.ax1x.com/2020/10/04/0GKvjA.png" srcset="/blog/img/loading.gif" alt="0GKvjA.png"></p><h2 id="使用自动代理"><a href="#使用自动代理" class="headerlink" title="使用自动代理"></a>使用自动代理</h2><p>IDEA ==&gt; Settings ==&gt; HTTP Proxy ==&gt; Auto-detect proxy settings：</p><p><img src="https://s1.ax1x.com/2020/10/04/0GMRVP.png" srcset="/blog/img/loading.gif" alt="0GMRVP.png"></p><p>等待check connection结果，若弹出connection successful即表示连接成功，问题解决。</p><h2 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h2><p>IDEA ==&gt; New Project ==&gt; <code>Spring Initializr</code> ==&gt; <code>Custom:</code></p><p>使用阿里云提供的镜像服务：</p><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//start.aliyun.com</span></code></pre><p>更换了阿里云之后，还可以使用阿里云的组件呢！！！</p><p><img src="https://s1.ax1x.com/2020/10/04/0GK2hF.png" srcset="/blog/img/loading.gif" alt="0GK2hF.png"></p><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IDEA新建的SpringBoot项目时：&lt;/p&gt;
&lt;p&gt;无法连接到&lt;code&gt;http://start.spring.io&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/04/0GKl6A.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;0GKl6A.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;解决&quot;&gt;&lt;a href=&quot;#解决&quot; class=&quot;headerlink&quot; title=&quot;解决&quot;&gt;&lt;/a&gt;解决&lt;/h1&gt;&lt;p&gt;对应不同情况，可能存在不止一种解决方法。&lt;/p&gt;
&lt;h2 id=&quot;网络问题&quot;&gt;&lt;a href=&quot;#网络问题&quot; class=&quot;headerlink&quot; title=&quot;网络问题&quot;&gt;&lt;/a&gt;网络问题&lt;/h2&gt;&lt;p&gt;不管是网站上的，还是IDEA里集成的，都有时会提示网络异常。&lt;/p&gt;
&lt;p&gt;多试试几次，或者更换网络环境，我用手机开热点，就解决了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/04/0GKvjA.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;0GKvjA.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用自动代理&quot;&gt;&lt;a href=&quot;#使用自动代理&quot; class=&quot;headerlink&quot; title=&quot;使用自动代理&quot;&gt;&lt;/a&gt;使用自动代理&lt;/h2&gt;&lt;p&gt;IDEA ==&amp;gt; Settings ==&amp;gt; HTTP Proxy ==&amp;gt; Auto-detect proxy settings：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/04/0GMRVP.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;0GMRVP.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;等待check connection结果，若弹出connection successful即表示连接成功，问题解决。&lt;/p&gt;
&lt;h2 id=&quot;更换源&quot;&gt;&lt;a href=&quot;#更换源&quot; class=&quot;headerlink&quot; title=&quot;更换源&quot;&gt;&lt;/a&gt;更换源&lt;/h2&gt;&lt;p&gt;IDEA ==&amp;gt; New Project ==&amp;gt; &lt;code&gt;Spring Initializr&lt;/code&gt; ==&amp;gt; &lt;code&gt;Custom:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用阿里云提供的镜像服务：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs dts&quot;&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;https:&lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//start.aliyun.com&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更换了阿里云之后，还可以使用阿里云的组件呢！！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/04/0GK2hF.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;0GK2hF.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="IDEA" scheme="https://melodyjerry.github.io/blog/tags/IDEA/"/>
    
      <category term="SPringBoot" scheme="https://melodyjerry.github.io/blog/tags/SPringBoot/"/>
    
  </entry>
  
  <entry>
    <title>IDEA新建SpringBoot项目无法引入SpringApplication</title>
    <link href="https://melodyjerry.github.io/blog/2020/10/04/IDEA%E6%96%B0%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E5%BC%95%E5%85%A5SpringApplication/"/>
    <id>https://melodyjerry.github.io/blog/2020/10/04/IDEA%E6%96%B0%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E5%BC%95%E5%85%A5SpringApplication/</id>
    <published>2020-10-04T04:12:11.000Z</published>
    <updated>2020-10-07T15:10:10.722Z</updated>
    
    <content type="html"><![CDATA[<p>IDEA新建的SpringBoot项目，run时居然会报错：</p><p>无法引入<code>SpringApplication</code>。。。</p><p><img src="https://s1.ax1x.com/2020/10/04/0Gedqf.png" srcset="/blog/img/loading.gif" alt="0Gedqf.png"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>对应不同情况，可能存在不止一种解决方法。</p><h2 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h2><p>Maven存在多个版本的springBoot，可能会造成版本冲突。</p><p>在路径<code>C:\Users\name\.m2\repository\org\springframework\boot\spring-boot</code>中，删除旧版本即可。</p><p>然后Maven执行<code>clean</code>、<code>compile</code>、<code>install</code>命令。</p><blockquote><p>来源：<a href="http://m.mamicode.com/info-detail-2209550.html" target="_blank" rel="noopener">http://m.mamicode.com/info-detail-2209550.html</a></p></blockquote><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IDEA新建的SpringBoot项目，run时居然会报错：&lt;/p&gt;
&lt;p&gt;无法引入&lt;code&gt;SpringApplication&lt;/code&gt;。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/04/0Gedqf.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;0Gedqf.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;解决&quot;&gt;&lt;a href=&quot;#解决&quot; class=&quot;headerlink&quot; title=&quot;解决&quot;&gt;&lt;/a&gt;解决&lt;/h1&gt;&lt;p&gt;对应不同情况，可能存在不止一种解决方法。&lt;/p&gt;
&lt;h2 id=&quot;版本问题&quot;&gt;&lt;a href=&quot;#版本问题&quot; class=&quot;headerlink&quot; title=&quot;版本问题&quot;&gt;&lt;/a&gt;版本问题&lt;/h2&gt;&lt;p&gt;Maven存在多个版本的springBoot，可能会造成版本冲突。&lt;/p&gt;
&lt;p&gt;在路径&lt;code&gt;C:\Users\name\.m2\repository\org\springframework\boot\spring-boot&lt;/code&gt;中，删除旧版本即可。&lt;/p&gt;
&lt;p&gt;然后Maven执行&lt;code&gt;clean&lt;/code&gt;、&lt;code&gt;compile&lt;/code&gt;、&lt;code&gt;install&lt;/code&gt;命令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://m.mamicode.com/info-detail-2209550.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://m.mamicode.com/info-detail-2209550.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="IDEA" scheme="https://melodyjerry.github.io/blog/tags/IDEA/"/>
    
      <category term="SPringBoot" scheme="https://melodyjerry.github.io/blog/tags/SPringBoot/"/>
    
  </entry>
  
  <entry>
    <title>uTools,你的生产力工具集</title>
    <link href="https://melodyjerry.github.io/blog/2020/10/03/uTools%E4%BD%A0%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    <id>https://melodyjerry.github.io/blog/2020/10/03/uTools%E4%BD%A0%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E9%9B%86/</id>
    <published>2020-10-03T09:39:00.000Z</published>
    <updated>2020-10-03T10:11:16.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="uTools是什么？"><a href="#uTools是什么？" class="headerlink" title="uTools是什么？"></a>uTools是什么？</h1><center><font color="#FF2800">u</font><font color="#FF5000">T</font><font color="#FF7800">o</font><font color="#FFA000">o</font><font color="#FFC800">l</font><font color="#FFF000">s</font><font color="#D7FF00">，</font><font color="#AFFF00">你</font><font color="#87FF00">的</font><font color="#5FFF00">生</font><font color="#37FF00">产</font><font color="#0FFF00">力</font><font color="#00FF28">工</font><font color="#00FF50">具</font><font color="#00FF78">集</font></center><ul><li>极简</li><li>插件化</li><li>跨平台</li></ul><blockquote><p>官网：<a href="https://www.u.tools/" target="_blank" rel="noopener">https://www.u.tools/</a></p><p>自由集成丰富插件，快速匹配「场景功能」，用完即走 。</p></blockquote><p>通过自由选配丰富的插件，打造你得心应手的工具集合。</p><p>该软件支持Windows、Mac以及Linux使用，并且拥有丰富的插件库。</p><p>简单来讲，uTools可以作为一个<strong>程序快速启动器</strong>，使用中英文搜索并快速打开你的本地程序、文件、系统设置等。你可以使用快捷键（默认为<code>alt+space</code>）快速呼出这个搜索框，小巧却不简单。</p><p><strong>当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。</strong></p><h1 id="uTools能做什么？"><a href="#uTools能做什么？" class="headerlink" title="uTools能做什么？"></a>uTools能做什么？</h1><p>uTools作者将此软件设计为<font color="red" size="5">“一切皆插件”</font>的插件化工具，<strong>所有的功能均可通过插件实现。</strong></p><p>插件中心有很多实用高效地插件，例如：在线翻译、压缩图片、颜色小助手、开发文档、图床、OCR图片识别等等小工具，你可以选择适合自己使用场景的插件安装使用。</p><p><img src="https://s1.ax1x.com/2020/10/03/03G2r9.png" srcset="/blog/img/loading.gif" alt="03G2r9.png"></p><a id="more"></a><hr><p>接下来给大家看看MelodyJerry经常使用的一些插件👇</p><h1 id="MelodyJerry的uTools"><a href="#MelodyJerry的uTools" class="headerlink" title="MelodyJerry的uTools"></a>MelodyJerry的uTools</h1><h2 id="在线翻译"><a href="#在线翻译" class="headerlink" title="在线翻译"></a>在线翻译</h2><p>搜索框中搜索“翻译”就可以呼出在线翻译界面。简洁易用、随用随走。</p><p><img src="https://s1.ax1x.com/2020/10/03/03GzPf.png" srcset="/blog/img/loading.gif" alt="03GzPf.png"></p><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>写博客必备，搭配<a href="">Typora</a>使用，效果最佳！！！</p><p>使用非常简单：</p><ul><li>拖动图片到搜索框</li><li>复制图片，到插件页Ctrl+V</li><li>插件页的上传按钮</li></ul><p><img src="https://s1.ax1x.com/2020/10/03/03wynO.png" srcset="/blog/img/loading.gif" alt="03wynO.png"></p><p>图床支持三种返回格式：</p><ul><li>URL</li><li>MarkDown</li><li>Html</li></ul><p><img src="https://s1.ax1x.com/2020/10/03/03Jsot.png" srcset="/blog/img/loading.gif" alt="03Jsot.png"></p><p>当然，还可以选择不同的图床源。更快速的，✔自动复制，并选择MarkDown。</p><p>这样粘贴好图片，自动复制md格式的图片链接到剪切板，提升办公写作效率呢！</p><ul><li><input disabled="" type="checkbox"> 自动复制 MarkDown</li></ul><p><img src="https://s1.ax1x.com/2020/10/03/03Jooq.png" srcset="/blog/img/loading.gif" alt="03Jooq.png"></p><h2 id="图片识别"><a href="#图片识别" class="headerlink" title="图片识别"></a>图片识别</h2><p><img src="https://s1.ax1x.com/2020/10/03/03wYBF.png" srcset="/blog/img/loading.gif" alt="03wYBF.png"></p><h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><p>最常用的插件之一，可以保存所有复制过的内容。</p><ul><li>文本</li><li>文件</li><li>图片</li></ul><p><strong>不用担心uTools会泄露你的信息，所有插件的生命周期就是 <em>开机到关机。</em></strong></p><p><img src="https://s1.ax1x.com/2020/10/03/03wZnS.png" srcset="/blog/img/loading.gif" alt="03wZnS.png"></p><h2 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h2><ul><li>快速打开cmd</li></ul><p><img src="https://s1.ax1x.com/2020/10/03/03Ye0A.png" srcset="/blog/img/loading.gif" alt="03Ye0A.png"></p><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ul><li><font color="red">前端开发者的福利工具</font></li></ul><p>uTools提供了多个插件，有的是官方的，还有的是开发者们维护的。</p><p><img src="https://s1.ax1x.com/2020/10/03/03Y36g.png" srcset="/blog/img/loading.gif" alt="03Y36g.png"></p><p>MelodyJerry最常用的是<strong>“色彩助手”</strong>。</p><p>看，羡慕了吗？</p><p><img src="https://s1.ax1x.com/2020/10/03/03YIje.png" srcset="/blog/img/loading.gif" alt="03YIje.png"></p><p><img src="https://s1.ax1x.com/2020/10/03/03YLNt.png" srcset="/blog/img/loading.gif" alt="03YLNt.png"></p><p><img src="https://s1.ax1x.com/2020/10/03/03t9Bj.png" srcset="/blog/img/loading.gif" alt="03t9Bj.png"></p><h2 id="本地快速搜索"><a href="#本地快速搜索" class="headerlink" title="本地快速搜索"></a>本地快速搜索</h2><ul><li>集成Everything的内核<ul><li>干净简洁的用户界面</li><li>快速文件索引</li><li>快速搜索</li><li>最小资源使用</li><li>便于文件分享</li><li>实时更新</li><li>……</li></ul></li></ul><p><img src="https://s1.ax1x.com/2020/10/03/03ts8f.png" srcset="/blog/img/loading.gif" alt="03ts8f.png"></p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><ul><li>能够快速的将你的内网服务暴露到公网</li></ul><p><img src="https://s1.ax1x.com/2020/10/03/03NcJx.png" srcset="/blog/img/loading.gif" alt="03NcJx.png"></p><p>启动你本地服务器，如下配置你本地的ip，和随便起个外网域名。</p><p>这样你就可以外网访问你的服务了，超简单，这可比有些网站搞个内网穿透还得收钱强多了。</p><p><img src="https://s1.ax1x.com/2020/10/03/03UklT.png" srcset="/blog/img/loading.gif" alt="03UklT.png"></p><h2 id="开发小工具"><a href="#开发小工具" class="headerlink" title="开发小工具"></a>开发小工具</h2><ul><li>只展示其中一部分插件</li></ul><p><img src="https://s1.ax1x.com/2020/10/03/03U8XD.png" srcset="/blog/img/loading.gif" alt="03U8XD.png"></p><h2 id="独立文档"><a href="#独立文档" class="headerlink" title="独立文档"></a>独立文档</h2><ul><li>只展示其中一部分文档手册</li></ul><p><img src="https://s1.ax1x.com/2020/10/03/03UJne.png" srcset="/blog/img/loading.gif" alt="03UJne.png"></p><p>像MelodyJerry经常用到的是：</p><ul><li>Linux</li></ul><p><img src="https://s1.ax1x.com/2020/10/03/03Udht.png" srcset="/blog/img/loading.gif" alt="03Udht.png"></p><ul><li>Java</li></ul><p><img src="https://s1.ax1x.com/2020/10/03/03UUAA.png" srcset="/blog/img/loading.gif" alt="03UUAA.png"></p><h2 id="程序员手册"><a href="#程序员手册" class="headerlink" title="程序员手册"></a>程序员手册</h2><p>不同于上面的独立文档，“程序员手册”直接集成了各种文档，list：</p><ul><li>php手册</li><li>linux手册 </li><li>python手册 </li><li>PyQt5文档 </li><li>C函数</li><li>go</li><li>vim命令</li><li>git命令 </li><li>sql手册 </li><li>uTools API</li><li>java </li><li>javascript </li><li>vue</li><li>payload</li><li>devdocs</li></ul><blockquote><p>关于此插件的详细信息：<a href="https://yuanliao.info/d/356" target="_blank" rel="noopener">https://yuanliao.info/d/356</a></p></blockquote><p><img src="https://s1.ax1x.com/2020/10/03/03UWhq.png" srcset="/blog/img/loading.gif" alt="03UWhq.png"></p><h2 id="网页快开"><a href="#网页快开" class="headerlink" title="网页快开"></a>网页快开</h2><p><img src="https://s1.ax1x.com/2020/10/03/03DDcq.png" srcset="/blog/img/loading.gif" alt="03DDcq.png"></p><ul><li>移动端网页聚合</li></ul><p><img src="https://s1.ax1x.com/2020/10/03/03rKbT.png" srcset="/blog/img/loading.gif" alt="03rKbT.png"></p><ul><li>B站</li></ul><p><img src="https://s1.ax1x.com/2020/10/03/03rpKP.png" srcset="/blog/img/loading.gif" alt="03rpKP.png"></p><ul><li>GitHub</li></ul><p><img src="https://s1.ax1x.com/2020/10/03/03r9Df.png" srcset="/blog/img/loading.gif" alt="03r9Df.png"></p><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p><img src="https://s1.ax1x.com/2020/10/03/03Dv8A.png" srcset="/blog/img/loading.gif" alt="03Dv8A.png"></p><h1 id="进阶使用uTools"><a href="#进阶使用uTools" class="headerlink" title="进阶使用uTools"></a>进阶使用uTools</h1><h2 id="全局快捷键"><a href="#全局快捷键" class="headerlink" title="全局快捷键"></a>全局快捷键</h2><p>顾名思义，上图MelodyJerry的：</p><p><img src="https://s1.ax1x.com/2020/10/03/03N7FI.png" srcset="/blog/img/loading.gif" alt="03N7FI.png"></p><h2 id="超级面板"><a href="#超级面板" class="headerlink" title="超级面板"></a>超级面板</h2><ul><li>这是1.3版本后新增的</li></ul><p><img src="https://s1.ax1x.com/2020/10/03/03NxmQ.png" srcset="/blog/img/loading.gif" alt="03NxmQ.png"></p><p><img src="https://s1.ax1x.com/2020/10/03/03NOl8.png" srcset="/blog/img/loading.gif" alt="03NOl8.png"></p><h1 id="自己开发uTools插件"><a href="#自己开发uTools插件" class="headerlink" title="自己开发uTools插件"></a>自己开发uTools插件</h1><p>uTools已经向开发者们提供开发者文档，可以参考文档，捣鼓自己的插件哦。</p><p>像MelodyJerry的，暂时就不开源，也就暂不演示了。</p><p>插件开发文档：<a href="https://u.tools/docs/developer/welcome.html" target="_blank" rel="noopener">https://u.tools/docs/developer/welcome.html</a></p><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><ul><li>用户体验极佳</li><li>麻雀虽小，五脏俱全：简洁、方便、轻量、快速</li><li>文档齐全</li><li>支持开发个人插件</li><li>UI 很舒服</li></ul><p>就写这么多，更多的要自己去挖掘啦~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;uTools是什么？&quot;&gt;&lt;a href=&quot;#uTools是什么？&quot; class=&quot;headerlink&quot; title=&quot;uTools是什么？&quot;&gt;&lt;/a&gt;uTools是什么？&lt;/h1&gt;&lt;center&gt;&lt;font color=&quot;#FF2800&quot;&gt;u&lt;/font&gt;&lt;font color=&quot;#FF5000&quot;&gt;T&lt;/font&gt;&lt;font color=&quot;#FF7800&quot;&gt;o&lt;/font&gt;&lt;font color=&quot;#FFA000&quot;&gt;o&lt;/font&gt;&lt;font color=&quot;#FFC800&quot;&gt;l&lt;/font&gt;&lt;font color=&quot;#FFF000&quot;&gt;s&lt;/font&gt;&lt;font color=&quot;#D7FF00&quot;&gt;，&lt;/font&gt;&lt;font color=&quot;#AFFF00&quot;&gt;你&lt;/font&gt;&lt;font color=&quot;#87FF00&quot;&gt;的&lt;/font&gt;&lt;font color=&quot;#5FFF00&quot;&gt;生&lt;/font&gt;&lt;font color=&quot;#37FF00&quot;&gt;产&lt;/font&gt;&lt;font color=&quot;#0FFF00&quot;&gt;力&lt;/font&gt;&lt;font color=&quot;#00FF28&quot;&gt;工&lt;/font&gt;&lt;font color=&quot;#00FF50&quot;&gt;具&lt;/font&gt;&lt;font color=&quot;#00FF78&quot;&gt;集&lt;/font&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;极简&lt;/li&gt;
&lt;li&gt;插件化&lt;/li&gt;
&lt;li&gt;跨平台&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://www.u.tools/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.u.tools/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自由集成丰富插件，快速匹配「场景功能」，用完即走 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过自由选配丰富的插件，打造你得心应手的工具集合。&lt;/p&gt;
&lt;p&gt;该软件支持Windows、Mac以及Linux使用，并且拥有丰富的插件库。&lt;/p&gt;
&lt;p&gt;简单来讲，uTools可以作为一个&lt;strong&gt;程序快速启动器&lt;/strong&gt;，使用中英文搜索并快速打开你的本地程序、文件、系统设置等。你可以使用快捷键（默认为&lt;code&gt;alt+space&lt;/code&gt;）快速呼出这个搜索框，小巧却不简单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;uTools能做什么？&quot;&gt;&lt;a href=&quot;#uTools能做什么？&quot; class=&quot;headerlink&quot; title=&quot;uTools能做什么？&quot;&gt;&lt;/a&gt;uTools能做什么？&lt;/h1&gt;&lt;p&gt;uTools作者将此软件设计为&lt;font color=&quot;red&quot; size=&quot;5&quot;&gt;“一切皆插件”&lt;/font&gt;的插件化工具，&lt;strong&gt;所有的功能均可通过插件实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;插件中心有很多实用高效地插件，例如：在线翻译、压缩图片、颜色小助手、开发文档、图床、OCR图片识别等等小工具，你可以选择适合自己使用场景的插件安装使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/10/03/03G2r9.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;03G2r9.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="小技巧" scheme="https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="工具" scheme="https://melodyjerry.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="开发" scheme="https://melodyjerry.github.io/blog/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【狂神说Java】SpringBoot笔记存档</title>
    <link href="https://melodyjerry.github.io/blog/2020/10/02/%E3%80%90%E7%8B%82%E7%A5%9E%E8%AF%B4Java%E3%80%91SpringBoot%E7%AC%94%E8%AE%B0%E5%AD%98%E6%A1%A3/"/>
    <id>https://melodyjerry.github.io/blog/2020/10/02/%E3%80%90%E7%8B%82%E7%A5%9E%E8%AF%B4Java%E3%80%91SpringBoot%E7%AC%94%E8%AE%B0%E5%AD%98%E6%A1%A3/</id>
    <published>2020-10-02T14:51:02.771Z</published>
    <updated>2020-10-07T15:10:11.127Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转自<a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1" target="_blank" rel="noopener">狂神老师</a>，非常感谢老师，仅作为个人笔记使用</p><p>部分来自<a href="https://blog.csdn.net/qq_26017543/article/details/108530412?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160164522319725255512089%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160164522319725255512089&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28_p-12-108530412.pc_first_rank_v2_rank_v28_p&amp;utm_term=%E7%8B%82%E7%A5%9E+springboot" target="_blank" rel="noopener">CSDN</a></p></blockquote><a id="more"></a><h1 id="1、SpringBoot简介：Hello-World！"><a href="#1、SpringBoot简介：Hello-World！" class="headerlink" title="1、SpringBoot简介：Hello,World！"></a>1、SpringBoot简介：Hello,World！</h1><h2 id="1-1、回顾什么是Spring"><a href="#1-1、回顾什么是Spring" class="headerlink" title="1.1、回顾什么是Spring"></a>1.1、回顾什么是Spring</h2><p>Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。</p><p><strong>Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。</strong></p><h2 id="1-2、Spring是如何简化Java开发的"><a href="#1-2、Spring是如何简化Java开发的" class="headerlink" title="1.2、Spring是如何简化Java开发的"></a>1.2、Spring是如何简化Java开发的</h2><p>为了降低Java开发的复杂性，Spring采用了以下4种关键策略：</p><p>1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean；</p><p>2、通过IOC，依赖注入（DI）和面向接口实现松耦合；</p><p>3、基于切面（AOP）和惯例进行声明式编程；</p><p>4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate；</p><h2 id="1-3、什么是SpringBoot"><a href="#1-3、什么是SpringBoot" class="headerlink" title="1.3、什么是SpringBoot"></a>1.3、什么是SpringBoot</h2><p>学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍；</p><p>言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。</p><p>所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。</p><p>是的这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。</p><p>随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；</p><p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以<strong>约定大于配置的核心思想</strong>，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</p><p>简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。</p><p>Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。</p><p><strong>Spring Boot的主要优点：</strong></p><ul><li>为所有Spring开发者更快的入门</li><li><strong>开箱即用</strong>，提供各种默认配置来简化项目配置</li><li>内嵌式容器简化Web项目</li><li>没有冗余代码生成和XML配置的要求</li></ul><p>真的很爽，我们快速去体验开发个接口的感觉吧！</p><p>Hello，World</p><h2 id="1-4、准备工作"><a href="#1-4、准备工作" class="headerlink" title="1.4、准备工作"></a>1.4、准备工作</h2><p>我们将学习如何快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p><p>我的环境准备：</p><ul><li>java version “1.8.0_181”</li><li>Maven-3.6.1</li><li>SpringBoot 2.x 最新版</li></ul><p>开发工具：</p><ul><li>IDEA</li></ul><h2 id="1-5、创建基础项目说明"><a href="#1-5、创建基础项目说明" class="headerlink" title="1.5、创建基础项目说明"></a>1.5、创建基础项目说明</h2><p>Spring官方提供了非常方便的工具让我们快速构建应用</p><p>Spring Initializr：<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a></p><p><strong>项目创建方式一：</strong>使用Spring Initializr 的 Web页面创建项目</p><p>1、打开 <a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a></p><p>2、填写项目信息</p><p>3、点击”Generate Project“按钮生成项目；下载此项目</p><p>4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。</p><p>5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。</p><p><strong>项目创建方式二：</strong>使用 IDEA 直接创建项目</p><p>1、创建一个新项目</p><p>2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现</p><p>3、填写项目信息</p><p>4、选择初始化的组件（初学勾选 Web 即可）</p><p>5、填写项目路径</p><p>6、等待项目构建成功</p><p><strong>项目结构分析：</strong></p><p>通过上面步骤完成了基础项目的创建。就会自动生成以下文件。</p><p>1、程序的主启动类</p><p>2、一个 application.properties 配置文件</p><p>3、一个 测试类</p><p>4、一个 pom.xml</p><h2 id="1-6、pom-xml-分析"><a href="#1-6、pom-xml-分析" class="headerlink" title="1.6、pom.xml 分析"></a>1.6、pom.xml 分析</h2><p>打开pom.xml，看看Spring Boot项目的依赖：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 父依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!-- web场景启动器 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!-- springboot单元测试 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 剔除依赖 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 打包插件 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre><h2 id="1-7、编写一个http接口"><a href="#1-7、编写一个http接口" class="headerlink" title="1.7、编写一个http接口"></a>1.7、编写一个http接口</h2><p>1、在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到</p><p>2、在包中新建一个HelloController类</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>{    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello World"</span>;    }    }</code></pre><p>3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412220856954-754704117.png" srcset="/blog/img/loading.gif" alt="img"></p><p>简单几步，就完成了一个web接口的开发，SpringBoot就是这么简单。所以我们常用它来建立我们的微服务项目！</p><h2 id="1-8、将项目打成jar包，点击-maven的-package"><a href="#1-8、将项目打成jar包，点击-maven的-package" class="headerlink" title="1.8、将项目打成jar包，点击 maven的 package"></a>1.8、将项目打成jar包，点击 maven的 package</h2><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412220931385-1725690944.png" srcset="/blog/img/loading.gif" alt="img"></p><p>如果遇到以上错误，可以配置打包时 跳过项目运行测试用例</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">    在工作中,很多情况下我们打包是不想执行测试用例的</span><span class="hljs-comment">    可能是测试用例不完事,或是测试用例会影响数据库数据</span><span class="hljs-comment">    跳过测试用例执</span><span class="hljs-comment">    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-comment">&lt;!--跳过项目运行测试用例--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">skipTests</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">skipTests</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre><p>如果打包成功，则会在target目录下生成一个 jar 包</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412220948749-1673815977.png" srcset="/blog/img/loading.gif" alt="img"></p><p>打成了jar包后，就可以在任何地方运行了！OK</p><p><strong>彩蛋</strong></p><p>如何更改启动时显示的字符拼成的字母，SpringBoot呢？也就是 banner 图案；</p><p>只需一步：到项目下的 resources 目录下新建一个banner.txt 即可。</p><p>图案可以到：<a href="https://www.bootschool.net/ascii" target="_blank" rel="noopener">https://www.bootschool.net/ascii</a> 这个网站生成，然后拷贝到文件中即可！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221004279-2137228085.png" srcset="/blog/img/loading.gif" alt="img"></p><p>**SpringBoot这么简单的东西背后一定有故事，我们之后</p><h1 id="2、SpringBoot：运行原理初探"><a href="#2、SpringBoot：运行原理初探" class="headerlink" title="2、SpringBoot：运行原理初探"></a>2、SpringBoot：运行原理初探</h1><p>我们之前写的HelloSpringBoot，到底是怎么运行的呢，Maven项目，我们一般从pom.xml文件探究起；</p><blockquote><p><strong>pom.xml</strong></p></blockquote><h2 id="2-1、父依赖"><a href="#2-1、父依赖" class="headerlink" title="2.1、父依赖"></a>2.1、父依赖</h2><p>其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre><p>点进去，发现还有一个父依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre><p>这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p><p><strong>以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；</strong></p><h2 id="2-2、启动器-spring-boot-starter"><a href="#2-2、启动器-spring-boot-starter" class="headerlink" title="2.2、启动器 spring-boot-starter"></a>2.2、启动器 spring-boot-starter</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><strong>springboot-boot-starter-xxx</strong>：就是spring-boot的场景启动器</p><p><strong>spring-boot-starter-web</strong>：帮我们导入了web模块正常运行所依赖的组件；</p><p>SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；</p><blockquote><p><strong>主启动类</strong></p></blockquote><p>分析完了 pom.xml 来看看这个启动类</p><h2 id="2-3、默认的主启动类"><a href="#2-3、默认的主启动类" class="headerlink" title="2.3、默认的主启动类"></a>2.3、默认的主启动类</h2><pre><code class="hljs java"><span class="hljs-comment">//@SpringBootApplication 来标注一个主程序类</span><span class="hljs-comment">//说明这是一个Spring Boot应用</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootApplication</span> </span>{   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{     <span class="hljs-comment">//以为是启动了一个方法，没想到启动了一个服务</span>      SpringApplication.run(SpringbootApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;   }}</code></pre><p>但是<strong>一个简单的启动类并不简单！</strong>我们来分析一下这些注解都干了什么</p><h2 id="2-4、-SpringBootApplication"><a href="#2-4、-SpringBootApplication" class="headerlink" title="2.4、@SpringBootApplication"></a>2.4、@SpringBootApplication</h2><p>作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><p>进入这个注解：可以看到上面还有很多其他注解！</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootConfiguration</span><span class="hljs-meta">@EnableAutoConfiguration</span><span class="hljs-meta">@ComponentScan</span>(    excludeFilters = {<span class="hljs-meta">@Filter</span>(    type = FilterType.CUSTOM,    classes = {TypeExcludeFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>}</span><span class="hljs-class">), @<span class="hljs-title">Filter</span>(</span><span class="hljs-class">    <span class="hljs-title">type</span> </span>= FilterType.CUSTOM,    classes = {AutoConfigurationExcludeFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>}</span><span class="hljs-class">)}</span><span class="hljs-class">)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">SpringBootApplication</span> </span>{    <span class="hljs-comment">// ......</span>}</code></pre><h2 id="2-5、-ComponentScan"><a href="#2-5、-ComponentScan" class="headerlink" title="2.5、@ComponentScan"></a>2.5、@ComponentScan</h2><p>这个注解在Spring中很重要 ,它对应XML配置中的元素。</p><p>作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中</p><h2 id="2-6、-SpringBootConfiguration"><a href="#2-6、-SpringBootConfiguration" class="headerlink" title="2.6、@SpringBootConfiguration"></a>2.6、@SpringBootConfiguration</h2><p>作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；</p><p>我们继续进去这个注解查看</p><pre><code class="hljs java"><span class="hljs-comment">// 点进去得到下面的 @Component</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration {}<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Configuration {}</code></pre><p>这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；</p><p>里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！</p><p>我们回到 SpringBootApplication 注解中继续看。</p><h2 id="2-7、-EnableAutoConfiguration"><a href="#2-7、-EnableAutoConfiguration" class="headerlink" title="2.7、@EnableAutoConfiguration"></a>2.7、@EnableAutoConfiguration</h2><p><strong>@EnableAutoConfiguration ：开启自动配置功能</strong></p><p>以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；</p><p>点进注解接续查看：</p><p><strong>@AutoConfigurationPackage ：自动配置包</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Import</span>({Registrar<span class="hljs-class">.<span class="hljs-keyword">class</span>})</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">AutoConfigurationPackage</span> </span>{}</code></pre><p><strong>@import</strong> ：Spring底层注解@import ， 给容器中导入一个组件</p><p>Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ；</p><p>这个分析完了，退到上一步，继续看</p><p><strong>@Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ；</strong></p><p>AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：</p><p>1、这个类中有一个这样的方法</p><pre><code class="hljs java"><span class="hljs-comment">// 获得候选的配置</span><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>{    <span class="hljs-comment">//这里的getSpringFactoriesLoaderFactoryClass（）方法</span>    <span class="hljs-comment">//返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration</span>    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="hljs-keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-keyword">this</span>.getBeanClassLoader());    Assert.notEmpty(configurations, <span class="hljs-string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span>);    <span class="hljs-keyword">return</span> configurations;}</code></pre><p>2、这个方法又调用了 SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>{    String factoryClassName = factoryClass.getName();    <span class="hljs-comment">//这里它又调用了 loadSpringFactories 方法</span>    <span class="hljs-keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());}</code></pre><p>3、我们继续点击查看 loadSpringFactories 方法</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) {    <span class="hljs-comment">//获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身</span>    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) {        <span class="hljs-keyword">return</span> result;    } <span class="hljs-keyword">else</span> {        <span class="hljs-keyword">try</span> {            <span class="hljs-comment">//去获取一个资源 "META-INF/spring.factories"</span>            Enumeration&lt;URL&gt; urls = classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(<span class="hljs-string">"META-INF/spring.factories"</span>) : ClassLoader.getSystemResources(<span class="hljs-string">"META-INF/spring.factories"</span>);            LinkedMultiValueMap result = <span class="hljs-keyword">new</span> LinkedMultiValueMap();            <span class="hljs-comment">//将读取到的资源遍历，封装成为一个Properties</span>            <span class="hljs-keyword">while</span>(urls.hasMoreElements()) {                URL url = (URL)urls.nextElement();                UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);                Properties properties = PropertiesLoaderUtils.loadProperties(resource);                Iterator var6 = properties.entrySet().iterator();                <span class="hljs-keyword">while</span>(var6.hasNext()) {                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();                    String factoryClassName = ((String)entry.getKey()).trim();                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());                    <span class="hljs-keyword">int</span> var10 = var9.length;                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var11 = <span class="hljs-number">0</span>; var11 &lt; var10; ++var11) {                        String factoryName = var9[var11];                        result.add(factoryClassName, factoryName.trim());                    }                }            }            cache.put(classLoader, result);            <span class="hljs-keyword">return</span> result;        } <span class="hljs-keyword">catch</span> (IOException var13) {            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unable to load factories from location [META-INF/spring.factories]"</span>, var13);        }    }}</code></pre><p>4、发现一个多次出现的文件：spring.factories，全局搜索它</p><h2 id="2-8、spring-factories"><a href="#2-8、spring-factories" class="headerlink" title="2.8、spring.factories"></a>2.8、spring.factories</h2><p>我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221052594-126548247.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>WebMvcAutoConfiguration</strong></p><p>我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221108489-300000735.png" srcset="/blog/img/loading.gif" alt="img"></p><p>可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！</p><p>所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p><p><strong>结论：</strong></p><ol><li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</li><li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li><li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li><li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li><li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li></ol><p><strong>现在大家应该大概的了解了下，SpringBoot的运行原理，后面我们还会深化一次！</strong></p><blockquote><p><strong>SpringApplication</strong></p></blockquote><h2 id="2-9、不简单的方法"><a href="#2-9、不简单的方法" class="headerlink" title="2.9、不简单的方法"></a>2.9、不简单的方法</h2><p>我最初以为就是运行了一个main方法，没想到却开启了一个服务；</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootApplication</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{        SpringApplication.run(SpringbootApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    }}</code></pre><p><strong>SpringApplication.run分析</strong></p><p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；</p><h2 id="2-10、SpringApplication"><a href="#2-10、SpringApplication" class="headerlink" title="2.10、SpringApplication"></a>2.10、SpringApplication</h2><p><strong>这个类主要做了以下四件事情：</strong></p><p>1、推断应用的类型是普通的项目还是Web项目</p><p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p><p>3、找出所有的应用程序监听器，设置到listeners属性中</p><p>4、推断并设置main方法的定义类，找到运行的主类</p><p>查看构造器：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class... primarySources)</span> </span>{    <span class="hljs-comment">// ......</span>    <span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();    <span class="hljs-keyword">this</span>.setInitializers(<span class="hljs-keyword">this</span>.getSpringFactoriesInstances();    <span class="hljs-keyword">this</span>.setListeners(<span class="hljs-keyword">this</span>.getSpringFactoriesInstances(ApplicationListener<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;    <span class="hljs-keyword">this</span>.mainApplicationClass = <span class="hljs-keyword">this</span>.deduceMainApplicationClass();}</code></pre><h2 id="2-11、run方法流程分析"><a href="#2-11、run方法流程分析" class="headerlink" title="2.11、run方法流程分析"></a>2.11、run方法流程分析</h2><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221135119-1843322351.png" srcset="/blog/img/loading.gif" alt="img"><br>跟着源码和这幅图就可以一探究竟了！</p><h1 id="3、SpringBoot：yaml配置注入"><a href="#3、SpringBoot：yaml配置注入" class="headerlink" title="3、SpringBoot：yaml配置注入"></a>3、SpringBoot：yaml配置注入</h1><p>yaml语法学习</p><h2 id="3-1、配置文件"><a href="#3-1、配置文件" class="headerlink" title="3.1、配置文件"></a>3.1、配置文件</h2><p>SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的</p><ul><li>application.properties</li><li><ul><li>语法结构 ：key=value</li></ul></li><li>application.yml</li><li><ul><li>语法结构 ：key：空格 value</li></ul></li></ul><p><strong>配置文件的作用 ：</strong>修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；</p><p>比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！</p><ul><li><pre><code class="hljs ini"><span class="hljs-attr">server.port</span>=<span class="hljs-number">8081</span></code></pre></li></ul><h2 id="3-2、yaml概述"><a href="#3-2、yaml概述" class="headerlink" title="3.2、yaml概述"></a>3.2、yaml概述</h2><p>YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）</p><p><strong>这种语言以数据\</strong>**作**<em>\</em>为中心，而不是以标记语言为重点！**</p><p>以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml</p><p>传统xml配置：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8081<span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span></code></pre><p>yaml配置：</p><pre><code class="hljs yml"><span class="hljs-string">server：</span>  <span class="hljs-attr">prot:</span> <span class="hljs-number">8080</span></code></pre><h2 id="3-3、yaml基础语法"><a href="#3-3、yaml基础语法" class="headerlink" title="3.3、yaml基础语法"></a>3.3、yaml基础语法</h2><p>说明：语法要求严格！</p><p>1、空格不能省略</p><p>2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。</p><p>3、属性和值的大小写都是十分敏感的。</p><p><strong>字面量：普通的值 [ 数字，布尔值，字符串 ]</strong></p><p>字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；</p><pre><code class="hljs yml"><span class="hljs-attr">k:</span> <span class="hljs-string">v</span></code></pre><p>注意：</p><ul><li><p>“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；</p><p>  比如 ：name: “kuang \n shen” 输出 ：kuang 换行 shen</p></li><li><p>‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出</p><p>  比如 ：name: ‘kuang \n shen’ 输出 ：kuang \n shen</p></li></ul><p><strong>对象、Map（键值对）</strong></p><pre><code class="hljs yml"><span class="hljs-comment">#对象、Map格式</span><span class="hljs-attr">k:</span>     <span class="hljs-attr">v1:</span>    <span class="hljs-attr">v2:</span></code></pre><p>在下一行来写对象的属性和值得关系，注意缩进；比如：</p><pre><code class="hljs yml"><span class="hljs-attr">student:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">qinjiang</span>    <span class="hljs-attr">age:</span> <span class="hljs-number">3</span></code></pre><p>行内写法</p><pre><code class="hljs yml"><span class="hljs-attr">student:</span> <span class="hljs-string">{name:</span> <span class="hljs-string">qinjiang,age:</span> <span class="hljs-number">3</span><span class="hljs-string">}</span></code></pre><p><strong>数组（ List、set ）</strong></p><p>用 - 值表示数组中的一个元素,比如：</p><pre><code class="hljs yml"><span class="hljs-attr">pets:</span> <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span> <span class="hljs-bullet">-</span> <span class="hljs-string">dog</span> <span class="hljs-bullet">-</span> <span class="hljs-string">pig</span></code></pre><p>行内写法</p><pre><code class="hljs yml"><span class="hljs-attr">pets:</span> <span class="hljs-string">[cat,dog,pig]</span></code></pre><p><strong>修改SpringBoot的默认端口号</strong></p><p>配置文件中添加，端口号的参数，就可以切换端口；</p><pre><code class="hljs yml"><span class="hljs-attr">server:</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">8082</span></code></pre><p>注入配置文件</p><p>yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！</p><h2 id="3-4、yaml注入配置文件"><a href="#3-4、yaml注入配置文件" class="headerlink" title="3.4、yaml注入配置文件"></a>3.4、yaml注入配置文件</h2><p>1、在springboot项目中的resources目录下新建一个文件 application.yml</p><p>2、编写一个实体类 Dog；</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.springboot.pojo;<span class="hljs-meta">@Component</span>  <span class="hljs-comment">//注册bean到容器中</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>{    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;        <span class="hljs-comment">//有参无参构造、get、set方法、toString()方法  </span>}</code></pre><p>3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下：</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//注册bean</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>{    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"阿黄"</span>)    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"18"</span>)    <span class="hljs-keyword">private</span> Integer age;}</code></pre><p>4、在SpringBoot的测试类下注入狗狗输出一下；</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplicationTests</span> </span>{    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">//将狗狗自动注入进来</span>    Dog dog;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>{        System.out.println(dog); <span class="hljs-comment">//打印看下狗狗对象</span>    }}</code></pre><p>结果成功输出，@Value注入成功，这是我们原来的办法对吧。</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221242434-877025455.png" srcset="/blog/img/loading.gif" alt="img"></p><p>5、我们在编写一个复杂一点的实体类：Person 类</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//注册bean到容器中</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> Boolean happy;    <span class="hljs-keyword">private</span> Date birth;    <span class="hljs-keyword">private</span> Map&lt;String,Object&gt; maps;    <span class="hljs-keyword">private</span> List&lt;Object&gt; lists;    <span class="hljs-keyword">private</span> Dog dog;        <span class="hljs-comment">//有参无参构造、get、set方法、toString()方法  </span>}</code></pre><p>6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！</p><pre><code class="hljs yml"><span class="hljs-attr">person:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">qinjiang</span>  <span class="hljs-attr">age:</span> <span class="hljs-number">3</span>  <span class="hljs-attr">happy:</span> <span class="hljs-literal">false</span>  <span class="hljs-attr">birth:</span> <span class="hljs-number">2000</span><span class="hljs-string">/01/01</span>  <span class="hljs-attr">maps:</span> <span class="hljs-string">{k1:</span> <span class="hljs-string">v1,k2:</span> <span class="hljs-string">v2}</span>  <span class="hljs-attr">lists:</span>   <span class="hljs-bullet">-</span> <span class="hljs-string">code</span>   <span class="hljs-bullet">-</span> <span class="hljs-string">girl</span>   <span class="hljs-bullet">-</span> <span class="hljs-string">music</span>  <span class="hljs-attr">dog:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">旺财</span>    <span class="hljs-attr">age:</span> <span class="hljs-number">1</span></code></pre><p>7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！</p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">@ConfigurationProperties作用：</span><span class="hljs-comment">将配置文件中配置的每一个属性的值，映射到这个组件中；</span><span class="hljs-comment">告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定</span><span class="hljs-comment">参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应</span><span class="hljs-comment">*/</span><span class="hljs-meta">@Component</span> <span class="hljs-comment">//注册bean</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> Boolean happy;    <span class="hljs-keyword">private</span> Date birth;    <span class="hljs-keyword">private</span> Map&lt;String,Object&gt; maps;    <span class="hljs-keyword">private</span> List&lt;Object&gt; lists;    <span class="hljs-keyword">private</span> Dog dog;}</code></pre><p>8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221317864-79632654.png" srcset="/blog/img/loading.gif" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221337189-113941879.png" srcset="/blog/img/loading.gif" alt="img"></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>9、确认以上配置都OK之后，我们去测试类中测试一下：</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplicationTests</span> </span>{    <span class="hljs-meta">@Autowired</span>    Person person; <span class="hljs-comment">//将person自动注入进来</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>{        System.out.println(person); <span class="hljs-comment">//打印person信息</span>    }}</code></pre><p>结果：所有值全部注入成功！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221356464-178925188.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>yaml配置注入到实体类完全OK！</strong></p><p>课堂测试：</p><p>1、将配置文件的key 值 和 属性的值设置为不一样，则结果输出为null，注入失败</p><p>2、在配置一个person2，然后将 @ConfigurationProperties(prefix = “person2”) 指向我们的person2；</p><h2 id="3-5、加载指定的配置文件"><a href="#3-5、加载指定的配置文件" class="headerlink" title="3.5、加载指定的配置文件"></a>3.5、加载指定的配置文件</h2><p><strong>@PropertySource ：</strong>加载指定的配置文件；</p><p><strong>@configurationProperties</strong>：默认从全局配置文件中获取值；</p><p>1、我们去在resources目录下新建一个<strong>person.properties</strong>文件</p><pre><code class="hljs properties"><span class="hljs-attr">name</span>=<span class="hljs-string">kuangshen</span></code></pre><p>2、然后在我们的代码中指定加载person.properties文件</p><pre><code class="hljs java"><span class="hljs-meta">@PropertySource</span>(value = <span class="hljs-string">"classpath:person.properties"</span>)<span class="hljs-meta">@Component</span> <span class="hljs-comment">//注册bean</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"${name}"</span>)    <span class="hljs-keyword">private</span> String name;    ......  }</code></pre><p>3、再次输出测试一下：指定配置文件绑定成功！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221412474-1138637819.png" srcset="/blog/img/loading.gif" alt="img"></p><h2 id="3-6、配置文件占位符"><a href="#3-6、配置文件占位符" class="headerlink" title="3.6、配置文件占位符"></a>3.6、配置文件占位符</h2><p>配置文件还可以编写占位符生成随机数</p><pre><code class="hljs yml"><span class="hljs-attr">person:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">qinjiang${random.uuid}</span> <span class="hljs-comment"># 随机uuid</span>    <span class="hljs-attr">age:</span> <span class="hljs-string">${random.int}</span>  <span class="hljs-comment"># 随机int</span>    <span class="hljs-attr">happy:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">birth:</span> <span class="hljs-number">2000</span><span class="hljs-string">/01/01</span>    <span class="hljs-attr">maps:</span> <span class="hljs-string">{k1:</span> <span class="hljs-string">v1,k2:</span> <span class="hljs-string">v2}</span>    <span class="hljs-attr">lists:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">code</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">girl</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">music</span>    <span class="hljs-attr">dog:</span>      <span class="hljs-attr">name:</span> <span class="hljs-string">${person.hello:other}_旺财</span>      <span class="hljs-attr">age:</span> <span class="hljs-number">1</span></code></pre><h2 id="3-7、回顾properties配置"><a href="#3-7、回顾properties配置" class="headerlink" title="3.7、回顾properties配置"></a>3.7、回顾properties配置</h2><p>我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！</p><p>【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8；</p><p>settings–&gt;FileEncodings 中配置；</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221443954-1928760896.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>测试步骤：</strong></p><p>1、新建一个实体类User</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//注册bean</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">private</span> String sex;}</code></pre><p>2、编辑配置文件 user.properties</p><pre><code class="hljs properties"><span class="hljs-meta">user1.name</span>=<span class="hljs-string">kuangshen</span><span class="hljs-meta">user1.age</span>=<span class="hljs-string">18user1.sex=男</span></code></pre><p>3、我们在User类上使用@Value来进行注入！</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//注册bean</span><span class="hljs-meta">@PropertySource</span>(value = <span class="hljs-string">"classpath:user.properties"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{    <span class="hljs-comment">//直接使用@value</span>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"${user.name}"</span>) <span class="hljs-comment">//从配置文件中取值</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"#{9*2}"</span>)  <span class="hljs-comment">// #{SPEL} Spring表达式</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"男"</span>)  <span class="hljs-comment">// 字面量</span>    <span class="hljs-keyword">private</span> String sex;}</code></pre><p>4、Springboot测试</p><pre><code class="hljs ini"><span class="hljs-attr">user1.name</span>=kuangshen<span class="hljs-attr">user1.age</span>=<span class="hljs-number">18</span><span class="hljs-attr">user1.sex</span>=男</code></pre><p>结果正常输出：</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221511674-573127843.png" srcset="/blog/img/loading.gif" alt="img"></p><h2 id="3-8、对比小结"><a href="#3-8、对比小结" class="headerlink" title="3.8、对比小结"></a>3.8、对比小结</h2><p>@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221528114-1258238964.png" srcset="/blog/img/loading.gif" alt="img"></p><p>1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加</p><p>2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下</p><p>3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性</p><p>4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持</p><p><strong>结论：</strong></p><p>配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；</p><p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；</p><p>如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！</p><h1 id="4、SpringBoot：JSR303数据校验及多环境切换"><a href="#4、SpringBoot：JSR303数据校验及多环境切换" class="headerlink" title="4、SpringBoot：JSR303数据校验及多环境切换"></a>4、SpringBoot：JSR303数据校验及多环境切换</h1><p>JSR303数据校验</p><h2 id="4-1、先看看如何使用"><a href="#4-1、先看看如何使用" class="headerlink" title="4.1、先看看如何使用"></a>4.1、先看看如何使用</h2><p>Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式；</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//注册bean</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)<span class="hljs-meta">@Validated</span>  <span class="hljs-comment">//数据校验</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{    <span class="hljs-meta">@Email</span>(message=<span class="hljs-string">"邮箱格式错误"</span>) <span class="hljs-comment">//name必须是邮箱格式</span>    <span class="hljs-keyword">private</span> String name;}</code></pre><p>运行结果 ：default message [不是一个合法的电子邮件地址];</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221556237-391670975.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>使用数据校验，可以保证数据的正确性；</strong></p><h2 id="4-2、常见参数"><a href="#4-2、常见参数" class="headerlink" title="4.2、常见参数"></a>4.2、常见参数</h2><pre><code class="hljs java"><span class="hljs-meta">@NotNull</span>(message=<span class="hljs-string">"名字不能为空"</span>)<span class="hljs-keyword">private</span> String userName;<span class="hljs-meta">@Max</span>(value=<span class="hljs-number">120</span>,message=<span class="hljs-string">"年龄最大不能查过120"</span>)<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<span class="hljs-meta">@Email</span>(message=<span class="hljs-string">"邮箱格式错误"</span>)<span class="hljs-keyword">private</span> String email;空检查<span class="hljs-meta">@Null</span>       验证对象是否为<span class="hljs-keyword">null</span><span class="hljs-meta">@NotNull</span>    验证对象是否不为<span class="hljs-keyword">null</span>, 无法查检长度为<span class="hljs-number">0</span>的字符串<span class="hljs-meta">@NotBlank</span>   检查约束字符串是不是Null还有被Trim的长度是否大于<span class="hljs-number">0</span>,只对字符串,且会去掉前后空格.<span class="hljs-meta">@NotEmpty</span>   检查约束元素是否为NULL或者是EMPTY.    Booelan检查<span class="hljs-meta">@AssertTrue</span>     验证 Boolean 对象是否为 <span class="hljs-keyword">true</span>  <span class="hljs-meta">@AssertFalse</span>    验证 Boolean 对象是否为 <span class="hljs-keyword">false</span>      长度检查<span class="hljs-meta">@Size</span>(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  <span class="hljs-meta">@Length</span>(min=, max=) string is between min and max included.日期检查<span class="hljs-meta">@Past</span>       验证 Date 和 Calendar 对象是否在当前时间之前  <span class="hljs-meta">@Future</span>     验证 Date 和 Calendar 对象是否在当前时间之后  <span class="hljs-meta">@Pattern</span>    验证 String 对象是否符合正则表达式的规则.......等等除此以外，我们还可以自定义一些数据校验规则</code></pre><p>多环境切换</p><p>profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；</p><h2 id="4-3、多配置文件"><a href="#4-3、多配置文件" class="headerlink" title="4.3、多配置文件"></a>4.3、多配置文件</h2><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本；</p><p><strong>例如：</strong></p><p>application-test.properties 代表测试环境配置</p><p>application-dev.properties 代表开发环境配置</p><p>但是Springboot并不会直接启动这些配置文件，它<strong>默认使用application.properties主配置文件</strong>；</p><p>我们需要通过一个配置来选择需要激活的环境：</p><pre><code class="hljs properties"><span class="hljs-comment">#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；</span><span class="hljs-comment">#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；</span><span class="hljs-meta">spring.profiles.active</span>=<span class="hljs-string">dev</span></code></pre><h2 id="4-4、yaml的多文档块"><a href="#4-4、yaml的多文档块" class="headerlink" title="4.4、yaml的多文档块"></a>4.4、yaml的多文档块</h2><p>和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !</p><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><span class="hljs-comment">#选择要激活那个环境块</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span>    <span class="hljs-attr">active:</span> <span class="hljs-string">prod</span><span class="hljs-meta">---</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8083</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#配置环境的名称</span><span class="hljs-meta">---</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8084</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">prod</span>  <span class="hljs-comment">#配置环境的名称</span></code></pre><p><strong>注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！</strong></p><h2 id="4-5、配置文件加载位置"><a href="#4-5、配置文件加载位置" class="headerlink" title="4.5、配置文件加载位置"></a>4.5、配置文件加载位置</h2><p><strong>外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！</strong></p><p>官方外部配置文件说明参考文档</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221627864-281289739.png" srcset="/blog/img/loading.gif" alt="img"></p><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：</p><pre><code class="hljs angelscript">优先级<span class="hljs-number">1</span>：项目路径下的config文件夹配置文件优先级<span class="hljs-number">2</span>：项目路径下配置文件优先级<span class="hljs-number">3</span>：资源路径下的config文件夹配置文件优先级<span class="hljs-number">4</span>：资源路径下配置文件</code></pre><p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p><p><strong>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</strong></p><p>我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；</p><pre><code class="hljs properties"><span class="hljs-comment">#配置项目的访问路径</span><span class="hljs-meta">server.servlet.context-path</span>=<span class="hljs-string">/kuang</span></code></pre><h2 id="4-6、拓展，运维小技巧"><a href="#4-6、拓展，运维小技巧" class="headerlink" title="4.6、拓展，运维小技巧"></a>4.6、拓展，运维小技巧</h2><p>指定位置加载配置文件</p><p>我们还可以通过spring.config.location来改变默认的配置文件位置</p><p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高</p><h1 id="5、SpringBoot：自动配置原理"><a href="#5、SpringBoot：自动配置原理" class="headerlink" title="5、SpringBoot：自动配置原理"></a>5、SpringBoot：自动配置原理</h1><p>自动配置原理</p><p>配置文件到底能写什么？怎么写？</p><p>SpringBoot官方文档中有大量的配置，我们无法全部记住</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221646159-343420531.png" srcset="/blog/img/loading.gif" alt="img"></p><h2 id="5-1、分析自动配置原理"><a href="#5-1、分析自动配置原理" class="headerlink" title="5.1、分析自动配置原理"></a>5.1、分析自动配置原理</h2><p>我们以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p><pre><code class="hljs java"><span class="hljs-comment">//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；</span><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//启动指定类的ConfigurationProperties功能；</span>  <span class="hljs-comment">//进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；</span>  <span class="hljs-comment">//并把HttpProperties加入到ioc容器中</span><span class="hljs-meta">@EnableConfigurationProperties</span>({HttpProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>}) </span><span class="hljs-class"></span><span class="hljs-class">//<span class="hljs-title">Spring</span>底层@<span class="hljs-title">Conditional</span>注解</span><span class="hljs-class">  //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；</span><span class="hljs-class">  //这里的意思就是判断当前应用是否是<span class="hljs-title">web</span>应用，如果是，当前配置类生效</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnWebApplication</span>(</span><span class="hljs-class">    <span class="hljs-title">type</span> </span>= Type.SERVLET)<span class="hljs-comment">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span><span class="hljs-meta">@ConditionalOnClass</span>({CharacterEncodingFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>})</span><span class="hljs-class"></span><span class="hljs-class">//判断配置文件中是否存在某个配置：<span class="hljs-title">spring</span>.<span class="hljs-title">http</span>.<span class="hljs-title">encoding</span>.<span class="hljs-title">enabled</span>；</span><span class="hljs-class">  //如果不存在，判断也是成立的</span><span class="hljs-class">  //即使我们配置文件中不配置<span class="hljs-title">pring</span>.<span class="hljs-title">http</span>.<span class="hljs-title">encoding</span>.<span class="hljs-title">enabled</span></span>=<span class="hljs-keyword">true</span>，也是默认生效的；<span class="hljs-meta">@ConditionalOnProperty</span>(    prefix = <span class="hljs-string">"spring.http.encoding"</span>,    value = {<span class="hljs-string">"enabled"</span>},    matchIfMissing = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span> </span>{    <span class="hljs-comment">//他已经和SpringBoot的配置文件映射了</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Encoding properties;    <span class="hljs-comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span><span class="hljs-params">(HttpProperties properties)</span> </span>{        <span class="hljs-keyword">this</span>.properties = properties.getEncoding();    }        <span class="hljs-comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConditionalOnMissingBean</span> <span class="hljs-comment">//判断容器没有这个组件？</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title">characterEncodingFilter</span><span class="hljs-params">()</span> </span>{        CharacterEncodingFilter filter = <span class="hljs-keyword">new</span> OrderedCharacterEncodingFilter();        filter.setEncoding(<span class="hljs-keyword">this</span>.properties.getCharset().name());        filter.setForceRequestEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));        filter.setForceResponseEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));        <span class="hljs-keyword">return</span> filter;    }    <span class="hljs-comment">//。。。。。。。</span>}</code></pre><p><strong>一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！</strong></p><ul><li>一但这个配置类生效；这个配置类就会给容器中添加各种组件；</li><li>这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</li><li>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；</li><li>配置文件能配置什么就可以参照某个功能对应的这个属性类</li></ul><pre><code class="hljs java"><span class="hljs-comment">//从配置文件中获取指定的值和bean的属性进行绑定</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.http"</span>) <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpProperties</span> </span>{    <span class="hljs-comment">// .....</span>}</code></pre><p>我们去配置文件里面试试前缀，看提示！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221709469-1927678332.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>这就是自动装配的原理！</strong></p><h2 id="5-2、精髓"><a href="#5-2、精髓" class="headerlink" title="5.2、精髓"></a>5.2、精髓</h2><p>1、SpringBoot启动会加载大量的自动配置类</p><p>2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；</p><p>3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）</p><p>4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；</p><p><strong>xxxxAutoConfigurartion：自动配置类；</strong>给容器中添加组件</p><p><strong>xxxxProperties:封装配置文件中相关属性；</strong></p><h2 id="5-3、了解：-Conditional"><a href="#5-3、了解：-Conditional" class="headerlink" title="5.3、了解：@Conditional"></a>5.3、了解：@Conditional</h2><p>了解完自动装配的原理后，我们来关注一个细节问题，<strong>自动配置类必须在一定的条件下才能生效；</strong></p><p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221747954-591282661.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。</strong></p><p>我们怎么知道哪些自动配置类生效？</p><p><strong>我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</strong></p><pre><code class="hljs properties"><span class="hljs-comment">#开启springboot的调试类</span><span class="hljs-attr">debug</span>=<span class="hljs-string">true</span></code></pre><p><strong>Positive matches:（自动配置类启用的：正匹配）</strong></p><p><strong>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</strong></p><p><strong>Unconditional classes: （没有条件的类）</strong></p><p>【演示：查看输出的日志】</p><p>掌握吸收理解原理，即可以不变应万变！</p><h1 id="6、SpringBoot：自定义starter"><a href="#6、SpringBoot：自定义starter" class="headerlink" title="6、SpringBoot：自定义starter"></a>6、SpringBoot：自定义starter</h1><p>我们分析完毕了源码以及自动装配的过程，我们可以尝试自定义一个启动器来玩玩！</p><h2 id="6-1、说明"><a href="#6-1、说明" class="headerlink" title="6.1、说明"></a>6.1、说明</h2><p>启动器模块是一个 空 jar 文件，仅提供辅助性依赖管理，这些依赖可能用于自动装配或者其他类库；</p><p><strong>命名归约：</strong></p><p>官方命名：</p><ul><li>前缀：spring-boot-starter-xxx</li><li>比如：spring-boot-starter-web….</li></ul><p>自定义命名：</p><ul><li>xxx-spring-boot-starter</li><li>比如：mybatis-spring-boot-starter</li></ul><h2 id="6-2、编写启动器"><a href="#6-2、编写启动器" class="headerlink" title="6.2、编写启动器"></a>6.2、编写启动器</h2><p>1、在IDEA中新建一个空项目 spring-boot-starter-diy</p><p>2、新建一个普通Maven模块：kuang-spring-boot-starter</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221856069-1152361375.png" srcset="/blog/img/loading.gif" alt="img"></p><p>3、新建一个Springboot模块：kuang-spring-boot-starter-autoconfigure</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412221930344-363603356.png" srcset="/blog/img/loading.gif" alt="img"></p><p>4、点击apply即可，基本结构</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412222010544-802039453.png" srcset="/blog/img/loading.gif" alt="img"></p><p>5、在我们的 starter 中 导入 autoconfigure 的依赖！</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 启动器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!--  引入自动配置模块 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.kuang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kuang-spring-boot-starter-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>6、将 autoconfigure 项目下多余的文件都删掉，Pom中只留下一个 starter，这是所有的启动器基本配置！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412222056275-508024261.png" srcset="/blog/img/loading.gif" alt="img"></p><p>7、我们编写一个自己的服务</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>{    HelloProperties helloProperties;    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloProperties <span class="hljs-title">getHelloProperties</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> helloProperties;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHelloProperties</span><span class="hljs-params">(HelloProperties helloProperties)</span> </span>{        <span class="hljs-keyword">this</span>.helloProperties = helloProperties;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>{        <span class="hljs-keyword">return</span> helloProperties.getPrefix() + name + helloProperties.getSuffix();    }}</code></pre><p>8、编写HelloProperties 配置类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-comment">// 前缀 kuang.hello</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"kuang.hello"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloProperties</span> </span>{    <span class="hljs-keyword">private</span> String prefix;    <span class="hljs-keyword">private</span> String suffix;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPrefix</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> prefix;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrefix</span><span class="hljs-params">(String prefix)</span> </span>{        <span class="hljs-keyword">this</span>.prefix = prefix;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSuffix</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> suffix;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSuffix</span><span class="hljs-params">(String suffix)</span> </span>{        <span class="hljs-keyword">this</span>.suffix = suffix;    }}</code></pre><p>9、编写我们的自动配置类并注入bean，测试！</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnWebApplication</span> <span class="hljs-comment">//web应用生效</span><span class="hljs-meta">@EnableConfigurationProperties</span>(HelloProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">HelloServiceAutoConfiguration</span> </span>{    <span class="hljs-meta">@Autowired</span>    HelloProperties helloProperties;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloService <span class="hljs-title">helloService</span><span class="hljs-params">()</span></span>{        HelloService service = <span class="hljs-keyword">new</span> HelloService();        service.setHelloProperties(helloProperties);        <span class="hljs-keyword">return</span> service;    }}</code></pre><p>10、在resources编写一个自己的 META-INF\spring.factories</p><pre><code class="hljs xml"># Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.kuang.HelloServiceAutoConfiguration</code></pre><p>11、编写完成后，可以安装到maven仓库中！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412223705466-546919127.png" srcset="/blog/img/loading.gif" alt="img"></p><h2 id="6-3、新建项目测试我们自己写的启动器"><a href="#6-3、新建项目测试我们自己写的启动器" class="headerlink" title="6.3、新建项目测试我们自己写的启动器"></a>6.3、新建项目测试我们自己写的启动器</h2><p>1、新建一个SpringBoot 项目</p><p>2、导入我们自己写的启动器</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.kuang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kuang-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>3、编写一个 HelloController 进行测试我们自己的写的接口！</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.controller;<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>{    <span class="hljs-meta">@Autowired</span>    HelloService helloService;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{        <span class="hljs-keyword">return</span> helloService.sayHello(<span class="hljs-string">"zxc"</span>);    }}</code></pre><p>4、编写配置文件 application.properties</p><pre><code class="hljs java">kuang.hello.prefix=<span class="hljs-string">"ppp"</span>kuang.hello.suffix=<span class="hljs-string">"sss"</span></code></pre><p>5、启动项目进行测试，结果成功 !</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412222355347-1685568990.png" srcset="/blog/img/loading.gif" alt="img"></p><h1 id="7、SpringBoot整合JDBC"><a href="#7、SpringBoot整合JDBC" class="headerlink" title="7、SpringBoot整合JDBC"></a>7、SpringBoot整合JDBC</h1><h2 id="7-1、SpringData简介"><a href="#7-1、SpringData简介" class="headerlink" title="7.1、SpringData简介"></a>7.1、SpringData简介</h2><p>对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。</p><p>Spring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。</p><p>Sping Data 官网：<a href="https://spring.io/projects/spring-data" target="_blank" rel="noopener">https://spring.io/projects/spring-data</a></p><p>数据库相关的启动器 ：可以参考官方文档：</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a></p><p>整合JDBC</p><h2 id="7-2、创建测试项目测试数据源"><a href="#7-2、创建测试项目测试数据源" class="headerlink" title="7.2、创建测试项目测试数据源"></a>7.2、创建测试项目测试数据源</h2><p>1、我去新建一个项目测试：springboot-data-jdbc ; 引入相应的模块！基础模块</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412223600851-874349014.png" srcset="/blog/img/loading.gif" alt="img"></p><p>2、项目建好之后，发现自动帮我们导入了如下的启动器</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>3、编写yaml配置文件连接数据库；</p><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>    <span class="hljs-comment">#?serverTimezone=UTC解决时区的报错</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span></code></pre><p>4、配置完这一些东西后，我们就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去测试类测试一下</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootDataJdbcApplicationTests</span> </span>{    <span class="hljs-comment">//DI注入数据源</span>    <span class="hljs-meta">@Autowired</span>    DataSource dataSource;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>{        <span class="hljs-comment">//看一下默认数据源</span>        System.out.println(dataSource.getClass());        <span class="hljs-comment">//获得连接</span>        Connection connection =   dataSource.getConnection();        System.out.println(connection);        <span class="hljs-comment">//关闭连接</span>        connection.close();    }}</code></pre><p>结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置</p><p>我们来全局搜索一下，找到数据源的所有自动配置都在 ：DataSourceAutoConfiguration文件：</p><pre><code class="hljs java"><span class="hljs-meta">@Import</span>(    {Hikari<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Tomcat</span>.<span class="hljs-title">class</span>, <span class="hljs-title">Dbcp2</span>.<span class="hljs-title">class</span>, <span class="hljs-title">Generic</span>.<span class="hljs-title">class</span>, <span class="hljs-title">DataSourceJmxConfiguration</span>.<span class="hljs-title">class</span>}</span><span class="hljs-class">)</span><span class="hljs-class"><span class="hljs-title">protected</span> <span class="hljs-title">static</span> <span class="hljs-title">class</span> <span class="hljs-title">PooledDataSourceConfiguration</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">PooledDataSourceConfiguration</span><span class="hljs-params">()</span> </span>{    }}</code></pre><p>这里导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源；</p><p><strong>HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀；</strong></p><p><strong>可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。</strong></p><p>关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate</p><h2 id="7-3、JDBCTemplate"><a href="#7-3、JDBCTemplate" class="headerlink" title="7.3、JDBCTemplate"></a>7.3、JDBCTemplate</h2><p>1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库；</p><p>2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。</p><p>3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。</p><p>4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用</p><p>5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类</p><p><strong>JdbcTemplate主要提供以下几类方法：</strong></p><ul><li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li><li>update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</li><li>query方法及queryForXXX方法：用于执行查询相关语句；</li><li>call方法：用于执行存储过程、函数相关语句。</li></ul><h2 id="7-4、测试"><a href="#7-4、测试" class="headerlink" title="7.4、测试"></a>7.4、测试</h2><p>编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试；</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.controller;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/jdbc"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcController</span> </span>{    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate</span><span class="hljs-comment">     * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作</span><span class="hljs-comment">     * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    JdbcTemplate jdbcTemplate;    <span class="hljs-comment">//查询employee表中所有数据</span>    <span class="hljs-comment">//List 中的1个 Map 对应数据库的 1行数据</span>    <span class="hljs-comment">//Map 中的 key 对应数据库的字段名，value 对应数据库的字段值</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/list"</span>)    <span class="hljs-keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; userList(){        String sql = <span class="hljs-string">"select * from employee"</span>;        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql);        <span class="hljs-keyword">return</span> maps;    }        <span class="hljs-comment">//新增一个用户</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/add"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addUser</span><span class="hljs-params">()</span></span>{        <span class="hljs-comment">//插入语句，注意时间问题</span>        String sql = <span class="hljs-string">"insert into employee(last_name, email,gender,department,birth)"</span> +                <span class="hljs-string">" values ('狂神说','24736743@qq.com',1,101,'"</span>+ <span class="hljs-keyword">new</span> Date().toLocaleString() +<span class="hljs-string">"')"</span>;        jdbcTemplate.update(sql);        <span class="hljs-comment">//查询</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">"addOk"</span>;    }    <span class="hljs-comment">//修改用户信息</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/update/{id}"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateUser</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> <span class="hljs-keyword">int</span> id)</span>{        <span class="hljs-comment">//插入语句</span>        String sql = <span class="hljs-string">"update employee set last_name=?,email=? where id="</span>+id;        <span class="hljs-comment">//数据</span>        Object[] objects = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">2</span>];        objects[<span class="hljs-number">0</span>] = <span class="hljs-string">"秦疆"</span>;        objects[<span class="hljs-number">1</span>] = <span class="hljs-string">"24736743@sina.com"</span>;        jdbcTemplate.update(sql,objects);        <span class="hljs-comment">//查询</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">"updateOk"</span>;    }    <span class="hljs-comment">//删除用户</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/delete/{id}"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">delUser</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> <span class="hljs-keyword">int</span> id)</span>{        <span class="hljs-comment">//插入语句</span>        String sql = <span class="hljs-string">"delete from employee where id=?"</span>;        jdbcTemplate.update(sql,id);        <span class="hljs-comment">//查询</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">"deleteOk"</span>;    }    }</code></pre><p>测试请求，结果正常；</p><p>到此，CURD的基本操作，使用 JDBC 就搞定了。<a href="https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#using-boot-starter" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#using-boot-starter</a>)</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="7-5、原理探究-："><a href="#7-5、原理探究-：" class="headerlink" title="7.5、原理探究 ："></a>7.5、原理探究 ：</h2><p>org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration 数据源配置类作用 ：根据逻辑判断之后，添加数据源；</p><p><strong>SpringBoot默认支持以下数据源：</strong></p><p><strong>com.zaxxer.hikari.HikariDataSource （Spring Boot 2.0 以上，默认使用此数据源）</strong></p><p>org.apache.tomcat.jdbc.pool.DataSource</p><p>org.apache.commons.dbcp2.BasicDataSource</p><p><strong>可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。默认情况下，它是从类路径自动检测的。</strong></p><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><span class="hljs-variable">@ConditionalOnMissingBean</span>({DataSource.class})<span class="hljs-variable">@ConditionalOnProperty</span>(    name = {<span class="hljs-string">"spring.datasource.type"</span>})static class Generic {    <span class="hljs-selector-tag">Generic</span>() {    }    <span class="hljs-variable">@Bean</span>    public DataSource dataSource(DataSourceProperties properties) {        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">properties</span><span class="hljs-selector-class">.initializeDataSourceBuilder</span>()<span class="hljs-selector-class">.build</span>();    }}</code></pre><h1 id="8、SpringBoot整合Druid"><a href="#8、SpringBoot整合Druid" class="headerlink" title="8、SpringBoot整合Druid"></a>8、SpringBoot整合Druid</h1><h2 id="8-1、Druid简介"><a href="#8-1、Druid简介" class="headerlink" title="8.1、Druid简介"></a>8.1、Druid简介</h2><p>Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。</p><p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。</p><p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p><p>Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。</p><p>Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。</p><p>Github地址：<a href="https://github.com/alibaba/druid/" target="_blank" rel="noopener">https://github.com/alibaba/druid/</a></p><p><strong>com.alibaba.druid.pool.DruidDataSource 基本配置参数如下：</strong></p><table><thead><tr><th>配置</th><th>缺省值</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td></td><td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-“ + System.identityHashCode(this). 另外配置此属性至少在1.0.5版本中是不起作用的，强行设置name会出错 <a href="http://blog.csdn.net/lanmo555/article/details/41248763" target="_blank" rel="noopener">详情-点此处</a>。</td></tr><tr><td>url</td><td></td><td>连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td></tr><tr><td>username</td><td></td><td>连接数据库的用户名</td></tr><tr><td>password</td><td></td><td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/使用ConfigFilter" target="_blank" rel="noopener">https://github.com/alibaba/druid/wiki/使用ConfigFilter</a></td></tr><tr><td>driverClassName</td><td>根据url自动识别</td><td>这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName</td></tr><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td></tr><tr><td>maxActive</td><td>8</td><td>最大连接池数量</td></tr><tr><td>maxIdle</td><td>8</td><td>已经不再使用，配置了也没效果</td></tr><tr><td>minIdle</td><td></td><td>最小连接池数量</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td></tr><tr><td>maxOpenPreparedStatements</td><td>-1</td><td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td></tr><tr><td>validationQuery</td><td></td><td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td></tr><tr><td>validationQueryTimeout</td><td></td><td>单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法</td></tr><tr><td>testOnBorrow</td><td>true</td><td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testOnReturn</td><td>false</td><td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td></tr><tr><td>testWhileIdle</td><td>false</td><td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td>1分钟（1.0.14）</td><td>有两个含义： 1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td></tr><tr><td>numTestsPerEvictionRun</td><td></td><td>不再使用，一个DruidDataSource只支持一个EvictionRun</td></tr><tr><td>minEvictableIdleTimeMillis</td><td>30分钟（1.0.14）</td><td>连接保持空闲而不被驱逐的最长时间</td></tr><tr><td>connectionInitSqls</td><td></td><td>物理连接初始化的时候执行的sql</td></tr><tr><td>exceptionSorter</td><td>根据dbType自动识别</td><td>当数据库抛出一些不可恢复的异常时，抛弃连接</td></tr><tr><td>filters</td><td></td><td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat 日志用的filter:log4j 防御sql注入的filter:wall</td></tr><tr><td>proxyFilters</td><td></td><td>类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td></tr></tbody></table><h2 id="8-2、配置数据源"><a href="#8-2、配置数据源" class="headerlink" title="8.2、配置数据源"></a>8.2、配置数据源</h2><p>1、添加上 Druid 数据源依赖。</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>2、切换数据源；之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以 通过 spring.datasource.type 指定数据源。</p><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span> <span class="hljs-comment"># 自定义数据源</span></code></pre><p>3、数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换；</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412223942091-598892546.png" srcset="/blog/img/loading.gif" alt="img"></p><p>4、切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码</p><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>    <span class="hljs-comment">#?serverTimezone=UTC解决时区的报错</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>    <span class="hljs-comment">#Spring Boot 默认是不注入这些属性值的，需要自己绑定</span>    <span class="hljs-comment">#druid 数据源专有配置</span>    <span class="hljs-attr">initialSize:</span> <span class="hljs-number">5</span>    <span class="hljs-attr">minIdle:</span> <span class="hljs-number">5</span>    <span class="hljs-attr">maxActive:</span> <span class="hljs-number">20</span>    <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span>    <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span>    <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span>    <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span>    <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">poolPreparedStatements:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment">#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span>    <span class="hljs-comment">#如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span>    <span class="hljs-comment">#则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j</span>    <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall,log4j</span>    <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="hljs-number">20</span>    <span class="hljs-attr">useGlobalDataSourceStat:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">connectionProperties:</span> <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></code></pre><p>5、导入Log4j 的依赖</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>6、现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性；</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.config;<span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSource;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> javax.sql.DataSource;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>{    <span class="hljs-comment">/*</span><span class="hljs-comment">       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建</span><span class="hljs-comment">       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效</span><span class="hljs-comment">       @ConfigurationProperties(prefix = "spring.datasource")：作用就是将 全局配置文件中</span><span class="hljs-comment">       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();    }}</code></pre><p>7、去测试类中测试一下；看是否成功！</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootDataJdbcApplicationTests</span> </span>{    <span class="hljs-comment">//DI注入数据源</span>    <span class="hljs-meta">@Autowired</span>    DataSource dataSource;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>{        <span class="hljs-comment">//看一下默认数据源</span>        System.out.println(dataSource.getClass());        <span class="hljs-comment">//获得连接</span>        Connection connection =   dataSource.getConnection();        System.out.println(connection);        DruidDataSource druidDataSource = (DruidDataSource) dataSource;        System.out.println(<span class="hljs-string">"druidDataSource 数据源最大连接数："</span> + druidDataSource.getMaxActive());        System.out.println(<span class="hljs-string">"druidDataSource 数据源初始化连接数："</span> + druidDataSource.getInitialSize());        <span class="hljs-comment">//关闭连接</span>        connection.close();    }}</code></pre><p>输出结果 ：可见配置参数已经生效！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412224035706-1280927557.png" srcset="/blog/img/loading.gif" alt="img"></p><h2 id="8-3、配置Druid数据源监控"><a href="#8-3、配置Druid数据源监控" class="headerlink" title="8.3、配置Druid数据源监控"></a>8.3、配置Druid数据源监控</h2><p>Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。</p><p>所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；</p><pre><code class="hljs java"><span class="hljs-comment">//配置 Druid 监控管理后台的Servlet；</span><span class="hljs-comment">//内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">statViewServlet</span><span class="hljs-params">()</span> </span>{    ServletRegistrationBean bean = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> StatViewServlet(), <span class="hljs-string">"/druid/*"</span>);    <span class="hljs-comment">// 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet </span>    <span class="hljs-comment">// 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到</span>    Map&lt;String, String&gt; initParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    initParams.put(<span class="hljs-string">"loginUsername"</span>, <span class="hljs-string">"admin"</span>); <span class="hljs-comment">//后台管理界面的登录账号</span>    initParams.put(<span class="hljs-string">"loginPassword"</span>, <span class="hljs-string">"123456"</span>); <span class="hljs-comment">//后台管理界面的登录密码</span>    <span class="hljs-comment">//后台允许谁可以访问</span>    <span class="hljs-comment">//initParams.put("allow", "localhost")：表示只有本机可以访问</span>    <span class="hljs-comment">//initParams.put("allow", "")：为空或者为null时，表示允许所有访问</span>    initParams.put(<span class="hljs-string">"allow"</span>, <span class="hljs-string">""</span>);    <span class="hljs-comment">//deny：Druid 后台拒绝谁访问</span>    <span class="hljs-comment">//initParams.put("kuangshen", "192.168.1.20");表示禁止此ip访问</span>    <span class="hljs-comment">//设置初始化参数</span>    bean.setInitParameters(initParams);    <span class="hljs-keyword">return</span> bean;}</code></pre><p>配置完毕后，我们可以选择访问 ：<a href="http://localhost:8080/druid/login.html" target="_blank" rel="noopener">http://localhost:8080/druid/login.html</a></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412224112471-646829041.png" srcset="/blog/img/loading.gif" alt="img"></p><p>进入之后</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412224131010-12963631.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>配置 Druid web 监控 filter 过滤器</strong></p><pre><code class="hljs java"><span class="hljs-comment">//配置 Druid 监控 之  web 监控的 filter</span><span class="hljs-comment">//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">webStatFilter</span><span class="hljs-params">()</span> </span>{    FilterRegistrationBean bean = <span class="hljs-keyword">new</span> FilterRegistrationBean();    bean.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());    <span class="hljs-comment">//exclusions：设置哪些请求进行过滤排除掉，从而不进行统计</span>    Map&lt;String, String&gt; initParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    initParams.put(<span class="hljs-string">"exclusions"</span>, <span class="hljs-string">"*.js,*.css,/druid/*,/jdbc/*"</span>);    bean.setInitParameters(initParams);    <span class="hljs-comment">//"/*" 表示过滤所有请求</span>    bean.setUrlPatterns(Arrays.asList(<span class="hljs-string">"/*"</span>));    <span class="hljs-keyword">return</span> bean;}</code></pre><p>平时在工作中，按需求进行配置即可，主要用作监</p><h1 id="9、SpringBoot-整合mybatis"><a href="#9、SpringBoot-整合mybatis" class="headerlink" title="9、SpringBoot 整合mybatis"></a>9、SpringBoot 整合mybatis</h1><h2 id="9-1、导入mybatis所需要的依赖"><a href="#9-1、导入mybatis所需要的依赖" class="headerlink" title="9.1、导入mybatis所需要的依赖"></a><strong>9.1、导入mybatis所需要的依赖</strong></h2><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入 myBatis，这是 MyBatis官方提供的适配 Spring Boot 的，而不是Spring Boot自己的--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="9-2、配置数据库连接信息"><a href="#9-2、配置数据库连接信息" class="headerlink" title="9.2、配置数据库连接信息"></a><strong>9.2、配置数据库连接信息</strong></h2><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">123456</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span></code></pre><h2 id="9-3、我们这里就是用默认的数据源了；先去测试一下连接是否成功！"><a href="#9-3、我们这里就是用默认的数据源了；先去测试一下连接是否成功！" class="headerlink" title="9.3、我们这里就是用默认的数据源了；先去测试一下连接是否成功！"></a>9.3、我们这里就是用默认的数据源了；先去测试一下连接是否成功！</h2><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">SpringbootDemoMybatisApplicationTests</span> </span>{    <span class="hljs-meta">@Autowired</span>    DataSource dataSource;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>{        System.out.println(<span class="hljs-string">"数据源&gt;&gt;&gt;&gt;&gt;&gt;"</span> + dataSource.getClass());        Connection connection = dataSource.getConnection();        System.out.println(<span class="hljs-string">"连接&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span> + connection);        System.out.println(<span class="hljs-string">"连接地址&gt;&gt;&gt;&gt;&gt;"</span> + connection.getMetaData().getURL());        connection.close();    }}</code></pre><p><strong>查看输出结果，数据库配置OK！</strong></p><h2 id="9-4、创建实体类"><a href="#9-4、创建实体类" class="headerlink" title="9.4、创建实体类"></a><strong>9.4、创建实体类</strong></h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.mybatis.pojo;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String pwd;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>{    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, String pwd)</span> </span>{        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.pwd = pwd;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> id;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>{        <span class="hljs-keyword">this</span>.id = id;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> name;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{        <span class="hljs-keyword">this</span>.name = name;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPwd</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> pwd;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPwd</span><span class="hljs-params">(String pwd)</span> </span>{        <span class="hljs-keyword">this</span>.pwd = pwd;    }    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"User{"</span> +                <span class="hljs-string">"id="</span> + id +                <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", pwd='"</span> + pwd + <span class="hljs-string">'\''</span> +                <span class="hljs-string">'}'</span>;    }}</code></pre><h2 id="9-5、配置Mapper接口类"><a href="#9-5、配置Mapper接口类" class="headerlink" title="9.5、配置Mapper接口类"></a>9.5、配置Mapper接口类</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.mybatis.pojo.mapper;<span class="hljs-keyword">import</span> com.kuang.mybatis.pojo.User;<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">//@Mapper : 表示本类是一个 MyBatis 的 Mapper，等价于以前 Spring 整合 MyBatis 时的 Mapper 接口</span><span class="hljs-meta">@Mapper</span><span class="hljs-meta">@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>{    <span class="hljs-comment">//选择全部用户</span>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">selectUser</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//根据id选择用户</span>    <span class="hljs-function">User <span class="hljs-title">selectUserById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;    <span class="hljs-comment">//添加一个用户</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-comment">//修改一个用户</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-comment">//根据id删除用户</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;}</code></pre><h2 id="9-6、对应Mapper映射文件"><a href="#9-6、对应Mapper映射文件" class="headerlink" title="9.6、对应Mapper映射文件"></a>9.6、对应Mapper映射文件</h2><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE mapper</span><span class="hljs-meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span><span class="hljs-meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.kuang.mybatis.pojo.mapper.UserMapper"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectUser"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"User"</span>&gt;</span>    select * from user  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectUserById"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"User"</span>&gt;</span>    select * from user where id = #{id}<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"addUser"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"User"</span>&gt;</span>    insert into user (id,name,pwd) values (#{id},#{name},#{pwd})<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateUser"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"User"</span>&gt;</span>    update user set name=#{name},pwd=#{pwd} where id = #{id}<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"deleteUser"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"int"</span>&gt;</span>    delete from user where id = #{id}<span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><h2 id="9-7、maven配置资源过滤问题"><a href="#9-7、maven配置资源过滤问题" class="headerlink" title="9.7、maven配置资源过滤问题"></a>9.7、maven配置资源过滤问题</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre><h2 id="9-8、SpringBoot-整合！"><a href="#9-8、SpringBoot-整合！" class="headerlink" title="9.8、SpringBoot 整合！"></a>9.8、SpringBoot 整合！</h2><p>以前 MyBatis 未与 spring 整合时，配置数据源、事务、连接数据库的账号、密码等都是在 myBatis 核心配置文件中进行的myBatis 与 spring 整合后，配置数据源、事务、连接数据库的账号、密码等就交由 spring 管理。因此，在这里我们即使不使用mybatis配置文件也完全ok！<br><strong>既然已经提供了 myBatis 的映射配置文件，自然要告诉 spring boot 这些文件的位置</strong></p><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">123456</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-comment">#指定myBatis的核心配置文件与Mapper映射文件</span><span class="hljs-meta">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mybatis/mapper/*.xml</span><span class="hljs-comment"># 注意：对应实体类的路径</span><span class="hljs-meta">mybatis.type-aliases-package</span>=<span class="hljs-string">com.kuang.mybatis.pojo</span></code></pre><p>已经说过 spring boot 官方并没有提供 myBaits 的启动器，是 myBatis 官方提供的开发包来适配的 spring boot，从 pom.xml 文件中的依赖包名也能看出来，并非是以 spring-boot 开头的；</p><p>同理上面全局配置文件中的这两行配置也是以 mybatis 开头 而非 spring 开头也充分说明这些都是 myBatis 官方提供的</p><p>可以从 org.mybatis.spring.boot.autoconfigure.MybatisProperties 中查看所有配置项</p><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties</span>(    prefix = <span class="hljs-string">"mybatis"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisProperties</span> </span>{    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MYBATIS_PREFIX = <span class="hljs-string">"mybatis"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ResourcePatternResolver resourceResolver = <span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver();    <span class="hljs-keyword">private</span> String configLocation;    <span class="hljs-keyword">private</span> String[] mapperLocations;    <span class="hljs-keyword">private</span> String typeAliasesPackage;    <span class="hljs-keyword">private</span> Class&lt;?&gt; typeAliasesSuperType;    <span class="hljs-keyword">private</span> String typeHandlersPackage;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> checkConfigLocation = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">private</span> ExecutorType executorType;    <span class="hljs-keyword">private</span> Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageDriver;    <span class="hljs-keyword">private</span> Properties configurationProperties;    <span class="hljs-meta">@NestedConfigurationProperty</span>    <span class="hljs-keyword">private</span> Configuration configuration;</code></pre><p>也可以直接去查看 <a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">官方文档</a></p><h2 id="9-9、编写controller"><a href="#9-9、编写controller" class="headerlink" title="9.9、编写controller"></a>9.9、编写controller</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.mybatis.controller;<span class="hljs-keyword">import</span> com.kuang.mybatis.pojo.User;<span class="hljs-keyword">import</span> com.kuang.mybatis.pojo.mapper.UserMapper;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>{    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserMapper userMapper;    <span class="hljs-comment">//选择全部用户</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/selectUser"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">selectUser</span><span class="hljs-params">()</span></span>{        List&lt;User&gt; users = userMapper.selectUser();        <span class="hljs-keyword">for</span> (User user : users) {            System.out.println(user);        }        <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;    }    <span class="hljs-comment">//根据id选择用户</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/selectUserById"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">selectUserById</span><span class="hljs-params">()</span></span>{        User user = userMapper.selectUserById(<span class="hljs-number">1</span>);        System.out.println(user);        <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;    }    <span class="hljs-comment">//添加一个用户</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/addUser"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addUser</span><span class="hljs-params">()</span></span>{        userMapper.addUser(<span class="hljs-keyword">new</span> User(<span class="hljs-number">5</span>,<span class="hljs-string">"阿毛"</span>,<span class="hljs-string">"456789"</span>));        <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;    }    <span class="hljs-comment">//修改一个用户</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/updateUser"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateUser</span><span class="hljs-params">()</span></span>{        userMapper.updateUser(<span class="hljs-keyword">new</span> User(<span class="hljs-number">5</span>,<span class="hljs-string">"阿毛"</span>,<span class="hljs-string">"421319"</span>));        <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;    }    <span class="hljs-comment">//根据id删除用户</span>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/deleteUser"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deleteUser</span><span class="hljs-params">()</span></span>{        userMapper.deleteUser(<span class="hljs-number">5</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">"ok"</span>;    }}</code></pre><h2 id="9-10、启动项目访问进行测试！"><a href="#9-10、启动项目访问进行测试！" class="headerlink" title="9.10、启动项目访问进行测试！"></a><strong>9.10、启动项目访问进行测试！</strong></h2><p><strong>步骤：</strong></p><p>Mybatis整合包</p><p>mybatis-spring-boot-starter</p><p>1.导入包</p><p>2.配置文件</p><p>3.mybatis配置</p><p>4.编写sql</p><p>5.service层调用dao层</p><p>6.controller调用service层</p><h2 id="注：配置数据库连接信息（不变）"><a href="#注：配置数据库连接信息（不变）" class="headerlink" title="注：配置数据库连接信息（不变）"></a><strong>注：配置数据库连接信息（不变）</strong></h2><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>    <span class="hljs-comment">#?serverTimezone=UTC解决时区的报错</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>    <span class="hljs-comment">#Spring Boot 默认是不注入这些属性值的，需要自己绑定</span>    <span class="hljs-comment">#druid 数据源专有配置</span>    <span class="hljs-attr">initialSize:</span> <span class="hljs-number">5</span>    <span class="hljs-attr">minIdle:</span> <span class="hljs-number">5</span>    <span class="hljs-attr">maxActive:</span> <span class="hljs-number">20</span>    <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span>    <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span>    <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span>    <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span>    <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">poolPreparedStatements:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment">#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span>    <span class="hljs-comment">#如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span>    <span class="hljs-comment">#则导入 log4j 依赖即可，Maven 地址： https://mvnrepository.com/artifact/log4j/log4j</span>    <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall,log4j</span>    <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="hljs-number">20</span>    <span class="hljs-attr">useGlobalDataSourceStat:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">connectionProperties:</span> <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></code></pre><h1 id="10、SpringBoot：Web开发静态资源处理"><a href="#10、SpringBoot：Web开发静态资源处理" class="headerlink" title="10、SpringBoot：Web开发静态资源处理"></a>10、SpringBoot：Web开发静态资源处理</h1><p>Web开发探究</p><h2 id="10-1、简介"><a href="#10-1、简介" class="headerlink" title="10.1、简介"></a>10.1、简介</h2><p>好的，同学们，那么接下来呢，我们开始学习SpringBoot与Web开发，从这一章往后，就属于我们实战部分的内容了；</p><p>其实SpringBoot的东西用起来非常简单，因为SpringBoot最大的特点就是自动装配。</p><p><strong>使用SpringBoot的步骤：</strong></p><p>1、创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好</p><p>2、手动在配置文件中配置部分配置项目就可以运行起来了</p><p>3、专注编写业务代码，不需要考虑以前那样一大堆的配置了。</p><p>要熟悉掌握开发，之前学习的自动配置的原理一定要搞明白！</p><p>比如SpringBoot到底帮我们配置了什么？我们能不能修改？我们能修改哪些配置？我们能不能扩展？</p><ul><li>向容器中自动配置组件 ：*** Autoconfiguration</li><li>自动配置类，封装配置文件的内容：***Properties</li></ul><p>没事就找找类，看看自动装配原理！</p><p>我们之后来进行一个单体项目的小项目测试，让大家能够快速上手开发！</p><p>静态资源处理</p><h2 id="10-2、静态资源映射规则"><a href="#10-2、静态资源映射规则" class="headerlink" title="10.2、静态资源映射规则"></a>10.2、静态资源映射规则</h2><p><strong>首先，我们搭建一个普通的SpringBoot项目，回顾一下HelloWorld程序！</strong></p><p>写请求非常简单，那我们要引入我们前端资源，我们项目中有许多的静态资源，比如css，js等文件，这个SpringBoot怎么处理呢？</p><p>如果我们是一个web应用，我们的main下会有一个webapp，我们以前都是将所有的页面导在这里面的，对吧！但是我们现在的pom呢，打包方式是为jar的方式，那么这种方式SpringBoot能不能来给我们写页面呢？当然是可以的，但是SpringBoot对于静态资源放置的位置，是有规定的！</p><p><strong>我们先来聊聊这个静态资源映射规则：</strong></p><p>SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面；</p><p>我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法；</p><p>有一个方法：addResourceHandlers 添加资源处理</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>{    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resourceProperties.isAddMappings()) {        <span class="hljs-comment">// 已禁用默认资源处理</span>        logger.debug(<span class="hljs-string">"Default resource handling disabled"</span>);        <span class="hljs-keyword">return</span>;    }    <span class="hljs-comment">// 缓存控制</span>    Duration cachePeriod = <span class="hljs-keyword">this</span>.resourceProperties.getCache().getPeriod();    CacheControl cacheControl = <span class="hljs-keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();    <span class="hljs-comment">// webjars 配置</span>    <span class="hljs-keyword">if</span> (!registry.hasMappingForPattern(<span class="hljs-string">"/webjars/**"</span>)) {        customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="hljs-string">"/webjars/**"</span>)                                             .addResourceLocations(<span class="hljs-string">"classpath:/META-INF/resources/webjars/"</span>)                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));    }    <span class="hljs-comment">// 静态资源配置</span>    String staticPathPattern = <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern();    <span class="hljs-keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) {        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)                                             .addResourceLocations(getResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations()))                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));    }}</code></pre><p>读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源；</p><h2 id="10-3、什么是webjars-呢？"><a href="#10-3、什么是webjars-呢？" class="headerlink" title="10.3、什么是webjars 呢？"></a>10.3、什么是webjars 呢？</h2><p>Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。</p><p>使用SpringBoot需要使用Webjars，我们可以去搜索一下：</p><p>网站：<a href="https://www.webjars.org/" target="_blank" rel="noopener">https://www.webjars.org</a></p><p>要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>导入完毕，查看webjars目录结构，并访问Jquery.js文件！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412224229426-796441519.png" srcset="/blog/img/loading.gif" alt="img"></p><p>访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：<a href="http://localhost:8080/webjars/jquery/3.4.1/jquery.js" target="_blank" rel="noopener">http://localhost:8080/webjars/jquery/3.4.1/jquery.js</a></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412224306836-344577320.png" srcset="/blog/img/loading.gif" alt="img"></p><h2 id="10-4、第二种静态资源映射规则"><a href="#10-4、第二种静态资源映射规则" class="headerlink" title="10.4、第二种静态资源映射规则"></a>10.4、第二种静态资源映射规则</h2><p>那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码；</p><p>我们去找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析：</p><pre><code class="hljs java"><span class="hljs-comment">// 进入方法</span><span class="hljs-keyword">public</span> String[] getStaticLocations() {    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.staticLocations;}<span class="hljs-comment">// 找到对应的值</span><span class="hljs-keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;<span class="hljs-comment">// 找到路径</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = {     <span class="hljs-string">"classpath:/META-INF/resources/"</span>,  <span class="hljs-string">"classpath:/resources/"</span>,     <span class="hljs-string">"classpath:/static/"</span>,     <span class="hljs-string">"classpath:/public/"</span> };</code></pre><p>ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。</p><p>所以得出结论，以下四个目录存放的静态资源可以被我们识别：</p><pre><code class="hljs java"><span class="hljs-string">"classpath:/META-INF/resources/"</span><span class="hljs-string">"classpath:/resources/"</span><span class="hljs-string">"classpath:/static/"</span><span class="hljs-string">"classpath:/public/"</span></code></pre><p>我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件；</p><p>比如我们访问 <a href="http://localhost:8080/1.js" target="_blank" rel="noopener">http://localhost:8080/1.js</a> , 他就会去这些文件夹中寻找对应的静态资源文件；</p><h2 id="10-5、自定义静态资源路径"><a href="#10-5、自定义静态资源路径" class="headerlink" title="10.5、自定义静态资源路径"></a>10.5、自定义静态资源路径</h2><p>我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；</p><pre><code class="hljs properties"><span class="hljs-meta">spring.resources.static-locations</span>=<span class="hljs-string">classpath:/coding/,classpath:/kuang/</span></code></pre><p>一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！</p><p>首页处理</p><p>静态资源文件夹说完后，我们继续向下看源码！可以看到一个欢迎页的映射，就是我们的首页！</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> WelcomePageHandlerMapping <span class="hljs-title">welcomePageHandlerMapping</span><span class="hljs-params">(ApplicationContext applicationContext, FormattingConversionService mvcConversionService,ResourceUrlProvider mvcResourceUrlProvider)</span> </span>{    WelcomePageHandlerMapping welcomePageHandlerMapping = <span class="hljs-keyword">new</span> WelcomePageHandlerMapping(        <span class="hljs-keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), <span class="hljs-comment">// getWelcomePage 获得欢迎页</span>        <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern());    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));    <span class="hljs-keyword">return</span> welcomePageHandlerMapping;}</code></pre><p>点进去继续看</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Optional&lt;Resource&gt; <span class="hljs-title">getWelcomePage</span><span class="hljs-params">()</span> </span>{    String[] locations = getResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations());    <span class="hljs-comment">// ::是java8 中新引入的运算符</span>    <span class="hljs-comment">// Class::function的时候function是属于Class的，应该是静态方法。</span>    <span class="hljs-comment">// this::function的funtion是属于这个对象的。</span>    <span class="hljs-comment">// 简而言之，就是一种语法糖而已，是一种简写</span>    <span class="hljs-keyword">return</span> Arrays.stream(locations).map(<span class="hljs-keyword">this</span>::getIndexHtml).filter(<span class="hljs-keyword">this</span>::isReadable).findFirst();}<span class="hljs-comment">// 欢迎页就是一个location下的的 index.html 而已</span><span class="hljs-function"><span class="hljs-keyword">private</span> Resource <span class="hljs-title">getIndexHtml</span><span class="hljs-params">(String location)</span> </span>{    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resourceLoader.getResource(location + <span class="hljs-string">"index.html"</span>);}</code></pre><p>欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。</p><p>比如我访问 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> ，就会找静态资源文件夹下的 index.html</p><p>新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 看结果！</p><p><strong>关于网站图标说明</strong>：</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412224327971-166301362.png" srcset="/blog/img/loading.gif" alt="img"></p><p>与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。</p><p>1、关闭SpringBoot默认图标</p><pre><code class="hljs properties"><span class="hljs-comment">#关闭默认图标spring.mvc.favicon.enabled=false</span></code></pre><p>2、自己放一个图标在静态资源目录下，我放在 public 目录下</p><p>3、清除浏览器缓存！刷新网页，发现图标已经变成自己的了！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412224343431-2144081992.png" srcset="/blog/img/loading.gif" alt="img"></p><h1 id="11、SpringBoot：Thymeleaf模板引擎"><a href="#11、SpringBoot：Thymeleaf模板引擎" class="headerlink" title="11、SpringBoot：Thymeleaf模板引擎"></a>11、SpringBoot：Thymeleaf模板引擎</h1><h2 id="11-1、模板引擎"><a href="#11-1、模板引擎" class="headerlink" title="11.1、模板引擎"></a>11.1、模板引擎</h2><p>前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。</p><p>jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，<strong>他现在默认是不支持jsp的</strong>。</p><p>那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？</p><p><strong>SpringBoot推荐你可以来使用模板引擎：</strong></p><p>模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图：</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412224715664-994768786.png" srcset="/blog/img/loading.gif" alt="img"></p><p>模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。</p><p>我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。</p><h2 id="11-2、引入Thymeleaf"><a href="#11-2、引入Thymeleaf" class="headerlink" title="11.2、引入Thymeleaf"></a>11.2、引入Thymeleaf</h2><p>怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址：</p><p>Thymeleaf 官网：<a href="https://www.thymeleaf.org/" target="_blank" rel="noopener">https://www.thymeleaf.org/</a></p><p>Thymeleaf 在Github 的主页：<a href="https://github.com/thymeleaf/thymeleaf" target="_blank" rel="noopener">https://github.com/thymeleaf/thymeleaf</a></p><p>Spring官方文档：找到我们对应的版本</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a></p><p>找到对应的pom依赖：可以适当点进源码看下本来的包！</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--thymeleaf--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>Maven会自动下载jar包，我们可以去看下下载的东西；</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412224749784-1143746028.png" srcset="/blog/img/loading.gif" alt="img"></p><h2 id="11-3、Thymeleaf分析"><a href="#11-3、Thymeleaf分析" class="headerlink" title="11.3、Thymeleaf分析"></a>11.3、Thymeleaf分析</h2><p>前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？</p><p>我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。</p><p>我们去找一下Thymeleaf的自动配置类：ThymeleafPropert</p><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties</span>(    prefix = <span class="hljs-string">"spring.thymeleaf"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThymeleafProperties</span> </span>{    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset DEFAULT_ENCODING;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">"classpath:/templates/"</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">".html"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> checkTemplate = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> checkTemplateLocation = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">private</span> String prefix = <span class="hljs-string">"classpath:/templates/"</span>;    <span class="hljs-keyword">private</span> String suffix = <span class="hljs-string">".html"</span>;    <span class="hljs-keyword">private</span> String mode = <span class="hljs-string">"HTML"</span>;    <span class="hljs-keyword">private</span> Charset encoding;}</code></pre><p>我们可以在其中看到默认的前缀和后缀！</p><p>我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。</p><p>使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！</p><p><strong>测试</strong></p><p>1、编写一个TestController</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>{        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/t1"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>{        <span class="hljs-comment">//classpath:/templates/test.html</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">"test"</span>;    }    }</code></pre><p>2、编写一个测试页面 test.html 放在 templates 目录下</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>测试页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>3、启动项目请求测试</p><h2 id="11-4、Thymeleaf-语法学习"><a href="#11-4、Thymeleaf-语法学习" class="headerlink" title="11.4、Thymeleaf 语法学习"></a>11.4、Thymeleaf 语法学习</h2><p>要学习语法，还是参考官网文档最为准确，我们找到对应的版本看一下；</p><p>Thymeleaf 官网：<a href="https://www.thymeleaf.org/" target="_blank" rel="noopener">https://www.thymeleaf.org/</a> ， 简单看一下官网！我们去下载Thymeleaf的官方文档！</p><p><strong>我们做个最简单的练习 ：我们需要查出一些数据，在页面中展示</strong></p><p>1、修改测试请求，增加数据传输；</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/t1"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test1</span><span class="hljs-params">(Model model)</span></span>{    <span class="hljs-comment">//存入数据</span>    model.addAttribute(<span class="hljs-string">"msg"</span>,<span class="hljs-string">"Hello,Thymeleaf"</span>);    <span class="hljs-comment">//classpath:/templates/test.html</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"test"</span>;}</code></pre><p>2、我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。</p><p>我们可以去官方文档的#3中看一下命名空间拿来过来：</p><pre><code class="hljs html">xmlns:th="http://www.thymeleaf.org"</code></pre><p>3、我们去编写下前端页面</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>狂神说<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>测试页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-comment">&lt;!--th:text就是将div中的内容设置为它指定的值，和之前学习的Vue一样--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${msg}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>4、启动测试！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412224807885-1463858775.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>OK，入门搞定，我们来认真研习一下Thymeleaf的使用语法！</strong></p><p><strong>1、我们可以使用任意的 th:attr 来替换Html中原生属性的值！</strong></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412224828773-2028075377.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>2、我们能写哪些表达式呢？</strong></p><pre><code class="hljs java">Simple expressions:（表达式语法）Variable Expressions: ${...}：获取变量值；OGNL；    <span class="hljs-number">1</span>）、获取对象的属性、调用方法    2）、使用内置的基本对象：#18         #ctx : the context object.         #vars: the context variables.         #locale : the context locale.         #request : (only in Web Contexts) the HttpServletRequest object.         #response : (only in Web Contexts) the HttpServletResponse object.         #session : (only in Web Contexts) the HttpSession object.         #servletContext : (only in Web Contexts) the ServletContext object.    <span class="hljs-number">3</span>）、内置的一些工具对象：　　　　　　#execInfo : information about the template being processed.　　　　　　#uris : methods for escaping parts of URLs/URIs　　　　　　#conversions : methods for executing the configured conversion service (if any).　　　　　　#dates : methods for java.util.Date objects: formatting, component extraction, etc.　　　　　　#calendars : analogous to #dates , but for java.util.Calendar objects.　　　　　　#numbers : methods for formatting numeric objects.　　　　　　#strings : methods for String objects: contains, startsWith, prepending/appending, etc.　　　　　　#objects : methods for objects in general.　　　　　　#bools : methods for boolean evaluation.　　　　　　#arrays : methods for arrays.　　　　　　#lists : methods for lists.　　　　　　#sets : methods for sets.　　　　　　#maps : methods for maps.　　　　　　#aggregates : methods for creating aggregates on arrays or collections.==================================================================================  Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样；  Message Expressions: #{...}：获取国际化内容  Link URL Expressions: @{...}：定义URL；  Fragment Expressions: ~{...}：片段引用表达式Literals（字面量）      Text literals: <span class="hljs-string">'one text'</span> , <span class="hljs-string">'Another one!'</span> ,…      Number literals: <span class="hljs-number">0</span> , <span class="hljs-number">34</span> , <span class="hljs-number">3.0</span> , <span class="hljs-number">12.3</span> ,…      Boolean literals: <span class="hljs-keyword">true</span> , <span class="hljs-keyword">false</span>      Null literal: <span class="hljs-keyword">null</span>      Literal tokens: one , sometext , main ,…      Text operations:（文本操作）    String concatenation: +    Literal substitutions: |The name is ${name}|    Arithmetic operations:（数学运算）    Binary operators: + , - , * , / , %    <span class="hljs-function">Minus <span class="hljs-title">sign</span> <span class="hljs-params">(unary operator)</span>: -</span><span class="hljs-function">    </span><span class="hljs-function">Boolean operations:（布尔运算）</span><span class="hljs-function">    Binary operators: and , or</span><span class="hljs-function">    Boolean <span class="hljs-title">negation</span> <span class="hljs-params">(unary operator)</span>: ! , not</span><span class="hljs-function">    </span><span class="hljs-function">Comparisons and equality:（比较运算）</span><span class="hljs-function">    Comparators: &gt; , &lt; , &gt;</span>= , &lt;= ( gt , lt , ge , le )    Equality operators: == , != ( eq , ne )    Conditional operators:条件运算（三元运算符）    If-then: (<span class="hljs-keyword">if</span>) ? (then)    If-then-<span class="hljs-keyword">else</span>: (<span class="hljs-keyword">if</span>) ? (then) : (<span class="hljs-keyword">else</span>)    Default: (value) ?: (defaultvalue)    Special tokens:    No-Operation: _</code></pre><p><strong>练习测试：</strong></p><p>1、 我们编写一个Controller，放一些数据</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/t2"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test2</span><span class="hljs-params">(Map&lt;String,Object&gt; map)</span></span>{    <span class="hljs-comment">//存入数据</span>    map.put(<span class="hljs-string">"msg"</span>,<span class="hljs-string">"&lt;h1&gt;Hello&lt;/h1&gt;"</span>);    map.put(<span class="hljs-string">"users"</span>, Arrays.asList(<span class="hljs-string">"qinjiang"</span>,<span class="hljs-string">"kuangshen"</span>));    <span class="hljs-comment">//classpath:/templates/test.html</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"test"</span>;}</code></pre><p>2、测试页面取出数据</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>狂神说<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>测试页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${msg}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!--不转义--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:utext</span>=<span class="hljs-string">"${msg}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!--遍历数据--&gt;</span><span class="hljs-comment">&lt;!--th:each每次遍历都会生成当前这个标签：官网#9--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"user :${users}"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${user}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>    <span class="hljs-comment">&lt;!--行内写法：官网#12--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"user:${users}"</span>&gt;</span>[[${user}]]<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>3、启动项目测试！</p><p><strong>我们看完语法，很多样式，我们即使现在学习了，也会忘记，所以我们在学习过程中，需要使用什么，根据官方文档来查询，才是最重要的，要熟练使用官方文档！</strong></p><h1 id="12、SpringBoot：MVC自动配置原理"><a href="#12、SpringBoot：MVC自动配置原理" class="headerlink" title="12、SpringBoot：MVC自动配置原理"></a>12、SpringBoot：MVC自动配置原理</h1><h2 id="12-1、官网阅读"><a href="#12-1、官网阅读" class="headerlink" title="12.1、官网阅读"></a>12.1、官网阅读</h2><p>在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。</p><p>只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！</p><p>地址 ：<a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration</a></p><pre><code class="hljs java">Spring MVC Auto-configuration<span class="hljs-comment">// Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。</span>Spring Boot provides auto-configuration <span class="hljs-keyword">for</span> Spring MVC that works well with most applications.<span class="hljs-comment">// 自动配置在Spring默认设置的基础上添加了以下功能：</span>The auto-configuration adds the following features on top of Spring’s defaults:<span class="hljs-comment">// 包含视图解析器</span>Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.<span class="hljs-comment">// 支持静态资源文件夹的路径，以及webjars</span>Support <span class="hljs-keyword">for</span> serving <span class="hljs-keyword">static</span> resources, including support <span class="hljs-keyword">for</span> WebJars <span class="hljs-comment">// 自动注册了Converter：</span><span class="hljs-comment">// 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把"1"字符串自动转换为int类型</span><span class="hljs-comment">// Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】</span>Automatic registration of Converter, GenericConverter, and Formatter beans.<span class="hljs-comment">// HttpMessageConverters</span><span class="hljs-comment">// SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释；</span><span class="hljs-function">Support <span class="hljs-keyword">for</span> <span class="hljs-title">HttpMessageConverters</span> <span class="hljs-params">(covered later in <span class="hljs-keyword">this</span> document)</span>.</span><span class="hljs-function"><span class="hljs-comment">// 定义错误代码生成规则的</span></span><span class="hljs-function">Automatic registration of <span class="hljs-title">MessageCodesResolver</span> <span class="hljs-params">(covered later in <span class="hljs-keyword">this</span> document)</span>.</span><span class="hljs-function"><span class="hljs-comment">// 首页定制</span></span><span class="hljs-function">Static index.html support.</span><span class="hljs-function"><span class="hljs-comment">// 图标定制</span></span><span class="hljs-function">Custom Favicon <span class="hljs-title">support</span> <span class="hljs-params">(covered later in <span class="hljs-keyword">this</span> document)</span>.</span><span class="hljs-function"><span class="hljs-comment">// 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！</span></span><span class="hljs-function">Automatic use of a ConfigurableWebBindingInitializer <span class="hljs-title">bean</span> <span class="hljs-params">(covered later in <span class="hljs-keyword">this</span> document)</span>.</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-comment">/*</span></span><span class="hljs-function"><span class="hljs-comment">如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己</span></span><span class="hljs-function"><span class="hljs-comment">的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供</span></span><span class="hljs-function"><span class="hljs-comment">RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义</span></span><span class="hljs-function"><span class="hljs-comment">实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。</span></span><span class="hljs-function"><span class="hljs-comment">*/</span></span><span class="hljs-function">If you want to keep Spring Boot MVC features and you want to add additional MVC configuration </span><span class="hljs-function"><span class="hljs-params">(interceptors, formatters, view controllers, and other features)</span>, you can add your own </span><span class="hljs-function">@Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide </span><span class="hljs-function">custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or </span><span class="hljs-function">ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-comment">// 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。</span></span><span class="hljs-function">If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.</span></code></pre><p>我们来仔细对照，看一下它怎么实现的，它告诉我们SpringBoot已经帮我们自动配置好了SpringMVC，然后自动配置了哪些东西呢？</p><h2 id="12-2、ContentNegotiatingViewResolver-内容协商视图解析器"><a href="#12-2、ContentNegotiatingViewResolver-内容协商视图解析器" class="headerlink" title="12.2、ContentNegotiatingViewResolver 内容协商视图解析器"></a><strong>12.2、ContentNegotiatingViewResolver 内容协商视图解析器</strong></h2><p>自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器；</p><p>即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。</p><p>我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnBean</span>(ViewResolver<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnMissingBean</span>(<span class="hljs-title">name</span> </span>= <span class="hljs-string">"viewResolver"</span>, value = ContentNegotiatingViewResolver<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">ContentNegotiatingViewResolver</span> <span class="hljs-title">viewResolver</span>(<span class="hljs-title">BeanFactory</span> <span class="hljs-title">beanFactory</span>) </span>{    ContentNegotiatingViewResolver resolver = <span class="hljs-keyword">new</span> ContentNegotiatingViewResolver();    resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;    <span class="hljs-comment">// ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级</span>    resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);    <span class="hljs-keyword">return</span> resolver;}</code></pre><p>我们可以点进这类看看！找到对应的解析视图的代码；</p><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span> <span class="hljs-comment">// 注解说明：@Nullable 即参数可为null</span><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>{    RequestAttributes attrs = RequestContextHolder.getRequestAttributes();    Assert.state(attrs <span class="hljs-keyword">instanceof</span> ServletRequestAttributes, <span class="hljs-string">"No current ServletRequestAttributes"</span>);    List&lt;MediaType&gt; requestedMediaTypes = <span class="hljs-keyword">this</span>.getMediaTypes(((ServletRequestAttributes)attrs).getRequest());    <span class="hljs-keyword">if</span> (requestedMediaTypes != <span class="hljs-keyword">null</span>) {        <span class="hljs-comment">// 获取候选的视图对象</span>        List&lt;View&gt; candidateViews = <span class="hljs-keyword">this</span>.getCandidateViews(viewName, locale, requestedMediaTypes);        <span class="hljs-comment">// 选择一个最适合的视图对象，然后把这个对象返回</span>        View bestView = <span class="hljs-keyword">this</span>.getBestView(candidateViews, requestedMediaTypes, attrs);        <span class="hljs-keyword">if</span> (bestView != <span class="hljs-keyword">null</span>) {            <span class="hljs-keyword">return</span> bestView;        }    }    <span class="hljs-comment">// .....</span>}</code></pre><p>我们继续点进去看，他是怎么获得候选的视图的呢？</p><p>getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！</p><pre><code class="hljs java">Iterator var5 = <span class="hljs-keyword">this</span>.viewResolvers.iterator();</code></pre><p>所以得出结论：<strong>ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的</strong></p><p>我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initServletContext</span><span class="hljs-params">(ServletContext servletContext)</span> </span>{    <span class="hljs-comment">// 这里它是从beanFactory工具中获取容器中的所有视图解析器</span>    <span class="hljs-comment">// ViewRescolver.class 把所有的视图解析器来组合的</span>    Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(<span class="hljs-keyword">this</span>.obtainApplicationContext(), ViewResolver<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">values</span>()</span>;    ViewResolver viewResolver;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers == <span class="hljs-keyword">null</span>) {        <span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">new</span> ArrayList(matchingBeans.size());    }    <span class="hljs-comment">// ...............</span>}</code></pre><p>既然它是在容器中去找视图解析器，我们是否可以猜想，我们就可以去实现一个视图解析器了呢？</p><p>我们可以自己给容器中去添加一个视图解析器；这个类就会帮我们自动的将它组合进来；<strong>我们去实现一下</strong></p><p>1、我们在我们的主程序中去写一个视图解析器来试试；</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span> <span class="hljs-comment">//放到bean中</span><span class="hljs-function"><span class="hljs-keyword">public</span> ViewResolver <span class="hljs-title">myViewResolver</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyViewResolver();}<span class="hljs-comment">//我们写一个静态内部类，视图解析器就需要实现ViewResolver接口</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyViewResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewResolver</span></span>{    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String s, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>{        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    }}</code></pre><p>2、怎么看我们自己写的视图解析器有没有起作用呢？</p><p>我们给 DispatcherServlet 中的 doDispatch方法 加个断点进行调试一下，因为所有的请求都会走到这个方法中</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412224922244-774346297.png" srcset="/blog/img/loading.gif" alt="img"></p><p>3、我们启动我们的项目，然后随便访问一个页面，看一下Debug信息；</p><p>找到this</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412224940354-738491944.png" srcset="/blog/img/loading.gif" alt="img"></p><p>找到视图解析器，我们看到我们自己定义的就在这里了；</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412224955594-693958833.png" srcset="/blog/img/loading.gif" alt="img"></p><p>所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情SpringBoot就会帮我们做了！</p><h2 id="12-3、转换器和格式化器"><a href="#12-3、转换器和格式化器" class="headerlink" title="12.3、转换器和格式化器"></a>12.3、转换器和格式化器</h2><p>找到格式化转换器：</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> FormattingConversionService <span class="hljs-title">mvcConversionService</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">// 拿到配置文件中的格式化规则</span>    WebConversionService conversionService =         <span class="hljs-keyword">new</span> WebConversionService(<span class="hljs-keyword">this</span>.mvcProperties.getDateFormat());    addFormatters(conversionService);    <span class="hljs-keyword">return</span> conversionService;}</code></pre><p>点击去：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDateFormat</span><span class="hljs-params">()</span> </span>{    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.dateFormat;}<span class="hljs-comment">/**</span><span class="hljs-comment">* Date format to use. For instance, `dd/MM/yyyy`. 默认的</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> String dateFormat;</code></pre><p>可以看到在我们的Properties文件中，我们可以进行自动配置它！</p><p>如果配置了自己的格式化方式，就会注册到Bean中生效，我们可以在配置文件中配置日期格式化的规则：</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225016479-244888602.png" srcset="/blog/img/loading.gif" alt="img"></p><p>其余的就不一一举例了，大家可以下去多研究探讨即可！</p><h2 id="12-4、修改SpringBoot的默认配置"><a href="#12-4、修改SpringBoot的默认配置" class="headerlink" title="12.4、修改SpringBoot的默认配置"></a>12.4、修改SpringBoot的默认配置</h2><p>这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。</p><p>SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论；</p><p>SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的；</p><p>如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！</p><p><strong>扩展使用SpringMVC</strong> 官方文档如下：</p><p>If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.</p><p>我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig；</p><pre><code class="hljs java"><span class="hljs-comment">//应为类型要求为WebMvcConfigurer，所以我们实现其接口</span><span class="hljs-comment">//可以使用自定义类扩展MVC的功能</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>{        <span class="hljs-comment">// 浏览器发送/test ， 就会跳转到test页面；</span>        registry.addViewController(<span class="hljs-string">"/test"</span>).setViewName(<span class="hljs-string">"test"</span>);    }}</code></pre><p>我们去浏览器访问一下：</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225034989-1426302926.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>确实也跳转过来了！所以说，我们要扩展SpringMVC，官方就推荐我们这么去使用，既保SpringBoot留所有的自动配置，也能用我们扩展的配置！</strong></p><p>我们可以去分析一下原理：</p><p>1、WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter</p><p>2、这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class)</p><p>3、我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration</p><p>这个父类中有这样一段代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>{    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebMvcConfigurerComposite configurers = <span class="hljs-keyword">new</span> WebMvcConfigurerComposite();      <span class="hljs-comment">// 从容器中获取所有的webmvcConfigurer</span>    <span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConfigurers</span><span class="hljs-params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>{        <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(configurers)) {            <span class="hljs-keyword">this</span>.configurers.addWebMvcConfigurers(configurers);        }    }}</code></pre><p>4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>{    <span class="hljs-keyword">this</span>.configurers.addViewControllers(registry);}</code></pre><p>5、我们点进去看一下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>{    Iterator var2 = <span class="hljs-keyword">this</span>.delegates.iterator();    <span class="hljs-keyword">while</span>(var2.hasNext()) {        <span class="hljs-comment">// 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的</span>        WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next();        delegate.addViewControllers(registry);    }}</code></pre><p>所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用；</p><h2 id="12-5、全面接管SpringMVC"><a href="#12-5、全面接管SpringMVC" class="headerlink" title="12.5、全面接管SpringMVC"></a>12.5、全面接管SpringMVC</h2><p>官方文档：</p><pre><code class="hljs java">If you want to take complete control of Spring MVCyou can add your own <span class="hljs-meta">@Configuration</span> annotated with <span class="hljs-meta">@EnableWebMvc</span>.</code></pre><p>全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！</p><p>只需在我们的配置类中要加一个@EnableWebMvc。</p><p>我们看下如果我们全面接管了SpringMVC了，我们之前SpringBoot给我们配置的静态资源映射一定会无效，我们可以去测试一下；</p><p>不加注解之前，访问首页：</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225051724-1570792880.png" srcset="/blog/img/loading.gif" alt="img"></p><p>给配置类加上注解：@EnableWebMvc</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225103839-1070501209.png" srcset="/blog/img/loading.gif" alt="img"></p><p>我们发现所有的SpringMVC自动配置都失效了！回归到了最初的样子；</p><p><strong>当然，我们开发中，不推荐使用全面接管SpringMVC</strong></p><p>思考问题？为什么加了一个注解，自动配置就失效了！我们看下源码：</p><p>1、这里发现它是导入了一个类，我们可以继续进去看</p><pre><code class="hljs java"><span class="hljs-meta">@Import</span>({DelegatingWebMvcConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>})<span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableWebMvc</span> </span>{}</code></pre><p>2、它继承了一个父类 WebMvcConfigurationSupport</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>{  <span class="hljs-comment">// ......}</span></code></pre><p>3、我们来回顾一下Webmvc自动配置类</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)<span class="hljs-meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)<span class="hljs-meta">@ConditionalOnClass</span>({ Servlet<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">DispatcherServlet</span>.<span class="hljs-title">class</span>, <span class="hljs-title">WebMvcConfigurer</span>.<span class="hljs-title">class</span> })</span><span class="hljs-class">// 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnMissingBean</span>(<span class="hljs-title">WebMvcConfigurationSupport</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureOrder</span>(<span class="hljs-title">Ordered</span>.<span class="hljs-title">HIGHEST_PRECEDENCE</span> + 10)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureAfter</span>(</span>{ DispatcherServletAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">TaskExecutionAutoConfiguration</span>.<span class="hljs-title">class</span>,</span><span class="hljs-class">    <span class="hljs-title">ValidationAutoConfiguration</span>.<span class="hljs-title">class</span> })</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span> </span>{    }</code></pre><p>总结一句话：@EnableWebMvc将WebMvcConfigurationSupport组件导入进来了；</p><p>而导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能！</p><p><strong>在SpringBoot中会有非常多的扩展配置，只要看见了这个，我们就应该多留心注意~</strong></p><h1 id="13、SpringBoot：页面国际化"><a href="#13、SpringBoot：页面国际化" class="headerlink" title="13、SpringBoot：页面国际化"></a>13、SpringBoot：页面国际化</h1><p>有的时候，我们的网站会去涉及中英文甚至多语言的切换，这时候我们就需要学习国际化了！</p><h2 id="13-1、准备工作"><a href="#13-1、准备工作" class="headerlink" title="13.1、准备工作"></a>13.1、准备工作</h2><p>先在IDEA中统一设置properties的编码问题！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225128194-996554004.png" srcset="/blog/img/loading.gif" alt="img"></p><p>编写国际化配置文件，抽取页面需要显示的国际化页面消息。我们可以去登录页面查看一下，哪些内容我们需要编写国际化的配置！</p><h2 id="13-2、配置文件编写"><a href="#13-2、配置文件编写" class="headerlink" title="13.2、配置文件编写"></a>13.2、配置文件编写</h2><p>1、我们在resources资源文件下新建一个i18n目录，存放国际化配置文件</p><p>2、建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹变了！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225141876-1307608137.png" srcset="/blog/img/loading.gif" alt="img"></p><p>3、我们可以在这上面去新建一个文件；</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225154889-1524653449.png" srcset="/blog/img/loading.gif" alt="img"></p><p>弹出如下页面：我们再添加一个英文的；</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225207604-1238451568.png" srcset="/blog/img/loading.gif" alt="img"></p><p>这样就快捷多了！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225221065-887398655.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>4、接下来，我们就来编写配置，我们可以看到idea下面有另外一个视图；</strong></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225234441-258590952.png" srcset="/blog/img/loading.gif" alt="img"></p><p>这个视图我们点击 + 号就可以直接添加属性了；我们新建一个login.tip，可以看到边上有三个文件框可以输入</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225247649-1746815344.png" srcset="/blog/img/loading.gif" alt="img"></p><p>我们添加一下首页的内容！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225259474-1140791172.png" srcset="/blog/img/loading.gif" alt="img"></p><p>然后依次添加其他页面内容即可！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225311999-716532013.png" srcset="/blog/img/loading.gif" alt="img"></p><p>然后去查看我们的配置文件；</p><p>login.properties ：默认</p><pre><code class="hljs properties"><span class="hljs-meta">login.btn</span>=<span class="hljs-string">登录</span><span class="hljs-meta">login.password</span>=<span class="hljs-string">密码</span><span class="hljs-meta">login.remember</span>=<span class="hljs-string">记住我</span><span class="hljs-meta">login.tip</span>=<span class="hljs-string">请登录</span><span class="hljs-meta">login.username</span>=<span class="hljs-string">用户名</span></code></pre><p>英文：</p><pre><code class="hljs properties"><span class="hljs-meta">login.btn</span>=<span class="hljs-string">Sign in</span><span class="hljs-meta">login.password</span>=<span class="hljs-string">Password</span><span class="hljs-meta">login.remember</span>=<span class="hljs-string">Remember me</span><span class="hljs-meta">login.tip</span>=<span class="hljs-string">Please sign in</span><span class="hljs-meta">login.username</span>=<span class="hljs-string">Username</span></code></pre><p>中文：</p><pre><code class="hljs properties"><span class="hljs-meta">login.btn</span>=<span class="hljs-string">登录</span><span class="hljs-meta">login.password</span>=<span class="hljs-string">密码</span><span class="hljs-meta">login.remember</span>=<span class="hljs-string">记住我</span><span class="hljs-meta">login.tip</span>=<span class="hljs-string">请登录</span><span class="hljs-meta">login.username</span>=<span class="hljs-string">用户名</span></code></pre><p>OK，配置文件步骤搞定！</p><h2 id="13-3、配置文件生效探究"><a href="#13-3、配置文件生效探究" class="headerlink" title="13.3、配置文件生效探究"></a>13.3、配置文件生效探究</h2><p>我们去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：MessageSourceAutoConfiguration</p><p>里面有一个方法，这里发现SpringBoot已经自动配置好了管理我们国际化资源文件的组件 ResourceBundleMessageSource；</p><pre><code class="hljs java"><span class="hljs-comment">// 获取 properties 传递过来的值进行判断</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> MessageSource <span class="hljs-title">messageSource</span><span class="hljs-params">(MessageSourceProperties properties)</span> </span>{    ResourceBundleMessageSource messageSource = <span class="hljs-keyword">new</span> ResourceBundleMessageSource();    <span class="hljs-keyword">if</span> (StringUtils.hasText(properties.getBasename())) {        <span class="hljs-comment">// 设置国际化文件的基础名（去掉语言国家代码的）</span>        messageSource.setBasenames(            StringUtils.commaDelimitedListToStringArray(                                       StringUtils.trimAllWhitespace(properties.getBasename())));    }    <span class="hljs-keyword">if</span> (properties.getEncoding() != <span class="hljs-keyword">null</span>) {        messageSource.setDefaultEncoding(properties.getEncoding().name());    }    messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());    Duration cacheDuration = properties.getCacheDuration();    <span class="hljs-keyword">if</span> (cacheDuration != <span class="hljs-keyword">null</span>) {        messageSource.setCacheMillis(cacheDuration.toMillis());    }    messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());    messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());    <span class="hljs-keyword">return</span> messageSource;}</code></pre><p>我们真实 的情况是放在了i18n目录下，所以我们要去配置这个messages的路径；</p><pre><code class="hljs java">spring.messages.basename=i18n.login</code></pre><h2 id="13-4、配置页面国际化值"><a href="#13-4、配置页面国际化值" class="headerlink" title="13.4、配置页面国际化值"></a>13.4、配置页面国际化值</h2><p>去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{…}。我们去页面测试下：</p><p>IDEA还有提示，非常智能的！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225332289-780138786.png" srcset="/blog/img/loading.gif" alt="img"></p><p>我们可以去启动项目，访问一下，发现已经自动识别为中文的了！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225346425-1869149052.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>但是我们想要更好！可以根据按钮自动切换中文英文！</strong></p><h2 id="13-5、配置国际化解析"><a href="#13-5、配置国际化解析" class="headerlink" title="13.5、配置国际化解析"></a>13.5、配置国际化解析</h2><p>在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！</p><p>我们去我们webmvc自动配置文件，寻找一下！看到SpringBoot默认配置：</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.mvc"</span>, name = <span class="hljs-string">"locale"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> LocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span> </span>{    <span class="hljs-comment">// 容器中没有就自己配，有的话就用用户配置的</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) {        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FixedLocaleResolver(<span class="hljs-keyword">this</span>.mvcProperties.getLocale());    }    <span class="hljs-comment">// 接收头国际化分解</span>    AcceptHeaderLocaleResolver localeResolver = <span class="hljs-keyword">new</span> AcceptHeaderLocaleResolver();    localeResolver.setDefaultLocale(<span class="hljs-keyword">this</span>.mvcProperties.getLocale());    <span class="hljs-keyword">return</span> localeResolver;}</code></pre><p>AcceptHeaderLocaleResolver 这个类中有一个方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span> </span>{    Locale defaultLocale = <span class="hljs-keyword">this</span>.getDefaultLocale();    <span class="hljs-comment">// 默认的就是根据请求头带来的区域信息获取Locale进行国际化</span>    <span class="hljs-keyword">if</span> (defaultLocale != <span class="hljs-keyword">null</span> &amp;&amp; request.getHeader(<span class="hljs-string">"Accept-Language"</span>) == <span class="hljs-keyword">null</span>) {        <span class="hljs-keyword">return</span> defaultLocale;    } <span class="hljs-keyword">else</span> {        Locale requestLocale = request.getLocale();        List&lt;Locale&gt; supportedLocales = <span class="hljs-keyword">this</span>.getSupportedLocales();        <span class="hljs-keyword">if</span> (!supportedLocales.isEmpty() &amp;&amp; !supportedLocales.contains(requestLocale)) {            Locale supportedLocale = <span class="hljs-keyword">this</span>.findSupportedLocale(request, supportedLocales);            <span class="hljs-keyword">if</span> (supportedLocale != <span class="hljs-keyword">null</span>) {                <span class="hljs-keyword">return</span> supportedLocale;            } <span class="hljs-keyword">else</span> {                <span class="hljs-keyword">return</span> defaultLocale != <span class="hljs-keyword">null</span> ? defaultLocale : requestLocale;            }        } <span class="hljs-keyword">else</span> {            <span class="hljs-keyword">return</span> requestLocale;        }    }}</code></pre><p>那假如我们现在想点击链接让我们的国际化资源生效，就需要让我们自己的Locale生效！</p><p>我们去自己写一个自己的LocaleResolver，可以在链接上携带区域信息！</p><p>修改一下前端页面的跳转连接：</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这里传入参数不需要使用 ？使用 （key=value）--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-sm"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/index.html(l='zh_CN')}"</span>&gt;</span>中文<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-sm"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/index.html(l='en_US')}"</span>&gt;</span>English<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>我们去写一个处理的组件类！</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.component;<span class="hljs-keyword">import</span> org.springframework.util.StringUtils;<span class="hljs-keyword">import</span> org.springframework.web.servlet.LocaleResolver;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.util.Locale;<span class="hljs-comment">//可以在链接上携带区域信息</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLocaleResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LocaleResolver</span> </span>{    <span class="hljs-comment">//解析请求</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span> </span>{        String language = request.getParameter(<span class="hljs-string">"l"</span>);        Locale locale = Locale.getDefault(); <span class="hljs-comment">// 如果没有获取到就使用系统默认的</span>        <span class="hljs-comment">//如果请求链接不为空</span>        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(language)){            <span class="hljs-comment">//分割请求参数</span>            String[] split = language.split(<span class="hljs-string">"_"</span>);            <span class="hljs-comment">//国家，地区</span>            locale = <span class="hljs-keyword">new</span> Locale(split[<span class="hljs-number">0</span>],split[<span class="hljs-number">1</span>]);        }        <span class="hljs-keyword">return</span> locale;    }    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocale</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale)</span> </span>{    }}</code></pre><p>为了让我们的区域化信息能够生效，我们需要再配置一下这个组件！在我们自己的MvcConofig下添加bean；</p><pre><code class="hljs java"><span class="hljs-meta">@Beanpublic</span> <span class="hljs-function">LocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyLocaleResolver();}</code></pre><p><strong>我们重启项目，来访问一下，发现点击按钮可以实现成功切换！搞定收工！</strong></p><h1 id="14、SpringBoot：集成Swagger终极版"><a href="#14、SpringBoot：集成Swagger终极版" class="headerlink" title="14、SpringBoot：集成Swagger终极版"></a>14、SpringBoot：集成Swagger终极版</h1><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225407880-1259118410.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>学习目标：</strong></p><ul><li>了解Swagger的概念及作用</li><li>掌握在项目中集成Swagger自动生成API文档</li></ul><h3 id="14-1、Swagger简介"><a href="#14-1、Swagger简介" class="headerlink" title="14.1、Swagger简介"></a>14.1、Swagger简介</h3><p><strong>前后端分离</strong></p><ul><li>前端 -&gt; 前端控制层、视图层</li><li>后端 -&gt; 后端控制层、服务层、数据访问层</li><li>前后端通过API进行交互</li><li>前后端相对独立且松耦合</li></ul><p><strong>产生的问题</strong></p><ul><li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li></ul><p><strong>解决方案</strong></p><ul><li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li></ul><p><strong>Swagger</strong></p><ul><li>号称世界上最流行的API框架</li><li>Restful Api 文档在线自动生成器 =&gt; <strong>API 文档 与API 定义同步更新</strong></li><li>直接运行，在线测试API</li><li>支持多种语言 （如：Java，PHP等）</li><li>官网：<a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></li></ul><h3 id="14-2、SpringBoot集成Swagger"><a href="#14-2、SpringBoot集成Swagger" class="headerlink" title="14.2、SpringBoot集成Swagger"></a>14.2、SpringBoot集成Swagger</h3><p><strong>SpringBoot集成Swagger</strong> =&gt; <strong>springfox</strong>，两个jar包</p><ul><li><strong>Springfox-swagger2</strong></li><li>swagger-springmvc</li></ul><p><strong>使用Swagger</strong></p><p>要求：jdk 1.8 + 否则swagger2无法运行</p><p>步骤：</p><p>1、新建一个SpringBoot-web项目</p><p>2、添加Maven依赖</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>3、编写HelloController，测试确保运行成功！</p><p>4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//配置类</span><span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-comment">// 开启Swagger2的自动配置</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>{  }j</code></pre><p>5、访问测试 ：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225423594-1396861605.png" srcset="/blog/img/loading.gif" alt="img"></p><h3 id="14-3、配置Swagger"><a href="#14-3、配置Swagger" class="headerlink" title="14.3、配置Swagger"></a>14.3、配置Swagger</h3><p>1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span> <span class="hljs-comment">//配置docket以配置Swagger具体参数</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span> </span>{   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2);}</code></pre><p>2、可以通过apiInfo()属性配置文档信息</p><pre><code class="hljs java"><span class="hljs-comment">//配置文档信息</span><span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>{   Contact contact = <span class="hljs-keyword">new</span> Contact(<span class="hljs-string">"联系人名字"</span>, <span class="hljs-string">"http://xxx.xxx.com/联系人访问链接"</span>, <span class="hljs-string">"联系人邮箱"</span>);   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfo(           <span class="hljs-string">"Swagger学习"</span>, <span class="hljs-comment">// 标题</span>           <span class="hljs-string">"学习演示如何配置Swagger"</span>, <span class="hljs-comment">// 描述</span>           <span class="hljs-string">"v1.0"</span>, <span class="hljs-comment">// 版本</span>           <span class="hljs-string">"http://terms.service.url/组织链接"</span>, <span class="hljs-comment">// 组织链接</span>           contact, <span class="hljs-comment">// 联系人信息</span>           <span class="hljs-string">"Apach 2.0 许可"</span>, <span class="hljs-comment">// 许可</span>           <span class="hljs-string">"许可链接"</span>, <span class="hljs-comment">// 许可连接</span>           <span class="hljs-keyword">new</span> ArrayList&lt;&gt;()<span class="hljs-comment">// 扩展</span>  );}</code></pre><p>3、Docket 实例关联上 apiInfo()</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span> </span>{   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());}</code></pre><p>4、重启项目，访问测试 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a> 看下效果；</p><h3 id="14-4、配置扫描接口"><a href="#14-4、配置扫描接口" class="headerlink" title="14.4、配置扫描接口"></a>14.4、配置扫描接口</h3><p>1、构建Docket时通过select()方法配置怎么扫描接口。</p><pre><code class="hljs java">any() <span class="hljs-comment">// 扫描所有，项目中的所有接口都会被扫描到</span>none() <span class="hljs-comment">// 不扫描接口</span><span class="hljs-comment">// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span>withMethodAnnotation(<span class="hljs-keyword">final</span> Class&lt;? extends Annotation&gt; annotation)<span class="hljs-comment">// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span>withClassAnnotation(<span class="hljs-keyword">final</span> Class&lt;? extends Annotation&gt; annotation)basePackage(<span class="hljs-keyword">final</span> String basePackage) <span class="hljs-comment">// 根据包路径扫描接口</span></code></pre><p>2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类</p><p>3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式：</p><pre><code class="hljs java">any() <span class="hljs-comment">// 扫描所有，项目中的所有接口都会被扫描到</span>none() <span class="hljs-comment">// 不扫描接口</span><span class="hljs-comment">// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span>withMethodAnnotation(<span class="hljs-keyword">final</span> Class&lt;? extends Annotation&gt; annotation)<span class="hljs-comment">// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span>withClassAnnotation(<span class="hljs-keyword">final</span> Class&lt;? extends Annotation&gt; annotation)basePackage(<span class="hljs-keyword">final</span> String basePackage) <span class="hljs-comment">// 根据包路径扫描接口</span></code></pre><p>4、除此之外，我们还可以配置接口扫描过滤：</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span> </span>{   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)      .apiInfo(apiInfo())      .select()<span class="hljs-comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span>      .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.kuang.swagger.controller"</span>))       <span class="hljs-comment">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span>      .paths(PathSelectors.ant(<span class="hljs-string">"/kuang/**"</span>))      .build();}</code></pre><p>5、这里的可选值还有</p><pre><code class="hljs java">any() <span class="hljs-comment">// 任何请求都扫描</span>none() <span class="hljs-comment">// 任何请求都不扫描</span>regex(<span class="hljs-keyword">final</span> String pathRegex) <span class="hljs-comment">// 通过正则表达式控制</span>ant(<span class="hljs-keyword">final</span> String antPattern) <span class="hljs-comment">// 通过ant()控制</span></code></pre><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225444394-644044214.png" srcset="/blog/img/loading.gif" alt="img"></p><h3 id="14-5、配置Swagger开关"><a href="#14-5、配置Swagger开关" class="headerlink" title="14.5、配置Swagger开关"></a>14.5、配置Swagger开关</h3><p>1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span> </span>{   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)      .apiInfo(apiInfo())      .enable(<span class="hljs-keyword">false</span>) <span class="hljs-comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span>      .select()<span class="hljs-comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span>      .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.kuang.swagger.controller"</span>))       <span class="hljs-comment">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span>      .paths(PathSelectors.ant(<span class="hljs-string">"/kuang/**"</span>))      .build();}</code></pre><p>2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">(Environment environment)</span> </span>{   <span class="hljs-comment">// 设置要显示swagger的环境</span>   Profiles of = Profiles.of(<span class="hljs-string">"dev"</span>, <span class="hljs-string">"test"</span>);   <span class="hljs-comment">// 判断当前是否处于该环境</span>   <span class="hljs-comment">// 通过 enable() 接收此参数判断是否要显示</span>   <span class="hljs-keyword">boolean</span> b = environment.acceptsProfiles(of);      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)      .apiInfo(apiInfo())      .enable(b) <span class="hljs-comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span>      .select()<span class="hljs-comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span>      .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.kuang.swagger.controller"</span>))       <span class="hljs-comment">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span>      .paths(PathSelectors.ant(<span class="hljs-string">"/kuang/**"</span>))      .build();}</code></pre><p>3、可以在项目中增加一个dev的配置文件查看效果！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225500625-350010165.png" srcset="/blog/img/loading.gif" alt="img"></p><h3 id="14-6、配置API分组"><a href="#14-6、配置API分组" class="headerlink" title="14.6、配置API分组"></a>14.6、配置API分组</h3><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225514634-1503893280.png" srcset="/blog/img/loading.gif" alt="img"></p><p>1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组：</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">(Environment environment)</span> </span>{   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())      .groupName(<span class="hljs-string">"hello"</span>) <span class="hljs-comment">// 配置分组</span>       <span class="hljs-comment">// 省略配置....</span>}</code></pre><p>2、重启项目查看分组</p><p>3、如何配置多个分组？配置多个分组只需要配置多个docket即可：</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket1</span><span class="hljs-params">()</span></span>{   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">"group1"</span>);}<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket2</span><span class="hljs-params">()</span></span>{   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">"group2"</span>);}<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket3</span><span class="hljs-params">()</span></span>{   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">"group3"</span>);}</code></pre><p>4、重启项目查看即可</p><h3 id="14-7、实体配置"><a href="#14-7、实体配置" class="headerlink" title="14.7、实体配置"></a>14.7、实体配置</h3><p>1、新建一个实体类</p><pre><code class="hljs java"><span class="hljs-meta">@ApiModel</span>(<span class="hljs-string">"用户实体"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{   <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"用户名"</span>)   <span class="hljs-keyword">public</span> String username;   <span class="hljs-meta">@ApiModelProperty</span>(<span class="hljs-string">"密码"</span>)   <span class="hljs-keyword">public</span> String password;}</code></pre><p>2、只要这个实体在<strong>请求接口</strong>的返回值上（即使是泛型），都能映射到实体项中：</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/getUser"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>{   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();}</code></pre><p>3、重启查看测试</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225529234-1972244754.png" srcset="/blog/img/loading.gif" alt="img"></p><p>注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。</p><p>@ApiModel为类添加注释</p><p>@ApiModelProperty为类属性添加注释</p><h3 id="14-8、常用注解"><a href="#14-8、常用注解" class="headerlink" title="14.8、常用注解"></a>14.8、常用注解</h3><p>Swagger的所有注解定义在io.swagger.annotations包下</p><p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p><table><thead><tr><th>Swagger注解</th><th>简单说明</th></tr></thead><tbody><tr><td>@Api(tags = “xxx模块说明”)</td><td>作用在模块类上</td></tr><tr><td>@ApiOperation(“xxx接口说明”)</td><td>作用在接口方法上</td></tr><tr><td>@ApiModel(“xxxPOJO说明”)</td><td>作用在模型类上：如VO、BO</td></tr><tr><td>@ApiModelProperty(value = “xxx属性说明”,hidden = true)</td><td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td></tr><tr><td>@ApiParam(“xxx参数说明”)</td><td>作用在参数、方法和字段上，类似@ApiModelProperty</td></tr></tbody></table><p>我们也可以给请求的接口配置一些注释</p><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">"狂神的接口"</span>)<span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/kuang"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">kuang</span><span class="hljs-params">(@ApiParam(<span class="hljs-string">"这个名字会被返回"</span>)</span>String username)</span>{   <span class="hljs-keyword">return</span> username;}</code></pre><p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p><p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p><p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p><h3 id="14-9、拓展：其他皮肤"><a href="#14-9、拓展：其他皮肤" class="headerlink" title="14.9、拓展：其他皮肤"></a>14.9、拓展：其他皮肤</h3><p>我们可以导入不同的包实现不同的皮肤定义：</p><p>1、默认的 <strong>访问 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a></strong></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225545785-2143727145.png" srcset="/blog/img/loading.gif" alt="img"></p><p>2、bootstrap-ui <strong>访问 <a href="http://localhost:8080/doc.html" target="_blank" rel="noopener">http://localhost:8080/doc.html</a></strong></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225558425-1483910.png" srcset="/blog/img/loading.gif" alt="img"></p><p>3、Layui-ui <strong>访问 <a href="http://localhost:8080/docs.html" target="_blank" rel="noopener">http://localhost:8080/docs.html</a></strong></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.caspar-chen<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-ui-layer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225610315-997693293.png" srcset="/blog/img/loading.gif" alt="img"></p><p>4、mg-ui <strong>访问 <a href="http://localhost:8080/document.html" target="_blank" rel="noopener">http://localhost:8080/document.html</a></strong></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zyplayer<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-mg-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225623225-1419329566.png" srcset="/blog/img/loading.gif" alt="img"></p><h1 id="15、SpringBoot：异步、定时、邮件任务"><a href="#15、SpringBoot：异步、定时、邮件任务" class="headerlink" title="15、SpringBoot：异步、定时、邮件任务"></a>15、SpringBoot：异步、定时、邮件任务</h1><p>前言</p><blockquote><p>在我们的工作中，常常会用到异步处理任务，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。还有一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息。还有就是邮件的发送，微信的前身也是邮件服务呢？这些东西都是怎么实现的呢？其实SpringBoot都给我们提供了对应的支持，我们上手使用十分的简单，只需要开启一些注解支持，配置一些配置文件即可！那我们来看看吧~</p><p>最后编辑于2020.3.26 作者：狂神说</p></blockquote><h2 id="15-1、异步任务"><a href="#15-1、异步任务" class="headerlink" title="15.1、异步任务"></a>15.1、异步任务</h2><p>1、创建一个service包</p><p>2、创建一个类AsyncService</p><p>异步处理还是非常常用的，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。</p><p>编写方法，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况；</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncService</span> </span>{   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{       <span class="hljs-keyword">try</span> {           Thread.sleep(<span class="hljs-number">3000</span>);      } <span class="hljs-keyword">catch</span> (InterruptedException e) {           e.printStackTrace();      }       System.out.println(<span class="hljs-string">"业务进行中...."</span>);  }}</code></pre><p>3、编写controller包</p><p>4、编写AsyncController类</p><p>我们去写一个Controller测试一下</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncController</span> </span>{   <span class="hljs-meta">@Autowired</span>   AsyncService asyncService;   <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{       asyncService.hello();       <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;  }}</code></pre><p>5、访问<a href="http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。" target="_blank" rel="noopener">http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。</a></p><p>问题：我们如果想让用户直接得到消息，就在后台使用多线程的方式进行处理即可，但是每次都需要自己手动去编写多线程的实现的话，太麻烦了，我们只需要用一个简单的办法，在我们的方法上加一个简单的注解即可，如下：</p><p>6、给hello方法添加@Async注解；</p><pre><code class="hljs java"><span class="hljs-comment">//告诉Spring这是一个异步方法</span><span class="hljs-meta">@Async</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{   <span class="hljs-keyword">try</span> {       Thread.sleep(<span class="hljs-number">3000</span>);  } <span class="hljs-keyword">catch</span> (InterruptedException e) {       e.printStackTrace();  }   System.out.println(<span class="hljs-string">"业务进行中...."</span>);}</code></pre><p>SpringBoot就会自己开一个线程池，进行调用！但是要让这个注解生效，我们还需要在主程序上添加一个注解@EnableAsync ，开启异步注解功能；</p><pre><code class="hljs java"><span class="hljs-meta">@EnableAsync</span> <span class="hljs-comment">//开启异步注解功能</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootTaskApplication</span> </span>{   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{       SpringApplication.run(SpringbootTaskApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;  }}</code></pre><p>7、重启测试，网页瞬间响应，后台代码依旧执行！</p><h2 id="15-2、定时任务"><a href="#15-2、定时任务" class="headerlink" title="15.2、定时任务"></a>15.2、定时任务</h2><p>项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。</p><ul><li>TaskExecutor接口</li><li>TaskScheduler接口</li></ul><p>两个注解：</p><ul><li>@EnableScheduling</li><li>@Scheduled</li></ul><p><strong>cron表达式：</strong></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225641164-1934062088.png" srcset="/blog/img/loading.gif" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225651289-251704533.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>测试步骤：</strong></p><p>1、创建一个ScheduledService</p><p>我们里面存在一个hello方法，他需要定时执行，怎么处理呢？</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledService</span> </span>{      <span class="hljs-comment">//秒   分   时     日   月   周几</span>   <span class="hljs-comment">//0 * * * * MON-FRI</span>   <span class="hljs-comment">//注意cron表达式的用法；</span>   <span class="hljs-meta">@Scheduled</span>(cron = <span class="hljs-string">"0 * * * * 0-7"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{       System.out.println(<span class="hljs-string">"hello....."</span>);  }}</code></pre><p>2、这里写完定时任务之后，我们需要在主程序上增加@EnableScheduling 开启定时任务功能</p><pre><code class="hljs java"><span class="hljs-meta">@EnableAsync</span> <span class="hljs-comment">//开启异步注解功能</span><span class="hljs-meta">@EnableScheduling</span> <span class="hljs-comment">//开启基于注解的定时任务</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootTaskApplication</span> </span>{   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{       SpringApplication.run(SpringbootTaskApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;  }}</code></pre><p>3、我们来详细了解下cron表达式；</p><p><a href="http://www.bejson.com/othertools/cron/" target="_blank" rel="noopener">http://www.bejson.com/othertools/cron/</a></p><p>4、常用的表达式</p><pre><code class="hljs angelscript"> (<span class="hljs-number">1</span>）<span class="hljs-number">0</span>/<span class="hljs-number">2</span> * * * * ?   表示每<span class="hljs-number">2</span>秒 执行任务（<span class="hljs-number">1</span>）<span class="hljs-number">0</span> <span class="hljs-number">0</span>/<span class="hljs-number">2</span> * * * ?   表示每<span class="hljs-number">2</span>分钟 执行任务（<span class="hljs-number">1</span>）<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> * ?   表示在每月的<span class="hljs-number">1</span>日的凌晨<span class="hljs-number">2</span>点调整任务（<span class="hljs-number">2</span>）<span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> ? * MON-FRI   表示周一到周五每天上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>执行作业（<span class="hljs-number">3</span>）<span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> ? <span class="hljs-number">6</span>L <span class="hljs-number">2002</span><span class="hljs-number">-2006</span>   表示<span class="hljs-number">2002</span><span class="hljs-number">-2006</span>年的每个月的最后一个星期五上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>执行作（<span class="hljs-number">4</span>）<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span> * * ?   每天上午<span class="hljs-number">10</span>点，下午<span class="hljs-number">2</span>点，<span class="hljs-number">4</span>点（<span class="hljs-number">5</span>）<span class="hljs-number">0</span> <span class="hljs-number">0</span>/<span class="hljs-number">30</span> <span class="hljs-number">9</span><span class="hljs-number">-17</span> * * ?   朝九晚五工作时间内每半小时（<span class="hljs-number">6</span>）<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">12</span> ? * WED   表示每个星期三中午<span class="hljs-number">12</span>点（<span class="hljs-number">7</span>）<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">12</span> * * ?   每天中午<span class="hljs-number">12</span>点触发（<span class="hljs-number">8</span>）<span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> ? * *   每天上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发（<span class="hljs-number">9</span>）<span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> * * ?     每天上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发（<span class="hljs-number">10</span>）<span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> * * ?   每天上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发（<span class="hljs-number">11</span>）<span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> * * ? <span class="hljs-number">2005</span>   <span class="hljs-number">2005</span>年的每天上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发（<span class="hljs-number">12</span>）<span class="hljs-number">0</span> * <span class="hljs-number">14</span> * * ?     在每天下午<span class="hljs-number">2</span>点到下午<span class="hljs-number">2</span>:<span class="hljs-number">59</span>期间的每<span class="hljs-number">1</span>分钟触发（<span class="hljs-number">13</span>）<span class="hljs-number">0</span> <span class="hljs-number">0</span>/<span class="hljs-number">5</span> <span class="hljs-number">14</span> * * ?   在每天下午<span class="hljs-number">2</span>点到下午<span class="hljs-number">2</span>:<span class="hljs-number">55</span>期间的每<span class="hljs-number">5</span>分钟触发（<span class="hljs-number">14</span>）<span class="hljs-number">0</span> <span class="hljs-number">0</span>/<span class="hljs-number">5</span> <span class="hljs-number">14</span>,<span class="hljs-number">18</span> * * ?     在每天下午<span class="hljs-number">2</span>点到<span class="hljs-number">2</span>:<span class="hljs-number">55</span>期间和下午<span class="hljs-number">6</span>点到<span class="hljs-number">6</span>:<span class="hljs-number">55</span>期间的每<span class="hljs-number">5</span>分钟触发（<span class="hljs-number">15</span>）<span class="hljs-number">0</span> <span class="hljs-number">0</span><span class="hljs-number">-5</span> <span class="hljs-number">14</span> * * ?   在每天下午<span class="hljs-number">2</span>点到下午<span class="hljs-number">2</span>:<span class="hljs-number">05</span>期间的每<span class="hljs-number">1</span>分钟触发（<span class="hljs-number">16</span>）<span class="hljs-number">0</span> <span class="hljs-number">10</span>,<span class="hljs-number">44</span> <span class="hljs-number">14</span> ? <span class="hljs-number">3</span> WED   每年三月的星期三的下午<span class="hljs-number">2</span>:<span class="hljs-number">10</span>和<span class="hljs-number">2</span>:<span class="hljs-number">44</span>触发（<span class="hljs-number">17</span>）<span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> ? * MON-FRI   周一至周五的上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发（<span class="hljs-number">18</span>）<span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> <span class="hljs-number">15</span> * ?   每月<span class="hljs-number">15</span>日上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发（<span class="hljs-number">19</span>）<span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> L * ?   每月最后一日的上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发（<span class="hljs-number">20</span>）<span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> ? * <span class="hljs-number">6</span>L   每月的最后一个星期五上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发（<span class="hljs-number">21</span>）<span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> ? * <span class="hljs-number">6</span>L <span class="hljs-number">2002</span><span class="hljs-number">-2005</span>   <span class="hljs-number">2002</span>年至<span class="hljs-number">2005</span>年的每月的最后一个星期五上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发（<span class="hljs-number">22</span>）<span class="hljs-number">0</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> ? * <span class="hljs-number">6</span>#<span class="hljs-number">3</span>   每月的第三个星期五上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发</code></pre><h2 id="15-3、邮件任务"><a href="#15-3、邮件任务" class="headerlink" title="15.3、邮件任务"></a>15.3、邮件任务</h2><p>邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持</p><ul><li>邮件发送需要引入spring-boot-start-mail</li><li>SpringBoot 自动配置MailSenderAutoConfiguration</li><li>定义MailProperties内容，配置在application.yml中</li><li>自动装配JavaMailSender</li><li>测试邮件发送</li></ul><p><strong>测试：</strong></p><p>1、引入pom依赖</p><pre><code class="hljs java">&lt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>看它引入的依赖，可以看到 jakarta.mail</p><pre><code class="hljs java">&lt;dependency&gt;   &lt;groupId&gt;com.sun.mail&lt;/groupId&gt;   &lt;artifactId&gt;jakarta.mail&lt;/artifactId&gt;   &lt;version&gt;1.6.4&lt;/version&gt;   &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p>2、查看自动配置类：MailSenderAutoConfiguration</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225708744-252995174.png" srcset="/blog/img/loading.gif" alt="img"></p><p>这个类中存在bean，JavaMailSenderImpl</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225721465-1009548816.png" srcset="/blog/img/loading.gif" alt="img"></p><p>然后我们去看下配置文件</p><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties</span>(   prefix = <span class="hljs-string">"spring.mail"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailProperties</span> </span>{   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset DEFAULT_CHARSET;   <span class="hljs-keyword">private</span> String host;   <span class="hljs-keyword">private</span> Integer port;   <span class="hljs-keyword">private</span> String username;   <span class="hljs-keyword">private</span> String password;   <span class="hljs-keyword">private</span> String protocol = <span class="hljs-string">"smtp"</span>;   <span class="hljs-keyword">private</span> Charset defaultEncoding;   <span class="hljs-keyword">private</span> Map&lt;String, String&gt; properties;   <span class="hljs-keyword">private</span> String jndiName;}</code></pre><p>3、配置文件：</p><pre><code class="hljs properties"><span class="hljs-meta">spring.mail.username</span>=<span class="hljs-string">24736743@qq.comspring.mail.password=你的qq授权码spring.mail.host=smtp.qq.com# qq需要配置sslspring.mail.properties.mail.smtp.ssl.enable=true</span></code></pre><p>获取授权码：在QQ邮箱中的设置-&gt;账户-&gt;开启pop3和smtp服务</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225736355-1251829128.png" srcset="/blog/img/loading.gif" alt="img"></p><p>4、Spring单元测试</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>JavaMailSenderImpl mailSender;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>{   <span class="hljs-comment">//邮件设置1：一个简单的邮件</span>   SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();   message.setSubject(<span class="hljs-string">"通知-明天来狂神这听课"</span>);   message.setText(<span class="hljs-string">"今晚7:30开会"</span>);   message.setTo(<span class="hljs-string">"24736743@qq.com"</span>);   message.setFrom(<span class="hljs-string">"24736743@qq.com"</span>);   mailSender.send(message);}<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>{   <span class="hljs-comment">//邮件设置2：一个复杂的邮件</span>   MimeMessage mimeMessage = mailSender.createMimeMessage();   MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);   helper.setSubject(<span class="hljs-string">"通知-明天来狂神这听课"</span>);   helper.setText(<span class="hljs-string">"&lt;b style='color:red'&gt;今天 7:30来开会&lt;/b&gt;"</span>,<span class="hljs-keyword">true</span>);   <span class="hljs-comment">//发送附件</span>   helper.addAttachment(<span class="hljs-string">"1.jpg"</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">""</span>));   helper.addAttachment(<span class="hljs-string">"2.jpg"</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">""</span>));   helper.setTo(<span class="hljs-string">"24736743@qq.com"</span>);   helper.setFrom(<span class="hljs-string">"24736743@qq.com"</span>);   mailSender.send(mimeMessage);}</code></pre><p>查看邮箱，邮件接收成功！</p><p>我们只需要使用Thymeleaf进行前后端结合即可开发自己网站邮件收发功能了！</p><h1 id="16、SpringBoot：富文本编辑器"><a href="#16、SpringBoot：富文本编辑器" class="headerlink" title="16、SpringBoot：富文本编辑器"></a>16、SpringBoot：富文本编辑器</h1><h3 id="16-1、简介"><a href="#16-1、简介" class="headerlink" title="16.1、简介"></a>16.1、简介</h3><p>思考：我们平时在博客园，或者CSDN等平台进行写作的时候，有同学思考过他们的编辑器是怎么实现的吗？</p><p>在博客园后台的选项设置中，可以看到一个文本编辑器的选项：</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225751589-577736769.png" srcset="/blog/img/loading.gif" alt="img"></p><p>其实这个就是富文本编辑器，市面上有许多非常成熟的富文本编辑器，比如：</p><ul><li><strong>Editor.md</strong>——功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费</li><li><ul><li>官网：<a href="https://pandao.github.io/editor.md/" target="_blank" rel="noopener">https://pandao.github.io/editor.md/</a></li></ul></li><li><strong>wangEditor</strong>——基于javascript和css开发的 Web富文本编辑器， 轻量、简洁、界面美观、易用、开源免费。</li><li><ul><li>官网：<a href="http://www.wangeditor.com/" target="_blank" rel="noopener">http://www.wangeditor.com/</a></li></ul></li><li><strong>TinyMCE</strong>——TinyMCE是一个轻量级的基于浏览器的所见即所得编辑器，由JavaScript写成。它对IE6+和Firefox1.5+都有着非常良好的支持。功能齐全，界面美观，就是文档是英文的，对开发人员英文水平有一定要求。</li><li><ul><li>官网：<a href="https://www.tiny.cloud/docs/demo/full-featured/" target="_blank" rel="noopener">https://www.tiny.cloud/docs/demo/full-featured/</a><ul><li>博客园</li></ul></li></ul></li><li><strong>百度ueditor</strong>——UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，功能齐全，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码，缺点是已经没有更新了</li><li><ul><li>官网：<a href="https://ueditor.baidu.com/website/onlinedemo.html" target="_blank" rel="noopener">https://ueditor.baidu.com/website/onlinedemo.html</a></li></ul></li><li><strong>kindeditor</strong>——界面经典。</li><li><ul><li>官网：<a href="http://kindeditor.net/demo.php" target="_blank" rel="noopener">http://kindeditor.net/demo.php</a></li></ul></li><li><strong>Textbox</strong>——Textbox是一款极简但功能强大的在线文本编辑器，支持桌面设备和移动设备。主要功能包含内置的图像处理和存储、文件拖放、拼写检查和自动更正。此外，该工具还实现了屏幕阅读器等辅助技术，并符合WAI-ARIA可访问性标准。</li><li><ul><li>官网：<a href="https://textbox.io/" target="_blank" rel="noopener">https://textbox.io/</a></li></ul></li><li><strong>CKEditor</strong>——国外的，界面美观。</li><li><ul><li>官网：<a href="https://ckeditor.com/ckeditor-5/demo/" target="_blank" rel="noopener">https://ckeditor.com/ckeditor-5/demo/</a></li></ul></li><li><strong>quill</strong>——功能强大，还可以编辑公式等</li><li><ul><li>官网：<a href="https://quilljs.com/" target="_blank" rel="noopener">https://quilljs.com/</a></li></ul></li><li><strong>simditor</strong>——界面美观，功能较全。</li><li><ul><li>官网：<a href="https://simditor.tower.im/" target="_blank" rel="noopener">https://simditor.tower.im/</a></li></ul></li><li><strong>summernote</strong>——UI好看，精美</li><li><ul><li>官网：<a href="https://summernote.org/" target="_blank" rel="noopener">https://summernote.org/</a></li></ul></li><li><strong>jodit</strong>——功能齐全</li><li><ul><li>官网：<a href="https://xdsoft.net/jodit/" target="_blank" rel="noopener">https://xdsoft.net/jodit/</a></li></ul></li><li><strong>froala Editor</strong>——界面非常好看，功能非常强大，非常好用（非免费）</li><li><ul><li>官网：<a href="https://www.froala.com/wysiwyg-editor" target="_blank" rel="noopener">https://www.froala.com/wysiwyg-editor</a></li></ul></li></ul><p>总之，目前可用的富文本编辑器有很多……这只是其中的一部分</p><h3 id="16-2、Editor-md"><a href="#16-2、Editor-md" class="headerlink" title="16.2、Editor.md"></a>16.2、Editor.md</h3><p>我这里使用的就是Editor.md，作为一个资深码农，Mardown必然是我们程序猿最喜欢的格式，看下面，就爱上了！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225807875-1956792074.png" srcset="/blog/img/loading.gif" alt="img"></p><p>我们可以在官网下载它：<a href="https://pandao.github.io/editor.md/" target="_blank" rel="noopener">https://pandao.github.io/editor.md/</a> ， 得到它的压缩包！</p><p>解压以后，在examples目录下面，可以看到他的很多案例使用！学习，其实就是看人家怎么写的，然后进行模仿就好了！</p><p>我们可以将整个解压的文件倒入我们的项目，将一些无用的测试和案例删掉即可！</p><h3 id="16-3、基础工程搭建"><a href="#16-3、基础工程搭建" class="headerlink" title="16.3、基础工程搭建"></a>16.3、基础工程搭建</h3><blockquote><p>数据库设计</p></blockquote><p>article：文章表</p><table><thead><tr><th>字段</th><th></th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>文章的唯一ID</td></tr><tr><td>author</td><td>varchar</td><td>作者</td></tr><tr><td>title</td><td>varchar</td><td>标题</td></tr><tr><td>content</td><td>longtext</td><td>文章的内容</td></tr></tbody></table><p>建表SQL：</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`article`</span> (<span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'int文章的唯一ID'</span>,<span class="hljs-string">`author`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'作者'</span>,<span class="hljs-string">`title`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'标题'</span>,<span class="hljs-string">`content`</span> longtext <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'文章的内容'</span>,PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8</code></pre><blockquote><p>基础项目搭建</p></blockquote><p>1、建一个SpringBoot项目配置</p><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><span class="hljs-attr">datasource:</span>  <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>  <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>  <span class="hljs-comment">#?serverTimezone=UTC解决时区的报错</span>  <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span>  <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><span class="hljs-string">&lt;resources&gt;</span>   <span class="hljs-string">&lt;resource&gt;</span>       <span class="hljs-string">&lt;directory&gt;src/main/java&lt;/directory&gt;</span>       <span class="hljs-string">&lt;includes&gt;</span>           <span class="hljs-string">&lt;include&gt;**/*.xml&lt;/include&gt;</span>       <span class="hljs-string">&lt;/includes&gt;</span>       <span class="hljs-string">&lt;filtering&gt;true&lt;/filtering&gt;</span>   <span class="hljs-string">&lt;/resource&gt;</span><span class="hljs-string">&lt;/resources&gt;</span></code></pre><p>2、实体类：</p><pre><code class="hljs java"><span class="hljs-comment">//文章类</span><span class="hljs-meta">@Data</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">//文章的唯一ID</span>   <span class="hljs-keyword">private</span> String author; <span class="hljs-comment">//作者名</span>   <span class="hljs-keyword">private</span> String title; <span class="hljs-comment">//标题</span>   <span class="hljs-keyword">private</span> String content; <span class="hljs-comment">//文章的内容</span>}</code></pre><p>3、mapper接口：</p><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-meta">@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ArticleMapper</span> </span>{   <span class="hljs-comment">//查询所有的文章</span>   <span class="hljs-function">List&lt;Article&gt; <span class="hljs-title">queryArticles</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//新增一个文章</span>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addArticle</span><span class="hljs-params">(Article article)</span></span>;   <span class="hljs-comment">//根据文章id查询文章</span>   <span class="hljs-function">Article <span class="hljs-title">getArticleById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;   <span class="hljs-comment">//根据文章id删除文章</span>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteArticleById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;}</code></pre><p><strong>既然已经提供了 myBatis 的映射配置文件，自然要告诉 spring boot 这些文件的位置</strong></p><pre><code class="hljs yml"><span class="hljs-attr">mybatis:</span><span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:com/kuang/mapper/*.xml</span><span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.kuang.pojo</span></code></pre><p>编写一个Controller测试下，是否ok；</p><h3 id="16-4、文章编辑整合（重点）"><a href="#16-4、文章编辑整合（重点）" class="headerlink" title="16.4、文章编辑整合（重点）"></a>16.4、文章编辑整合（重点）</h3><p>1、导入 editor.md 资源 ，删除多余文件</p><p>2、编辑文章页面 editor.html、需要引入 jQuery；</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"x-admin-sm"</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>秦疆'Blog<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"renderer"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"webkit"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge,chrome=1"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width,user-scalable=yes, minimum-scale=0.4, initial-scale=0.8,target-densitydpi=low-dpi"</span> /&gt;</span>   <span class="hljs-comment">&lt;!--Editor.md--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/editormd/css/editormd.css}"</span>/&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"shortcut icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://pandao.github.io/editor.md/favicon.ico"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/x-icon"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"layui-fluid"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"layui-row layui-col-space15"</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"layui-col-md12"</span>&gt;</span>           <span class="hljs-comment">&lt;!--博客表单--&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mdEditorForm"</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>                  标题：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"title"</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>                  作者：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"author"</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"article-content"</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"content"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"content"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"display:none;"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-comment">&lt;!--editormd--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/editormd/lib/jquery.min.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/editormd/editormd.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">   <span class="hljs-keyword">var</span> testEditor;</span><span class="actionscript">   <span class="hljs-comment">//window.onload = function(){ }</span></span><span class="javascript">   $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</span><span class="actionscript">       testEditor = editormd(<span class="hljs-string">"article-content"</span>, {</span><span class="actionscript">           width : <span class="hljs-string">"95%"</span>,</span>           height : 400,<span class="actionscript">           syncScrolling : <span class="hljs-string">"single"</span>,</span><span class="actionscript">           path : <span class="hljs-string">"../editormd/lib/"</span>,</span><span class="actionscript">           saveHTMLToTextarea : <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 保存 HTML 到 Textarea</span></span><span class="actionscript">           emoji: <span class="hljs-literal">true</span>,</span><span class="actionscript">           theme: <span class="hljs-string">"dark"</span>,<span class="hljs-comment">//工具栏主题</span></span><span class="actionscript">           previewTheme: <span class="hljs-string">"dark"</span>,<span class="hljs-comment">//预览主题</span></span><span class="actionscript">           editorTheme: <span class="hljs-string">"pastel-on-dark"</span>,<span class="hljs-comment">//编辑主题</span></span><span class="actionscript">           tex : <span class="hljs-literal">true</span>,                   <span class="hljs-comment">// 开启科学公式TeX语言支持，默认关闭</span></span><span class="actionscript">           flowChart : <span class="hljs-literal">true</span>,             <span class="hljs-comment">// 开启流程图支持，默认关闭</span></span><span class="actionscript">           sequenceDiagram : <span class="hljs-literal">true</span>,       <span class="hljs-comment">// 开启时序/序列图支持，默认关闭,</span></span><span class="actionscript">           <span class="hljs-comment">//图片上传</span></span><span class="actionscript">           imageUpload : <span class="hljs-literal">true</span>,</span><span class="actionscript">           imageFormats : [<span class="hljs-string">"jpg"</span>, <span class="hljs-string">"jpeg"</span>, <span class="hljs-string">"gif"</span>, <span class="hljs-string">"png"</span>, <span class="hljs-string">"bmp"</span>, <span class="hljs-string">"webp"</span>],</span><span class="actionscript">           imageUploadURL : <span class="hljs-string">"/article/file/upload"</span>,</span><span class="actionscript">           onload : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</span><span class="javascript">               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'onload'</span>, <span class="hljs-keyword">this</span>);</span>          },<span class="actionscript">           <span class="hljs-comment">/*指定需要显示的功能按钮*/</span></span><span class="actionscript">           toolbarIcons : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</span><span class="actionscript">               <span class="hljs-keyword">return</span> [<span class="hljs-string">"undo"</span>,<span class="hljs-string">"redo"</span>,<span class="hljs-string">"|"</span>,</span><span class="actionscript">                   <span class="hljs-string">"bold"</span>,<span class="hljs-string">"del"</span>,<span class="hljs-string">"italic"</span>,<span class="hljs-string">"quote"</span>,<span class="hljs-string">"ucwords"</span>,<span class="hljs-string">"uppercase"</span>,<span class="hljs-string">"lowercase"</span>,<span class="hljs-string">"|"</span>,</span><span class="actionscript">                   <span class="hljs-string">"h1"</span>,<span class="hljs-string">"h2"</span>,<span class="hljs-string">"h3"</span>,<span class="hljs-string">"h4"</span>,<span class="hljs-string">"h5"</span>,<span class="hljs-string">"h6"</span>,<span class="hljs-string">"|"</span>,</span><span class="actionscript">                   <span class="hljs-string">"list-ul"</span>,<span class="hljs-string">"list-ol"</span>,<span class="hljs-string">"hr"</span>,<span class="hljs-string">"|"</span>,</span><span class="actionscript">                   <span class="hljs-string">"link"</span>,<span class="hljs-string">"reference-link"</span>,<span class="hljs-string">"image"</span>,<span class="hljs-string">"code"</span>,<span class="hljs-string">"preformatted-text"</span>,</span><span class="actionscript">                   <span class="hljs-string">"code-block"</span>,<span class="hljs-string">"table"</span>,<span class="hljs-string">"datetime"</span>,<span class="hljs-string">"emoji"</span>,<span class="hljs-string">"html-entities"</span>,<span class="hljs-string">"pagebreak"</span>,<span class="hljs-string">"|"</span>,</span><span class="actionscript">                   <span class="hljs-string">"goto-line"</span>,<span class="hljs-string">"watch"</span>,<span class="hljs-string">"preview"</span>,<span class="hljs-string">"fullscreen"</span>,<span class="hljs-string">"clear"</span>,<span class="hljs-string">"search"</span>,<span class="hljs-string">"|"</span>,</span><span class="actionscript">                   <span class="hljs-string">"help"</span>,<span class="hljs-string">"info"</span>,<span class="hljs-string">"releaseIcon"</span>, <span class="hljs-string">"index"</span>]</span>          },<span class="actionscript">           <span class="hljs-comment">/*自定义功能按钮，下面我自定义了2个，一个是发布，一个是返回首页*/</span></span>           toolbarIconTexts : {<span class="handlebars"><span class="xml">               releaseIcon : "<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">\</span>"<span class="hljs-attr">gray</span>\"&gt;</span>发布<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>",</span></span><span class="handlebars"><span class="xml">               index : "<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">\</span>"<span class="hljs-attr">red</span>\"&gt;</span>返回首页<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>",</span></span>          },<span class="actionscript">           <span class="hljs-comment">/*给自定义按钮指定回调函数*/</span></span>           toolbarHandlers:{<span class="actionscript">               releaseIcon : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cm, icon, cursor, selection)</span> </span>{</span><span class="actionscript">                   <span class="hljs-comment">//表单提交</span></span><span class="actionscript">                   mdEditorForm.method = <span class="hljs-string">"post"</span>;</span><span class="actionscript">                   mdEditorForm.action = <span class="hljs-string">"/article/addArticle"</span>;<span class="hljs-comment">//提交至服务器的路径</span></span>                   mdEditorForm.submit();              },<span class="actionscript">               index : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{</span><span class="javascript">                   <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">'/'</span>;</span>              },          }      });  });<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>3、编写Controller，进行跳转，以及保存文章</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/article"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArticleController</span> </span>{   <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/toEditor"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toEditor</span><span class="hljs-params">()</span></span>{       <span class="hljs-keyword">return</span> <span class="hljs-string">"editor"</span>;  }      <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/addArticle"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addArticle</span><span class="hljs-params">(Article article)</span></span>{       articleMapper.addArticle(article);       <span class="hljs-keyword">return</span> <span class="hljs-string">"editor"</span>;  }   }</code></pre><blockquote><p>图片上传问题</p></blockquote><p>1、前端js中添加配置</p><pre><code class="hljs http">//图片上传imageUpload : true,imageFormats : ["jpg", "jpeg", "gif", "png", "bmp", "webp"],imageUploadURL : "/article/file/upload", // //这个是上传图片时的访问地址</code></pre><p>2、后端请求，接收保存这个图片, 需要导入 FastJson 的依赖！</p><pre><code class="hljs java"><span class="hljs-comment">//博客图片上传问题</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/file/upload"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> JSONObject <span class="hljs-title">fileUpload</span><span class="hljs-params">(@RequestParam(value = <span class="hljs-string">"editormd-image-file"</span>, required = <span class="hljs-keyword">true</span>)</span> MultipartFile file, HttpServletRequest request) <span class="hljs-keyword">throws</span> IOException </span>{   <span class="hljs-comment">//上传路径保存设置</span>   <span class="hljs-comment">//获得SpringBoot当前项目的路径：System.getProperty("user.dir")</span>   String path = System.getProperty(<span class="hljs-string">"user.dir"</span>)+<span class="hljs-string">"/upload/"</span>;   <span class="hljs-comment">//按照月份进行分类：</span>   Calendar instance = Calendar.getInstance();   String month = (instance.get(Calendar.MONTH) + <span class="hljs-number">1</span>)+<span class="hljs-string">"月"</span>;   path = path+month;   File realPath = <span class="hljs-keyword">new</span> File(path);   <span class="hljs-keyword">if</span> (!realPath.exists()){       realPath.mkdir();  }   <span class="hljs-comment">//上传文件地址</span>   System.out.println(<span class="hljs-string">"上传文件保存地址："</span>+realPath);   <span class="hljs-comment">//解决文件名字问题：我们使用uuid;</span>   String filename = <span class="hljs-string">"ks-"</span>+UUID.randomUUID().toString().replaceAll(<span class="hljs-string">"-"</span>, <span class="hljs-string">""</span>);   <span class="hljs-comment">//通过CommonsMultipartFile的方法直接写文件（注意这个时候）</span>   file.transferTo(<span class="hljs-keyword">new</span> File(realPath +<span class="hljs-string">"/"</span>+ filename));   <span class="hljs-comment">//给editormd进行回调</span>   JSONObject res = <span class="hljs-keyword">new</span> JSONObject();   res.put(<span class="hljs-string">"url"</span>,<span class="hljs-string">"/upload/"</span>+month+<span class="hljs-string">"/"</span>+ filename);   res.put(<span class="hljs-string">"success"</span>, <span class="hljs-number">1</span>);   res.put(<span class="hljs-string">"message"</span>, <span class="hljs-string">"upload success!"</span>);   <span class="hljs-keyword">return</span> res;}</code></pre><p>3、解决文件回显显示的问题，设置虚拟目录映射！在我们自己拓展的MvcConfig中进行配置即可！</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{   <span class="hljs-comment">// 文件保存在真实目录/upload/下，</span>   <span class="hljs-comment">// 访问的时候使用虚路径/upload，比如文件名为1.png，就直接/upload/1.png就ok了。</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>{       registry.addResourceHandler(<span class="hljs-string">"/upload/**"</span>)          .addResourceLocations(<span class="hljs-string">"file:"</span>+System.getProperty(<span class="hljs-string">"user.dir"</span>)+<span class="hljs-string">"/upload/"</span>);  }}</code></pre><blockquote><p>表情包问题</p></blockquote><p>自己手动下载，emoji 表情包，放到图片路径下：</p><p>修改editormd.js文件</p><pre><code class="hljs js"><span class="hljs-comment">// Emoji graphics files url path</span>editormd.emoji     = {   path : <span class="hljs-string">"../editormd/plugins/emoji-dialog/emoji/"</span>,   ext   : <span class="hljs-string">".png"</span>};</code></pre><h3 id="16-5、文章展示"><a href="#16-5、文章展示" class="headerlink" title="16.5、文章展示"></a>16.5、文章展示</h3><p>1、Controller 中增加方法</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/{id}"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">show</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> <span class="hljs-keyword">int</span> id,Model model)</span>{   Article article = articleMapper.getArticleById(id);   model.addAttribute(<span class="hljs-string">"article"</span>,article);   <span class="hljs-keyword">return</span> <span class="hljs-string">"article"</span>;}</code></pre><p>2、编写页面 article.html</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1, maximum-scale=1"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${article.title}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-comment">&lt;!--文章头部信息：标题，作者，最后更新日期，导航--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: auto 0"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${article.title}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  作者：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"float: left"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${article.author}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>   <span class="hljs-comment">&lt;!--文章主体内容--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"doc-content"</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"display:none;"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"markdown"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${article.content}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/editormd/css/editormd.preview.css}"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/editormd/lib/jquery.min.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/editormd/lib/marked.min.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/editormd/lib/prettify.min.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/editormd/lib/raphael.min.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/editormd/lib/underscore.min.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/editormd/lib/sequence-diagram.min.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/editormd/lib/flowchart.min.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/editormd/lib/jquery.flowchart.min.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/editormd/editormd.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript">   <span class="hljs-keyword">var</span> testEditor;</span><span class="javascript">   $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><span class="actionscript">       testEditor = editormd.markdownToHTML(<span class="hljs-string">"doc-content"</span>, {<span class="hljs-comment">//注意：这里是上面DIV的id</span></span><span class="actionscript">           htmlDecode: <span class="hljs-string">"style,script,iframe"</span>,</span><span class="actionscript">           emoji: <span class="hljs-literal">true</span>,</span><span class="actionscript">           taskList: <span class="hljs-literal">true</span>,</span><span class="actionscript">           tocm: <span class="hljs-literal">true</span>,</span><span class="actionscript">           tex: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 默认不解析</span></span><span class="actionscript">           flowChart: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 默认不解析</span></span><span class="actionscript">           sequenceDiagram: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 默认不解析</span></span><span class="actionscript">           codeFold: <span class="hljs-literal">true</span></span>      });});<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>重启项目，访问进行测试！大功告成！</p><p>小结：</p><p>有了富文本编辑器，我们网站的功能就会又多一项，大家到了这里完全可以有时间写一个属于自己的博客网站了，根据所学的知识是完全没有任何问题的！</p><h1 id="17、SpringBoot：Dubbo和Zookeeper集成"><a href="#17、SpringBoot：Dubbo和Zookeeper集成" class="headerlink" title="17、SpringBoot：Dubbo和Zookeeper集成"></a>17、SpringBoot：Dubbo和Zookeeper集成</h1><p>分布式理论</p><h2 id="17-1、什么是分布式系统？"><a href="#17-1、什么是分布式系统？" class="headerlink" title="17.1、什么是分布式系统？"></a><strong>17.1、什么是分布式系统？</strong></h2><p>在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”；</p><p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是<strong>利用更多的机器，处理更多的数据</strong>。</p><p>分布式系统（distributed system）是建立在网络之上的软件系统。</p><p>首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。</p><h2 id="17-2、Dubbo文档"><a href="#17-2、Dubbo文档" class="headerlink" title="17.2、Dubbo文档"></a><strong>17.2、Dubbo文档</strong></h2><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需<strong>一个治理系统</strong>确保架构有条不紊的演进。</p><p>在Dubbo的官网文档有这样一张图</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225836241-1744130417.png" srcset="/blog/img/loading.gif" alt="img"></p><h2 id="单一应用架构"><a href="#单一应用架构" class="headerlink" title="**单一应用架构**"></a><strong>**</strong>单一应用架构<strong>**</strong></h2><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225848354-475809714.png" srcset="/blog/img/loading.gif" alt="img"></p><p>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</p><p><strong>缺点：</strong></p><p>1、性能扩展比较难</p><p>2、协同开发问题</p><p>3、不利于升级维护</p><h2 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="*\*\垂直应用架构******"></a><strong>*\</strong>*<em>\</em>垂直应用架构*<em>*</em>****</h2><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225901199-858224740.png" srcset="/blog/img/loading.gif" alt="img"></p><p>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</p><p>缺点：公用模块无法重复利用，开发性的浪费</p><h2 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="**分布式服务架构**"></a><strong><strong>**</strong></strong>分布式服务架构<strong><strong>**</strong></strong></h2><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的<strong>分布式服务框架(RPC)</strong>是关键。</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225913839-69515130.png" srcset="/blog/img/loading.gif" alt="img"></p><h2 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="*\***\流动计算架构********"></a><strong>*\</strong>*<em>*</em>*<em>\</em>流动计算架构*<em>*</em>*<em>*</em>****</h2><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心</strong>(SOA)[ Service Oriented Architecture]是关键。</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225925894-2054203963.png" srcset="/blog/img/loading.gif" alt="img"></p><p>什么是RPC</p><p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p><p>也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数；</p><p>推荐阅读文章：<a href="https://www.jianshu.com/p/2accc2840a1b" target="_blank" rel="noopener">https://www.jianshu.com/p/2accc2840a1b</a></p><p><strong>RPC基本原理</strong></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225942424-634751471.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>步骤解析：</strong></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412225954994-2069522644.png" srcset="/blog/img/loading.gif" alt="img"></p><p>RPC两个核心模块：通讯，序列化。</p><p>测试环境搭建</p><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="*\***\Dubbo********"></a><strong>*\</strong>*<em>*</em>*<em>\</em>Dubbo*<em>*</em>*<em>*</em>****</h2><p>Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p><p>dubbo官网 <a href="http://dubbo.apache.org/zh-cn/index.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/index.html</a></p><p>1.了解Dubbo的特性</p><p>2.查看官方文档</p><p><strong>dubbo基本概念</strong></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230011744-1175379704.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>服务提供者</strong>（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p><p><strong>服务消费者</strong>（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p><p><strong>注册中心</strong>（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p><p><strong>监控中心</strong>（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p><p><strong>调用关系说明</strong></p><p>l 服务容器负责启动，加载，运行服务提供者。</p><p>l 服务提供者在启动时，向注册中心注册自己提供的服务。</p><p>l 服务消费者在启动时，向注册中心订阅自己所需的服务。</p><p>l 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p><p>l 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p><p>l 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p><h2 id="Dubbo环境搭建"><a href="#Dubbo环境搭建" class="headerlink" title="*\***\Dubbo环境搭建********"></a><strong>*\</strong>*<em>*</em>*<em>\</em>Dubbo环境搭建*<em>*</em>*<em>*</em>****</h2><p>点进dubbo官方文档，推荐我们使用Zookeeper 注册中心</p><p>什么是zookeeper呢？可以查看官方文档</p><h2 id="Window下安装zookeeper"><a href="#Window下安装zookeeper" class="headerlink" title="*\***\Window下安装zookeeper********"></a><strong>*\</strong>*<em>*</em>*<em>\</em>Window下安装zookeeper*<em>*</em>*<em>*</em>****</h2><p>1、下载zookeeper ：地址， 我们下载3.4.14 ， 最新版！解压zookeeper</p><p>2、运行/bin/zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件；</p><p>可能遇到问题：闪退 !</p><p>解决方案：编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230026479-947348663.png" srcset="/blog/img/loading.gif" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230037329-740930228.png" srcset="/blog/img/loading.gif" alt="img"></p><p>3、修改zoo.cfg配置文件</p><p>将conf文件夹下面的zoo_sample.cfg复制一份改名为zoo.cfg即可。</p><p>注意几个重要位置：</p><p>dataDir=./ 临时数据存储的目录（可写相对路径）</p><p>clientPort=2181 zookeeper的端口号</p><p>修改完成后再次启动zookeeper</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230050035-1907960449.png" srcset="/blog/img/loading.gif" alt="img"></p><p>4、使用zkCli.cmd测试</p><p>ls /：列出zookeeper根下保存的所有节点</p><pre><code class="hljs angelscript">[zk: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">4</span>] ls /[zookeeper]</code></pre><p>create –e /kuangshen 123：创建一个kuangshen节点，值为123</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230103589-1318102017.png" srcset="/blog/img/loading.gif" alt="img"></p><p>get /kuangshen：获取/kuangshen节点的值</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230116159-2103649071.png" srcset="/blog/img/loading.gif" alt="img"></p><p>我们再来查看一下节点</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230133804-1513007496.png" srcset="/blog/img/loading.gif" alt="img"></p><h2 id="window下安装dubbo-admin"><a href="#window下安装dubbo-admin" class="headerlink" title="*\***\window下安装dubbo-admin********"></a><strong>*\</strong>*<em>*</em>*<em>\</em>window下安装dubbo-admin*<em>*</em>*<em>*</em>****</h2><p>dubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。</p><p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。</p><p>我们这里来安装一下：</p><p><strong>1、下载dubbo-admin</strong></p><p>地址 ：<a href="https://github.com/apache/dubbo-admin/tree/master" target="_blank" rel="noopener">https://github.com/apache/dubbo-admin/tree/master</a></p><p><strong>2、解压进入目录</strong></p><p>修改 dubbo-admin\src\main\resources \application.properties 指定zookeeper地址</p><pre><code class="hljs stylus">server.port=<span class="hljs-number">7001s</span>pring<span class="hljs-selector-class">.velocity</span>.cache=falsespring<span class="hljs-selector-class">.velocity</span>.charset=UTF-<span class="hljs-number">8s</span>pring<span class="hljs-selector-class">.velocity</span>.layout-url=/templates/default<span class="hljs-selector-class">.vmspring</span><span class="hljs-selector-class">.messages</span>.fallback-to-system-locale=falsespring<span class="hljs-selector-class">.messages</span>.basename=i18n/messagespring<span class="hljs-selector-class">.root</span>.password=rootspring<span class="hljs-selector-class">.guest</span>.password=guestdubbo<span class="hljs-selector-class">.registry</span>.address=zookeeper:<span class="hljs-comment">//127.0.0.1:2181</span></code></pre><p><strong>3、在项目目录下</strong>打包dubbo-admin</p><pre><code class="hljs reasonml">mvn clean package -<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dmaven</span>.</span></span>test.skip=<span class="hljs-literal">true</span></code></pre><p><strong>第一次打包的过程有点慢，需要耐心等待！直到成功！</strong></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230149119-363508332.png" srcset="/blog/img/loading.gif" alt="img"></p><p>4、执行 dubbo-admin\target 下的dubbo-admin-0.0.1-SNAPSHOT.jar</p><pre><code class="hljs css"><span class="hljs-selector-tag">java</span> <span class="hljs-selector-tag">-jar</span> <span class="hljs-selector-tag">dubbo-admin-0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.1-SNAPSHOT</span><span class="hljs-selector-class">.jar</span></code></pre><p>【注意：zookeeper的服务一定要打开！】</p><p>执行完毕，我们去访问一下 <a href="http://localhost:7001/" target="_blank" rel="noopener">http://localhost:7001/</a> ， 这时候我们需要输入登录账户和密码，我们都是默认的root-root；</p><p>登录成功后，查看界面</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230202910-800109291.png" srcset="/blog/img/loading.gif" alt="img"></p><p>安装完成！</p><h2 id="17-3、SpringBoot-Dubbo-zookeeper"><a href="#17-3、SpringBoot-Dubbo-zookeeper" class="headerlink" title="17.3、SpringBoot + Dubbo + zookeeper"></a>17.3、SpringBoot + Dubbo + zookeeper</h2><h2 id="框架搭建"><a href="#框架搭建" class="headerlink" title="*\***\框架搭建********"></a><strong>*\</strong>*<em>*</em>*<em>\</em>框架搭建*<em>*</em>*<em>*</em>****</h2><p><strong>1. 启动zookeeper ！</strong></p><p><strong>2. IDEA创建一个空项目；</strong></p><p><strong>3.创建一个模块，实现服务提供者：provider-server ， 选择web依赖即可</strong></p><p><strong>4.项目创建完毕，我们写一个服务，比如卖票的服务；</strong></p><p>编写接口</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.provider.service;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TicketService</span> </span>{   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTicket</span><span class="hljs-params">()</span></span>;}</code></pre><p>编写实现类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.provider.service;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TicketServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TicketService</span> </span>{   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTicket</span><span class="hljs-params">()</span> </span>{       <span class="hljs-keyword">return</span> <span class="hljs-string">"《狂神说Java》"</span>;  }}</code></pre><p><strong>5.创建一个模块，实现服务消费者：consumer-server ， 选择web依赖即可</strong></p><p><strong>6.项目创建完毕，我们写一个服务，比如用户的服务；</strong></p><p>编写service</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.consumer.service;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>{   <span class="hljs-comment">//我们需要去拿去注册中心的服务</span>}</code></pre><p><strong>需求：现在我们的用户想使用买票的服务，这要怎么弄呢 ？</strong></p><h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="*\***\服务提供者********"></a><strong>*\</strong>*<em>*</em>*<em>\</em>服务提供者*<em>*</em>*<em>*</em>****</h2><p><strong>1、将服务提供者注册到注册中心，我们需要整合Dubbo和zookeeper，所以需要导包</strong></p><p><strong>我们从dubbo官网进入github，看下方的帮助文档，找到dubbo-springboot，找到依赖包</strong></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Dubbo Spring Boot Starter --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><strong>zookeeper的包我们去maven仓库下载，zkclient；</strong></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.sgroschupf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zkclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><strong>【新版的坑】zookeeper及其依赖包，解决日志冲突，还需要剔除日志依赖；</strong></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入zookeeper --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-comment">&lt;!--排除这个slf4j-log4j12--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p><strong>2、在springboot配置文件中配置dubbo相关属性！</strong></p><pre><code class="hljs properties"><span class="hljs-comment">#当前应用名字</span><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">provider-server</span><span class="hljs-comment">#注册中心地址</span><span class="hljs-meta">dubbo.registry.address</span>=<span class="hljs-string">zookeeper://127.0.0.1:2181</span><span class="hljs-comment">#扫描指定包下服务</span><span class="hljs-meta">dubbo.scan.base-packages</span>=<span class="hljs-string">com.kuang.provider.service</span></code></pre><p><strong>3、在service的实现类中配置服务注解，发布服务！注意导包问题</strong></p><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.dubbo.config.annotation.Service;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Service</span> <span class="hljs-comment">//将服务发布出去</span><span class="hljs-meta">@Component</span> <span class="hljs-comment">//放在容器中</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TicketServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TicketService</span> </span>{   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTicket</span><span class="hljs-params">()</span> </span>{       <span class="hljs-keyword">return</span> <span class="hljs-string">"《狂神说Java》"</span>;  }}</code></pre><p><strong>逻辑理解 ：应用启动起来，dubbo就会扫描指定的包下带有@component注解的服务，将它发布在指定的注册中心中！</strong></p><h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="*\***\服务消费者********"></a><strong>*\</strong>*<em>*</em>*<em>\</em>服务消费者*<em>*</em>*<em>*</em>****</h2><p><strong>1、导入依赖，和之前的依赖一样；</strong></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dubbo--&gt;</span><span class="hljs-comment">&lt;!-- Dubbo Spring Boot Starter --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--zookeeper--&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.sgroschupf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zkclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 引入zookeeper --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <span class="hljs-comment">&lt;!--排除这个slf4j-log4j12--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>2、<strong>配置参数</strong></p><pre><code class="hljs properties"><span class="hljs-comment">#当前应用名字</span><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">consumer-server</span><span class="hljs-comment">#注册中心地址</span><span class="hljs-meta">dubbo.registry.address</span>=<span class="hljs-string">zookeeper://127.0.0.1:2181</span></code></pre><p><strong>3. 本来正常步骤是需要将服务提供者的接口打包，然后用pom文件导入，我们这里使用简单的方式，直接将服务的接口拿过来，路径必须保证正确，即和服务提供者相同；</strong></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230223249-22793107.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>4. 完善消费者的服务类</strong></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.consumer.service;<span class="hljs-keyword">import</span> com.kuang.provider.service.TicketService;<span class="hljs-keyword">import</span> org.apache.dubbo.config.annotation.Reference;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-meta">@Service</span> <span class="hljs-comment">//注入到容器中</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>{   <span class="hljs-meta">@Reference</span> <span class="hljs-comment">//远程引用指定的服务，他会按照全类名进行匹配，看谁给注册中心注册了这个全类名</span>   TicketService ticketService;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bugTicket</span><span class="hljs-params">()</span></span>{       String ticket = ticketService.getTicket();       System.out.println(<span class="hljs-string">"在注册中心买到"</span>+ticket);  }}</code></pre><p><strong>5. 测试类编写；</strong></p><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ConsumerServerApplicationTests</span> </span>{   <span class="hljs-meta">@Autowired</span>   UserService userService;   <span class="hljs-meta">@Test</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>{       userService.bugTicket();  }}</code></pre><h2 id="启动测试"><a href="#启动测试" class="headerlink" title="*\***\启动测试********"></a><strong>*\</strong>*<em>*</em>*<em>\</em>启动测试*<em>*</em>*<em>*</em>****</h2><p><strong>1. 开启zookeeper</strong></p><p><strong>2. 打开dubbo-admin实现监控【可以不用做】</strong></p><p><strong>3. 开启服务者</strong></p><p><strong>4. 消费者消费测试，结果：</strong></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230239279-1442230316.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>监控中心 ：</strong></p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230254269-261185375.png" srcset="/blog/img/loading.gif" alt="img"></p><p><strong>ok , 这就是SpingBoot + dubbo + zookeeper实现分布式开发的应用，其实就是一个服务拆分的思想；</strong></p><h1 id="18、SpringBoot：集成SpringSecurity"><a href="#18、SpringBoot：集成SpringSecurity" class="headerlink" title="18、SpringBoot：集成SpringSecurity"></a>18、SpringBoot：集成SpringSecurity</h1><h2 id="18-1、安全简介"><a href="#18-1、安全简介" class="headerlink" title="18.1、安全简介"></a>18.1、安全简介</h2><p>在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。</p><p>市面上存在比较有名的：Shiro，Spring Security ！</p><p>这里需要阐述一下的是，每一个框架的出现都是为了解决某一问题而产生了，那么Spring Security框架的出现是为了解决什么问题呢？</p><p>首先我们看下它的官网介绍：Spring Security官网地址</p><p>Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.</p><p>Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements</p><p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。</p><p>Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求</p><p>从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。</p><p>怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。</p><p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p><p>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。</p><h2 id="18-2、实战测试"><a href="#18-2、实战测试" class="headerlink" title="18.2、实战测试"></a>18.2、实战测试</h2><h3 id="18-2-1、实验环境搭建"><a href="#18-2-1、实验环境搭建" class="headerlink" title="18.2.1、实验环境搭建"></a>18.2.1、实验环境搭建</h3><p>1、新建一个初始的springboot项目web模块，thymeleaf模块</p><p>2、导入静态资源</p><pre><code class="hljs angelscript">welcome.html|views|level1<span class="hljs-number">1.</span>html<span class="hljs-number">2.</span>html<span class="hljs-number">3.</span>html|level2<span class="hljs-number">1.</span>html<span class="hljs-number">2.</span>html<span class="hljs-number">3.</span>html|level3<span class="hljs-number">1.</span>html<span class="hljs-number">2.</span>html<span class="hljs-number">3.</span>htmlLogin.html</code></pre><p>3、controller跳转！</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.controller;<span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouterController</span> </span>{   <span class="hljs-meta">@RequestMapping</span>({<span class="hljs-string">"/"</span>,<span class="hljs-string">"/index"</span>})   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>{       <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;  }   <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/toLogin"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLogin</span><span class="hljs-params">()</span></span>{       <span class="hljs-keyword">return</span> <span class="hljs-string">"views/login"</span>;  }   <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/level1/{id}"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">level1</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> <span class="hljs-keyword">int</span> id)</span>{       <span class="hljs-keyword">return</span> <span class="hljs-string">"views/level1/"</span>+id;  }   <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/level2/{id}"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">level2</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> <span class="hljs-keyword">int</span> id)</span>{       <span class="hljs-keyword">return</span> <span class="hljs-string">"views/level2/"</span>+id;  }   <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/level3/{id}"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">level3</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> <span class="hljs-keyword">int</span> id)</span>{       <span class="hljs-keyword">return</span> <span class="hljs-string">"views/level3/"</span>+id;  }}</code></pre><p>4、测试实验环境是否OK！</p><h3 id="18-2-2、认识SpringSecurity"><a href="#18-2-2、认识SpringSecurity" class="headerlink" title="18.2.2、认识SpringSecurity"></a>18.2.2、认识SpringSecurity</h3><p>Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！</p><p>记住几个类：</p><ul><li>WebSecurityConfigurerAdapter：自定义Security策略</li><li>AuthenticationManagerBuilder：自定义认证策略</li><li>@EnableWebSecurity：开启WebSecurity模式</li></ul><p>Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。</p><p><strong>“认证”（Authentication）</strong></p><p>身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。</p><p>身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。</p><p><strong>“授权” （Authorization）</strong></p><p>授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。</p><p>这个概念是通用的，而不是只在Spring Security 中存在。</p><h3 id="18-2-3、认证和授权"><a href="#18-2-3、认证和授权" class="headerlink" title="18.2.3、认证和授权"></a>18.2.3、认证和授权</h3><p>目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能</p><p>1、引入 Spring Security 模块</p><pre><code class="hljs java">&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2、编写 Spring Security 配置类</p><p>参考官网：<a href="https://spring.io/projects/spring-security" target="_blank" rel="noopener">https://spring.io/projects/spring-security</a></p><p>查看我们自己项目中的版本，找到对应的帮助文档：</p><p><a href="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5" target="_blank" rel="noopener">https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5</a> #servlet-applications 8.16.4</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230317849-1998269068.png" srcset="/blog/img/loading.gif" alt="img"></p><p>3、编写基础配置类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.config;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<span class="hljs-meta">@EnableWebSecurity</span> <span class="hljs-comment">// 开启WebSecurity模式</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>{   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>{         }}</code></pre><p>4、定制请求的授权规则</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>{   <span class="hljs-comment">// 定制请求的授权规则</span>   <span class="hljs-comment">// 首页所有人可以访问</span>   http.authorizeRequests().antMatchers(<span class="hljs-string">"/"</span>).permitAll()  .antMatchers(<span class="hljs-string">"/level1/**"</span>).hasRole(<span class="hljs-string">"vip1"</span>)  .antMatchers(<span class="hljs-string">"/level2/**"</span>).hasRole(<span class="hljs-string">"vip2"</span>)  .antMatchers(<span class="hljs-string">"/level3/**"</span>).hasRole(<span class="hljs-string">"vip3"</span>);}</code></pre><p>5、测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！</p><p>6、在configure()方法中加入以下配置，开启自动配置的登录功能！</p><pre><code class="hljs java"><span class="hljs-comment">// 开启自动配置的登录功能</span><span class="hljs-comment">// /login 请求来到登录页</span><span class="hljs-comment">// /login?error 重定向到这里表示登录失败</span>http.formLogin();</code></pre><p>7、测试一下：发现，没有权限的时候，会跳转到登录的页面！</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230333154-1538491155.png" srcset="/blog/img/loading.gif" alt="img"></p><p>8、查看刚才登录页的注释信息；</p><p>我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法</p><pre><code class="hljs java"><span class="hljs-comment">//定义认证规则</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>{      <span class="hljs-comment">//在内存中定义，也可以在jdbc中去拿....</span>   auth.inMemoryAuthentication()          .withUser(<span class="hljs-string">"kuangshen"</span>).password(<span class="hljs-string">"123456"</span>).roles(<span class="hljs-string">"vip2"</span>,<span class="hljs-string">"vip3"</span>)          .and()          .withUser(<span class="hljs-string">"root"</span>).password(<span class="hljs-string">"123456"</span>).roles(<span class="hljs-string">"vip1"</span>,<span class="hljs-string">"vip2"</span>,<span class="hljs-string">"vip3"</span>)          .and()          .withUser(<span class="hljs-string">"guest"</span>).password(<span class="hljs-string">"123456"</span>).roles(<span class="hljs-string">"vip1"</span>,<span class="hljs-string">"vip2"</span>);}</code></pre><p>9、测试，我们可以使用这些账号登录进行测试！发现会报错！</p><p>There is no PasswordEncoder mapped for the id “null”</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230347555-1367252514.png" srcset="/blog/img/loading.gif" alt="img"></p><p>10、原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码</p><pre><code class="hljs java"><span class="hljs-comment">//定义认证规则</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>{   <span class="hljs-comment">//在内存中定义，也可以在jdbc中去拿....</span>   <span class="hljs-comment">//Spring security 5.0中新增了多种加密方式，也改变了密码的格式。</span>   <span class="hljs-comment">//要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密</span>   <span class="hljs-comment">//spring security 官方推荐的是使用bcrypt加密方式。</span>      auth.inMemoryAuthentication().passwordEncoder(<span class="hljs-keyword">new</span> BCryptPasswordEncoder())          .withUser(<span class="hljs-string">"kuangshen"</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123456"</span>)).roles(<span class="hljs-string">"vip2"</span>,<span class="hljs-string">"vip3"</span>)          .and()          .withUser(<span class="hljs-string">"root"</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123456"</span>)).roles(<span class="hljs-string">"vip1"</span>,<span class="hljs-string">"vip2"</span>,<span class="hljs-string">"vip3"</span>)          .and()          .withUser(<span class="hljs-string">"guest"</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123456"</span>)).roles(<span class="hljs-string">"vip1"</span>,<span class="hljs-string">"vip2"</span>);}</code></pre><p>11、测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定</p><h3 id="18-2-4、权限控制和注销"><a href="#18-2-4、权限控制和注销" class="headerlink" title="18.2.4、权限控制和注销"></a>18.2.4、权限控制和注销</h3><p>1、开启自动配置的注销的功能</p><pre><code class="hljs java"><span class="hljs-comment">//定制请求的授权规则</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>{   <span class="hljs-comment">//....</span>   <span class="hljs-comment">//开启自动配置的注销的功能</span>      <span class="hljs-comment">// /logout 注销请求</span>   http.logout();}</code></pre><p>2、我们在前端，增加一个注销的按钮，index.html 导航栏中</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/logout}"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"address card icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> 注销<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>3、我们可以去测试一下，登录成功后点击注销，发现注销完毕会跳转到登录页面！</p><p>4、但是，我们想让他注销成功后，依旧可以跳转到首页，该怎么处理呢？</p><pre><code class="hljs java"><span class="hljs-comment">// .logoutSuccessUrl("/"); 注销成功来到首页</span>http.logout().logoutSuccessUrl(<span class="hljs-string">"/"</span>);</code></pre><p>5、测试，注销完毕后，发现跳转到首页OK</p><p>6、我们现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？</p><p><strong>我们需要结合thymeleaf中的一些功能</strong></p><p>sec：authorize=”isAuthenticated()”:是否认证登录！来显示不同的页面</p><p>Maven依赖：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-extras-springsecurity5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>7、修改我们的 前端页面</p><ol><li><p>导入命名空间</p></li><li><pre><code class="html">xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity5"<span class="comment"><pre><code class="hljs dust"><span class="xml">3. 修改导航栏，增加认证判断</span><span class="xml">4. ```html</span><span class="xml"><span class="hljs-comment">&lt;!--登录注销--&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right menu"</span>&gt;</span></span><span class="xml"></span><span class="xml">   <span class="hljs-comment">&lt;!--如果未登录--&gt;</span></span><span class="xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">sec:authorize</span>=<span class="hljs-string">"!isAuthenticated()"</span>&gt;</span></span><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@</span></span></span><span class="hljs-template-tag">{/<span class="hljs-name">login</span>}</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>&gt;</span></span><span class="xml">           <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"address card icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> 登录</span><span class="xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"></span><span class="xml">   <span class="hljs-comment">&lt;!--如果已登录--&gt;</span></span><span class="xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">sec:authorize</span>=<span class="hljs-string">"isAuthenticated()"</span>&gt;</span></span><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span></span><span class="xml">           <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"address card icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><span class="xml">          用户名：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">sec:authentication</span>=<span class="hljs-string">"principal.username"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="xml">          角色：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">sec:authentication</span>=<span class="hljs-string">"principal.authorities"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"></span><span class="xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">sec:authorize</span>=<span class="hljs-string">"isAuthenticated()"</span>&gt;</span></span><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@</span></span></span><span class="hljs-template-tag">{/<span class="hljs-name">logout</span>}</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>&gt;</span></span><span class="xml">           <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"address card icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> 注销</span><span class="xml">       <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre></span></code></pre></li></ol><p>8、重启测试，我们可以登录试试看，登录成功后确实，显示了我们想要的页面；</p><p>9、如果注销404了，就是因为它默认防止csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 <code>http.csrf().disable();</code></p><pre><code class="hljs java">http.csrf().disable();<span class="hljs-comment">//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求</span>http.logout().logoutSuccessUrl(<span class="hljs-string">"/"</span>);</code></pre><p>10、我们继续将下面的角色功能块认证完成！</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- sec:authorize="hasRole('vip1')" --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span> <span class="hljs-attr">sec:authorize</span>=<span class="hljs-string">"hasRole('vip1')"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ui raised segment"</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ui"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content"</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content"</span>&gt;</span>Level 1<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/level1/1}"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bullhorn icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-1-1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/level1/2}"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bullhorn icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-1-2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/level1/3}"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bullhorn icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-1-3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span> <span class="hljs-attr">sec:authorize</span>=<span class="hljs-string">"hasRole('vip2')"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ui raised segment"</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ui"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content"</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content"</span>&gt;</span>Level 2<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/level2/1}"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bullhorn icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-2-1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/level2/2}"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bullhorn icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-2-2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/level2/3}"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bullhorn icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-2-3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"column"</span> <span class="hljs-attr">sec:authorize</span>=<span class="hljs-string">"hasRole('vip3')"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ui raised segment"</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ui"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content"</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content"</span>&gt;</span>Level 3<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/level3/1}"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bullhorn icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-3-1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/level3/2}"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bullhorn icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-3-2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/level3/3}"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bullhorn icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-3-3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>11、测试一下！</p><p>12、权限控制和注销搞定！</p><h3 id="18-2-5、记住我"><a href="#18-2-5、记住我" class="headerlink" title="18.2.5、记住我"></a>18.2.5、记住我</h3><p>现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单</p><p>1、开启记住我功能</p><pre><code class="hljs java"><span class="hljs-comment">//定制请求的授权规则</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>{<span class="hljs-comment">//。。。。。。。。。。。</span>   <span class="hljs-comment">//记住我</span>   http.rememberMe();}</code></pre><p>2、我们再次启动项目测试一下，发现登录页多了一个记住我功能，我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！</p><p>思考：如何实现的呢？其实非常简单</p><p>我们可以查看浏览器的cookie</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230410090-275194565.png" srcset="/blog/img/loading.gif" alt="img"></p><p>3、我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230424964-1382261300.png" srcset="/blog/img/loading.gif" alt="img"><br>4、结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie，具体的原理我们在JavaWeb阶段都讲过了，这里就不在多说了！</p><h3 id="18-2-6、定制登录页"><a href="#18-2-6、定制登录页" class="headerlink" title="18.2.6、定制登录页"></a>18.2.6、定制登录页</h3><p>现在这个登录页面都是spring security 默认的，怎么样可以使用我们自己写的Login界面呢？</p><p>1、在刚才的登录页配置后面指定 loginpage</p><pre><code class="hljs java">http.formLogin().loginPage(<span class="hljs-string">"/toLogin"</span>);</code></pre><p>2、然后前端也需要指向我们自己定义的 login请求</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/toLogin}"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"address card icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> 登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>3、我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为post:</p><p>在 loginPage()源码中的注释上有写明：</p><p><img src="https://img2020.cnblogs.com/blog/1905053/202004/1905053-20200412230440929-230804638.png" srcset="/blog/img/loading.gif" alt="img"></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">"@{/login}"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"field"</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ui left icon input"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Username"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"user icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"field"</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Password<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ui left icon input"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"lock icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ui blue submit button"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><p>4、这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看formLogin()方法的源码！我们配置接收登录的用户名和密码的参数！</p><pre><code class="hljs java">http.formLogin()  .usernameParameter(<span class="hljs-string">"username"</span>)  .passwordParameter(<span class="hljs-string">"password"</span>)  .loginPage(<span class="hljs-string">"/toLogin"</span>)  .loginProcessingUrl(<span class="hljs-string">"/login"</span>); <span class="hljs-comment">// 登陆表单提交请求</span></code></pre><p>5、在登录页增加记住我的多选框</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"remember"</span>&gt;</span> 记住我</code></pre><p>6、后端验证处理！</p><pre><code class="hljs java"><span class="hljs-comment">//定制记住我的参数！</span>http.rememberMe().rememberMeParameter(<span class="hljs-string">"remember"</span>);</code></pre><p>7、测试，OK</p><h2 id="18-3、完整配置代码"><a href="#18-3、完整配置代码" class="headerlink" title="18.3、完整配置代码"></a>18.3、完整配置代码</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.config;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<span class="hljs-keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;<span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>{   <span class="hljs-comment">//定制请求的授权规则</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>{       http.authorizeRequests().antMatchers(<span class="hljs-string">"/"</span>).permitAll()      .antMatchers(<span class="hljs-string">"/level1/**"</span>).hasRole(<span class="hljs-string">"vip1"</span>)      .antMatchers(<span class="hljs-string">"/level2/**"</span>).hasRole(<span class="hljs-string">"vip2"</span>)      .antMatchers(<span class="hljs-string">"/level3/**"</span>).hasRole(<span class="hljs-string">"vip3"</span>);       <span class="hljs-comment">//开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！</span>           <span class="hljs-comment">// /login 请求来到登录页</span>           <span class="hljs-comment">// /login?error 重定向到这里表示登录失败</span>       http.formLogin()          .usernameParameter(<span class="hljs-string">"username"</span>)          .passwordParameter(<span class="hljs-string">"password"</span>)          .loginPage(<span class="hljs-string">"/toLogin"</span>)          .loginProcessingUrl(<span class="hljs-string">"/login"</span>); <span class="hljs-comment">// 登陆表单提交请求</span>       <span class="hljs-comment">//开启自动配置的注销的功能</span>           <span class="hljs-comment">// /logout 注销请求</span>           <span class="hljs-comment">// .logoutSuccessUrl("/"); 注销成功来到首页</span>       http.csrf().disable();<span class="hljs-comment">//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求</span>       http.logout().logoutSuccessUrl(<span class="hljs-string">"/"</span>);       <span class="hljs-comment">//记住我</span>       http.rememberMe().rememberMeParameter(<span class="hljs-string">"remember"</span>);  }   <span class="hljs-comment">//定义认证规则</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>{       <span class="hljs-comment">//在内存中定义，也可以在jdbc中去拿....</span>       <span class="hljs-comment">//Spring security 5.0中新增了多种加密方式，也改变了密码的格式。</span>       <span class="hljs-comment">//要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密</span>       <span class="hljs-comment">//spring security 官方推荐的是使用bcrypt加密方式。</span>       auth.inMemoryAuthentication().passwordEncoder(<span class="hljs-keyword">new</span> BCryptPasswordEncoder())              .withUser(<span class="hljs-string">"kuangshen"</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123456"</span>)).roles(<span class="hljs-string">"vip2"</span>,<span class="hljs-string">"vip3"</span>)              .and()              .withUser(<span class="hljs-string">"root"</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123456"</span>)).roles(<span class="hljs-string">"vip1"</span>,<span class="hljs-string">"vip2"</span>,<span class="hljs-string">"vip3"</span>)              .and()              .withUser(<span class="hljs-string">"guest"</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123456"</span>)).roles(<span class="hljs-string">"vip1"</span>,<span class="hljs-string">"vip2"</span>);  }}</code></pre><p>去进行一波源码分析！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转自&lt;a href=&quot;https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;狂神老师&lt;/a&gt;，非常感谢老师，仅作为个人笔记使用&lt;/p&gt;
&lt;p&gt;部分来自&lt;a href=&quot;https://blog.csdn.net/qq_26017543/article/details/108530412?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160164522319725255512089%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;amp;request_id=160164522319725255512089&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28_p-12-108530412.pc_first_rank_v2_rank_v28_p&amp;amp;utm_term=%E7%8B%82%E7%A5%9E+springboot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="SSM" scheme="https://melodyjerry.github.io/blog/tags/SSM/"/>
    
      <category term="笔记" scheme="https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaWeb" scheme="https://melodyjerry.github.io/blog/tags/JavaWeb/"/>
    
      <category term="SpringBoot" scheme="https://melodyjerry.github.io/blog/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装node v12.16.3</title>
    <link href="https://melodyjerry.github.io/blog/2020/09/23/Linux%E4%B8%8B%E5%AE%89%E8%A3%85node-v12.16.3/"/>
    <id>https://melodyjerry.github.io/blog/2020/09/23/Linux%E4%B8%8B%E5%AE%89%E8%A3%85node-v12.16.3/</id>
    <published>2020-09-23T09:21:21.000Z</published>
    <updated>2020-10-07T15:10:10.791Z</updated>
    
    <content type="html"><![CDATA[<ol><li>下载nodejs</li></ol><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~wget http://nodejs.org/dist/v12.16.3/node-v12.16.3-linux-x64.tar.gz</code></pre><ol start="2"><li>解压并修改解压后文件名</li></ol><pre><code class="hljs bash">tar -zxvf node-v12.16.3-linux-x64.tar.gz mv node-v12.16.3-linux-x64 nodejs</code></pre><ol start="3"><li>切换路径到解压后文件</li></ol><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> nodejs/bin   //　　切换路径./node -v        //查看node是否安装成功 若成功返回 v12.16.3pwm               //查看node路径   (我安装在根目录下)返回 /root/nodejs/bin</code></pre><ol start="4"><li>配置环境变量</li></ol><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~ //切换到根目录vim ~/.bash_profile     //查看环境变量文件//在配置文件里面，设置PATH环境变量//我查看时，PATH环境变量为PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/bin。在其后面添加：，在：后面添加之前执行pwm返回的路径PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/bin:/root/nodejs/bin     //键盘输入i 切换为输入状态。编辑完之后 点击esc键 退出编辑状态  输入：wq 保存离开<span class="hljs-built_in">source</span> ~/.bash_profile     //保存配置文件  可不执行</code></pre><ol start="5"><li>查看node版本</li></ol><pre><code class="hljs bash">node -v</code></pre><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;下载nodejs&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;cd&lt;/span&gt; ~
wget http://nodejs.org/dist/v12.16.3/node-v12.16.3-linux-x64.tar.gz&lt;/code&gt;&lt;/pre&gt;

&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;解压并修改解压后文件名&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;tar -zxvf node-v12.16.3-linux-x64.tar.gz 
mv node-v12.16.3-linux-x64 nodejs&lt;/code&gt;&lt;/pre&gt;

&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;切换路径到解压后文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;cd&lt;/span&gt; nodejs/bin   //　　切换路径
./node -v        //查看node是否安装成功 若成功返回 v12.16.3
pwm               //查看node路径   (我安装在根目录下)返回 /root/nodejs/bin&lt;/code&gt;&lt;/pre&gt;

&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;配置环境变量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;cd&lt;/span&gt; ~ //切换到根目录
vim ~/.bash_profile     //查看环境变量文件
//在配置文件里面，设置PATH环境变量
//我查看时，PATH环境变量为PATH=&lt;span class=&quot;hljs-variable&quot;&gt;$PATH&lt;/span&gt;:&lt;span class=&quot;hljs-variable&quot;&gt;$HOME&lt;/span&gt;/bin。在其后面添加：，在：后面添加之前执行pwm返回的路径
PATH=&lt;span class=&quot;hljs-variable&quot;&gt;$PATH&lt;/span&gt;:&lt;span class=&quot;hljs-variable&quot;&gt;$HOME&lt;/span&gt;/bin:/root/nodejs/bin     //键盘输入i 切换为输入状态。编辑完之后 点击esc键 退出编辑状态  输入：wq 保存离开
&lt;span class=&quot;hljs-built_in&quot;&gt;source&lt;/span&gt; ~/.bash_profile     //保存配置文件  可不执行&lt;/code&gt;&lt;/pre&gt;

&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;查看node版本&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;node -v&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="Linux" scheme="https://melodyjerry.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>yum常见命令-安装与卸载软件</title>
    <link href="https://melodyjerry.github.io/blog/2020/09/23/yum%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/"/>
    <id>https://melodyjerry.github.io/blog/2020/09/23/yum%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/</id>
    <published>2020-09-23T04:21:21.000Z</published>
    <updated>2020-10-07T15:10:10.923Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="1-使用yum安装和卸载软件"><a href="#1-使用yum安装和卸载软件" class="headerlink" title="1.使用yum安装和卸载软件"></a>1.使用yum安装和卸载软件</h2><ul><li>有个前提是yum安装的软件包都是rpm格式的</li></ul><p>安装的命令是，<code>yum install ~</code>，yum会查询数据库，有无这一软件包，如果有，则检查其依赖冲突关系，如果没有依赖冲突，那么最好，下载安装;如果有，则会给出提示，询问是否要同时安装依赖，或删除冲突的包，你可以自己作出判断；</p><p>删除的命令是，<code>yum remove ~</code>，同安装一样，yum也会查询数据库，给出解决依赖关系的提示。</p><p>其中<code>~</code>代表软件名</p><p>1) 用YUM安装软件包命令：<code>yum install ~</code></p><p>2) 用YUM删除软件包命令：<code>yum remove ~</code></p><h2 id="2-用yum查询想安装的软件"><a href="#2-用yum查询想安装的软件" class="headerlink" title="2.用yum查询想安装的软件"></a>2.用yum查询想安装的软件</h2><p>​    我们常会碰到这样的情况，想安装一个软件，只知道它和某方面有关，但又不能确切知道它的名字。这时yum的查询功能就起作用了。我们可以用<code>yum search keyword</code>这样的命令来进行搜索，比如我们要则安装一个InstantMessenger，但又不知到底有哪些，这时不妨用<code>yum search messenger</code>这样的指令进行搜索，yum会搜索所有可用rpm的描述，列出所有描述中和messeger有关的rpm包，于是我们可能得到 gaim，kopete等等，并从中选择。</p><p>有时我们还会碰到安装了一个包，但又不知道其用途，我们可以用<code>yuminfo packagename</code>这个指令来获取信息。</p><ol><li><p>使用YUM查找软件包</p><p>命令：<code>yum search ~</code></p><p>2.列出所有可安装的软件包</p><p>命令：<code>yum list</code></p><p>3.列出所有可更新的软件包</p><p>命令：<code>yum list updates</code></p><p>4.列出所有已安装的软件包</p><p>命令：<code>yum list installed</code></p><p>5.列出所有已安装但不在Yum Repository內的软件包</p><p>命令：<code>yum list extras</code></p><p>6.列出所指定软件包</p><p>命令：<code>yum list ~</code></p><p>7.使用YUM获取软件包信息</p><p>命令：<code>yum info ~</code></p><p>8.列出所有软件包的信息</p><p>命令：<code>yum info</code></p><p>9.列出所有可更新的软件包信息</p><p>命令：<code>yum info updates</code></p><p>10.列出所有已安裝的软件包信息</p><p>命令：<code>yum info installed</code></p><p>11.列出所有已安裝但不在Yum Repository內的软件包信息</p><p>命令：<code>yum info extras</code></p><p>12.列出软件包提供哪些文件</p><p>命令：<code>yum provides ~</code></p></li></ol><h2 id="3-清除yum缓存"><a href="#3-清除yum缓存" class="headerlink" title="3.清除yum缓存"></a>3.清除yum缓存</h2><p>yum会把下载的软件包和header存储在cache中，而不会自动删除。如果我们觉得它们占用了磁盘空间，可以使用<code>yum clean</code>指令进行清除，更精确的用法是<code>yumclean headers</code>清除header，<code>yum clean packages</code>清除下载的rpm包，<code>yum clean all</code> 清除所有。</p><p>1.清除缓存目录(/var/cache/yum)下的软件包</p><p>命令：<code>yum clean packages</code></p><p>2.清除缓存目录(/var/cache/yum)下的 headers</p><p>命令：<code>yum clean headers</code></p><p>3.清除缓存目录(/var/cache/yum)下旧的 headers</p><p>命令：<code>yum clean oldheaders</code></p><p>4.清除缓存目录(/var/cache/yum)下的软件包及旧的headers</p><p>命令：<code>yum clean, yum clean all (= yum clean packages; yum clean oldheaders)</code></p><h2 id="4-yum命令工具使用举例"><a href="#4-yum命令工具使用举例" class="headerlink" title="4.yum命令工具使用举例"></a>4.yum命令工具使用举例</h2><p><code>yum update</code> 升级系统</p><p><code>yum install  ~</code> 安装指定软件包</p><p><code>yum update ~</code> 升级指定软件包</p><p><code>yum remove ~</code> 卸载指定软件</p><p><code>yum grouplist</code> 查看系统中已经安装的和可用的软件组，可用的可以安装</p><p><code>yum groupinstall ~</code> 安装上一个命令显示的可用的软件组中的一个</p><p><code>yum groupupdate ~</code> 更新指定软件组的软件包</p><p><code>yum groupremove ~</code> 卸载指定软件组中的软件包</p><p><code>yum deplist ~</code> 查询指定软件包的依赖关系</p><p><code>yum list yum\*</code> 列出所有以yum开头的软件包</p><p><code>yum localinstall ~</code> 从硬盘安装rpm包并使用yum解决依赖</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;1-使用yum安装和卸载软件&quot;&gt;&lt;a href=&quot;#1-使用yum安装和卸载软件&quot; class=&quot;headerlink&quot; title=&quot;1.使用yum安装和卸载软件&quot;&gt;&lt;/a&gt;1.使用yum安装和卸载软件&lt;/h2&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="Linux" scheme="https://melodyjerry.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下更新Node到最新版本</title>
    <link href="https://melodyjerry.github.io/blog/2020/09/22/Linux%E4%B8%8B%E6%9B%B4%E6%96%B0Node%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC/"/>
    <id>https://melodyjerry.github.io/blog/2020/09/22/Linux%E4%B8%8B%E6%9B%B4%E6%96%B0Node%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC/</id>
    <published>2020-09-22T14:21:21.000Z</published>
    <updated>2020-10-07T15:10:10.778Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-查看当前node的版本号"><a href="#1-查看当前node的版本号" class="headerlink" title="1. 查看当前node的版本号"></a>1. 查看当前node的版本号</h5><pre><code class="hljs bash">node --version</code></pre><p><img src="https://s1.ax1x.com/2020/09/22/wXeQwF.png" srcset="/blog/img/loading.gif" alt="wXeQwF.png"></p><h5 id="2-清理npm的cache"><a href="#2-清理npm的cache" class="headerlink" title="2. 清理npm的cache"></a>2. 清理npm的cache</h5><pre><code class="hljs bash">npm cache clean -f</code></pre><h5 id="3-版本管理工具-名称：-n"><a href="#3-版本管理工具-名称：-n" class="headerlink" title="3. 版本管理工具 名称： n"></a>3. 版本管理工具 名称： n</h5><pre><code class="hljs undefined">npm install -g n</code></pre><p><img src="https://s1.ax1x.com/2020/09/22/wXe8Y9.png" srcset="/blog/img/loading.gif" alt="wXe8Y9.png"></p><h5 id="4-更新到最新版"><a href="#4-更新到最新版" class="headerlink" title="4. 更新到最新版"></a>4. 更新到最新版</h5><pre><code class="hljs undefined">n latest</code></pre><p><img src="https://s1.ax1x.com/2020/09/22/wXeqXV.png" srcset="/blog/img/loading.gif" alt="wXeqXV.png"></p><ul><li><code>n</code> 常用的命令有：<br>  <code>n</code> 会列出所有安装的版本供你切换<br>  <code>n latest</code> 安装最新版本<br>  <code>n stable</code> 安装最新稳定版<br>  <code>n lts</code> 安装最新长期支持版本<br>  <code>n rm [版本号]</code> 删除某一版本<br>  <code>n -h</code> 帮助命令<br>  <code>n [版本号]</code> 安装指定版本node</li></ul><h5 id="5-验证是否成功"><a href="#5-验证是否成功" class="headerlink" title="5. 验证是否成功"></a>5. 验证是否成功</h5><pre><code class="hljs undefined">node -v</code></pre><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-查看当前node的版本号&quot;&gt;&lt;a href=&quot;#1-查看当前node的版本号&quot; class=&quot;headerlink&quot; title=&quot;1. 查看当前node的版本号&quot;&gt;&lt;/a&gt;1. 查看当前node的版本号&lt;/h5&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;node --version&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/09/22/wXeQwF.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;wXeQwF.png&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;2-清理npm的cache&quot;&gt;&lt;a href=&quot;#2-清理npm的cache&quot; class=&quot;headerlink&quot; title=&quot;2. 清理npm的cache&quot;&gt;&lt;/a&gt;2. 清理npm的cache&lt;/h5&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;npm cache clean -f&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;3-版本管理工具-名称：-n&quot;&gt;&lt;a href=&quot;#3-版本管理工具-名称：-n&quot; class=&quot;headerlink&quot; title=&quot;3. 版本管理工具 名称： n&quot;&gt;&lt;/a&gt;3. 版本管理工具 名称： n&lt;/h5&gt;&lt;pre&gt;&lt;code class=&quot;hljs undefined&quot;&gt;npm install -g n&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/09/22/wXe8Y9.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;wXe8Y9.png&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;4-更新到最新版&quot;&gt;&lt;a href=&quot;#4-更新到最新版&quot; class=&quot;headerlink&quot; title=&quot;4. 更新到最新版&quot;&gt;&lt;/a&gt;4. 更新到最新版&lt;/h5&gt;&lt;pre&gt;&lt;code class=&quot;hljs undefined&quot;&gt;n latest&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/09/22/wXeqXV.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;wXeqXV.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; 常用的命令有：&lt;br&gt;  &lt;code&gt;n&lt;/code&gt; 会列出所有安装的版本供你切换&lt;br&gt;  &lt;code&gt;n latest&lt;/code&gt; 安装最新版本&lt;br&gt;  &lt;code&gt;n stable&lt;/code&gt; 安装最新稳定版&lt;br&gt;  &lt;code&gt;n lts&lt;/code&gt; 安装最新长期支持版本&lt;br&gt;  &lt;code&gt;n rm [版本号]&lt;/code&gt; 删除某一版本&lt;br&gt;  &lt;code&gt;n -h&lt;/code&gt; 帮助命令&lt;br&gt;  &lt;code&gt;n [版本号]&lt;/code&gt; 安装指定版本node&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;5-验证是否成功&quot;&gt;&lt;a href=&quot;#5-验证是否成功&quot; class=&quot;headerlink&quot; title=&quot;5. 验证是否成功&quot;&gt;&lt;/a&gt;5. 验证是否成功&lt;/h5&gt;&lt;pre&gt;&lt;code class=&quot;hljs undefined&quot;&gt;node -v&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="Linux" scheme="https://melodyjerry.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下mongodb安装</title>
    <link href="https://melodyjerry.github.io/blog/2020/09/22/Ubuntu%E4%B8%8Bmongodb%E5%AE%89%E8%A3%85/"/>
    <id>https://melodyjerry.github.io/blog/2020/09/22/Ubuntu%E4%B8%8Bmongodb%E5%AE%89%E8%A3%85/</id>
    <published>2020-09-22T13:21:21.000Z</published>
    <updated>2020-10-07T15:10:10.836Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>下载mongodb源码，并解压：</p> <pre><code class="hljs bash">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-4.0.11.tgztar -zxvf mongodb-linux-x86_64-ubuntu1604-4.0.11.tgz</code></pre></li><li><p>创建mongo专属目录，拷贝bin下文件到mongodb目录下bin中：</p> <pre><code class="hljs bash">mkdir /usr/<span class="hljs-built_in">local</span>/mongodb<span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/mongodbmkdir bincp .../mongodb-linux-x86_64-ubuntu1604-4.0.11/bin/* ./bin/</code></pre></li><li><p>创建数据库文件目录、日志目录、配置文件：</p> <pre><code class="hljs bash">mkdir datatouch mongodb.logtouch mongodb.conf</code></pre></li><li><p>配置文件内容：</p> <pre><code class="hljs bash">dbpath=/usr/<span class="hljs-built_in">local</span>/mongodb/datalogpath=/usr/<span class="hljs-built_in">local</span>/mongodb/mongodb.loglogappend=<span class="hljs-literal">true</span>journal=<span class="hljs-literal">true</span>fork=<span class="hljs-literal">true</span>bind_ip = 127.0.0.1port = 27017noauth = <span class="hljs-literal">true</span><span class="hljs-comment">#auth = true</span></code></pre></li><li><p>将mongo添加path：</p> <pre><code class="hljs bash"><span class="hljs-comment">#打开profile</span>vi /etc/profile<span class="hljs-comment">#输入下面内容：</span>MONGO_DB=<span class="hljs-string">"/usr/local/mongodb"</span>PATH=<span class="hljs-variable">$MONGO_DB</span>/bin:<span class="hljs-variable">$PATH</span>:<span class="hljs-built_in">export</span> PATH<span class="hljs-comment">#加载配置</span><span class="hljs-built_in">source</span> /etc/profile</code></pre></li><li><p>启动mongodb：</p> <pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/mongodb/bin/mongod --config /usr/<span class="hljs-built_in">local</span>/mongodb/mongodb.conf</code></pre> <pre><code class="hljs bash"><span class="hljs-comment">#启动后会看到：</span>about to fork child process, waiting until server is ready <span class="hljs-keyword">for</span> connections.forked process: 1361child process started successfully, parent exiting</code></pre>  <a id="more"></a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载mongodb源码，并解压：&lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-4.0.11.tgz

tar -zxvf mongodb-linux-x86_64-ubuntu1604-4.0.11.tgz&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建mongo专属目录，拷贝bin下文件到mongodb目录下bin中：&lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;mkdir /usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/mongodb

&lt;span class=&quot;hljs-built_in&quot;&gt;cd&lt;/span&gt; /usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/mongodb

mkdir bin

cp .../mongodb-linux-x86_64-ubuntu1604-4.0.11/bin/* ./bin/&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建数据库文件目录、日志目录、配置文件：&lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;mkdir data

touch mongodb.log

touch mongodb.conf&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置文件内容：&lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;dbpath=/usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/mongodb/data
logpath=/usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/mongodb/mongodb.log

logappend=&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;
journal=&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;
fork=&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;

bind_ip = 127.0.0.1
port = 27017

noauth = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;#auth = true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将mongo添加path：&lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#打开profile&lt;/span&gt;
vi /etc/profile

&lt;span class=&quot;hljs-comment&quot;&gt;#输入下面内容：&lt;/span&gt;
MONGO_DB=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/usr/local/mongodb&quot;&lt;/span&gt;
PATH=&lt;span class=&quot;hljs-variable&quot;&gt;$MONGO_DB&lt;/span&gt;/bin:&lt;span class=&quot;hljs-variable&quot;&gt;$PATH&lt;/span&gt;:
&lt;span class=&quot;hljs-built_in&quot;&gt;export&lt;/span&gt; PATH

&lt;span class=&quot;hljs-comment&quot;&gt;#加载配置&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;source&lt;/span&gt; /etc/profile&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动mongodb：&lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;/usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/mongodb/bin/mongod --config /usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/mongodb/mongodb.conf&lt;/code&gt;&lt;/pre&gt;

 &lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#启动后会看到：&lt;/span&gt;

about to fork child process, waiting until server is ready &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; connections.
forked process: 1361
child process started successfully, parent exiting&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="Linux" scheme="https://melodyjerry.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>[转]JavaScript 初学者教程（指南）</title>
    <link href="https://melodyjerry.github.io/blog/2020/09/22/JavaScript-%E5%88%9D%E5%AD%A6%E8%80%85%E6%95%99%E7%A8%8B%EF%BC%88%E6%8C%87%E5%8D%97%EF%BC%89/"/>
    <id>https://melodyjerry.github.io/blog/2020/09/22/JavaScript-%E5%88%9D%E5%AD%A6%E8%80%85%E6%95%99%E7%A8%8B%EF%BC%88%E6%8C%87%E5%8D%97%EF%BC%89/</id>
    <published>2020-09-22T13:21:13.000Z</published>
    <updated>2020-10-07T15:10:10.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-初学者教程（指南）"><a href="#JavaScript-初学者教程（指南）" class="headerlink" title="JavaScript 初学者教程（指南）"></a>JavaScript 初学者教程（指南）</h1><blockquote><p>原文链接：<a href="https://segmentfault.com/a/1190000016337325" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016337325</a></p><p>作者：joyqi</p></blockquote><p>JavaScript 是前端开发者使用的主要编程语言，随着前端技术的发展，这门语言的边界也得以不断扩展。我们在这里选择了与 JavaScript 相关的经典文章，可以让大家对如何学习这门语言有一些全面的认识。特别的，我们还着重于 JavaScript 这门语言与其它编程语言的不同之处，方便大家深入理解。</p><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><ul><li><a href="https://segmentfault.com/a/1190000016110909" target="_blank" rel="noopener">JavaScript 循环</a></li><li><a href="https://segmentfault.com/a/1190000009324194" target="_blank" rel="noopener">JavaScript 正则表达式</a></li><li><a href="https://segmentfault.com/a/1190000000652891" target="_blank" rel="noopener">JavaScript 闭包</a></li><li><a href="https://segmentfault.com/a/1190000007535316" target="_blank" rel="noopener">JavaScript async/await</a></li><li><a href="https://segmentfault.com/a/1190000016133613" target="_blank" rel="noopener">ES6 元编程</a></li><li><a href="https://segmentfault.com/a/1190000015569915" target="_blank" rel="noopener">JavaScript 垃圾内存回收机制</a></li><li><a href="https://segmentfault.com/a/1190000014495089" target="_blank" rel="noopener">JavaScript 装饰器</a></li><li><a href="https://segmentfault.com/a/1190000016231512" target="_blank" rel="noopener">JavaScript AST 抽象语法树</a></li><li><a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">JavaScript 单线程运行机制</a></li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul><li><a href="https://segmentfault.com/a/1190000015727237" target="_blank" rel="noopener">JavaScript 继承 原型链 prototype</a></li><li><a href="https://segmentfault.com/a/1190000011801127" target="_blank" rel="noopener">JavaScript <strong>proto</strong> 与 prototype</a></li><li><a href="https://segmentfault.com/a/1190000015444951" target="_blank" rel="noopener">JavaScript this</a></li><li><a href="https://segmentfault.com/a/1190000013107871" target="_blank" rel="noopener">JavaScript 拷贝对象</a></li></ul><h2 id="函数解析"><a href="#函数解析" class="headerlink" title="函数解析"></a>函数解析</h2><ul><li><a href="https://segmentfault.com/a/1190000003810652" target="_blank" rel="noopener">JavaScript Fetch</a></li><li><a href="https://segmentfault.com/a/1190000007434923" target="_blank" rel="noopener">JavaScript Object.defineProperty</a></li><li><a href="https://segmentfault.com/a/1190000012578794" target="_blank" rel="noopener">JavaScript cookie/localStorage/sessionStorage</a></li><li><a href="https://segmentfault.com/a/1190000015908109" target="_blank" rel="noopener">JavaScript Array 数组</a></li><li><a href="https://segmentfault.com/a/1190000010731933" target="_blank" rel="noopener">JavaScript Array.reduce</a></li><li><a href="https://segmentfault.com/a/1190000011652907" target="_blank" rel="noopener">JavaScript Promise</a></li><li><a href="https://segmentfault.com/a/1190000011389726" target="_blank" rel="noopener">JavaScript call/apply/bind</a></li><li><a href="https://segmentfault.com/a/1190000016098130" target="_blank" rel="noopener">JavaScript Date</a></li><li><a href="https://segmentfault.com/a/1190000000410506" target="_blank" rel="noopener">JavaScript Array.sort</a></li><li><a href="https://segmentfault.com/a/1190000016116657" target="_blank" rel="noopener">JavaScript setInterval/setTimeout</a></li></ul><h2 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h2><ul><li><a href="https://segmentfault.com/a/1190000016256731" target="_blank" rel="noopener">Chrome 调试技巧</a></li><li><a href="https://segmentfault.com/a/1190000016005163" target="_blank" rel="noopener">JavaScript 获取参数</a></li><li><a href="https://segmentfault.com/a/1190000012673854" target="_blank" rel="noopener">JavaScript 代码简写</a></li><li><a href="https://segmentfault.com/a/1190000015597029" target="_blank" rel="noopener">JavaScript 跨域问题</a></li><li><a href="https://segmentfault.com/a/1190000004292479" target="_blank" rel="noopener">script标签放在body里还是header里</a></li></ul><h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><ul><li><a href="https://segmentfault.com/a/1190000016276287" target="_blank" rel="noopener">JavaScript 模块化</a></li><li><a href="https://segmentfault.com/a/1190000014919700" target="_blank" rel="noopener">JavaScript 设计模式</a></li><li><a href="https://segmentfault.com/a/1190000016101940" target="_blank" rel="noopener">JavaScript 全栈开发</a></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li><a href="https://segmentfault.com/a/1190000015668383" target="_blank" rel="noopener">Ajax 基础知识</a></li><li><a href="https://segmentfault.com/a/1190000004322358" target="_blank" rel="noopener">JavaScript 同步 异步 事件循环</a></li><li><a href="https://segmentfault.com/a/1190000014643900" target="_blank" rel="noopener">JavaScript WebSocket</a></li><li><a href="https://segmentfault.com/a/1190000000481884" target="_blank" rel="noopener">JavaScript console对象</a></li><li><a href="https://segmentfault.com/a/1190000013412206" target="_blank" rel="noopener">JavaScript 剪贴板</a></li></ul><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript-初学者教程（指南）&quot;&gt;&lt;a href=&quot;#JavaScript-初学者教程（指南）&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 初学者教程（指南）&quot;&gt;&lt;/a&gt;JavaScript 初学者教程（指南）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://segmentfault.com/a/1190000016337325&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000016337325&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：joyqi&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JavaScript 是前端开发者使用的主要编程语言，随着前端技术的发展，这门语言的边界也得以不断扩展。我们在这里选择了与 JavaScript 相关的经典文章，可以让大家对如何学习这门语言有一些全面的认识。特别的，我们还着重于 JavaScript 这门语言与其它编程语言的不同之处，方便大家深入理解。&lt;/p&gt;
&lt;h2 id=&quot;语言特性&quot;&gt;&lt;a href=&quot;#语言特性&quot; class=&quot;headerlink&quot; title=&quot;语言特性&quot;&gt;&lt;/a&gt;语言特性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000016110909&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000009324194&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 正则表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000652891&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 闭包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007535316&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript async/await&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000016133613&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ES6 元编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000015569915&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 垃圾内存回收机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000014495089&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 装饰器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000016231512&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript AST 抽象语法树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000012925872&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 单线程运行机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000015727237&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 继承 原型链 prototype&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000011801127&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript &lt;strong&gt;proto&lt;/strong&gt; 与 prototype&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000015444951&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript this&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000013107871&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 拷贝对象&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;函数解析&quot;&gt;&lt;a href=&quot;#函数解析&quot; class=&quot;headerlink&quot; title=&quot;函数解析&quot;&gt;&lt;/a&gt;函数解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000003810652&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript Fetch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007434923&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript Object.defineProperty&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000012578794&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript cookie/localStorage/sessionStorage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000015908109&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript Array 数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000010731933&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript Array.reduce&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000011652907&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript Promise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000011389726&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript call/apply/bind&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000016098130&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript Date&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000410506&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript Array.sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000016116657&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript setInterval/setTimeout&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;编程技巧&quot;&gt;&lt;a href=&quot;#编程技巧&quot; class=&quot;headerlink&quot; title=&quot;编程技巧&quot;&gt;&lt;/a&gt;编程技巧&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000016256731&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrome 调试技巧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000016005163&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 获取参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000012673854&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 代码简写&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000015597029&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 跨域问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000004292479&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;script标签放在body里还是header里&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;编程思想&quot;&gt;&lt;a href=&quot;#编程思想&quot; class=&quot;headerlink&quot; title=&quot;编程思想&quot;&gt;&lt;/a&gt;编程思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000016276287&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 模块化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000014919700&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 设计模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000016101940&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 全栈开发&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;其它&quot;&gt;&lt;a href=&quot;#其它&quot; class=&quot;headerlink&quot; title=&quot;其它&quot;&gt;&lt;/a&gt;其它&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000015668383&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ajax 基础知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000004322358&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 同步 异步 事件循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000014643900&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript WebSocket&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000481884&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript console对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000013412206&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript 剪贴板&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="JavaScript" scheme="https://melodyjerry.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>[转]Yapi环境搭建(史上最详细步骤)</title>
    <link href="https://melodyjerry.github.io/blog/2020/09/22/[%E8%BD%AC]Yapi%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(%E5%8F%B2%E4%B8%8A%E6%9C%80%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4)/"/>
    <id>https://melodyjerry.github.io/blog/2020/09/22/[%E8%BD%AC]Yapi%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(%E5%8F%B2%E4%B8%8A%E6%9C%80%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4)/</id>
    <published>2020-09-22T09:21:21.000Z</published>
    <updated>2020-10-07T15:10:10.880Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/94297858" target="_blank" rel="noopener">内网搭建yapi接口管理平台</a></p></blockquote><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li><p><strong>操作系统：</strong>centos 7</p></li><li><p>环境要求：</p><ul><li>nodejs 7.6+</li><li>mongodb 2.6+</li><li>git</li></ul></li></ul><a id="more"></a><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><ol><li>获取资源（部署nodejs尽可能选择偶数版本，因为偶数版本官方有较长的维护时间，故这次选择8.x。）<br> <code>curl -sL https://rpm.nodesource.com/setup_8.x | bash -</code></li><li>安装<br> <code>yum install -y nodejs</code></li><li>查看版本<br> <code>node -v</code></li><li>查看npm版本<br> <code>npm -v</code></li></ol><h2 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h2><ol><li>更新yum源，非必须但是更新一下无害<br> <code>yum -y update</code></li><li>添加mongodb源文件，在/etc/yum.repos.d 创建一个 mongodb-org.repo 文件<br> <code>touch /etc/yum.repos.d/mongodb-org.repo</code></li><li>编辑mongodb-org.repo文件<br> <code>vim /etc/yum.repos.d/mongodb-org.repo</code></li><li>添加文件内容</li></ol><pre><code class="hljs ini"><span class="hljs-section">[mongodb-org]</span><span class="hljs-attr">name</span>=MongoDB Repository<span class="hljs-attr">baseurl</span>=http://mirrors.aliyun.com/mongodb/yum/redhat/<span class="hljs-number">7</span>Server/mongodb-org/<span class="hljs-number">3.2</span>/x<span class="hljs-number">86_64</span>/<span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">0</span><span class="hljs-attr">enabled</span>=<span class="hljs-number">1</span></code></pre><blockquote><p>这里可能退不出Vim，参考<a href="https://www.cnblogs.com/melodyjerry/p/13714705.html" target="_blank" rel="noopener">https://www.cnblogs.com/melodyjerry/p/13714705.html</a></p></blockquote><ol><li>安装mongodb<br> <code>yum install -y mongodb-org</code></li><li>启动mongodb<br> <code>service mongod start</code></li><li>设置开机启动<br> <code>chkconfig mongod on</code></li><li>打开moMongoDB(可忽略)<br> <code>/bin/mongo</code></li><li>配置远程访问</li></ol><ul><li>修改mongod.conf配置文件<br>  <code>vim /etc/mongod.conf</code></li><li>注释 bindIp: 127.0.0.1<br>  <code>#bindIp: 127.0.0.1</code></li><li>重启mongod<br>  <code>service mongod restart</code></li></ul><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><ul><li>官方推荐，在内网部署的时候安装git，可以根据自己所需安装<br>  <code>yum -y install git</code></li></ul><h2 id="搭建YApi环境"><a href="#搭建YApi环境" class="headerlink" title="搭建YApi环境"></a>搭建YApi环境</h2><p><strong>搭建YApi</strong></p><ol><li>准备环境搭建完成后，开始搭建YApi,安装命令</li></ol><pre><code class="hljs bash">npm install -g yapi-cli --registry https://registry.npm.taobao.orgyapi server</code></pre><blockquote><pre><code class="hljs bash">$ yapi server/usr/lib/node_modules/yapi-cli/src/utils.js:68  getVersions: async <span class="hljs-function"><span class="hljs-title">function</span></span>(){                     ^^^^^^^^SyntaxError: Unexpected token <span class="hljs-keyword">function</span>    at createScript (vm.js:56:10)    at Object.runInThisContext (vm.js:97:10)    at Module._compile (module.js:549:28)    at Object.Module._extensions..js (module.js:586:10)    at Module.load (module.js:494:32)    at tryModuleLoad (module.js:453:12)    at Function.Module._load (module.js:445:3)    at Module.require (module.js:504:17)    at require (internal/module.js:20:19)    at Object.&lt;anonymous&gt; (/usr/lib/node_modules/yapi-cli/src/index.js:4:15)</code></pre><p>解决办法：将node升级到版本&gt;7.6</p><p><a href="https://www.cnblogs.com/melodyjerry/p/13715111.html" target="_blank" rel="noopener">https://www.cnblogs.com/melodyjerry/p/13715111.html</a></p></blockquote><ul><li><p>实例截图：</p><p>  <img src="https://s1.ax1x.com/2020/09/22/wXMJrq.png" srcset="/blog/img/loading.gif" alt="wXMJrq.png"></p></li></ul><blockquote><p><code>yapi server</code>后提示：</p><pre><code class="hljs bash">Accessing non-existent property <span class="hljs-string">'cat'</span> of module exports inside circular dependency</code></pre><p>产生这个的原因是node的版本太高了<br>解决的办法很简单，卸载最新版的node v14，重新安装稳定版的node v12，这个问题就解决了</p></blockquote><blockquote><p>有使用宝塔的话，还需要到<strong>宝塔防火墙里放行9090端口</strong>。</p></blockquote><h2 id="部署YApi"><a href="#部署YApi" class="headerlink" title="部署YApi"></a>部署YApi</h2><ol><li>执行 yapi server 启动可视化部署程序，浏览器打开提示窗口上的地址，非本地服务器，将0.0.0.0替换指定的域名或IP，进入部署页面。</li></ol><ul><li>实例截图<br><img src="https://s1.ax1x.com/2020/09/23/wjZPfA.png" srcset="/blog/img/loading.gif" alt="wjZPfA.png"></li></ul><ol start="2"><li>根据项目实际需要可以修改部署信息，点击【开始部署】，完成部署任务</li></ol><ul><li><p>部署成功截图<br><img src="https://s1.ax1x.com/2020/09/23/wj66rn.png" srcset="/blog/img/loading.gif" alt="wj66rn.png"></p></li><li><p>MongoDB数据库连接失败，检查是不是配置文件的ip、port出错。或者，直接<code>shutdown -r now</code>重启一下服务器，反正我就是hh。<br><img src="https://s1.ax1x.com/2020/09/23/wjKeiD.png" srcset="/blog/img/loading.gif" alt="wjKeiD.png"></p></li></ul><p><strong>3.根据部署日志截图上的提示信息，启动服务</strong><br>启动服务：<code>node vendors/server/app.js</code><br>浏览器打开部署日志上的访问地址 <code>http://127.0.0.1:3000</code> 就可以访问搭建的YApi工具了（非本地服务器，将127.0.0.1替换指定的域名或IP），此时YApi本地环境搭建完成</p><p>如果是阿里云ecs服务器，端口需要在安全组里开放，不然访问不了</p><p><strong>4.pm2方式管理进程</strong></p><p>要保证后台保持进程，需要安装pm2。<br>全局安装：</p><pre><code class="hljs bash">npm install -g pm2`</code></pre><p>启动：</p><pre><code class="hljs bash">pm2 start /root/my-yapi/vendors/server/app.js --watch -i 1</code></pre><blockquote><p>这样以后就可以很方便的用<strong>pm2</strong>就行启动关闭啦~</p></blockquote><ol start="5"><li>通过<code>pm2 save</code>保存当前进程状态。</li></ol><p>查看：</p><pre><code class="hljs bash">pm2 list</code></pre><p>重启：</p><pre><code class="hljs bash">pm2 restart service/app.js</code></pre><p>停止：</p><p>可以先通过<code>pm2 list</code>获取应用的名字（–name指定的）或者进程id。</p><pre><code class="hljs bash"><span class="hljs-comment"># pm2 stop app_name|app_id</span>pm2 stop /root/my-yapi/vendors/server/app.js</code></pre><blockquote><p>pm2使用参考文档：<br><a href="http://imweb.io/topic/57c8cbb27f226f687b365636" target="_blank" rel="noopener">http://imweb.io/topic/57c8cbb27f226f687b365636</a></p></blockquote><p><strong>6.升级</strong></p><p>升级项目版本是非常容易的，并且不会影响已有的项目数据，只会同步 vendors 目录下的源码文件。</p><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> {项目目录}yapi <span class="hljs-keyword">ls</span> <span class="hljs-comment">//查看版本号列表</span>yapi <span class="hljs-keyword">update</span> <span class="hljs-comment">//更新到最新版本</span>yapi <span class="hljs-keyword">update</span> -v {<span class="hljs-keyword">Version</span>} <span class="hljs-comment">//更新到指定版本</span></code></pre><p><strong>9.nginx代理</strong></p><p>如果您是将服务器代理到 nginx 服务器，请配置 nginx 支持 websocket。</p><pre><code class="hljs routeros">在location /添加proxy_http_version 1.1;proxy_set_header<span class="hljs-built_in"> Upgrade </span><span class="hljs-variable">$http_upgrade</span>;proxy_set_header<span class="hljs-built_in"> Connection </span><span class="hljs-string">"upgrade"</span>;</code></pre><p><strong>10.禁止注册</strong></p><p>在 config.json 添加 <code>closeRegister:true</code> 配置项,就可以禁止用户注册 yapi 平台，修改完成后，请重启 yapi 服务器。</p><pre><code class="hljs json">{<span class="hljs-attr">"port"</span>: <span class="hljs-string">"*****"</span>,<span class="hljs-attr">"closeRegister"</span>:<span class="hljs-literal">true</span>}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/94297858&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;内网搭建yapi接口管理平台&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;操作系统：&lt;/strong&gt;centos 7&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;环境要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nodejs 7.6+&lt;/li&gt;
&lt;li&gt;mongodb 2.6+&lt;/li&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="Linux" scheme="https://melodyjerry.github.io/blog/tags/Linux/"/>
    
      <category term="API" scheme="https://melodyjerry.github.io/blog/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Vim-类似于Vi的文本编辑器</title>
    <link href="https://melodyjerry.github.io/blog/2020/09/21/Vim-%E7%B1%BB%E4%BC%BC%E4%BA%8EVi%E7%9A%84%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>https://melodyjerry.github.io/blog/2020/09/21/Vim-%E7%B1%BB%E4%BC%BC%E4%BA%8EVi%E7%9A%84%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</id>
    <published>2020-09-21T13:54:00.000Z</published>
    <updated>2020-10-07T15:10:10.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和Emacs并列成为类Unix系统用户最喜欢的编辑器。</p><h1 id="键盘图"><a href="#键盘图" class="headerlink" title="键盘图"></a>键盘图</h1><blockquote><p>来源见水印</p></blockquote><p><img src="https://s1.ax1x.com/2020/09/21/wq1Y6I.png" srcset="/blog/img/loading.gif" alt="wq1Y6I.png"></p><a id="more"></a><h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><ul><li>根据设定可以和原始vi完全兼容</li><li>多缓冲编辑</li><li>任意个数的分割窗口（横，竖）</li><li>具备列表和字典功能的脚本语言</li><li>可以在脚本中调用 Perl, Ruby, Python, Tcl, MzScheme</li><li>单词缩写功能</li><li>动态单词补完</li><li>多次撤销和重做</li><li>对应400种以上文本文件的语法高亮</li><li>C/C++, Perl, Java, Ruby, Python 等40种以上语言的自动缩排</li><li>利用ctags的标签中跳转</li><li>崩溃后文件恢复</li><li>光标位置和打开的缓冲状态的保存 复原（session功能）</li><li>可以对两个文件进行差分，同步功能的diff模式</li><li>远程文件编辑</li><li>Omni补完（上下文相关的补完）</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和Emacs并列成为类Unix系统用户最喜欢的编辑器。&lt;/p&gt;
&lt;h1 id=&quot;键盘图&quot;&gt;&lt;a href=&quot;#键盘图&quot; class=&quot;headerlink&quot; title=&quot;键盘图&quot;&gt;&lt;/a&gt;键盘图&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;来源见水印&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/09/21/wq1Y6I.png&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;wq1Y6I.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="Linux" scheme="https://melodyjerry.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下删除普通用户步骤</title>
    <link href="https://melodyjerry.github.io/blog/2020/09/21/Linux%E4%B8%8B%E5%88%A0%E9%99%A4%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%AD%A5%E9%AA%A4/"/>
    <id>https://melodyjerry.github.io/blog/2020/09/21/Linux%E4%B8%8B%E5%88%A0%E9%99%A4%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%AD%A5%E9%AA%A4/</id>
    <published>2020-09-21T13:47:00.000Z</published>
    <updated>2020-10-07T15:10:10.773Z</updated>
    
    <content type="html"><![CDATA[<ol><li>先用命令  <code>cat /etc/passwd</code> 查看一下所有的用户 可以看到片你需要删除的用户名</li><li>用命令  <code>who</code>  查询当前登录的用户</li><li>用命令  <code>ps -u 用户名</code>   查看该用户的pid </li><li>用命令 <code>kill pid</code>  杀掉他的sshd或者是shell进程</li><li>再用命令  <code>userdel -r 用户名</code>  删除用户</li></ol><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;先用命令  &lt;code&gt;cat /etc/passwd&lt;/code&gt; 查看一下所有的用户 可以看到片你需要删除的用户名&lt;/li&gt;
&lt;li&gt;用命令  &lt;code&gt;who&lt;/code&gt;  查询当前登录的用户&lt;/li&gt;
&lt;li&gt;用命令  &lt;code&gt;ps -u 用户名&lt;/code&gt;   查看该用户的pid &lt;/li&gt;
&lt;li&gt;用命令 &lt;code&gt;kill pid&lt;/code&gt;  杀掉他的sshd或者是shell进程&lt;/li&gt;
&lt;li&gt;再用命令  &lt;code&gt;userdel -r 用户名&lt;/code&gt;  删除用户&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="Linux" scheme="https://melodyjerry.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Xshell-配色方案</title>
    <link href="https://melodyjerry.github.io/blog/2020/09/21/Xshell-%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/"/>
    <id>https://melodyjerry.github.io/blog/2020/09/21/Xshell-%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/</id>
    <published>2020-09-21T13:21:21.000Z</published>
    <updated>2020-10-07T15:10:10.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设置命令行提示符"><a href="#设置命令行提示符" class="headerlink" title="设置命令行提示符"></a>设置命令行提示符</h1><p>在命令行提示符显示用户名，当前机器IP，当前时间，当前路径等信息。但有时候如果我们的目录很长，敲击命令很不方便，可以通过修改 PS1 环境变量，让命令提示符在第二行显示：</p><p>如下示例，后面的 \n 就是起到了提示符 $ 在第二行显示效果。</p><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PS1=<span class="hljs-string">"\[\033[01;31m\]\u\[\033[00m\]@\[\033[01;32m\]\h\[\033[00m\][\[\033[01;33m\]\t\[\033[00m\]]:\[\033[01;34m\]\w\[\033[00m\]\n$ "</span></code></pre><p>效果如下：</p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/F3DD95CE99324FCEA6BA15337467F42A/34380" srcset="/blog/img/loading.gif" alt="0"></p><p><strong>注：</strong></p><p>  <strong>设置为什么颜色，可以自己根据显示效果调，很灵活。</strong></p><a id="more"></a><h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p>如果要写入shell配置文件，建议写到<strong>环境变量文件</strong><code>~/.bash_profile</code>，而不要写入<code>~/.bashrc</code>，否则借助ssh类的工具都将因为trap DEBUG信号的特殊性而无限等待，比如scp/rsync等。</p><p>或者，直接判断是否是交互式登录，是的话就设置，否则不设置：</p><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">${-#*i}</span>"</span> != <span class="hljs-string">"$-"</span> ];<span class="hljs-keyword">then</span>    <span class="hljs-comment"># interactively shell</span>    PS1=<span class="hljs-string">"\[\033[01;31m\]\u\[\033[00m\]@\[\033[01;32m\]\h\[\033[00m\][\[\033[01;33m\]\t\[\033[00m\]]:\[\033[01;34m\]\w\[\033[00m\]\n$ "</span>    <span class="hljs-built_in">trap</span> <span class="hljs-string">'echo -ne "\e[0m"'</span> DEBUG<span class="hljs-keyword">fi</span></code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 写入</span>vim ~/.bash_profile<span class="hljs-comment"># 立即生效</span><span class="hljs-built_in">source</span> ~/.bash_profile</code></pre><h1 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h1><blockquote><p>在终端上的显示的命令提示符：<code>[root@root ~]#</code></p><p>配置文件中的设置：<code>PS1="[\u@\h \W]\$"</code></p></blockquote><ul><li>设置提示符格式：<code>PS1</code></li></ul><p><code>PS1</code>的定义中个常用的参数的含义如下：</p><p><code>\d</code> ：#代表日期，格式为weekday month date，例如：”Mon Aug 1”</p><p><code>\H</code> ：#完整的主机名称</p><p><code>\h</code> ：#仅取主机的第一个名字</p><p><code>\T</code> ：#显示时间为24小时格式，如：HH：MM：SS</p><p><code>\t</code> ：#显示时间为12小时格式 , 如：HH：MM：SS</p><p><code>\A</code> ：#显示时间为12小时格式：HH：MM</p><p><code>\u</code> ：#当前用户的账号名称</p><p><code>\v</code> ：#BASH的版本信息</p><p><code>\w</code> ：#完整的工作目录名称</p><p><code>\W</code> ：#利用basename取得工作目录名称，所以只会列出最后一个目录</p><p>`#` ：#下达的第几个命令</p><p><code>$</code> ：#提示字符，如果是root时，提示符为：<code>#</code> ，普通用户则为：<code>$</code></p><h1 id="设置颜色"><a href="#设置颜色" class="headerlink" title="设置颜色"></a>设置颜色</h1><blockquote><p>在<code>PS1</code>中设置字符颜色的格式为：<code>[\e[F;Bm]</code>，其中<code>F</code>为字体颜色，编号为30-37，<code>B</code>为背景颜色，编号为40-47。</p></blockquote><p>颜色表如下：</p><p><code>[\e[F;Bm]</code>需要改变颜色的部分<code>[\e[0m]</code></p><p>开始颜色输入：<code>[\e[F;Bm]</code></p><p>结束颜色输入：<code>[\e[0m]</code></p><ul><li>F B 值分别对应的颜色<pre><code class="hljs basic"><span class="hljs-symbol">30 </span><span class="hljs-number">40</span> 黑色<span class="hljs-symbol">31 </span><span class="hljs-number">41</span> 红色<span class="hljs-symbol">32 </span><span class="hljs-number">42</span> 绿色<span class="hljs-symbol">33 </span><span class="hljs-number">43</span> 黄色<span class="hljs-symbol">34 </span><span class="hljs-number">44</span> 蓝色<span class="hljs-symbol">35 </span><span class="hljs-number">45</span> 紫红色<span class="hljs-symbol">36 </span><span class="hljs-number">46</span> 青蓝色<span class="hljs-symbol">37 </span><span class="hljs-number">47</span> 白色</code></pre></li></ul><ul><li>设置特殊显示<pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-keyword">OFF</span>，关闭颜色<span class="hljs-symbol">1 </span>高亮显示<span class="hljs-symbol">4 </span>显示下划线<span class="hljs-symbol">5 </span>闪烁显示<span class="hljs-symbol">7 </span>反白显示<span class="hljs-symbol">8 </span>颜色不可见</code></pre>特殊显示可在结束颜色输入里面设置：<code>[\e[ 特殊颜色编号 m]</code></li></ul><h1 id="其他配色配置"><a href="#其他配色配置" class="headerlink" title="其他配色配置"></a>其他配色配置</h1><p>点击 Xshell 面板顶部的如下按钮。</p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/BD96E8E97F1041839D778415D8CABE9A/34339" srcset="/blog/img/loading.gif" alt="0"></p><p>点击 Browse 按钮，弹出如下面板，选择 ANSI Colors on Black，然后点击右侧save as 按钮，命名为 zkl。</p><p>这里其实就是复制一份 ANSI Colors on Black 的颜色方案，或者我们也可以 New 一个方案。</p><p>ANSI 颜色已经很好看，这里我们是沿用 ANSI 颜色，并加以修改，以得到自己想要的颜色方案。</p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/D1F435F681D641209349778E780A86D7/34342" srcset="/blog/img/loading.gif" alt="0"></p><p>然后，点击右侧的 edit 按钮，编辑前景色和背景色。</p><p><strong>1. 设置背景色</strong></p><p>点击 Backgroud 右侧的下拉列表， 在弹出的界面选择 other, 弹出一个界面，点击自定义颜色，然后会弹出如下界面：</p><p>按照如下 rgb 值填写颜色，（0，43, 53）</p><p>然后点击 Add to Custom Colors 按钮，添加自定义颜色到左侧面板中的 custom colors下，选择它。确定。</p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/39C2F44930674C0BA5109DAA2DC8C7EB/34330" srcset="/blog/img/loading.gif" alt="0"></p><p><strong>2. 设置字体颜色（前景色）</strong></p><p>点击 Normal Text，进行设置。</p><p>rgb颜色：（131,148,150）</p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/590A9972CA694D2F8E9F0B8E99DD6FEB/34325" srcset="/blog/img/loading.gif" alt="0"></p><p><strong>3. 设置目录颜色</strong></p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/32C463E5DEEA4F2E8A0BE945E80D02B5/34355" srcset="/blog/img/loading.gif" alt="0"></p><p>颜色 rgb 值如下：（128，128, 255）</p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/ABF6FAEC55324EB9831A00B1FC5B9201/34372" srcset="/blog/img/loading.gif" alt="0"></p><p><strong>4. 设置压缩文件颜色</strong></p><p>ANSI 颜色中，压缩文件颜色默认是红色，不干扰视线，如果感觉不好，可以调整为如下颜色：</p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/346D3113708F402FA7010678897293A9/34366" srcset="/blog/img/loading.gif" alt="0"></p><p>颜色 rgb 值如下：（128，128, 0）</p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/12A178F7B6E64CB89158765374F356B0/34370" srcset="/blog/img/loading.gif" alt="0"></p><p><strong>5. 设置VIM中注释的颜色</strong> </p><p>经过以上设置后，xshell的背景颜色，字体颜色，linux的目录，压缩文件颜色都比较好看了，效果如下。</p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/EE9F095AB52649F1AD384A170879FD59/34399" srcset="/blog/img/loading.gif" alt="0"></p><p>但是我们打开 vim，编辑一个 c++, python 代码文件时会发现注释的颜色很不好看。需要再进行设置。</p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/8CF1086E999A478682FE26CBBD6F66A4/34389" srcset="/blog/img/loading.gif" alt="0"></p><p>设置如下颜色即可：</p><p>rgb颜色：（255,128,64）</p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/D75AA5C048F846E2BC0DCFB897051CAE/34405" srcset="/blog/img/loading.gif" alt="0"></p><p>修改后的代码文件显示效果如下：</p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/F851D90807A74A27BDDD1905B947627E/34391" srcset="/blog/img/loading.gif" alt="0"></p><p><strong>6. 导出颜色方案</strong></p><p>xshell 非常强大，各种功能。我们设置的颜色方案也可以导出保存，当我们在其他机器上使用时，可以导入颜色方案。</p><p>下面界面中的 import 和 export 即可完成导入和导出颜色方案，下面这个文件是上述配置对应的颜色方案文件：</p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/83051EC210554E98A38A8767481ADBA8/34432" srcset="/blog/img/loading.gif" alt="zkl.xcs"></p><p>​    <img src="http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/0E901C3307584455B61DF5E18A68D001/34427" srcset="/blog/img/loading.gif" alt="0"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设置命令行提示符&quot;&gt;&lt;a href=&quot;#设置命令行提示符&quot; class=&quot;headerlink&quot; title=&quot;设置命令行提示符&quot;&gt;&lt;/a&gt;设置命令行提示符&lt;/h1&gt;&lt;p&gt;在命令行提示符显示用户名，当前机器IP，当前时间，当前路径等信息。但有时候如果我们的目录很长，敲击命令很不方便，可以通过修改 PS1 环境变量，让命令提示符在第二行显示：&lt;/p&gt;
&lt;p&gt;如下示例，后面的 \n 就是起到了提示符 $ 在第二行显示效果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;export&lt;/span&gt; PS1=&lt;span class=&quot;hljs-string&quot;&gt;&quot;\[\033[01;31m\]\u\[\033[00m\]@\[\033[01;32m\]\h\[\033[00m\][\[\033[01;33m\]\t\[\033[00m\]]:\[\033[01;34m\]\w\[\033[00m\]\n$ &quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;​    &lt;img src=&quot;http://note.youdao.com/yws/public/resource/202a88734065732c89c84f9e9197ab9c/xmlnote/F3DD95CE99324FCEA6BA15337467F42A/34380&quot; srcset=&quot;/blog/img/loading.gif&quot; alt=&quot;0&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;设置为什么颜色，可以自己根据显示效果调，很灵活。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="uncategorized" scheme="https://melodyjerry.github.io/blog/categories/uncategorized/"/>
    
    
      <category term="小技巧" scheme="https://melodyjerry.github.io/blog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://melodyjerry.github.io/blog/tags/Linux/"/>
    
  </entry>
  
</feed>
