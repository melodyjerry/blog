<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MelodyHub</title>
  
  <subtitle>你用走 可是我用跑</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://melodyjerry.github.io/blog/"/>
  <updated>2020-02-21T13:27:53.974Z</updated>
  <id>https://melodyjerry.github.io/blog/</id>
  
  <author>
    <name>Melody Jerry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP响应信息数据-Response</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/22/HTTP%E5%93%8D%E5%BA%94%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE-Response/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/22/HTTP响应信息数据-Response/</id>
    <published>2020-02-22T13:15:01.000Z</published>
    <updated>2020-02-21T13:27:53.974Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { r
      
    
    </summary>
    
    
    
      <category term="JavaWeb" scheme="https://melodyjerry.github.io/blog/tags/JavaWeb/"/>
    
      <category term="笔记" scheme="https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="HTTP" scheme="https://melodyjerry.github.io/blog/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP请求信息数据-Request</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/21/HTTP%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE-Request/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/21/HTTP请求信息数据-Request/</id>
    <published>2020-02-21T12:25:00.000Z</published>
    <updated>2020-02-21T15:29:28.903Z</updated>
    
    <content type="html"><![CDATA[<p>接着上篇博文 <a href="">《HTTP：超文本传输协议》</a> 的学习。</p><p>现在，来学习两个对象：Request &amp; Response。</p><h1 id="request对象和response对象的原理"><a href="#request对象和response对象的原理" class="headerlink" title="request对象和response对象的原理"></a>request对象和response对象的原理</h1><ol><li><strong>request和response对象是由服务器创建的</strong>。接着我们来使用它们</li><li><strong>request对象是来获取请求消息，response对象是来设置响应消息</strong></li><li>其基本原理，如下图👇</li></ol><p><fancybox><img src="https://s2.ax1x.com/2020/02/21/3KFYo4.png" alt="Request&amp;Response对象基本原理"></fancybox></p><h1 id="request对象继承体系结构"><a href="#request对象继承体系结构" class="headerlink" title="request对象继承体系结构"></a>request对象继承体系结构</h1><p><strong><code>ServletRequest</code></strong> – interface，接口</p><p>↓|<em>继承</em></p><p><strong><code>HttpServletRequest</code></strong> – interface，接口</p><p>↓|<em>实现</em></p><p><strong><code>org.apache.catalina.connector.RequestFacade</code></strong> – 类，<strong>Tomcat编写的</strong></p><blockquote><p>Tomcat 是用<strong>纯Java语言编写</strong>的</p></blockquote><h1 id="request功能"><a href="#request功能" class="headerlink" title="request功能"></a>request功能</h1><ol><li>获取请求消息数据</li><li>其他功能</li></ol><h2 id="获取请求消息数据"><a href="#获取请求消息数据" class="headerlink" title="获取请求消息数据"></a>获取请求消息数据</h2><ol><li>获取请求行数据</li><li>获取请求头数据</li><li>获取请求体数据</li></ol><a id="more"></a><h3 id="一-获取请求行数据"><a href="#一-获取请求行数据" class="headerlink" title="一.获取请求行数据"></a>一.获取请求行数据</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET  /day14/demo1?name=zhangsan  HTTP/1.1</span><br></pre></td></tr></tbody></table></figure><p>调用方法（★★重点掌握）：</p><ol><li>获取请求方式：GET</li></ol><ul><li><code>String getMethod()</code></li></ul><ol start="2"><li>★★获取虚拟目录：/day14</li></ol><ul><li><code>String getContextPath()</code></li></ul><ol start="3"><li>获取Servlet路径：/demo1</li></ol><ul><li><code>String getServletPath()</code></li></ul><ol start="4"><li>获取get方式请求参数：name=zhangsan</li></ol><ul><li><code>String getQueryString()</code></li><li>不用这个，以后会用<strong>更高级的方式</strong></li><li>多个参数之间用<code>&amp;</code>连接</li></ul><ol start="5"><li>★★获取请求URI：/day14/demo1</li></ol><ul><li><p><code>String getRequestURI()</code>：/day14/demo1</p></li><li><p><code>StringBuffer getRequestURL()</code>：<a href="http://localhost/day14/demo1" target="_blank" rel="noopener">http://localhost/day14/demo1</a></p></li><li><blockquote><ul><li><p><font color="red">URL：统一资源定位符</font> ： <a href="http://localhost/day14/demo1" target="_blank" rel="noopener">http://localhost/day14/demo1</a>      其地位相当于”中华人民共和国”</p></li><li><p><font color="red">URI：统一资源标识符，其表示范围更大</font> ：/day14/demo1          其地位相当于”共和国”</p></li></ul></blockquote></li></ul><ol start="6"><li>获取协议及版本：HTTP/1.1</li></ol><ul><li><p><code>String getProtocol()</code></p></li><li><blockquote><p>该方法在<code>Interface ServletRequest</code>中</p></blockquote></li></ul><ol start="7"><li>获取客户机的IP地址：</li></ol><ul><li><p><code>String getRemoteAddr()</code></p></li><li><blockquote><p>该方法在<code>Interface ServletRequest</code>中</p></blockquote></li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>新建RequestDemo1.java，输入代码👇</p><blockquote><p> 可以在新建时候选择创建Servlet，IDEA自动生成相应模板。</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 演示Request对象获取请求行数据</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@WebServlet("/requestDemo1")</span><br><span class="line">public class RequestDemo1 extends HttpServlet {</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {</span><br><span class="line">        /*</span><br><span class="line">            1. 获取请求方式 ：GET</span><br><span class="line">                * String getMethod()</span><br><span class="line">            2. (*)获取虚拟目录：/Servlet</span><br><span class="line">                * String getContextPath()</span><br><span class="line">            3. 获取Servlet路径: /requestDemo1</span><br><span class="line">                * String getServletPath()</span><br><span class="line">            4. 获取get方式请求参数：name=zhangsan</span><br><span class="line">                * String getQueryString()</span><br><span class="line">            5. (*)获取请求URI：/Servlet/requestDemo1</span><br><span class="line">                * String getRequestURI():/day14/requestDemo1</span><br><span class="line">                * StringBuffer getRequestURL()  :http://localhost/Servlet/requestDemo1</span><br><span class="line">            6. 获取协议及版本：HTTP/1.1</span><br><span class="line">                * String getProtocol()</span><br><span class="line"></span><br><span class="line">            7. 获取客户机的IP地址：</span><br><span class="line">                * String getRemoteAddr()</span><br><span class="line"></span><br><span class="line">         */</span><br><span class="line">        //1. 获取请求方式 ：GET</span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        System.out.println(method);</span><br><span class="line">        //2.(*)获取虚拟目录：/day14</span><br><span class="line">        String contextPath = request.getContextPath();</span><br><span class="line">        System.out.println(contextPath);</span><br><span class="line">        //3. 获取Servlet路径: /demo1</span><br><span class="line">        String servletPath = request.getServletPath();</span><br><span class="line">        System.out.println(servletPath);</span><br><span class="line">        //4. 获取get方式请求参数：name=zhangsan</span><br><span class="line">        String queryString = request.getQueryString();</span><br><span class="line">        System.out.println(queryString);</span><br><span class="line">        //5.(*)获取请求URI：/day14/demo1</span><br><span class="line">        String requestURI = request.getRequestURI();</span><br><span class="line">        StringBuffer requestURL = request.getRequestURL();</span><br><span class="line">        System.out.println(requestURI);</span><br><span class="line">        System.out.println(requestURL);</span><br><span class="line">        //6. 获取协议及版本：HTTP/1.1</span><br><span class="line">        String protocol = request.getProtocol();</span><br><span class="line">        System.out.println(protocol);</span><br><span class="line">        //7. 获取客户机的IP地址：</span><br><span class="line">        String remoteAddr = request.getRemoteAddr();</span><br><span class="line">        System.out.println(remoteAddr);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>演示👇</p><p>浏览器访问：<a href="http://localhost/Servlet/requestDemo1?name=zhangsan" target="_blank" rel="noopener">http://localhost/Servlet/requestDemo1?name=zhangsan</a></p><p>IDEA控制台输出：</p><p><fancybox><img src="https://s2.ax1x.com/2020/02/21/3Kuh1e.png" alt=""></fancybox></p><h3 id="二-获取请求头数据"><a href="#二-获取请求头数据" class="headerlink" title="二.获取请求头数据"></a>二.获取请求头数据</h3><p>调用方法（★★重点掌握）：</p><ol><li>★★<code>String getHeader(String name)</code></li></ol><ul><li>通过请求头的名称获取请求头的值</li></ul><ol start="2"><li><code>Enumeration&lt;String&gt;  getHeaderNames()</code></li></ol><ul><li>获取所有的请求头名称</li><li>封装成 <code>Enumeration&lt;String&gt;</code></li></ul><blockquote><p>注意：从JDK1.0开始，该接口的功能由Iterator（迭代器）接口 <strong>复制</strong>。此外，Iterator还添加了一个可选的删除操作，并且有较短的方法名称。新的实现应该考虑使用迭代器优选于枚举。——JDK 8 文档</p></blockquote><h3 id="三-获取请求体数据"><a href="#三-获取请求体数据" class="headerlink" title="三.获取请求体数据"></a>三.获取请求体数据</h3><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><p>下篇博客 <a href="">《HTTP响应信息数据 - Response》</a> 中，详细学习<strong>响应信息数据 - Response</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接着上篇博文 &lt;a href=&quot;&quot;&gt;《HTTP：超文本传输协议》&lt;/a&gt; 的学习。&lt;/p&gt;
&lt;p&gt;现在，来学习两个对象：Request &amp;amp; Response。&lt;/p&gt;
&lt;h1 id=&quot;request对象和response对象的原理&quot;&gt;&lt;a href=&quot;#request对象和response对象的原理&quot; class=&quot;headerlink&quot; title=&quot;request对象和response对象的原理&quot;&gt;&lt;/a&gt;request对象和response对象的原理&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;request和response对象是由服务器创建的&lt;/strong&gt;。接着我们来使用它们&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;request对象是来获取请求消息，response对象是来设置响应消息&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;其基本原理，如下图👇&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;fancybox&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/21/3KFYo4.png&quot; alt=&quot;Request&amp;amp;Response对象基本原理&quot;&gt;&lt;/fancybox&gt;&lt;/p&gt;
&lt;h1 id=&quot;request对象继承体系结构&quot;&gt;&lt;a href=&quot;#request对象继承体系结构&quot; class=&quot;headerlink&quot; title=&quot;request对象继承体系结构&quot;&gt;&lt;/a&gt;request对象继承体系结构&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;ServletRequest&lt;/code&gt;&lt;/strong&gt; – interface，接口&lt;/p&gt;
&lt;p&gt;↓|&lt;em&gt;继承&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;HttpServletRequest&lt;/code&gt;&lt;/strong&gt; – interface，接口&lt;/p&gt;
&lt;p&gt;↓|&lt;em&gt;实现&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;org.apache.catalina.connector.RequestFacade&lt;/code&gt;&lt;/strong&gt; – 类，&lt;strong&gt;Tomcat编写的&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tomcat 是用&lt;strong&gt;纯Java语言编写&lt;/strong&gt;的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;request功能&quot;&gt;&lt;a href=&quot;#request功能&quot; class=&quot;headerlink&quot; title=&quot;request功能&quot;&gt;&lt;/a&gt;request功能&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;获取请求消息数据&lt;/li&gt;
&lt;li&gt;其他功能&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;获取请求消息数据&quot;&gt;&lt;a href=&quot;#获取请求消息数据&quot; class=&quot;headerlink&quot; title=&quot;获取请求消息数据&quot;&gt;&lt;/a&gt;获取请求消息数据&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;获取请求行数据&lt;/li&gt;
&lt;li&gt;获取请求头数据&lt;/li&gt;
&lt;li&gt;获取请求体数据&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="JavaWeb" scheme="https://melodyjerry.github.io/blog/tags/JavaWeb/"/>
    
      <category term="笔记" scheme="https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="HTTP" scheme="https://melodyjerry.github.io/blog/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP：超文本传输协议</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/21/HTTP%EF%BC%9A%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/21/HTTP：超文本传输协议/</id>
    <published>2020-02-21T10:25:00.000Z</published>
    <updated>2020-02-21T14:10:28.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li>HTTP == <strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol</li><li><strong>超文本传输协议</strong></li></ul><blockquote><p><font color="blue">传输协议：定义了<strong>客户端和服务器端通信时，发送数据的格式</strong>。</font></p></blockquote><p><fancybox><img src="https://s2.ax1x.com/2020/02/21/3uIs6P.png" alt=""></fancybox></p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ol><li><p>基于<strong>TCP/IP</strong>的高级协议</p></li><li><p><strong>默认端口号:80</strong></p></li><li><p>基于请求/响应模型的：<strong>一次请求对应一次响应</strong></p></li><li><p>无状态的：<strong>每次请求之间相互独立，不能交互数据</strong></p></li><li><p>网页中每一个文件都是一次单独的请求，几张图片，就是几次请求。如下图所示。</p></li></ol><p><fancybox><img src="https://s2.ax1x.com/2020/02/21/3uIZLT.png" alt="每一个文件都是一次单独的请求"></fancybox></p><a id="more"></a><h1 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h1><h2 id="http-0-9"><a href="#http-0-9" class="headerlink" title="http 0.9"></a>http 0.9</h2><ul><li>只有一个命令GET</li><li>没有HEADER等描述数据的信息</li><li>服务器发送完毕，就关闭TCP连接</li><li><strong>每一次请求响应都会建立新的连接</strong></li></ul><h2 id="http-1-0"><a href="#http-1-0" class="headerlink" title="http 1.0"></a>http 1.0</h2><ul><li>增加了很多命令，如status code和header</li><li>多字符集支持、多部分发送、权限、缓存等</li></ul><h2 id="http-1-1"><a href="#http-1-1" class="headerlink" title="http 1.1"></a>http 1.1</h2><ul><li>持久连接：<strong>keep-alive</strong></li><li><strong>复用连接</strong>（较http1.0的每一次请求响应都会建立新的连接。<strong>好处：节约了连接的资源，提升了传输的速度。</strong>）</li><li>提高性能的关键是<strong>低延迟</strong>而不是高带宽。</li><li>较http1.0，<strong>对缓存的支持更好</strong></li></ul><blockquote><p>推送：主动发送js、css推送到浏览器。</p><p>二进制流：可以并行发送数据。</p></blockquote><h2 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h2><ul><li>所有数据以二进制传输</li><li>同一个连接里面发送多个请求不再需要按顺序来</li><li>头消息压缩以及推送等提高效率的功能</li><li>所有的请求共用一个连接，可以更有效的使用tcp连接，通过<strong>带宽</strong>来提升http性能</li><li>可以减少服务链接的压力，内存减少了，链接吞吐量大了</li><li><strong>解决浏览器连接数有限的问题</strong></li><li><strong>资源合并减少请求</strong>的优化手段在http2.0来说是<strong>没有效果</strong>的</li></ul><h1 id="请求信息数据格式"><a href="#请求信息数据格式" class="headerlink" title="请求信息数据格式"></a>请求信息数据格式</h1><ul><li><code>Servlet</code>类中<code>service()</code>方法的参数<code>ServletRequest</code></li><li>字符串格式，比如：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST /login.htmlHTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://localhost/login.html</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">  </span><br><span class="line">username=zhangsan</span><br></pre></td></tr></tbody></table></figure><p>以下关于 <font color="blue">请求信息数据格式</font> 的内容有缺省，详细见下一篇博客 <a href="">《HTTP请求信息数据 - Request》</a> 中。</p><h2 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h2><ul><li>格式：<code>请求方式  请求url  请求协议/版本</code></li></ul><h3 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h3><ul><li>HTTP协议有7种请求协议，常用的有GET、POST两种</li><li><font color="orange">GET</font></li></ul><ol><li>请求参数在请求行中，<strong>在url后</strong></li><li>请求的url长度<strong>有限制的</strong></li><li>不太安全（参数跟在url之后）</li><li>浏览器控制台显示👇</li></ol><p><fancybox><img src="https://s2.ax1x.com/2020/02/21/3ubYIU.png" alt=""></fancybox></p><ul><li><font color="orange">POST</font></li></ul><ol><li>请求参数<strong>在请求体中</strong></li><li>请求的url长度<strong>没有限制的</strong></li><li>相对安全（参数在请求体中）</li><li>浏览器控制台显示👇</li></ol><p><fancybox><img src="https://s2.ax1x.com/2020/02/21/3ub6IO.png" alt=""></fancybox></p><h3 id="请求url"><a href="#请求url" class="headerlink" title="请求url"></a>请求url</h3><ul><li>假设为 /login.html</li></ul><h3 id="请求协议-版本"><a href="#请求协议-版本" class="headerlink" title="请求协议/版本"></a>请求协议/版本</h3><ul><li>HTTP/1.1</li></ul><h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><ul><li><strong>客户端浏览器告诉服务器一些信息</strong></li><li>格式：<code>请求头名称 : 请求头值</code></li><li>若有多个，则<strong>一行一个</strong>。</li></ul><h3 id="常见的请求头"><a href="#常见的请求头" class="headerlink" title="常见的请求头"></a>常见的请求头</h3><ul><li><p>Host</p></li><li><p>User-Agent</p></li><li><p>Referer</p></li></ul><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><ul><li>请求的主机地址</li></ul><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><ul><li>浏览器告诉服务器，我访问你时候使用的<strong>浏览器版本信息</strong></li><li>作用：可以在服务器端获取该头的信息，<strong>解决浏览器的兼容性问题</strong></li></ul><h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><ul><li>比如上面几张图片的Referer是 <a href="http://localhost/login.html" target="_blank" rel="noopener">http://localhost/login.html</a></li><li>告诉服务器，我（当前请求）从哪里来？</li><li>作用：<strong>防盗链、统计工作</strong></li><li>举个例子：我的网站想播放《战狼2》电影👇</li></ul><p><fancybox><img src="https://s2.ax1x.com/2020/02/21/3ujWr9.png" alt="Referer请求头"></fancybox></p><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><ul><li><strong>keep-alive</strong></li><li>http1.1，表示该<strong>链接可以被复用</strong></li></ul><h2 id="请求空行"><a href="#请求空行" class="headerlink" title="请求空行"></a>请求空行</h2><ul><li>就是一个<strong>空行</strong>（空白行）</li><li>作用：<strong>分割POST请求的请求头和请求体</strong></li></ul><h2 id="请求体-请求正文"><a href="#请求体-请求正文" class="headerlink" title="请求体/请求正文"></a>请求体/请求正文</h2><ul><li><strong>封装</strong>POST请求信息的请求参数</li></ul><p><br>下一篇博客 <a href="">《HTTP请求信息数据 - Request》</a> 中，详细学习了 <strong>请求信息数据 - Request</strong>。</p><h1 id="响应信息数据格式"><a href="#响应信息数据格式" class="headerlink" title="响应信息数据格式"></a>响应信息数据格式</h1><ul><li><code>Servlet</code>类中<code>service()</code>方法的参数<code>ServletResponse</code></li></ul><p>下下篇博客 <a href="">《HTTP响应信息数据 - Response》</a> 中，详细学习<strong>响应信息数据 - Response</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;HTTP == &lt;strong&gt;H&lt;/strong&gt;yper &lt;strong&gt;T&lt;/strong&gt;ext &lt;strong&gt;T&lt;/strong&gt;ransfer &lt;strong&gt;P&lt;/strong&gt;rotocol&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;超文本传输协议&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;传输协议：定义了&lt;strong&gt;客户端和服务器端通信时，发送数据的格式&lt;/strong&gt;。&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;fancybox&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/21/3uIs6P.png&quot; alt=&quot;&quot;&gt;&lt;/fancybox&gt;&lt;/p&gt;
&lt;h1 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基于&lt;strong&gt;TCP/IP&lt;/strong&gt;的高级协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;默认端口号:80&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于请求/响应模型的：&lt;strong&gt;一次请求对应一次响应&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;无状态的：&lt;strong&gt;每次请求之间相互独立，不能交互数据&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网页中每一个文件都是一次单独的请求，几张图片，就是几次请求。如下图所示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;fancybox&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/21/3uIZLT.png&quot; alt=&quot;每一个文件都是一次单独的请求&quot;&gt;&lt;/fancybox&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JavaWeb" scheme="https://melodyjerry.github.io/blog/tags/JavaWeb/"/>
    
      <category term="笔记" scheme="https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="HTTP" scheme="https://melodyjerry.github.io/blog/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>hexo s浏览博客时，提示4000端口问题</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/21/hexo%20s%E6%B5%8F%E8%A7%88%E5%8D%9A%E5%AE%A2%E6%97%B6%EF%BC%8C%E6%8F%90%E7%A4%BA4000%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/21/hexo s浏览博客时，提示4000端口问题/</id>
    <published>2020-02-21T10:17:00.000Z</published>
    <updated>2020-02-21T10:19:19.210Z</updated>
    
    <content type="html"><![CDATA[<p>记录一次使用Hexo来，第一次遇到的问题。</p><p>讲真我也不知道为什么我的4000端口会被占用，我只是如常一样地使用Hexo而已。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>hexo s浏览博客时，提示4000端口问题。代码提示如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">FATAL Port 4000 has been used. Try other port instead.</span><br><span class="line">FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/do</span><br><span class="line">Error: listen EADDRINUSE 0.0.0.0:4000</span><br><span class="line">    at Object.exports._errnoException (util.js:1026:11)</span><br><span class="line">    at exports._exceptionWithHostPort (util.js:1049:20)</span><br><span class="line">    at Server._listen2 (net.js:1257:14)</span><br><span class="line">    at listen (net.js:1293:10)</span><br><span class="line">    at net.js:1403:9</span><br><span class="line">    at _combinedTickCallback (internal/process/next_tick.js:77:11)</span><br><span class="line">    at process._tickCallback (internal/process/next_tick.js:98:9)</span><br><span class="line">FATAL listen EADDRINUSE 0.0.0.0:4000</span><br><span class="line">Error: listen EADDRINUSE 0.0.0.0:4000</span><br><span class="line">    at Object.exports._errnoException (util.js:1026:11)</span><br><span class="line">    at exports._exceptionWithHostPort (util.js:1049:20)</span><br><span class="line">    at Server._listen2 (net.js:1257:14)</span><br><span class="line">    at listen (net.js:1293:10)</span><br><span class="line">    at net.js:1403:9</span><br><span class="line">    at _combinedTickCallback (internal/process/next_tick.js:77:11)</span><br><span class="line">    at process._tickCallback (internal/process/next_tick.js:98:9)</span><br></pre></td></tr></tbody></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>可以在站点下的文件<code>_config.yml</code>内加上如下代码更改hexo-server运行时的端口号：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 40401</span><br><span class="line">  compress: true</span><br><span class="line">  header: true</span><br></pre></td></tr></tbody></table></figure><p>其中<code>40401</code>可以换成想要运行的端口号。</p><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一次使用Hexo来，第一次遇到的问题。&lt;/p&gt;
&lt;p&gt;讲真我也不知道为什么我的4000端口会被占用，我只是如常一样地使用Hexo而已。&lt;/p&gt;
&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;hexo s浏览博客时，提示4000端口问题。代码提示如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FATAL Port 4000 has been used. Try other port instead.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FATAL Something&#39;s wrong. Maybe you can find the solution here: http://hexo.io/do&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Error: listen EADDRINUSE 0.0.0.0:4000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at Object.exports._errnoException (util.js:1026:11)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at exports._exceptionWithHostPort (util.js:1049:20)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at Server._listen2 (net.js:1257:14)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at listen (net.js:1293:10)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at net.js:1403:9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at _combinedTickCallback (internal/process/next_tick.js:77:11)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at process._tickCallback (internal/process/next_tick.js:98:9)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FATAL listen EADDRINUSE 0.0.0.0:4000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Error: listen EADDRINUSE 0.0.0.0:4000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at Object.exports._errnoException (util.js:1026:11)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at exports._exceptionWithHostPort (util.js:1049:20)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at Server._listen2 (net.js:1257:14)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at listen (net.js:1293:10)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at net.js:1403:9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at _combinedTickCallback (internal/process/next_tick.js:77:11)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at process._tickCallback (internal/process/next_tick.js:98:9)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h1 id=&quot;解决&quot;&gt;&lt;a href=&quot;#解决&quot; class=&quot;headerlink&quot; title=&quot;解决&quot;&gt;&lt;/a&gt;解决&lt;/h1&gt;&lt;p&gt;可以在站点下的文件&lt;code&gt;_config.yml&lt;/code&gt;内加上如下代码更改hexo-server运行时的端口号：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;server:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  port: 40401&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  compress: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  header: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;其中&lt;code&gt;40401&lt;/code&gt;可以换成想要运行的端口号。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Hexo" scheme="https://melodyjerry.github.io/blog/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>将本地文件传到阿里云服务器</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/21/%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%BC%A0%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/21/将本地文件传到阿里云服务器/</id>
    <published>2020-02-21T05:47:34.000Z</published>
    <updated>2020-02-21T05:00:50.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>怎么将本地文件传到阿里云服务器里面？</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><ol><li>第一种：在阿里云服务器里建一个FTP服务商，在本地用FTP客户端上传文件</li><li>第二种：进阿里云服务器远程界面的时候，把本地磁盘带进去，然后进服务器里直接从本地磁盘里把文件复制到服务器里</li><li>第三种：QQ安装到阿里云服务器里，用QQ对传</li><li>第四种：把本地文件上传到邮箱里 ，然后进阿里云服务器里打开您的邮箱，进去下载文件即可</li></ol><p>链接：<a href="https://www.w3cschool.cn/intellij_idea_doc/" target="_blank" rel="noopener">https://www.w3cschool.cn/intellij_idea_doc/</a></p><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;怎么将本地文件传到阿里云服务器里面？&lt;/p&gt;
&lt;h1 id=&quot;解决&quot;&gt;&lt;a href=&quot;#解决&quot; class=&quot;headerlink&quot; title=&quot;解决&quot;&gt;&lt;/a&gt;解决&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;第一种：在阿里云服务器里建一个FTP服务商，在本地用FTP客户端上传文件&lt;/li&gt;
&lt;li&gt;第二种：进阿里云服务器远程界面的时候，把本地磁盘带进去，然后进服务器里直接从本地磁盘里把文件复制到服务器里&lt;/li&gt;
&lt;li&gt;第三种：QQ安装到阿里云服务器里，用QQ对传&lt;/li&gt;
&lt;li&gt;第四种：把本地文件上传到邮箱里 ，然后进阿里云服务器里打开您的邮箱，进去下载文件即可&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.w3cschool.cn/intellij_idea_doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.w3cschool.cn/intellij_idea_doc/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="云服务器" scheme="https://melodyjerry.github.io/blog/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Servlet 体系结构</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/20/Servlet%20%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/20/Servlet 体系结构/</id>
    <published>2020-02-20T12:23:11.000Z</published>
    <updated>2020-02-21T13:58:43.395Z</updated>
    
    <content type="html"><![CDATA[<p>我们在写一个class 并 implement Servlet时，需要重写Servlet中的5个方法，但是<strong>大多时候都只用到 service 方法</strong>。</p><p>虽然中用到service方法，但其余的4个方法还得重写。</p><p>那我们能不能编写一个class，去继承或实现 Servlet 后，只用定义一个 service 方法就可以了。其他方法想有就有，不想有就没有？</p><p>这时候我们就要聊聊 Servlet 体系结构了。</p><h1 id="Servlet-体系结构"><a href="#Servlet-体系结构" class="headerlink" title="Servlet 体系结构"></a>Servlet 体系结构</h1><p><strong><code>Servlet</code></strong> – interface，接口</p><p>↓|<em>实现</em></p><p><strong><code>GenericServlet</code></strong> – 实现类，抽象类</p><p>↓|<em>继承</em></p><p><strong><code>HttpServlet</code></strong> – 实现类，抽象类</p><blockquote><p>做项目时，创建Servlet时候，推荐使用第三种方式：👉继承HttpServlet👉定义类继承HttpServlet👉 复写doGet/doPost方法</p></blockquote><a id="more"></a><h1 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h1><ul><li>将 <code>Servlet</code> 接口中的<strong>其他方法做了默认空实现</strong>，<strong>只将 <code>service()</code> 方法作为抽象</strong></li><li>将来定义 <code>Servlet</code> 类时候，可以继承 <code>GenericServlet</code>，实现 <code>service()</code> 方法即可</li><li><em>其余四种方法， 若有需要，手动重写即可。</em></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet("/demo2")</span><br><span class="line">public class ServletDemo2 extends GenericServlet {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {</span><br><span class="line">        System.out.println("demo2....");</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h1><ul><li>该抽象类是<strong>对 HTTP协议 的封装和描述</strong>，可以<strong>简化某些操作</strong></li><li><strong>HTTP协议 有 7种 请求方式。</strong>现在，我们假设只是用<strong>最常用的两种请求方式GET和POST</strong>这两种请求方式。</li><li><code>service()</code>方法中  <em>最先要干</em>  的其中2件事👇</li></ul><p><fancybox><img src="https://s2.ax1x.com/2020/02/20/3mYEiq.png" alt="service()方法要干的其中2件事"><fancybox></fancybox></fancybox></p><ul><li>将来不管怎么样，都得做这么一件事：<strong>“先判断请求方式👉判断完后，要通过不同的请求方式，做出不同的代码逻辑“。</strong></li><li>那么，这个过程是非常麻烦的。</li><li>同时，这个过程也是<strong>所有 <code>service()</code> 都该做的一个过程。</strong></li><li>所以这个时候，官方针对这个过程，专门提供了一个class <code>HttpServlet</code>。</li><li><code>HttpServlet</code> 已经帮程序员做好了这个过程，<strong>写好了相应的代码，就如上图的红色字体部分</strong>。集程序员不再需要去判断请求方式了。</li><li><code>HttpServlet</code> 内部定义了 <code>doGet(){}</code> 和  <code>doPost(){}</code> 这两个方法。并且在判断请求方式的 <code>if</code> 中调用了这两个方法。</li><li>这就是其基本的定义原理。就如下图👇</li></ul><p><fancybox><img src="https://s2.ax1x.com/2020/02/20/3mNOo9.png" alt="HttpServlet类"></fancybox></p><ul><li><p>若将来想要<strong>屏蔽这种GET或POST请求方式的处理逻辑</strong>：我们可以<strong>继承 HttpServlet，并且去重写 <code>doGet(){}</code> 和 <code>doPost(){}</code>这两个方法。</strong></p></li><li><p>因为将来都是<strong>调用 <code>service()</code>方法</strong> ，并且 <code>service()</code>会做一个<strong>方法分发</strong>：你是<strong>get</strong>就调用 <strong><code>doGet()</code></strong> ，你是<strong>post</strong>就调用 <strong><code>doPost()</code></strong> 。</p></li><li><blockquote><p>做项目时，创建Servlet时候，推荐使用第三种方式：👉继承HttpServlet👉定义类继承HttpServlet👉 复写doGet/doPost方法</p></blockquote></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>定义 class <strong>继承 <code>HttpServlet</code></strong></li><li><strong>重写<code>doGet()</code> 和 <code>doPost()</code></strong> 两个方法</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* ServletDemo3.java  */</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Classname ServletDemo3</span><br><span class="line"> * @Description TODO</span><br><span class="line"> * @Date 2020/2/20 下午 10:54</span><br><span class="line"> * @Created by jerry</span><br><span class="line"> */</span><br><span class="line">@WebServlet("demo3")</span><br><span class="line">public class ServletDemo3 extends HttpServlet {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {</span><br><span class="line">        System.out.println("doGet......");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {</span><br><span class="line">        System.out.println("doPost......");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><strong>通过浏览器直接请求，是GET方式</strong></li><li>现在掌握的知识，只能通过表单，完成POST方式</li></ul><h2 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h2><ol><li>新建login.html文件</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;表单&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action="/demo3" method="post"&gt;</span><br><span class="line">        &lt;input name="username"&gt;</span><br><span class="line">        &lt;input type="submit" value="提交"&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>重启服务，访问页面</li></ol><p><fancybox><img src="https://s2.ax1x.com/2020/02/20/3msHLq.gif" alt="3msHLq.gif"></fancybox></p><ol start="3"><li>将 <code>method="post"</code> 改为 <code>method="get"</code></li><li>再访问页面</li></ol><p><fancybox><img src="https://s2.ax1x.com/2020/02/20/3myRXR.gif" alt="3myRXR.gif"></fancybox></p><blockquote><p>注意：</p><p><strong>使用get方式后，请求的参数会跟在url后。</strong></p><p><img src="https://s2.ax1x.com/2020/02/20/3myjBt.png" alt="3myjBt.png"></p></blockquote><hr><h1 id="后续阅读相关文章"><a href="#后续阅读相关文章" class="headerlink" title="后续阅读相关文章"></a>后续阅读相关文章</h1><p>1、<a href="https://blog.csdn.net/green703338130/article/details/79460250" target="_blank" rel="noopener">GenericServlet和HttpServlet</a></p><p>2、<a href="https://www.cnblogs.com/tiancai/p/8509705.html" target="_blank" rel="noopener">GenericServlet 、Servlet和httpServler他们之间的关系</a></p><p>3、<a href="https://www.cnblogs.com/yonyong/p/9337284.html" target="_blank" rel="noopener">GenericServlet和HttpServlet有什么区别？</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在写一个class 并 implement Servlet时，需要重写Servlet中的5个方法，但是&lt;strong&gt;大多时候都只用到 service 方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;虽然中用到service方法，但其余的4个方法还得重写。&lt;/p&gt;
&lt;p&gt;那我们能不能编写一个class，去继承或实现 Servlet 后，只用定义一个 service 方法就可以了。其他方法想有就有，不想有就没有？&lt;/p&gt;
&lt;p&gt;这时候我们就要聊聊 Servlet 体系结构了。&lt;/p&gt;
&lt;h1 id=&quot;Servlet-体系结构&quot;&gt;&lt;a href=&quot;#Servlet-体系结构&quot; class=&quot;headerlink&quot; title=&quot;Servlet 体系结构&quot;&gt;&lt;/a&gt;Servlet 体系结构&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Servlet&lt;/code&gt;&lt;/strong&gt; – interface，接口&lt;/p&gt;
&lt;p&gt;↓|&lt;em&gt;实现&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;GenericServlet&lt;/code&gt;&lt;/strong&gt; – 实现类，抽象类&lt;/p&gt;
&lt;p&gt;↓|&lt;em&gt;继承&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;HttpServlet&lt;/code&gt;&lt;/strong&gt; – 实现类，抽象类&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;做项目时，创建Servlet时候，推荐使用第三种方式：👉继承HttpServlet👉定义类继承HttpServlet👉 复写doGet/doPost方法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="JavaWeb" scheme="https://melodyjerry.github.io/blog/tags/JavaWeb/"/>
    
      <category term="笔记" scheme="https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Servlet" scheme="https://melodyjerry.github.io/blog/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>IDEA官方文档</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/20/IntelliJ%20IDEA%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/20/IntelliJ IDEA官方文档/</id>
    <published>2020-02-20T11:47:34.000Z</published>
    <updated>2020-02-20T12:47:12.981Z</updated>
    
    <content type="html"><![CDATA[<p>一份 W3C school 提供的 <a href="https://www.w3cschool.cn/intellij_idea_doc/" target="_blank" rel="noopener">《IntelliJ IDEA官方文档》</a><br></p><p>链接：<a href="https://www.w3cschool.cn/intellij_idea_doc/" target="_blank" rel="noopener">https://www.w3cschool.cn/intellij_idea_doc/</a></p><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一份 W3C school 提供的 &lt;a href=&quot;https://www.w3cschool.cn/intellij_idea_doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《IntelliJ IDEA官方文档》&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.w3cschool.cn/intellij_idea_doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.w3cschool.cn/intellij_idea_doc/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IDEA" scheme="https://melodyjerry.github.io/blog/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>愿有情人终成眷属，执手前走共度一生</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/20/%E6%84%BF%E6%9C%89%E6%83%85%E4%BA%BA%E7%BB%88%E6%88%90%E7%9C%B7%E5%B1%9E%EF%BC%8C%E6%89%A7%E6%89%8B%E5%89%8D%E8%B5%B0%E5%85%B1%E5%BA%A6%E4%B8%80%E7%94%9F/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/20/愿有情人终成眷属，执手前走共度一生/</id>
    <published>2020-02-20T10:47:34.000Z</published>
    <updated>2020-02-20T11:14:02.991Z</updated>
    
    <content type="html"><![CDATA[<p>浏览博客 <a href="https://www.7ooooo.cn/490/.html" target="_blank" rel="noopener">网易云热评墙</a> 时，看见两段很感触的网易云音乐热评。截了两张图，就当做今天的随笔。<br></p><p><strong><font color="red">“愿有情人终成眷属”，这话我想在后边加上一句，”执手前走共度一生“。</font></strong>——2020.02.20随笔</p><fancybox><p><img src="https://s2.ax1x.com/2020/02/20/3eLXyq.png" alt="《melodyremix》网易云音乐热评"></p></fancybox><fancybox><p><img src="https://s2.ax1x.com/2020/02/20/3eOFp9.png" alt="《我还想他》网易云音乐热评"></p></fancybox><a id="more"></a><hr><p>图片[1]链接：<a href="https://www.7ooooo.cn/490/.html" target="_blank" rel="noopener">https://www.7ooooo.cn/490/.html</a></p><p>图片[2]链接：<a href="https://www.7ooooo.cn/523/.html" target="_blank" rel="noopener">https://www.7ooooo.cn/523/.html</a></p><p><strong>关注我们：</strong>请关注一下我们的微信公众号（xielihaia）<br><strong>版权声明：</strong>版权归 <a href="https://www.7ooooo.cn/490/.html" target="_blank" rel="noopener">网易云热评墙</a> 所有！</p><p><img src="https://cdn.7ooooo.cn/wp-content/themes/Nana/images/gongzhonghao.jpg" alt="网易云热评墙的公众号"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览博客 &lt;a href=&quot;https://www.7ooooo.cn/490/.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网易云热评墙&lt;/a&gt; 时，看见两段很感触的网易云音乐热评。截了两张图，就当做今天的随笔。&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;“愿有情人终成眷属”，这话我想在后边加上一句，”执手前走共度一生“。&lt;/font&gt;&lt;/strong&gt;——2020.02.20随笔&lt;/p&gt;
&lt;fancybox&gt;

&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/20/3eLXyq.png&quot; alt=&quot;《melodyremix》网易云音乐热评&quot;&gt;&lt;/p&gt;
&lt;/fancybox&gt;



&lt;fancybox&gt;

&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/20/3eOFp9.png&quot; alt=&quot;《我还想他》网易云音乐热评&quot;&gt;&lt;/p&gt;
&lt;/fancybox&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>IDEA与Tomcat的其他相关配置</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/20/IDEA%E4%B8%8ETomcat%E7%9A%84%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/20/IDEA与Tomcat的其他相关配置/</id>
    <published>2020-02-20T09:42:00.000Z</published>
    <updated>2020-02-20T11:41:38.008Z</updated>
    
    <content type="html"><![CDATA[<ol><li>IDEA会为每一个Tomcat部署的项目单独建立一份配置文件</li></ol><ul><li>查看控制台的log</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Using CATALINA_BASE:   "C:\Users\丶Melody\.IntelliJIdea2019.1\system\tomcat\_test"</span><br></pre></td></tr></tbody></table></figure><br><ol start="2"><li>工作空间项目    和     Tomcat部署的Web项目</li></ol><ul><li>Tomcat真正访问的是“Tomcat部署的Web项目”</li><li>“Tomcat部署的Teb项目”对应着“工作空间项目” 的Web目录下的所有资源</li><li>IDEA工作台中，项目的src对应着WEB-INF目录</li><li>WEB-INF目录下的资源不能被浏览器直接访问。日后可以利用其他技术访问到。</li></ul><br><ol start="3"><li>断点调试：使用”小虫子”启动 dubug 启动</li></ol><br><h2 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h2><p>【00:28】1.IDEA会为每一个Tomcat部署的项目单独建立一份配置文件</p><p>【03:15】2.工作空间项目    和     Tomcat部署的Web项目</p><p>【09:04】3.断点调试：使用”小虫子”启动 dubug 启动</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=70420291&amp;cid=122002004&amp;page=121" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><br><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;IDEA会为每一个Tomcat部署的项目单独建立一份配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;查看控制台的log&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Using CATALINA_BASE:   &quot;C:\Users\丶Melody\.IntelliJIdea2019.1\system\tomcat\_test&quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;br&gt;

&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;工作空间项目    和     Tomcat部署的Web项目&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Tomcat真正访问的是“Tomcat部署的Web项目”&lt;/li&gt;
&lt;li&gt;“Tomcat部署的Teb项目”对应着“工作空间项目” 的Web目录下的所有资源&lt;/li&gt;
&lt;li&gt;IDEA工作台中，项目的src对应着WEB-INF目录&lt;/li&gt;
&lt;li&gt;WEB-INF目录下的资源不能被浏览器直接访问。日后可以利用其他技术访问到。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;

&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;断点调试：使用”小虫子”启动 dubug 启动&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;

&lt;h2 id=&quot;视频讲解&quot;&gt;&lt;a href=&quot;#视频讲解&quot; class=&quot;headerlink&quot; title=&quot;视频讲解&quot;&gt;&lt;/a&gt;视频讲解&lt;/h2&gt;&lt;p&gt;【00:28】1.IDEA会为每一个Tomcat部署的项目单独建立一份配置文件&lt;/p&gt;
&lt;p&gt;【03:15】2.工作空间项目    和     Tomcat部署的Web项目&lt;/p&gt;
&lt;p&gt;【09:04】3.断点调试：使用”小虫子”启动 dubug 启动&lt;/p&gt;
&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=70420291&amp;amp;cid=122002004&amp;amp;page=121&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;br&gt;
    
    </summary>
    
    
    
      <category term="JavaWeb" scheme="https://melodyjerry.github.io/blog/tags/JavaWeb/"/>
    
      <category term="IDEA" scheme="https://melodyjerry.github.io/blog/tags/IDEA/"/>
    
      <category term="Tomcat" scheme="https://melodyjerry.github.io/blog/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Servlet：运行在服务器端的小程序</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/20/Servlet%EF%BC%9A%E8%BF%90%E8%A1%8C%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/20/Servlet：运行在服务器端的小程序/</id>
    <published>2020-02-20T07:19:00.000Z</published>
    <updated>2020-02-21T09:54:31.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet： server applet"></a>Servlet： server applet</h1><ul><li>概念：运行在服务器端的小程序</li><li>Servlet就是一个接口，定义了Java类被浏览器访问到（Tomcat识别）的规则<span id="jump"><font color="blue">（我是跳转内容）</font></span><a href="#jump" class="footnote-backref">↩</a>。</li><li>将来我们自定义一个类，实现Servlet接口，复写（重写Override）方法。</li></ul><h1 id="快速理解"><a href="#快速理解" class="headerlink" title="快速理解"></a>快速理解</h1><p> <fancybox><img src="https://s2.ax1x.com/2020/02/19/3EI7WT.png" alt="快速理解"></fancybox></p><a id="more"></a><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><ol><li><p>创建JavaEE项目</p></li><li><p>定义一个类，实现Servlet接口</p></li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* ServletDemo1.java */</span><br><span class="line">package cn.itcast.web.servlet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ServletDemo1 implements Servlet {</span><br><span class="line">//TODO</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>​    </p><ol start="3"><li>实现接口中的抽象方法</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/* ServletDemo1.java */</span><br><span class="line">package cn.itcast.web.servlet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ServletDemo1 implements Servlet {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig servletConfig) throws ServletException {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ServletConfig getServletConfig() {</span><br><span class="line">        return null;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 提供服务的方法</span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {</span><br><span class="line">        System.out.println("Hello Servlet");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getServletInfo() {</span><br><span class="line">        return null;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>配置Servlet，在web.xml的<code>&lt;web-app&gt;&lt;/web-app&gt;</code>中添加：</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置Servlet--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>servlet-mapping</code>是做一个<strong>映射</strong>，<code>servlet-name</code>对应<code>servlet-class</code>，<code>url-pattern</code>是资源路径（<strong>/开头</strong>）</p></blockquote><blockquote><p> <code>&lt;servlet-class&gt;</code>cn.itcast.web.servlet.ServletDemo1<code>&lt;/servlet-class&gt;</code>，中的<strong>cn.itcast.web.servlet.ServletDemo1</strong>是<font color="blue" size="5">全类名</font>，这里涉及到<font color="red" size="5">反射</font>。日后补充。</p></blockquote><ol start="5"><li>启动服务，看看结果</li></ol><p>浏览器中是空白的，</p><p><img src="https://s2.ax1x.com/2020/02/20/3eZQv6.png" alt=""></p><p>但是IDEA控制台中显示<strong>“Hello Servlet”</strong></p><blockquote><p>每刷新一次页面，控制台就多一句“Hello Servlet”。</p></blockquote><p><img src="https://s2.ax1x.com/2020/02/20/3eZ8bD.png" alt=""></p><h1 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h1><ol><li><p>当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</p></li><li><p>查找<strong>web.xml</strong>文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容。</p></li><li><p>如果有，则在找到对应的<code>&lt;servlet-class&gt;</code><strong>全类名</strong>（<font color="red">涉及到反射</font>）</p></li><li><p>tomcat会<strong>将字节码文件加载进内存，并且创建其对象</strong></p></li><li><p>调用其方法</p><ul><li><p>为什么能调用方法？</p></li><li><p>因为实现了【规则】（<a href="#jump">点击我跳转</a>）。实现规则，实现Servlet接口，实现了接口中的方法。</p><p><fancybox><img src="https://s2.ax1x.com/2020/02/20/3e83Ax.png" alt=""></fancybox></p></li></ul></li></ol><h1 id="ServletDemo"><a href="#ServletDemo" class="headerlink" title="ServletDemo"></a>ServletDemo</h1><p>可以调试、运行，看看每个方法的执行次数。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import javax.servlet.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Servlet的方法</span><br><span class="line"> */</span><br><span class="line">public class ServletDemo1 implements Servlet {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化的方法</span><br><span class="line">     * 在Servlet被创建时，执行，且只执行一次。</span><br><span class="line">     * @param servletConfig</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig servletConfig) throws ServletException {</span><br><span class="line">        System.out.println("init...");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取ServletConfig对象</span><br><span class="line">     * ServletConfig：Servlet的配置对象</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public ServletConfig getServletConfig() {</span><br><span class="line">        return null;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 提供服务的方法</span><br><span class="line">     * 每一次Servlet被访问时，执行。可执行多次。</span><br><span class="line">     * @param servletRequest</span><br><span class="line">     * @param servletResponse</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {</span><br><span class="line">        System.out.println("service...");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取Servlet的一些信息（版本、作者……）</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public String getServletInfo() {</span><br><span class="line">        return null;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 销毁的方法</span><br><span class="line">     * 在服务器正常关闭时，执行。只执行一次。</span><br><span class="line">     * 非正关闭时，destroy方法不会执行。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() {</span><br><span class="line">        System.out.println("destroy...");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Servlet中的生命周期方法"><a href="#Servlet中的生命周期方法" class="headerlink" title="Servlet中的生命周期方法"></a>Servlet中的生命周期方法</h1><h2 id="1-被创建：执行init方法，只执行一次"><a href="#1-被创建：执行init方法，只执行一次" class="headerlink" title="1.被创建：执行init方法，只执行一次"></a>1.被创建：执行init方法，只执行一次</h2><ul><li>Servlet什么时候被创建？</li></ul><ol><li>默认情况下，第一次被访问时，被创建。</li><li>在服务器启动时，被创建。</li></ol><ul><li>可以配置执行Servlet的创建时机，在<code>&lt;servlet&gt;&lt;/servlet&gt;</code>标签中配置<code>&lt;load-on-startup&gt;整数值&lt;/load-on-startup&gt;</code></li></ul><blockquote><p>1.第一次被访问时，创建</p><p><load-on-startup><strong>负整数</strong></load-on-startup></p><p>2.在服务器启动时，创建</p><p><load-on-startup><strong>0或正整数</strong>(一般0~10)</load-on-startup></p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 初始化的方法</span><br><span class="line"> * 在Servlet被创建时，执行，且只执行一次。</span><br><span class="line"> * @param servletConfig</span><br><span class="line"> * @throws ServletException</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void init(ServletConfig servletConfig) throws ServletException {</span><br><span class="line">    System.out.println("init...");</span><br><span class="line">    </span><br><span class="line">    // 定义局部变量，这样不存在多线程的安全问题</span><br><span class="line">    int number = 3;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Servlet的init方法，只执行一次，说明<strong>一个Servlet在内存中只存在一个对象，Servlet是单例的。</strong></li><li><em>多个用户同时访问时，可能存在线程安全问题。</em></li><li>解决：尽量不要在Servlet中定义成员变量（定义局部变量就不存在安全问题了）。即使定义了成员变量，也不要对修改值。</li></ul><h2 id="2-提供服务：执行service方法，可执行多次"><a href="#2-提供服务：执行service方法，可执行多次" class="headerlink" title="2.提供服务：执行service方法，可执行多次"></a>2.提供服务：执行service方法，可执行多次</h2><ul><li>每次访问Servlet时，Service方法都会被调用一次。</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 提供服务的方法</span><br><span class="line"> * 每一次Servlet被访问时，执行。可执行多次。</span><br><span class="line"> * @param servletRequest</span><br><span class="line"> * @param servletResponse</span><br><span class="line"> * @throws ServletException</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {</span><br><span class="line">    System.out.println("service...");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-被销毁：执行destroy方法，只执行一次"><a href="#3-被销毁：执行destroy方法，只执行一次" class="headerlink" title="3.被销毁：执行destroy方法，只执行一次"></a>3.被销毁：执行destroy方法，只执行一次</h2><ul><li>Servlet被销毁时执行。服务器关闭时，Servlet被销毁</li><li><strong>只有服务器正常关闭时，才会执行destroy方法。</strong></li><li>destroy方法在Servlet被销毁之前执行，<strong>一般用于释放资源</strong></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 销毁的方法</span><br><span class="line"> * 在服务器正常关闭时，执行。只执行一次。</span><br><span class="line"> * 非正关闭时，destroy方法不会执行。</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void destroy() {</span><br><span class="line">    System.out.println("destroy...");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Servlet-3-0"><a href="#Servlet-3-0" class="headerlink" title="Servlet 3.0"></a>Servlet 3.0</h1><ul><li>官方提供新的标准 Servlet 3.0</li><li>从 <strong>Java EE 6</strong> 开始支持 Servlet 3.0</li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>支持<strong>注解配置</strong>。可以不需要web.xml了</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml</p></li><li><p>定义一个类，实现Servlet接口</p></li><li><p>复写方法</p></li><li><p>在类上使用<strong><code>@WebServlet</code>注解</strong>，进行配置</p><ul><li><code>@WebServlet("资源路径")</code></li><li>比如：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(urlPatterns = "/demo2")</span><br><span class="line">或</span><br><span class="line">@WebServlet(value = "/demo2")</span><br><span class="line">或</span><br><span class="line">@WebServlet("/demo2")</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><ol start="5"><li>访问：<a href="http://localhost:8080/Servlet3/demo2" target="_blank" rel="noopener">http://localhost:8080/Servlet3/demo2</a></li></ol><p><img src="https://s2.ax1x.com/2020/02/20/3eyUxA.png" alt=""></p><h2 id="WebServlet注解"><a href="#WebServlet注解" class="headerlink" title="@WebServlet注解"></a>@WebServlet注解</h2><ul><li><code>@WebServlet</code>中有个很特殊的属性<code>value</code></li><li>一般<strong>表示最重要的属性</strong>，就用<code>value</code>表示。</li><li>特性：<strong>如果只有一个属性，<code>value</code>可以省略不写。</strong></li><li>除去<code>value</code>，最重要的属性是<code>urlPatterns</code></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Target({ElementType.TYPE})</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface WebServlet {</span><br><span class="line"></span><br><span class="line">    String name() default "";//相当于&lt;Servlet-name&gt;</span><br><span class="line">    String[] value() default {};//代表urlPatterns()属性配置</span><br><span class="line">    String[] urlPatterns() default {};//相当于&lt;url-pattern&gt;</span><br><span class="line">    int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;</span><br><span class="line">    WebInitParam[] initParams() default {};</span><br><span class="line">    boolean asyncSupported() default false;</span><br><span class="line">    String smallIcon() default "";</span><br><span class="line">    String largeIcon() default "";</span><br><span class="line">    String description() default "";</span><br><span class="line">    String displayName() default "";</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Servlet-体系结构"><a href="#Servlet-体系结构" class="headerlink" title="Servlet 体系结构"></a>Servlet 体系结构</h1><p>跳转到我得下一篇博文👉 [Servlet 体系结构](<a href="https://melodyjerry.gitee.io/blog/2020/02/20/Servlet" target="_blank" rel="noopener">https://melodyjerry.gitee.io/blog/2020/02/20/Servlet</a> 体系结构/)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Servlet：-server-applet&quot;&gt;&lt;a href=&quot;#Servlet：-server-applet&quot; class=&quot;headerlink&quot; title=&quot;Servlet： server applet&quot;&gt;&lt;/a&gt;Servlet： server applet&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;概念：运行在服务器端的小程序&lt;/li&gt;
&lt;li&gt;Servlet就是一个接口，定义了Java类被浏览器访问到（Tomcat识别）的规则&lt;span id=&quot;jump&quot;&gt;&lt;font color=&quot;blue&quot;&gt;（我是跳转内容）&lt;/font&gt;&lt;/span&gt;&lt;a href=&quot;#jump&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;将来我们自定义一个类，实现Servlet接口，复写（重写Override）方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;快速理解&quot;&gt;&lt;a href=&quot;#快速理解&quot; class=&quot;headerlink&quot; title=&quot;快速理解&quot;&gt;&lt;/a&gt;快速理解&lt;/h1&gt;&lt;p&gt; &lt;fancybox&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/19/3EI7WT.png&quot; alt=&quot;快速理解&quot;&gt;&lt;/fancybox&gt;&lt;/p&gt;

    
    </summary>
    
    
    
      <category term="JavaWeb" scheme="https://melodyjerry.github.io/blog/tags/JavaWeb/"/>
    
      <category term="笔记" scheme="https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Tomcat" scheme="https://melodyjerry.github.io/blog/tags/Tomcat/"/>
    
      <category term="Servlet" scheme="https://melodyjerry.github.io/blog/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat简单修改虚拟目录实现访问多个项目</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/20/Tomcat%E7%AE%80%E5%8D%95%E4%BF%AE%E6%94%B9%E8%99%9A%E6%8B%9F%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%8E%B0%E8%AE%BF%E9%97%AE%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/20/Tomcat简单修改虚拟目录实现访问多个项目/</id>
    <published>2020-02-20T06:55:00.000Z</published>
    <updated>2020-02-20T09:38:11.642Z</updated>
    
    <content type="html"><![CDATA[<p>可以通过 <strong>修改Application Contest（虚拟目录）</strong> 实现访问多个项目</p><p><img src="https://s2.ax1x.com/2020/02/20/3eeYLT.png" alt=""></p><p>修改<strong>项目名称作为对应的虚拟目录</strong>，</p><p>重启服务后，浏览器访问时，</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/项目a/资源5</span><br><span class="line">例如：http://localhost:55555/ServletDemo/demo1.html</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以通过 &lt;strong&gt;修改Application Contest（虚拟目录）&lt;/strong&gt; 实现访问多个项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/20/3eeYLT.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;修改&lt;strong&gt;项目名称作为对应的虚拟目录&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;重启服务后，浏览器访问时，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;http://localhost:8080/项目a/资源5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如：http://localhost:55555/ServletDemo/demo1.html&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="JavaWeb" scheme="https://melodyjerry.github.io/blog/tags/JavaWeb/"/>
    
      <category term="Tomcat" scheme="https://melodyjerry.github.io/blog/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>IDEA启动Tomcat报错</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/19/IDEA%E5%90%AF%E5%8A%A8Tomcat%E6%8A%A5%E9%94%99/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/19/IDEA启动Tomcat报错/</id>
    <published>2020-02-19T12:02:09.000Z</published>
    <updated>2020-02-20T09:37:58.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src="https://s2.ax1x.com/2020/02/20/3eCKI0.png" alt=""></p><p>IDEA run的时候报错：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error running 'Tomcat 8.5.51':</span><br><span class="line">Address loaclhost:1099 is already in use</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>控制台提示<strong>1099端口已经被占用</strong>。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>解决方法要么是杀死端口号1099对应的进程，要么就是修改IDEA中Tomcat的端口号。</p><p>建议优先选择杀死对应进程。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ol><li>根据端口号查找对应的PID，可以通过在cmd中输入命令，</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr 1099</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>找到该进程的进程号为7256</li></ol><p><img src="https://s2.ax1x.com/2020/02/20/3eCRot.png" alt=""></p><ol start="3"><li>输入命令，杀死进程</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tskill 7256</span><br><span class="line">或</span><br><span class="line">taskkill -f -pid 7256</span><br></pre></td></tr></tbody></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>同方法一，知道进程的PID后，直接去进程管理器，直接右键结束进程。</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>针对方法一、二均无效时，只能在IDEA中修改端口：</p><p><img src="https://s2.ax1x.com/2020/02/20/3eP07n.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/20/3eCKI0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;IDEA run的时候报错：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Error running &#39;Tomcat 8.5.51&#39;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Address loaclhost:1099 is already in use&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="IDEA" scheme="https://melodyjerry.github.io/blog/tags/IDEA/"/>
    
      <category term="Tomcat" scheme="https://melodyjerry.github.io/blog/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 常用快捷键列表</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/19/IDEA%E8%BE%93%E5%87%BA%E6%89%93%E5%8D%B0System.out.println()%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/19/IDEA输出打印System.out.println()的快捷键/</id>
    <published>2020-02-19T09:02:00.000Z</published>
    <updated>2020-02-20T06:19:40.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDEA输出打印System-out-println-的快捷键"><a href="#IDEA输出打印System-out-println-的快捷键" class="headerlink" title="IDEA输出打印System.out.println()的快捷键"></a>IDEA输出打印System.out.println()的快捷键</h1><p>在eclipse中习惯了使用syso，开始用idea很不习惯。</p><p>在idea中直接输入sout，自动出现提示，不像eclipse中那样还要alt+/，这算是idea的一个优点了。</p><p>sout 看图：</p><p><img src="https://s2.ax1x.com/2020/02/20/3ei99f.png" alt="3ei99f.png"></p><p>按Tab或Enter都可以出现</p><p><img src="https://s2.ax1x.com/2020/02/20/3eiPgS.png" alt="3eiPgS.png"></p><a id="more"></a><p><strong>十大Intellij IDEA快捷键 for System.out、main快捷键</strong></p><p>1 智能提示</p><p>Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。</p><p>最后要说一点，Intellij能够智能感知spring、hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。</p><p>2 重构</p><p>Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。</p><p>切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。</p><p>3 代码生成<br>这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。</p><p>另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。</p><p>4 编辑<br>编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+&lt;/&gt;折叠代码就不多说了。</p><p>关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。</p><p>5 查找打开<br>类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。</p><p>类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。</p><p>要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。</p><p>Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。</p><p>6 其他辅助<br>以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：</p><p>Ø  命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。</p><p>Ø  新建：Alt+Insert可以新建类、方法等任何东西。</p><p>Ø  格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。</p><p>Ø  切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。</p><p>Ø  单元测试：Ctrl+Alt+T创建单元测试用例。</p><p>Ø  运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。</p><p>Ø  调试：F7/F8/F9分别对应Step into，Step over，Continue。</p><p>此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。</p><p>7 最终榜单<br>这榜单阵容太豪华了，后几名都是如此有用，毫不示弱。</p><p>Ø  Top #10切来切去：Ctrl+Tab</p><p>Ø  Top #9选你所想：Ctrl+W</p><p>Ø  Top #8代码生成：Template/Postfix +Tab</p><p>Ø  Top #7发号施令：Ctrl+Shift+A</p><p>Ø  Top #6无处藏身：Shift+Shift</p><p>Ø  Top #5自动完成：Ctrl+Shift+Enter</p><p>Ø  Top #4创造万物：Alt+Insert</p><p>太难割舍，前三名并列吧！</p><p>Ø  Top #1智能补全：Ctrl+Shift+Space</p><p>Ø  Top #1自我修复：Alt+Enter</p><p>Ø  Top #1重构一切：Ctrl+Shift+Alt+T</p><p>————————<br>版权声明：本文为CSDN博主「Jenrey」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/jenrey/article/details/79961825" target="_blank" rel="noopener">https://blog.csdn.net/jenrey/article/details/79961825</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IDEA输出打印System-out-println-的快捷键&quot;&gt;&lt;a href=&quot;#IDEA输出打印System-out-println-的快捷键&quot; class=&quot;headerlink&quot; title=&quot;IDEA输出打印System.out.println()的快捷键&quot;&gt;&lt;/a&gt;IDEA输出打印System.out.println()的快捷键&lt;/h1&gt;&lt;p&gt;在eclipse中习惯了使用syso，开始用idea很不习惯。&lt;/p&gt;
&lt;p&gt;在idea中直接输入sout，自动出现提示，不像eclipse中那样还要alt+/，这算是idea的一个优点了。&lt;/p&gt;
&lt;p&gt;sout 看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/20/3ei99f.png&quot; alt=&quot;3ei99f.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;按Tab或Enter都可以出现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/20/3eiPgS.png&quot; alt=&quot;3eiPgS.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IDEA" scheme="https://melodyjerry.github.io/blog/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 常用快捷键列表</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/19/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%88%97%E8%A1%A8/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/19/IDEA常用快捷键列表/</id>
    <published>2020-02-19T09:00:00.000Z</published>
    <updated>2020-02-19T09:27:20.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDEA-常用快捷键列表"><a href="#IDEA-常用快捷键列表" class="headerlink" title="IDEA 常用快捷键列表"></a>IDEA 常用快捷键列表</h1><a id="more"></a><p>——-    IDEA中窗口最大化—-&gt;Windows 上： Ctrl+Shift+F12  </p><p>——–   ctrl+z撤回代码  </p><p>——-    ctrl+shift+z恢复撤回代码  </p><p>——-     ctrl + Alt + V (返回属性变量)  </p><p>——-      shift+ctrl+u (大小写的切换)  </p><p>——-      Ctrl+Alt+L，格式化代码  </p><p>——-     Ctrl+D 将当前行复制到下一行  </p><p>——-      Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch 也可抛错误  </p><p>——-       快捷方式一（光标移到该代码行，Alt+Enter），可以异常外抛出，也可以try-catch：  </p><p>——-       Ctrl+Shift+Space，自动补全代码（提示）  </p><p>——-        Ctrl+O，重写方法  </p><p>——-        Ctrl+I，实现方法  </p><p>——-        ctrl + shift + enter 句末加；  </p><p>——-        连安两下 shift 查找文件  </p><p>——-        CtrL +shift +r 全局搜索：  </p><p>——-     ctrl +r 替换当前页的单词  </p><p>——-        代码格式化： shfit + G   (自定义)    //ctrl +alt +L  </p><p>——     直接查看和进入接口实现类的快捷键  ：   Ctrl+Alt+鼠标左键  </p><p>—–       单机两下放大窗户：  </p><p>—–   alt+capslk(大小写切换)+鼠标左键  或者：ALT +    鼠标左键      列编辑模式  </p><p>————-   ctrl+shift+enter不只是用来行尾加分号的；  </p><p>  idea进阶快捷键：  </p><p>  1 查看接口的实现类：Ctrl+Alt+B：  </p><p>  2：查看一个类中有什么方法：Alt+7 或 点左侧边栏Structure  </p><p>  2 返回上/下个光标地方:Alt+Ctrl+箭头(向左) 和 Alt+ Ctrl+箭头(向右)—（全键盘）  </p><p>  3： 查看Java方法调用树(被调/主调)：Ctrl+Alt+H  </p><p>  4 :查看类继承关系图：Ctrl+Alt+U  </p><p>  5:查看当前类的继承树：Ctrl+H  </p><p>  6: 查看定义的变量在哪里被调用：Ctrl+Alt+F7  </p><p>  7:查看一个类中有什么方法：Alt+7 或 点左侧边栏Structure  </p><p>  8:列编辑：alt +左键  </p><p>9:自动生成not null判断语句</p><p>自动生成not null这种if判断，在<code>IDEA</code>里有很多种办法，其中一种办法你可能没想到。</p><p><a href="http://blog.didispace.com/images/pasted-25.png" target="_blank" rel="noopener"><img src="http://blog.didispace.com/images/pasted-25.png" alt="upload successful"></a>upload successful</p><p>当我们使用rabbitTemplate. 后，直接输入<code>notnull</code>并回车，<code>IDEA</code>就好自动生成if判断了。</p><p><a href="http://blog.didispace.com/images/pasted-26.png" target="_blank" rel="noopener"><img src="http://blog.didispace.com/images/pasted-26.png" alt="upload successful"></a>upload successful</p><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p><code>Ctrl+Shift + Enter</code>，语句完成<br><code>" ！"</code>，否定完成，输入表达式时按 “！”键<br><code>Ctrl+E</code>，最近的文件<br><code>Ctrl+Shift+E</code>，最近更改的文件<br><code>Shift+Click</code>，可以关闭文件<br><code>Ctrl+[ OR ]</code>，可以跑到大括号的开头与结尾<br><code>Ctrl+F12</code>，可以显示当前文件的结构<br><code>Ctrl+F7</code>，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择<br><code>Ctrl+N</code>，可以快速打开类<br><code>Ctrl+Shift+N</code>，可以快速打开文件<br><code>Alt+Q</code>，可以看到当前方法的声明<br><code>Ctrl+P</code>，可以显示参数信息<br><code>Ctrl+Shift+Insert</code>，可以选择剪贴板内容并插入<br><code>Alt+Insert</code>，可以生成构造器/Getter/Setter等<br><code>Ctrl+Alt+V</code>，可以引入变量。例如：new String(); 自动导入变量定义<br><code>Ctrl+Alt+T</code>，可以把代码包在一个块内，例如：try/catch<br><code>Ctrl+Enter</code>，导入包，自动修正<br><code>Ctrl+Alt+L</code>，格式化代码<br><code>Ctrl+Alt+I</code>，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作<br><code>Ctrl+Alt+O</code>，优化导入的类和包<br><code>Ctrl+R</code>，替换文本<br><code>Ctrl+F</code>，查找文本<br><code>Ctrl+Shift+Space</code>，自动补全代码<br><code>Ctrl+空格</code>，代码提示（与系统输入法快捷键冲突）<br><code>Ctrl+Shift+Alt+N</code>，查找类中的方法或变量<br>★<code>Alt+Enter</code>，快速修复错误提示、导入包、自动修正代码、解决出现的问题、生成返回值……</p><blockquote><p>详细见 <a href="http://www.phperz.com/article/17/0409/333071.html" target="_blank" rel="noopener">最特殊的快捷键 Alt + Enter 介绍</a></p></blockquote><p><code>Alt+Shift+C</code>，最近的更改<br><code>Alt+Shift+Up/Down</code>，上/下移一行<br><code>Shift+F6</code>，重构 – 重命名<br><code>Ctrl+X</code>，删除行<br><code>Ctrl+D</code>，复制行<br><code>Ctrl+/</code>或<code>Ctrl+Shift+/</code>，注释（//或者/**/）<br><code>Ctrl+J</code>，自动代码（例如：serr）<br><code>Ctrl+Alt+J</code>，用动态模板环绕<br><code>Ctrl+H</code>，显示类结构图（类的继承层次）<br><code>Ctrl+Q</code>，显示注释文档<br><code>Alt+F1</code>，查找代码所在位置<br><code>Alt+1</code>，快速打开或隐藏工程面板<br><code>Ctrl+Alt+left/right</code>，返回至上次浏览的位置<br><code>Alt+left/right</code>，切换代码视图<br><code>Alt+Up/Down</code>，在方法间快速移动定位<br><code>Ctrl+Shift+Up/Down</code>，向上/下移动语句<br><code>F2</code> 或 <code>Shift+F2</code>，高亮错误或警告快速定位<br><code>Tab</code>，代码标签输入完成后，按 Tab，生成代码<br><code>Ctrl+Shift+F7</code>，高亮显示所有该文本，按 <code>Esc</code> 高亮消失<br><code>Alt+F3</code>，逐个往下查找相同文本，并高亮显示<br><code>Ctrl+Up/Down</code>，光标中转到第一行或最后一行下<br><code>Ctrl+B/Ctrl+Click</code>，快速打开光标处的类或方法（跳转到定义处）<br><code>Ctrl+Alt+B</code>，跳转到方法实现处<br><code>Ctrl+Shift+Backspace</code>，跳转到上次编辑的地方<br><code>Ctrl+O</code>，重写方法<br><code>Ctrl+Alt+Space</code>，类名自动完成<br><code>Ctrl+Alt+Up/Down</code>，快速跳转搜索结果<br><code>Ctrl+Shift+J</code>，整合两行<br><code>Alt+F8</code>，计算变量值<br><code>Ctrl+Shift+V</code>，可以将最近使用的剪贴板内容选择插入到文本<br><code>Ctrl+Alt+Shift+V</code>，简单粘贴<br><code>Shift+Esc</code>，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口<br><code>F12</code>，把焦点从编辑器移到最近使用的工具窗口<br><code>Shift+F1</code>，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器<br><code>Ctrl+W</code>，可以选择单词继而语句继而行继而函数<br><code>Ctrl+Shift+W</code>，取消选择光标所在词<br><code>Alt+F7</code>，查找整个工程中使用地某一个类、方法或者变量的位置<br><code>Ctrl+I</code>，实现方法<br><code>Ctrl+Shift+U</code>，大小写转化<br><code>Ctrl+Y</code>，删除当前行</p><p><code>Shift+Enter</code>，向下插入新行<br>psvm/sout，main/System.out.println();<br><code>Ctrl+J</code>，查看更多<br><code>Ctrl+Shift+F</code>，全局查找<br><code>Ctrl+F</code>，查找<br><code>Shift+F3</code>，向上查找<br><code>F3</code>，向下查找<br><code>Ctrl+Shift+S</code>，高级搜索<br><code>Ctrl+U</code>，转到父类<br><code>Ctrl+Alt+S</code>，打开设置对话框<br><code>Alt+Shift+Inert</code>，开启/关闭列选择模式<br><code>Ctrl+Alt+Shift+S</code>，打开当前项目/模块属性<br><code>Ctrl+G</code>，定位行<br><code>Alt+Home</code>，跳转到导航栏<br><code>Ctrl+Enter</code>，上插一行<br><code>Ctrl+Backspace</code>，按单词删除<br><code>Ctrl+"+/-"</code>，当前方法展开、折叠<br><code>Ctrl+Shift+"+/-"</code>，全部展开、折叠</p><h2 id="调试、编译"><a href="#调试、编译" class="headerlink" title="调试、编译"></a>调试、编译</h2><p><code>Ctrl+F2</code>，停止<br><code>Alt+Shift+F9</code>，选择 Debug<br><code>Alt+Shift+F10</code>，选择 Run<br><code>Ctrl+Shift+F9</code>，编译<br><code>Ctrl+Shift+F10</code>，运行<br><code>Ctrl+Shift+F8</code>，查看断点<br><code>F8</code>，步过<br><code>F7</code>，步入<br><code>Shift+F7</code>，智能步入<br><code>Shift+F8</code>，步出<br><code>Alt+Shift+F8</code>，强制步过<br><code>Alt+Shift+F7</code>，强制步入<br><code>Alt+F9</code>，运行至光标处<br><code>Ctrl+Alt+F9</code>，强制运行至光标处<br><code>F9</code>，恢复程序<br><code>Alt+F10</code>，定位到断点<br><code>Ctrl+F8</code>，切换行断点<br><code>Ctrl+F9</code>，生成项目<br><code>Alt+1</code>，项目<br><code>Alt+2</code>，收藏<br><code>Alt+6</code>，TODO<br><code>Alt+7</code>，结构<br><code>Ctrl+Shift+C</code>，复制路径<br><code>Ctrl+Alt+Shift+C</code>，复制引用，必须选择类名<br><code>Ctrl+Alt+Y</code>，同步<br><code>Ctrl+~</code>，快速切换方案（界面外观、代码风格、快捷键映射等菜单）<br><code>Shift+F12</code>，还原默认布局<br><code>Ctrl+Shift+F12</code>，隐藏/恢复所有窗口<br><code>Ctrl+F4</code>，关闭<br><code>Ctrl+Shift+F4</code>，关闭活动选项卡<br><code>Ctrl+Tab</code>，转到下一个拆分器<br><code>Ctrl+Shift+Tab</code>，转到上一个拆分器</p><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p><code>Ctrl+Alt+Shift+T</code>，弹出重构菜单<br><code>Shift+F6</code>，重命名<br><code>F6</code>，移动<br><code>F5</code>，复制<br><code>Alt+Delete</code>，安全删除<br><code>Ctrl+Alt+N</code>，内联</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><code>Ctrl+F</code>，查找<br><code>Ctrl+R</code>，替换<br><code>F3</code>，查找下一个<br><code>Shift+F3</code>，查找上一个<br><code>Ctrl+Shift+F</code>，在路径中查找<br><code>Ctrl+Shift+R</code>，在路径中替换<br><code>Ctrl+Shift+S</code>，搜索结构<br><code>Ctrl+Shift+M</code>，替换结构<br><code>Alt+F7</code>，查找用法<br><code>Ctrl+Alt+F7</code>，显示用法<br><code>Ctrl+F7</code>，在文件中查找用法<br><code>Ctrl+Shift+F7</code>，在文件中高亮显示用法</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IDEA-常用快捷键列表&quot;&gt;&lt;a href=&quot;#IDEA-常用快捷键列表&quot; class=&quot;headerlink&quot; title=&quot;IDEA 常用快捷键列表&quot;&gt;&lt;/a&gt;IDEA 常用快捷键列表&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="IDEA" scheme="https://melodyjerry.github.io/blog/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat启动时中文乱码的问题</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/19/Tomcat%E5%90%AF%E5%8A%A8%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/19/Tomcat启动时中文乱码的问题/</id>
    <published>2020-02-19T08:01:00.000Z</published>
    <updated>2020-02-20T09:39:51.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Tomcat启动时中文乱码的问题</p><p><img src="https://s2.ax1x.com/2020/02/19/3E39nx.png" alt=""></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>修改<code>conf</code>文件夹下的<code>logging.properties</code>文件</p><p>第47行代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.logging.ConsoleHandler.encoding = UTF-8</span><br></pre></td></tr></tbody></table></figure><p>改为</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.logging.ConsoleHandler.encoding = GBK</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>如果IDEA中使用Tomcat也乱码，可以额为参考此方法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;Tomcat启动时中文乱码的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/19/3E39nx.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h1&gt;&lt;p&gt;修改&lt;code&gt;conf&lt;/code&gt;文件夹下的&lt;code&gt;logging.properties&lt;/code&gt;文件&lt;/p&gt;
&lt;p&gt;第47行代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.util.logging.ConsoleHandler.encoding = UTF-8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;改为&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.util.logging.ConsoleHandler.encoding = GBK&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="IDEA" scheme="https://melodyjerry.github.io/blog/tags/IDEA/"/>
    
      <category term="Tomcat" scheme="https://melodyjerry.github.io/blog/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat：Web服务器软件</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/19/Tomcat%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AF%E4%BB%B6/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/19/Tomcat：服务器软件/</id>
    <published>2020-02-19T07:25:00.000Z</published>
    <updated>2020-02-21T14:06:15.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat：web服务器软件"><a href="#Tomcat：web服务器软件" class="headerlink" title="Tomcat：web服务器软件"></a>Tomcat：web服务器软件</h1><blockquote><p>Tomcat 是用<strong>纯Java语言编写</strong>的</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下载 <a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-80.cgi</a></p><p>免安装，解压压缩包即可。</p><blockquote><p>注意：安装目录建议不要有中文和空格</p></blockquote><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="https://s2.ax1x.com/2020/02/19/3E1r6I.png" alt="目录结构"></p><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><ul><li><p>Windows：运行<code>./bin/startup.bat</code></p></li><li><p>Linux：运行<code>./bin/startup.sh</code></p></li></ul><p><img src="https://s2.ax1x.com/2020/02/19/3E39nx.png" alt="Windows10下运行"></p><a id="more"></a><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><h3 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h3><p>详细见博文 【<a href="https://melodyjerry.gitee.io/blog/2020/02/19/Tomcat%E5%90%AF%E5%8A%A8%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">Tomcat启动时中文乱码的问题</a>】</p><h3 id="黑窗口一闪而过"><a href="#黑窗口一闪而过" class="headerlink" title="黑窗口一闪而过"></a>黑窗口一闪而过</h3><ul><li>原因： 没有正确配置JAVA_HOME环境变量</li><li>解决方案：正确配置JAVA_HOME环境变量</li></ul><h3 id="启动报错"><a href="#启动报错" class="headerlink" title="启动报错"></a>启动报错</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><ul><li>找到占用的端口号，并且找到对应的进程，杀死该进程</li></ul><ul><li>cmd&gt;<code>netstat -ano</code> &gt; 查看进程id（PID）&gt;任务管理器（查看-选择列-PID）&gt;结束进程（对应PID） </li></ul><h4 id="温柔"><a href="#温柔" class="headerlink" title="温柔"></a>温柔</h4><ul><li>修改自身的端口号</li></ul><ul><li><p><code>./conf/server.xml</code></p></li><li><p>`&lt;Connector port=”8888” protocol=”HTTP/1.1”</p><pre><code>connectionTimeout="20000"redirectPort="8445" /&gt;`</code></pre></li><li><p>一般会将tomcat的默认端口号修改为80。<strong>80端口号是http协议的默认端口号。</strong></p><ul><li>好处：在访问时，就不用输入端口号</li></ul></li><li><p>该方式可实现<strong>单机多Tomcat并存</strong></p></li></ul><h1 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h1><p>浏览器输入：</p><ul><li>访问自己：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> </li><li>访问别人：http://别人的ip:8080 </li></ul><p><img src="https://s2.ax1x.com/2020/02/19/3E3PHK.png" alt="localhost"></p><h2 id="查看IP地址"><a href="#查看IP地址" class="headerlink" title="查看IP地址"></a>查看IP地址</h2><ul><li>cmd&gt;$ <code>ipconfig</code> &gt;IPv4地址</li></ul><h1 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h1><ul><li>针对服务器本身，推荐使用<strong>“正常关闭”</strong></li><li>但是后期是<strong>配合IDEA使用Tomcat</strong></li></ul><h2 id="正常关闭"><a href="#正常关闭" class="headerlink" title="正常关闭"></a>正常关闭</h2><ul><li>有两种方式：</li></ul><ol><li>手动运行<code>./bin/shutdown.bat</code></li><li>在Tomcat窗口，按<code>Ctrl+C</code></li></ol><h2 id="强制关闭"><a href="#强制关闭" class="headerlink" title="强制关闭"></a>强制关闭</h2><ul><li>点击<strong>Tomcat窗口右上角的X</strong></li></ul><h1 id="部署-配置项目的方式"><a href="#部署-配置项目的方式" class="headerlink" title="部署/配置项目的方式"></a>部署/配置项目的方式</h1><ul><li>有三种方式：</li></ul><ol><li>直接将项目放到<code>webapps</code>目录下即可</li><li>配置<code>conf/server.xml</code>文件</li><li>在<code>conf\Catalina\localhost</code>创建任意名称的xml文件</li></ol><h2 id="虚拟目录"><a href="#虚拟目录" class="headerlink" title="虚拟目录"></a>虚拟目录</h2><p>浏览器通过<code>http://localhost:8080</code>访问，需要访问到某一个项目时，需要在其随后加上<code>/目录或路径</code>（称作<strong>虚拟目录</strong>）</p><h2 id="直接将项目放到webapps目录下即可"><a href="#直接将项目放到webapps目录下即可" class="headerlink" title="直接将项目放到webapps目录下即可"></a>直接将项目放到webapps目录下即可</h2><ul><li><code>/项目(文件夹)名”</code>：项目的访问路径，也称<strong>虚拟目录</strong></li></ul><p><img src="https://s2.ax1x.com/2020/02/19/3EtemR.png" alt=""></p><h3 id="简化部署"><a href="#简化部署" class="headerlink" title="简化部署"></a>简化部署</h3><ul><li>第一种方式还有一种简化部署的形式</li></ul><ul><li>将项目打成一个war包，再将war包放置到webapps目录下</li></ul><ul><li>war 包会自动解压缩</li><li>若删除项目，删除对应war包即可。自动会删除对应生产的项目文件夹。</li></ul><p><img src="https://s2.ax1x.com/2020/02/19/3ENRrd.png" alt="war包自动解压"></p><h2 id="配置conf-server-xml文件"><a href="#配置conf-server-xml文件" class="headerlink" title="配置conf/server.xml文件"></a>配置conf/server.xml文件</h2><ul><li>在<code>&lt;Host&gt;</code>标签体中配置</li><li><code>&lt;Context docBase="D:\hello" path="/hehe" /&gt;</code></li><li><strong>docBase</strong>：项目存放的路径</li><li><strong>path</strong>：虚拟目录</li><li>缺点：<strong>需要修改配置文件，不太安全</strong></li></ul><h2 id="在conf-Catalina-localhost创建任意名称的xml文件"><a href="#在conf-Catalina-localhost创建任意名称的xml文件" class="headerlink" title="在conf\Catalina\localhost创建任意名称的xml文件"></a>在conf\Catalina\localhost创建任意名称的xml文件</h2><ul><li>在文件中编写</li><li><code>&lt;Context docBase="D:\hello" /&gt;</code></li><li>虚拟目录：xml文件的名称。比如<code>localhost:8080/xml文件/index.html</code></li><li>热部署方式：删除或修改文件名后，不需要重启服务。</li></ul><h1 id="部署项目的类型"><a href="#部署项目的类型" class="headerlink" title="部署项目的类型"></a>部署项目的类型</h1><ul><li>静态项目</li><li>动态项目</li></ul><h2 id="静态项目"><a href="#静态项目" class="headerlink" title="静态项目"></a>静态项目</h2><ul><li>只能存放静态资源</li><li>HTML、CSS、JavaScript、图片、音频、视频、文本等等</li></ul><h2 id="动态项目"><a href="#动态项目" class="headerlink" title="动态项目"></a>动态项目</h2><ul><li>不仅可存放静态资源，还有动态资源</li></ul><h3 id="目录结构-Java动态项目"><a href="#目录结构-Java动态项目" class="headerlink" title="目录结构(Java动态项目)"></a>目录结构(Java动态项目)</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">项目根目录</span><br><span class="line">  ﹂-WEB-INF目录</span><br><span class="line">  ﹂web.xml：web项目的核心配置文件</span><br><span class="line">  ﹂classes目录：放置字节码文件的目录</span><br><span class="line">  ﹂lib目录：放置依赖的jar包</span><br></pre></td></tr></tbody></table></figure><p>比如：</p><p><img src="https://s2.ax1x.com/2020/02/19/3Eg8mV.png" alt=""></p><h1 id="IDEA中配合使用Tomcat"><a href="#IDEA中配合使用Tomcat" class="headerlink" title="IDEA中配合使用Tomcat"></a>IDEA中配合使用Tomcat</h1><h2 id="集成到IDEA中"><a href="#集成到IDEA中" class="headerlink" title="集成到IDEA中"></a>集成到IDEA中</h2><p><img src="https://s2.ax1x.com/2020/02/19/3EDly8.png" alt=""></p><p><img src="https://s2.ax1x.com/2020/02/19/3EynY9.png" alt=""></p><p><img src="https://s2.ax1x.com/2020/02/19/3EybtJ.png" alt=""></p><h2 id="新建Web项目"><a href="#新建Web项目" class="headerlink" title="新建Web项目"></a>新建Web项目</h2><p><img src="https://s2.ax1x.com/2020/02/19/3Ec7W9.png" alt="勾选Web Application"></p><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p><img src="https://i.loli.net/2020/02/19/95CgPRtdiLbD4sX.gif" alt="run"></p><p>注意：</p><p><img src="https://s2.ax1x.com/2020/02/19/3EgBOx.png" alt="默认war打包部署"></p><blockquote><ol><li><p>默认war打包部署</p></li><li><p><code>/</code> ：默认虚拟目录设置<strong>当前项目为根目录</strong></p></li></ol></blockquote><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><ul><li>重新部署项目时，不再重启Tomcat服务器</li></ul><p><img src="https://s2.ax1x.com/2020/02/19/3EW4XR.png" alt="免重启服务器"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Tomcat：web服务器软件&quot;&gt;&lt;a href=&quot;#Tomcat：web服务器软件&quot; class=&quot;headerlink&quot; title=&quot;Tomcat：web服务器软件&quot;&gt;&lt;/a&gt;Tomcat：web服务器软件&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Tomcat 是用&lt;strong&gt;纯Java语言编写&lt;/strong&gt;的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;下载 &lt;a href=&quot;https://tomcat.apache.org/download-80.cgi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tomcat.apache.org/download-80.cgi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;免安装，解压压缩包即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：安装目录建议不要有中文和空格&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/19/3E1r6I.png&quot; alt=&quot;目录结构&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;启动&quot;&gt;&lt;a href=&quot;#启动&quot; class=&quot;headerlink&quot; title=&quot;启动&quot;&gt;&lt;/a&gt;启动&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Windows：运行&lt;code&gt;./bin/startup.bat&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Linux：运行&lt;code&gt;./bin/startup.sh&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/19/3E39nx.png&quot; alt=&quot;Windows10下运行&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JavaWeb" scheme="https://melodyjerry.github.io/blog/tags/JavaWeb/"/>
    
      <category term="笔记" scheme="https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Tomcat" scheme="https://melodyjerry.github.io/blog/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Github提速</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/18/Github%E6%8F%90%E9%80%9F/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/18/Github提速/</id>
    <published>2020-02-18T09:00:00.000Z</published>
    <updated>2020-02-19T10:46:27.721Z</updated>
    
    <content type="html"><![CDATA[<p>经常要clone github中的一些项目，无奈如果不爬梯子的话速度实在是龟速，经常1k/s，于是献上改Hosts大法。</p><p>第一步：打开<a href="https://link.zhihu.com/?target=http%3A//codeload.github.com.ipaddress.com/%23ipinfo">http://codeload.github.com.ipaddress.com/#ipinfo</a> 找到你浏览器上实际显示的IP地址， 例图 ：</p><p><img src="https://s2.ax1x.com/2020/02/19/3VCXo6.png" alt="3VCXo6.png"></p><p>第二步：按win+r唤起运行框，输入cmd，然后再依次ping一下上面的地址</p><p><img src="https://s2.ax1x.com/2020/02/19/3VPJYT.png" alt="3VPJYT.png"></p><p>第三步：打开你<code>C:\Windows\System32\drivers\etc\hosts</code>文件，在文件末尾追加如下一行即可</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">140.82.113.9http://codeload.github.com</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><p>另外以下这些github hosts，可能对你所在地区来说不是最优版本，最优hosts的选择可以参考上面三个步骤</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># GitHub Start</span><br><span class="line">192.30.253.112 github.com</span><br><span class="line">192.30.253.119 gist.github.com</span><br><span class="line">151.101.100.133 assets-cdn.github.com</span><br><span class="line">151.101.100.133 raw.githubusercontent.com</span><br><span class="line">151.101.100.133 gist.githubusercontent.com</span><br><span class="line">151.101.100.133 cloud.githubusercontent.com</span><br><span class="line">151.101.100.133 camo.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars2.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars3.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars4.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars5.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars6.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars7.githubusercontent.com</span><br><span class="line">151.101.100.133 avatars8.githubusercontent.com</span><br><span class="line"># GitHub End</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常要clone github中的一些项目，无奈如果不爬梯子的话速度实在是龟速，经常1k/s，于是献上改Hosts大法。&lt;/p&gt;
&lt;p&gt;第一步：打开&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//codeload.github.com.ipaddress.com/%23ipinfo&quot;&gt;http://codeload.github.com.ipaddress.com/#ipinfo&lt;/a&gt; 找到你浏览器上实际显示的IP地址， 例图 ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/19/3VCXo6.png&quot; alt=&quot;3VCXo6.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;第二步：按win+r唤起运行框，输入cmd，然后再依次ping一下上面的地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/19/3VPJYT.png&quot; alt=&quot;3VPJYT.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;第三步：打开你&lt;code&gt;C:\Windows\System32\drivers\etc\hosts&lt;/code&gt;文件，在文件末尾追加如下一行即可&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;140.82.113.9	http://codeload.github.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Github" scheme="https://melodyjerry.github.io/blog/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：让页面元素动起来</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/18/JavaScript%EF%BC%9A%E8%AE%A9%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E5%8A%A8%E8%B5%B7%E6%9D%A5/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/18/JavaScript：让页面元素动起来/</id>
    <published>2020-02-18T01:01:00.000Z</published>
    <updated>2020-02-18T14:50:39.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>一门<strong>客户端脚本语言</strong></p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎</li><li>脚本语言：<strong>不需要编译</strong>，直接就可以被浏览器解析执行了</li></ul><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul><li>可以来<strong>增强用户和html页面的交互过程</strong>，可以来控制html元素，让页面有一些动态的效果，<strong>增强用户的体验</strong>。</li></ul><a id="more"></a><h1 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h1><ol><li>1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C–    ，后来更名为：ScriptEase</li><li>1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript</li><li>1996年，微软抄袭JavaScript开发出JScript语言</li><li>1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。</li></ol><h1 id="JavaScript-ECMAScript-JavaScript自己特有的东西-BOM-DOM"><a href="#JavaScript-ECMAScript-JavaScript自己特有的东西-BOM-DOM" class="headerlink" title="JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)"></a>JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)</h1><h1 id="ECMAScript：客户端脚本语言的标准"><a href="#ECMAScript：客户端脚本语言的标准" class="headerlink" title="ECMAScript：客户端脚本语言的标准"></a>ECMAScript：客户端脚本语言的标准</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="与html结合方式"><a href="#与html结合方式" class="headerlink" title="与html结合方式"></a>与html结合方式</h3><h4 id="内部JS"><a href="#内部JS" class="headerlink" title="内部JS"></a>内部JS</h4><ul><li>定义<code>&lt;script&gt;</code>，标签体内容就是js代码</li></ul><h4 id="外部JS"><a href="#外部JS" class="headerlink" title="外部JS"></a>外部JS</h4><ul><li>定义<code>&lt;script&gt;</code>，通过src属性引入外部的js文件</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li><code>&lt;script&gt;</code>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。</li><li><code>&lt;script&gt;</code>可以定义多个。</li></ol><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol><li>单行注释：<code>// 注释内容</code></li><li>多行注释：<code>/* 注释内容 */</code></li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>详细见 <a href="https://www.w3school.com.cn/js/js_datatypes.asp" target="_blank" rel="noopener">JavaScript 数据类型</a></p><h4 id="原始数据类型-基本数据类型"><a href="#原始数据类型-基本数据类型" class="headerlink" title="原始数据类型(基本数据类型)"></a>原始数据类型(基本数据类型)</h4><ol><li><code>number</code>：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)</li><li><code>string</code>：字符串。 字符串  “abc” “a” ‘abc’</li><li><code>boolean</code>：布尔。 true和false</li><li><code>null</code>：一个对象为空的占位符</li><li><code>undefined</code>：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined</li></ol><blockquote><p>Undefined 与 Null 的区别</p><p>Undefined 与 Null 的值相等，但类型不相等：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined // undefined</span><br><span class="line"> typeof null // object</span><br><span class="line">null === undefined// false</span><br><span class="line">null == undefined // true</span><br></pre></td></tr></tbody></table></figure></blockquote><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ul><li><code>对象（object）</code></li><li><code>数组（array）</code></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>变量：一小块存储数据的内存空间</li><li>Java语言是强类型语言，而JavaScript是弱类型语言。</li></ul><blockquote><p>强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</p><p>弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。</p></blockquote><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 = 初始化值;</span><br></pre></td></tr></tbody></table></figure><h4 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h4><ul><li>获取变量的类型</li></ul><blockquote><p>注：null运算后得到的是object</p></blockquote><p>更多见 <a href="https://www.cnblogs.com/zhuyeshen/p/10997779.html" target="_blank" rel="noopener">《JavaScript中typeof知多少？》</a></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换。</li><li>其他类型转number：<ul><li>string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）</li><li>boolean转number：true转为1，false转为0</li></ul></li></ul><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>算术运算符对数值（文字或变量）执行算术运算。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加法</td></tr><tr><td align="left">-</td><td align="left">减法</td></tr><tr><td align="left">*</td><td align="left">乘法</td></tr><tr><td align="left">**</td><td align="left">幂（将第一个操作数提升到第二个操作数的幂。<a href="https://www.w3school.com.cn/js/js_es6.asp" target="_blank" rel="noopener">ES2016</a>）</td></tr><tr><td align="left">/</td><td align="left">除法</td></tr><tr><td align="left">%</td><td align="left">系数（返回除法的余数）</td></tr><tr><td align="left">++</td><td align="left">递增</td></tr><tr><td align="left">–</td><td align="left">递减</td></tr></tbody></table><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>赋值运算符向 JavaScript 变量赋值。</p><table><thead><tr><th align="left">运算符</th><th>特殊说明</th><th align="left">例子</th><th align="left">等同于</th></tr></thead><tbody><tr><td align="left">=</td><td></td><td align="left">x = y</td><td align="left">x = y</td></tr><tr><td align="left">+=</td><td></td><td align="left">x += y</td><td align="left">x = x + y</td></tr><tr><td align="left">-=</td><td></td><td align="left">x -= y</td><td align="left">x = x - y</td></tr><tr><td align="left">*=</td><td></td><td align="left">x *= y</td><td align="left">x = x * y</td></tr><tr><td align="left">/=</td><td></td><td align="left">x /= y</td><td align="left">x = x / y</td></tr><tr><td align="left">%=</td><td>把余数赋值给变量</td><td align="left">x %= y</td><td align="left">x = x % y</td></tr><tr><td align="left">&lt;&lt;=</td><td></td><td align="left">x &lt;&lt;= y</td><td align="left">x = x &lt;&lt; y</td></tr><tr><td align="left">&gt;&gt;=</td><td></td><td align="left">x &gt;&gt;= y</td><td align="left">x = x &gt;&gt; y</td></tr><tr><td align="left">&gt;&gt;&gt;=</td><td></td><td align="left">x &gt;&gt;&gt;= y</td><td align="left">x = x &gt;&gt;&gt; y</td></tr><tr><td align="left">&amp;=</td><td></td><td align="left">x &amp;= y</td><td align="left">x = x &amp; y</td></tr><tr><td align="left">^=</td><td></td><td align="left">x ^= y</td><td align="left">x = x ^ y</td></tr><tr><td align="left">|=</td><td></td><td align="left">x |= y</td><td align="left">x = x | y</td></tr><tr><td align="left">**=</td><td></td><td align="left">x **= y</td><td align="left">x = x ** y</td></tr></tbody></table><p><strong>提示：***</strong>*=** 运算符属于 ECMAScript 2016 proposal (ES7) 的实验部分。它的跨浏览器表现并不稳定。请勿使用。</p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>比较运算符在逻辑语句中使用，以判定变量或值是否相等。</p><p>我们给定 x = 5，下表中解释了比较运算符：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">比较</th><th align="left">返回</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">等于</td><td align="left">x == 8</td><td align="left">false</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">x == 5</td><td align="left">true</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">x == “5”</td><td align="left">true</td></tr><tr><td align="left">===</td><td align="left">值相等并且类型相等</td><td align="left">x === 5</td><td align="left">true</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">x === “5”</td><td align="left">false</td></tr><tr><td align="left">!=</td><td align="left">不相等</td><td align="left">x != 8</td><td align="left">true</td></tr><tr><td align="left">!==</td><td align="left">值不相等或类型不相等</td><td align="left">x !== 5</td><td align="left">false</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">x !== “5”</td><td align="left">true</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">x !== 8</td><td align="left">true</td></tr><tr><td align="left">&gt;</td><td align="left">大于</td><td align="left">x &gt; 8</td><td align="left">false</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td><td align="left">x &lt; 8</td><td align="left">true</td></tr><tr><td align="left">&gt;=</td><td align="left">大于或等于</td><td align="left">x &gt;= 8</td><td align="left">false</td></tr><tr><td align="left">&lt;=</td><td align="left">小于或等于</td><td align="left">x &lt;= 8</td><td align="left">true</td></tr></tbody></table><p>比较方式</p><ol><li>类型相同：直接比较<ul><li>字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。</li></ul></li><li>类型不同：先进行类型转换，再比较<ul><li>===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false</li></ul></li></ol><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算符用于判定变量或值之间的逻辑。</p><p>我们给定 x = 6 且 y = 3，下表解释了逻辑运算符：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">与</td><td align="left">(x &lt; 10 &amp;&amp; y &gt; 1) 为 true</td></tr><tr><td align="left">||</td><td align="left">或</td><td align="left">(x == 5 || y == 5) 为 false</td></tr><tr><td align="left">!</td><td align="left">非</td><td align="left">!(x == y) 为 true</td></tr></tbody></table><ul><li>其他类型转boolean：</li></ul><ol><li>number：0或NaN为假，其他为真</li><li>string：除了空字符串(“”)，其他都是true</li><li>null&amp;undefined：都是false</li><li>对象：所有对象都为true</li></ol><h4 id="条件（三元）运算符"><a href="#条件（三元）运算符" class="headerlink" title="条件（三元）运算符"></a>条件（三元）运算符</h4><p>语法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名=(表达式)? 值1:值2;</span><br></pre></td></tr></tbody></table></figure><ul><li>判断表达式的值，如果是true则取值1，如果是false则取值2；</li></ul><p>示例：    </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var voteable = (age &lt; 18) ? "太年轻":"足够成熟";</span><br></pre></td></tr></tbody></table></figure><h4 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h4><p>+ 运算符也可用于对字符串进行相加（concatenate，级联）。<br>+= 赋值运算符也可用于相加（级联）字符串：</p><p>实例：<br>给定 text1 = “Good “, text2 = “Morning”, 及 text3 = “”, 下面的表格解释了字符串运算符的使用：</p><table><thead><tr><th align="left">运算符</th><th align="left">例子</th><th align="left">text1</th><th align="left">text2</th><th align="left">text3或text1</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">text3 = text1 + text2</td><td align="left">“Good “</td><td align="left">“Morning”</td><td align="left">“Good Morning”</td></tr><tr><td align="left">+=</td><td align="left">text1 += text2</td><td align="left">“Hello”</td><td align="left">“Kitty！”</td><td align="left">“Hello Kitty!”</td></tr></tbody></table><blockquote><p><strong>字符串+数字=字符串</strong></p><p>相加两个数字，将返回和。但对一个数字和一个字符串相加将返回一个<strong>字符串</strong>。</p></blockquote><h4 id="类型运算符"><a href="#类型运算符" class="headerlink" title="类型运算符"></a>类型运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">typeof</td><td align="left">返回变量的类型。</td></tr><tr><td align="left">instanceof</td><td align="left">返回 true，如果对象是对象类型的实例。</td></tr></tbody></table><h5 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h5><p>您可以使用 typeof 运算符来确定 JavaScript 变量的数据类型。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typeof "Bill"                 // 返回 "string"</span><br><span class="line">typeof 3.14                   // 返回 "number"</span><br><span class="line">typeof NaN                    // 返回 "number"</span><br><span class="line">typeof false                  // 返回 "boolean"</span><br><span class="line">typeof [1,2,3,4]              // 返回 "object"</span><br><span class="line">typeof {name:'Bill', age:62}  // 返回 "object"</span><br><span class="line">typeof new Date()             // 返回 "object"</span><br><span class="line">typeof function () {}         // 返回 "function"</span><br><span class="line">typeof myCar                  // 返回 "undefined" *</span><br><span class="line">typeof null                   // 返回 "object"</span><br></pre></td></tr></tbody></table></figure><p><strong>请注意：</strong></p><ul><li>NaN 的数据类型是数值</li><li>数组的数据类型是对象</li><li>日期的数据类型是对象</li><li>null 的数据类型是对象</li><li>未定义变量的数据类型是 <em>undefined</em></li><li>尚未赋值的变量的数据类型也是 <em>undefined</em></li></ul><p>无法使用 typeof 去判断 JavaScript 对象是否是数组（或日期）。</p><p><strong>typeof 的数据类型：</strong></p><p>typeof 运算符不是变量。它属于运算符。运算符（比如 + - * /）没有数据类型。</p><p>但是，typeof 始终会<em>返回字符串</em>（包含运算数的类型）。</p><blockquote><p>另外涉及到<strong>Number() 转换数值，String() 转换字符串，Boolean() 转换布尔值。</strong></p></blockquote><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符处理 32 位数。</p><p>该运算中的任何数值运算数都会被转换为 32 位的数。结果会被转换回 JavaScript 数。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">例子</th><th align="left">等同于</th><th align="left">结果</th><th align="left">十进制</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">与 (and)</td><td align="left">5 &amp; 1</td><td align="left">0101 &amp; 0001</td><td align="left">0001</td><td align="left">1</td></tr><tr><td align="left">|</td><td align="left">或 (or)</td><td align="left">5 | 1</td><td align="left">0101 | 0001</td><td align="left">0101</td><td align="left">5</td></tr><tr><td align="left">~</td><td align="left">非 (not)</td><td align="left">~ 5</td><td align="left">~0101</td><td align="left">1010</td><td align="left">10</td></tr><tr><td align="left">^</td><td align="left">异或 (xor)</td><td align="left">5 ^ 1</td><td align="left">0101 ^ 0001</td><td align="left">0100</td><td align="left">4</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">零填充左位移</td><td align="left">5 &lt;&lt; 1</td><td align="left">0101 &lt;&lt; 1</td><td align="left">1010</td><td align="left">10</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">有符号右位移</td><td align="left">5 &gt;&gt; 1</td><td align="left">0101 &gt;&gt; 1</td><td align="left">0010</td><td align="left">2</td></tr><tr><td align="left">&gt;&gt;&gt;</td><td align="left">零填充右位移</td><td align="left">5 &gt;&gt;&gt; 1</td><td align="left">0101 &gt;&gt;&gt; 1</td><td align="left">0010</td><td align="left">2</td></tr></tbody></table><blockquote><p>上例使用 4 位无符号的例子。但是 JavaScript 使用 32 位有符号数。<br>因此，在 JavaScript 中，~ 5 不会返回 10，而是返回 -6。~00000000000000000000000000000101 将返回 11111111111111111111111111111010。</p></blockquote><blockquote><p>JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。<br>在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数。<br>执行按位操作后，结果将转换回 64 位 JavaScript 数。</p></blockquote><h4 id="运算符优先级值"><a href="#运算符优先级值" class="headerlink" title="运算符优先级值"></a>运算符优先级值</h4><table><thead><tr><th align="left">值</th><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">20</td><td align="left">( )</td><td align="left">表达式分组</td><td align="left">(3 + 4)</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">19</td><td align="left">.</td><td align="left">成员</td><td align="left">person.name</td></tr><tr><td align="left">19</td><td align="left">[]</td><td align="left">成员</td><td align="left">person[“name”]</td></tr><tr><td align="left">19</td><td align="left">()</td><td align="left">函数调用</td><td align="left">myFunction()</td></tr><tr><td align="left">19</td><td align="left">new</td><td align="left">创建</td><td align="left">new Date()</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">17</td><td align="left">++</td><td align="left">后缀递增</td><td align="left">i++</td></tr><tr><td align="left">17</td><td align="left">–</td><td align="left">后缀递减</td><td align="left">i–</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">16</td><td align="left">++</td><td align="left">前缀递增</td><td align="left">++i</td></tr><tr><td align="left">16</td><td align="left">–</td><td align="left">前缀递减</td><td align="left">–i</td></tr><tr><td align="left">16</td><td align="left">!</td><td align="left">逻辑否</td><td align="left">!(x==y)</td></tr><tr><td align="left">16</td><td align="left">typeof</td><td align="left">类型</td><td align="left">typeof x</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">15</td><td align="left">**</td><td align="left">求幂 (ES7)</td><td align="left">10 ** 2</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">14</td><td align="left">*</td><td align="left">乘</td><td align="left">10 * 5</td></tr><tr><td align="left">14</td><td align="left">/</td><td align="left">除</td><td align="left">10 / 5</td></tr><tr><td align="left">14</td><td align="left">%</td><td align="left">模数除法</td><td align="left">10 % 5</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">13</td><td align="left">+</td><td align="left">加</td><td align="left">10 + 5</td></tr><tr><td align="left">13</td><td align="left">-</td><td align="left">减</td><td align="left">10 - 5</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">12</td><td align="left">&lt;&lt;</td><td align="left">左位移</td><td align="left">x &lt;&lt; 2</td></tr><tr><td align="left">12</td><td align="left">&gt;&gt;</td><td align="left">右位移</td><td align="left">x &gt;&gt; 2</td></tr><tr><td align="left">12</td><td align="left">&gt;&gt;&gt;</td><td align="left">右位移（无符号）</td><td align="left">x &gt;&gt;&gt; 2</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">11</td><td align="left">&lt;</td><td align="left">小于</td><td align="left">x &lt; y</td></tr><tr><td align="left">11</td><td align="left">&lt;=</td><td align="left">小于或等于</td><td align="left">x &lt;= y</td></tr><tr><td align="left">11</td><td align="left">&gt;</td><td align="left">大于</td><td align="left">x &gt; y</td></tr><tr><td align="left">11</td><td align="left">&gt;=</td><td align="left">大于或等于</td><td align="left">x &gt;= y</td></tr><tr><td align="left">11</td><td align="left">in</td><td align="left">对象中的属性</td><td align="left">“PI” in Math</td></tr><tr><td align="left">11</td><td align="left">instanceof</td><td align="left">对象的实例</td><td align="left">instanceof Array</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">10</td><td align="left">==</td><td align="left">相等</td><td align="left">x == y</td></tr><tr><td align="left">10</td><td align="left">===</td><td align="left">严格相等</td><td align="left">x === y</td></tr><tr><td align="left">10</td><td align="left">!=</td><td align="left">不相等</td><td align="left">x != y</td></tr><tr><td align="left">10</td><td align="left">!==</td><td align="left">严格不相等</td><td align="left">x !== y</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">&amp;</td><td align="left">按位与</td><td align="left">x &amp; y</td></tr><tr><td align="left">8</td><td align="left">^</td><td align="left">按位 XOR</td><td align="left">x ^ y</td></tr><tr><td align="left">7</td><td align="left">|</td><td align="left">按位或</td><td align="left">x | y</td></tr><tr><td align="left">6</td><td align="left">&amp;&amp;</td><td align="left">逻辑与</td><td align="left">x &amp;&amp; y</td></tr><tr><td align="left">5</td><td align="left">||</td><td align="left">逻辑否</td><td align="left">x || y</td></tr><tr><td align="left">4</td><td align="left">? :</td><td align="left">条件</td><td align="left">? “Yes” : “No”</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">3</td><td align="left">=</td><td align="left">赋值</td><td align="left">x = y</td></tr><tr><td align="left">3</td><td align="left">+=</td><td align="left">赋值</td><td align="left">x += y</td></tr><tr><td align="left">3</td><td align="left">-=</td><td align="left">赋值</td><td align="left">x -= y</td></tr><tr><td align="left">3</td><td align="left">*=</td><td align="left">赋值</td><td align="left">x *= y</td></tr><tr><td align="left">3</td><td align="left">%=</td><td align="left">赋值</td><td align="left">x %= y</td></tr><tr><td align="left">3</td><td align="left">&lt;&lt;=</td><td align="left">赋值</td><td align="left">x &lt;&lt;= y</td></tr><tr><td align="left">3</td><td align="left">&gt;&gt;=</td><td align="left">赋值</td><td align="left">x &gt;&gt;= y</td></tr><tr><td align="left">3</td><td align="left">&gt;&gt;&gt;=</td><td align="left">赋值</td><td align="left">x &gt;&gt;&gt;= y</td></tr><tr><td align="left">3</td><td align="left">&amp;=</td><td align="left">赋值</td><td align="left">x &amp;= y</td></tr><tr><td align="left">3</td><td align="left">^=</td><td align="left">赋值</td><td align="left">x ^= y</td></tr><tr><td align="left">3</td><td align="left">|=</td><td align="left">赋值</td><td align="left">x |= y</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">2</td><td align="left">yield</td><td align="left">暂停函数</td><td align="left">yield x</td></tr><tr><td align="left">1</td><td align="left">,</td><td align="left">逗号</td><td align="left">7 , 8</td></tr></tbody></table><p><strong>注意：</strong>淡红色指示实验性或建议性的技术（ECMASScript 2016 或 ES7）</p><p><strong>提示：</strong>括号中的表达式会在值在表达式的其余部分中被使用之前进行完全计算。</p><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><ol><li><code>if...else...</code></li><li><code>switch</code>:<ul><li>在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)<ul><li>switch(变量):<ul><li>case 值:</li></ul></li></ul></li><li>在JS中,switch语句可以接受任意的原始数据类型</li></ul></li><li><code>while</code></li><li><code>for</code></li></ol><h3 id="JS特殊语法"><a href="#JS特殊语法" class="headerlink" title="JS特殊语法"></a>JS特殊语法</h3><ol><li><p>语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)</p></li><li><p>变量的定义使用var关键字，也可以不使用</p><ul><li>用： 定义的变量是局部变量</li><li>不用：定义的变量是全局变量(不建议)</li></ul></li></ol><h3 id="练习：99乘法表"><a href="#练习：99乘法表" class="headerlink" title="练习：99乘法表"></a>练习：99乘法表</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset="UTF-8"&gt;</span><br><span class="line">&lt;title&gt;99乘法表&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">td{</span><br><span class="line">border: 1px solid;</span><br><span class="line">}</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">document.write("&lt;table  align='center'&gt;");</span><br><span class="line">//1.完成基本的for循环嵌套，展示乘法表</span><br><span class="line">for (var i = 1; i &lt;= 9 ; i++) {</span><br><span class="line">document.write("&lt;tr&gt;");</span><br><span class="line">for (var j = 1; j &lt;=i ; j++) {</span><br><span class="line">document.write("&lt;td&gt;");</span><br><span class="line"></span><br><span class="line">//输出  1 * 1 = 1</span><br><span class="line">document.write(i + " * " + j + " = " + ( i*j) +"&amp;nbsp;&amp;nbsp;&amp;nbsp;");</span><br><span class="line"></span><br><span class="line">document.write("&lt;/td&gt;");</span><br><span class="line">}</span><br><span class="line">/*//输出换行</span><br><span class="line">document.write("&lt;br&gt;");*/</span><br><span class="line"></span><br><span class="line">document.write("&lt;/tr&gt;");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//2.完成表格嵌套</span><br><span class="line">document.write("&lt;/table&gt;");</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h2><h3 id="Function：函数-方法-对象"><a href="#Function：函数-方法-对象" class="headerlink" title="Function：函数(方法)对象"></a>Function：函数(方法)对象</h3><h4 id="创建格式"><a href="#创建格式" class="headerlink" title="创建格式"></a>创建格式</h4><ol><li><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 方法名称(形式参数列表){</span><br><span class="line">方法体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var 方法名 = function(形式参数列表){</span><br><span class="line">方法体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>建议不用</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fun = new Function(形式参数列表,方法体);  //忘掉吧</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li><code>length</code>：代表形参的个数</li></ul><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>方法定义是，形参的类型不用写,返回值类型也不写。</li><li>方法是一个对象，如果定义名称相同的方法，会覆盖</li><li>在JS中，方法的调用只与方法的名称有关，和参数列表无关</li><li>在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数</li></ol><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法名称(实际参数列表);</span><br><span class="line">&lt;!--</span><br><span class="line">比如：</span><br><span class="line">var x = myFunction(4, 3);        // 调用函数，返回值被赋值给 x</span><br><span class="line">--&gt;</span><br></pre></td></tr></tbody></table></figure><p>函数中的代码将在其他代码调用该函数时执行：</p><ul><li>当事件发生时（当用户点击按钮时）</li><li>当 JavaScript 代码调用时</li><li>自动的（自调用）</li></ul><h4 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h4><p>当 JavaScript 到达 <code>return</code> 语句，函数将停止执行。<br>如果函数被某条语句调用，JavaScript 将在调用语句之后“返回”执行代码。<br>函数通常会计算出返回值。这个返回值会返回给调用者：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myFunction(a, b) {</span><br><span class="line">    return a * b;                // 函数返回 a 和 b 的乘积</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Array：数组对象"><a href="#Array：数组对象" class="headerlink" title="Array：数组对象"></a>Array：数组对象</h3><h4 id="创建格式-1"><a href="#创建格式-1" class="headerlink" title="创建格式"></a>创建格式</h4><ol><li><code>var arr = new Array(元素列表);</code></li><li><code>var arr = new Array(默认长度);</code></li><li><code>var arr = [元素列表];</code></li></ol><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul><li><code>join(参数)</code>：将数组中的元素按照指定的分隔符拼接为字符串</li><li><code>push()</code>：向数组的末尾添加一个或更多元素，并返回新的长度</li></ul><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><ul><li><code>lengh</code>:数组的长度</li></ul><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><pre><code>1. JS中，数组元素的类型可变的。2. JS中，数组长度可变的。</code></pre><h3 id="Boolean：布尔"><a href="#Boolean：布尔" class="headerlink" title="Boolean：布尔"></a>Boolean：布尔</h3><p>布尔值只有两个值：<code>true</code> 或 <code>false</code>。</p><p><strong>实例</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x = true;</span><br><span class="line">var y = false;</span><br></pre></td></tr></tbody></table></figure><p>布尔值经常用在条件测试中。</p><h3 id="Date：日期对象"><a href="#Date：日期对象" class="headerlink" title="Date：日期对象"></a>Date：日期对象</h3><h4 id="创建格式-2"><a href="#创建格式-2" class="headerlink" title="创建格式"></a>创建格式</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date();</span><br></pre></td></tr></tbody></table></figure><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><ul><li><code>toLocaleString()</code>：返回当前date对象对应的时间本地字符串格式</li><li><code>getTime()</code>：获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</li></ul><h3 id="Math：数学对象"><a href="#Math：数学对象" class="headerlink" title="Math：数学对象"></a>Math：数学对象</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul><li>Math对象不用创建，直接使用。  </li><li>格式：<code>Math.方法名();</code></li></ul><h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><ul><li><code>random()</code>:返回 0 ~ 1 之间的随机数。 含0不含1</li><li><code>ceil(x)</code>：对数进行上舍入</li><li><code>floor(x)</code>：对数进行下舍入</li><li><code>round(x)</code>：把数四舍五入为最接近的整数</li></ul><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><ul><li><code>PI</code></li></ul><h3 id="Number：数值"><a href="#Number：数值" class="headerlink" title="Number：数值"></a>Number：数值</h3><p>JavaScript 只有一种数值类型。</p><p>写数值时用不用小数点均可：</p><p><strong>实例</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x1 = 34.00;     // 带小数点</span><br><span class="line">var x2 = 34;        // 不带小数点</span><br></pre></td></tr></tbody></table></figure><p>超大或超小的数值可以用科学计数法来写：</p><p><strong>实例</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var y = 123e5;      // 12300000</span><br><span class="line">var z = 123e-5;     // 0.00123</span><br></pre></td></tr></tbody></table></figure><h3 id="String：字符串"><a href="#String：字符串" class="headerlink" title="String：字符串"></a>String：字符串</h3><p>字符串（或文本字符串）是一串字符（比如 “Bill Gates”）。</p><p>字符串被引号包围。您可使用单引号或双引号：</p><p><strong>实例</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">"Porsche 911"</span>;   <span class="comment">// 使用双引号</span></span><br><span class="line"><span class="keyword">var</span> carName = <span class="string">'Porsche 911'</span>;   <span class="comment">// 使用单引号</span></span><br></pre></td></tr></tbody></table></figure><p>您可以在字符串内使用引号，只要这些引号与包围字符串的引号不匹配：</p><p><strong>实例</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> answer = <span class="string">"It's alright"</span>;             <span class="comment">// 双引号内的单引号</span></span><br><span class="line"><span class="keyword">var</span> answer = <span class="string">"He is called 'Bill'"</span>;    <span class="comment">// 双引号内的单引号</span></span><br><span class="line"><span class="keyword">var</span> answer = <span class="string">'He is called "Bill"'</span>;    <span class="comment">// 单引号内的双引号</span></span><br></pre></td></tr></tbody></table></figure><h3 id="RegExp：正则表达式对象"><a href="#RegExp：正则表达式对象" class="headerlink" title="RegExp：正则表达式对象"></a>RegExp：正则表达式对象</h3><h4 id="正则表达式：定义字符串的组成规则。"><a href="#正则表达式：定义字符串的组成规则。" class="headerlink" title="正则表达式：定义字符串的组成规则。"></a>正则表达式：定义字符串的组成规则。</h4><ol><li>单个字符:[]<br>如： <code>[a]</code> <code>[ab]</code> <code>[a-zA-Z0-9_]</code></li></ol><ul><li><p>特殊符号代表特殊含义的单个字符：</p><p>  <code>\d</code>:单个数字字符 [0-9]<br>  <code>\w</code>:单个单词字符 [a-zA-Z0-9_]</p></li></ul><ol start="2"><li>量词符号：<br> <code>?</code>：表示<strong>出现0次或1次</strong><br> <code>*</code>：表示<strong>出现0次或多次</strong><br> <code>+</code>：表示<strong>出现1次或多次</strong><br> <code>{m,n}</code>:表示 m&lt;= 数量 &lt;= n</li></ol><blockquote><p>m如果缺省：<code>{,n}</code>：最多n次<br>n 如果缺省：<code>{m,}</code>：最少m次</p></blockquote><ol start="3"><li><p>开始结束符号</p><ul><li><code>^</code>:开始</li><li><code>$</code>:结束</li></ul></li></ol><h4 id="正则对象"><a href="#正则对象" class="headerlink" title="正则对象"></a>正则对象</h4><h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><p>有两种创建形式：</p><ol><li><code>var reg = new RegExp("正则表达式");</code></li><li><code>var reg = /正则表达式/;</code></li></ol><h5 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h5><ol><li><code>test(参数)</code>:验证指定的字符串是否符合正则定义的规范    </li></ol><h3 id="Global：全局对象"><a href="#Global：全局对象" class="headerlink" title="Global：全局对象"></a>Global：全局对象</h3><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>全局对象</strong></li></ul><p>这个Global中封装的方法不需要对象就可以直接调用：<code>方法名();</code></p><h4 id="方法-5"><a href="#方法-5" class="headerlink" title="方法"></a>方法</h4><ul><li><p><code>encodeURI()</code>：url编码</p></li><li><p><code>decodeURI()</code>：url解码</p></li><li><p><code>encodeURIComponent()</code>：url编码,编码的字符更多</p></li><li><p><code>decodeURIComponent()</code>：url解码</p></li><li><p><code>parseInt()</code>：将字符串转为数字</p><ul><li>逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number</li></ul></li><li><p><code>isNaN()</code>：判断一个值是否是NaN</p><ul><li>NaN六亲不认，连自己都不认。<strong>NaN参与的==比较</strong>，全部都是<strong>false</strong></li></ul></li><li><p><code>eval()</code>：讲 JavaScript 字符串，并把它作为脚本代码来执行。</p></li></ul><h5 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h5><blockquote><p>传智播客 =  %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2</p></blockquote><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li>Browser Object Model 浏览器对象模型</li></ul><ul><li>将浏览器的各个组成部分封装成对象。</li></ul><h2 id="浏览器对象模型（Browser-Object-Model-BOM-）"><a href="#浏览器对象模型（Browser-Object-Model-BOM-）" class="headerlink" title="浏览器对象模型（Browser Object Model (BOM)）"></a>浏览器对象模型（Browser Object Model (BOM)）</h2><p>不存在浏览器对象模型（BOM）的官方标准。</p><p>现代的浏览器已经（几乎）实现了 JavaScript 交互相同的方法和属性，因此它经常作为 BOM 的方法和属性被提到。</p><blockquote><p>该部分笔记不全，详细见 <a href="https://www.w3school.com.cn/js/js_window.asp" target="_blank" rel="noopener">JavaScript Window - 浏览器对象模型</a></p></blockquote><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li><code>Window</code>：窗口对象</li><li><code>Navigator</code>：浏览器对象</li><li><code>Screen</code>：显示器屏幕对象</li><li><code>History</code>：历史记录对象</li><li><code>Location</code>：地址栏对象</li></ul><h2 id="Navigator-浏览器对象"><a href="#Navigator-浏览器对象" class="headerlink" title="Navigator 浏览器对象"></a>Navigator 浏览器对象</h2><ul><li>Navigator 对象获取一些浏览器的信息.</li></ul><h3 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h3><ul><li><code>appName</code> 返回浏览器的名称。</li></ul><blockquote><p>相关文档 <a href="https://www.w3school.com.cn/jsref/dom_obj_navigator.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/jsref/dom_obj_navigator.asp</a></p></blockquote><h2 id="Screen-屏幕对象"><a href="#Screen-屏幕对象" class="headerlink" title="Screen 屏幕对象"></a>Screen 屏幕对象</h2><ul><li>Screen 对象包含有关客户端显示屏幕的信息。</li></ul><h3 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h3><ul><li><code>width</code>: 返回屏幕的宽度</li><li><code>height</code>: 返回屏幕的高度</li></ul><blockquote><p>相关文档 <a href="https://www.w3school.com.cn/jsref/dom_obj_screen.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/jsref/dom_obj_screen.asp</a></p></blockquote><h2 id="Location-地址栏对象"><a href="#Location-地址栏对象" class="headerlink" title="Location 地址栏对象"></a>Location 地址栏对象</h2><ul><li>Location 对象包含有关当前 URL 的信息。</li></ul><h3 id="创建-获取"><a href="#创建-获取" class="headerlink" title="创建(获取)"></a>创建(获取)</h3><ol><li><code>window.location</code></li><li><code>location</code></li></ol><h3 id="方法-6"><a href="#方法-6" class="headerlink" title="方法"></a>方法</h3><ul><li><code>reload()</code>: 重新加载当前文档,刷新操作.</li></ul><h3 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h3><ul><li><code>href</code>: 设置或返回完整的url.</li></ul><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input id=<span class="string">"btn"</span> type=<span class="string">"button"</span> value=<span class="string">"跳转"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取input标签</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line"><span class="comment">// 设置事件</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>{</span><br><span class="line">location.href = <span class="string">"https://www.baidu.com"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>相关文档 <a href="https://www.w3school.com.cn/jsref/dom_obj_location.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/jsref/dom_obj_location.asp</a></p></blockquote><h2 id="History-对象"><a href="#History-对象" class="headerlink" title="History 对象"></a>History 对象</h2><ul><li>History 对象包含用户（在浏览器窗口中）访问过的 URL。</li></ul><h3 id="创建-获取-1"><a href="#创建-获取-1" class="headerlink" title="创建(获取)"></a>创建(获取)</h3><ol><li><code>window.history</code></li><li><code>history</code></li></ol><h3 id="方法-7"><a href="#方法-7" class="headerlink" title="方法"></a>方法</h3><ul><li><code>back()</code> 加载 history 列表中的前一个 URL。</li><li><code>forward()</code> 加载 history 列表中的下一个 URL。</li><li><code>go(参数)</code>加载 history 列表中的某个具体页面。</li></ul><blockquote><p>参数：<br>正数：前进几个历史记录<br>负数：后退几个历史记录</p></blockquote><h3 id="属性-6"><a href="#属性-6" class="headerlink" title="属性"></a>属性</h3><ul><li><code>length</code>: 返回当前窗口历史列表中的url数量.</li></ul><h2 id="Window-窗口对象"><a href="#Window-窗口对象" class="headerlink" title="Window 窗口对象"></a>Window 窗口对象</h2><ul><li>Window 对象表示浏览器中打开的窗口。</li></ul><h3 id="方法-8"><a href="#方法-8" class="headerlink" title="方法"></a>方法</h3><ol><li><p>与弹出框有关的方法</p><ul><li><code>alert()</code>: 显示带有一段消息和一个确认按钮的警告框.</li><li><code>confirm()</code>: 显示带有一段消息,以及确认和取消两个按钮的对话框. 若点击确定,该方法返回true, 点击取消,返回false.<ul><li>如果用户点击<strong>确定</strong>按钮，则方法返回<strong>true</strong></li><li>如果用户点击<strong>取消</strong>按钮，则方法返回<strong>false</strong></li></ul></li><li><code>prompt()</code>: 显示可提示用户输入的对话框. 返回值为用户输入的内容.</li></ul></li><li><p>与打开关闭有关的方法</p><ul><li><code>close()</code>:关闭浏览器窗口。<strong>谁调用我 ，我关谁</strong></li><li><code>open(arg1, arg2, arg3, arg4)</code>: 打开一个新的浏览器窗口，<strong>返回新的Window对象</strong><ul><li><strong>注意</strong>: 这4个参数都是可选的, arg1 传入url, arg3传入窗口的特征(设置宽高等)</li></ul></li></ul></li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">"https://www.baidu.com"</span>,<span class="string">""</span>,<span class="string">"width=100,height=100"</span>);</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li><p>与定时器有关的方法</p><ul><li><code>setTimeout(code,millisec)</code>: 在指定的毫秒数后调用函数或计算表达式。<ul><li>参数：<ul><li>js代码或者方法对象</li><li>毫秒值</li></ul></li><li>返回值：唯一标识，用于取消定时器</li></ul></li><li><code>clearTimeout(id_of_settimeout)</code>: 取消由 setTimeout() 方法设置的 timeout。传入某个定时器的id用来取消指定的定时器.</li><li><code>setInterval(code,millisec)</code>: 按照指定的周期（以毫秒计）来调用函数或计算表达式。</li><li><code>clearInterval(id_of_settimeout)</code>: 取消由 setInterval() 设置的 timeout。</li></ul></li></ol><h3 id="属性-7"><a href="#属性-7" class="headerlink" title="属性"></a>属性</h3><ol><li><p>获取其他BOM对象</p><ul><li><code>History</code></li><li><code>location</code></li><li><code>Navigator</code></li><li><code>Screen</code></li></ul></li><li><p>获取DOM对象</p><ul><li><code>document</code></li></ul></li></ol><h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><ul><li>Window对象不需要创建可以直接使用： <code>window.方法名()</code></li><li>window引用可以省略：<code>方法名();</code></li></ul><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="简单学习：为了满足案例要求"><a href="#简单学习：为了满足案例要求" class="headerlink" title="简单学习：为了满足案例要求"></a>简单学习：为了满足案例要求</h2><ul><li><p>功能：控制html文档的内容</p><ul><li>获取页面标签(元素)对象：Element<pre><code>* `document.getElementById("id值")`:通过元素的id获取元素对象</code></pre></li></ul></li><li><p>操作Element对象：</p><ol><li>修改属性值：<ol><li>明确获取的对象是哪一个？</li><li>查看API文档，找其中有哪些属性可以设置</li></ol></li><li>修改标签体内容：<ul><li>属性：``innerHTML`</li></ul><ol><li>获取元素对象</li><li>使用<code>innerHTML</code>属性修改标签体内容</li></ol></li></ol></li></ul><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><ul><li><p>Document Object Model 文档对象模型</p></li><li><p>将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作</p></li></ul><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><ul><li>控制html文档的内容</li></ul><h2 id="W3C-DOM-标准被分为-3-个不同的部分"><a href="#W3C-DOM-标准被分为-3-个不同的部分" class="headerlink" title="W3C DOM 标准被分为 3 个不同的部分"></a>W3C DOM 标准被分为 3 个不同的部分</h2><ul><li><p>核心 DOM — 针对任何结构化文档的标准模型</p><ul><li>Document：文档对象</li><li>Element：元素对象</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li><li>Node：节点对象，其他5个(D、E、A、T、C)的父对象</li></ul></li><li><p>XML DOM — 针对 XML 文档的标准模型</p></li><li><p>HTML DOM — 针对 HTML 文档的标准模型</p></li></ul><h2 id="对象树"><a href="#对象树" class="headerlink" title="对象树"></a>对象树</h2><p>当网页被加载时，浏览器会创建页面的文档对象模型（<em>D</em>ocument <em>O</em>bject <em>M</em>odel）。</p><p><em>HTML DOM</em> 模型被结构化为<em>对象树</em>：</p><p><img src="https://www.w3school.com.cn/i/ct_htmltree.gif" alt="对象树"></p><p>DOM: <code>Document Object Model</code> 文档对象模型</p><ul><li><strong>文档</strong>: 超文本文档(超文本标记文档) html, xml</li><li><strong>对象</strong>: 提供了属性和方法.</li><li><strong>模型</strong>: 使用属性和方法操作超文本标记文档</li><li>可以使用js里面的dom里面提供的对象,使用这些对象的属性和方法,对标记型文档进行操作.</li><li>dom里面已经将html里面的标签,属性,文本内容都封装成了对象.</li></ul><blockquote><p>该部分笔记不全，详细见 <a href="https://www.w3school.com.cn/js/js_htmldom.asp" target="_blank" rel="noopener">JavaScript HTML DOM</a></p></blockquote><h3 id="DOM解析html文档的过程"><a href="#DOM解析html文档的过程" class="headerlink" title="DOM解析html文档的过程"></a>DOM解析html文档的过程</h3><p><img src="https://s2.ax1x.com/2020/02/18/3FtrGQ.png" alt="3FtrGQ.png"></p><p>根据html的层级结构,在内存中分配一个<strong>树形结构</strong>, 需要把html中的每部分封装为对象.</p><ul><li><p><code>Document</code>对象: 整个文档</p></li><li><p><code>Element</code>对象: 标签对象</p></li><li><p><code>Attribute</code>对象: 首先要获取标签对象</p></li><li><p><code>Text</code>对象: 首先要获取标签对象</p></li><li><p><code>Comment</code>对象: 注释对象</p></li><li><p><code>Node节点对象</code>: 这个对象是上面这些对象的父对象, 如果在对象内找不到想要的方法, 此时可以在Node节点对象中去查找想要的方法.</p></li></ul><h2 id="核心DOM模型"><a href="#核心DOM模型" class="headerlink" title="核心DOM模型"></a>核心DOM模型</h2><h3 id="Document-文档对象"><a href="#Document-文档对象" class="headerlink" title="Document 文档对象"></a>Document 文档对象</h3><h4 id="创建-获取-2"><a href="#创建-获取-2" class="headerlink" title="创建(获取)"></a>创建(获取)</h4><ul><li>在html dom模型中可以使用window对象来获取</li><li>window.document</li><li>document</li></ul><h4 id="方法-9"><a href="#方法-9" class="headerlink" title="方法"></a>方法</h4><p><code>write()</code> 向页面输出变量/html代码</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.write("abc");</span><br><span class="line">document.write("&lt;hr&gt;");</span><br></pre></td></tr></tbody></table></figure><ul><li><p>获取Element对象<br><code>getElementById()</code> ： 根据id属性值获取元素对象,id属性值一般唯一<br><code>getElementsByTagName()</code>：根据元素名称获取元素对象们。返回值是一个数组<br><code>getElementsByClassName()</code>:根据Class属性值获取元素对象们。返回值是一个数组<br><code>getElementsByName()</code>: 根据name属性值获取元素对象们。返回值是一个数组</p></li><li><p>创建其他的DOM对象<br>  <code>createAttribute(name)</code><br>  <code>createComment()</code><br>  <code>createElement()</code><br>  <code>createTextNode()</code></p></li></ul><h3 id="Element-元素对象-标签对象"><a href="#Element-元素对象-标签对象" class="headerlink" title="Element 元素对象(标签对象)"></a>Element 元素对象(标签对象)</h3><h4 id="创建-获取-3"><a href="#创建-获取-3" class="headerlink" title="创建(获取)"></a>创建(获取)</h4><ul><li>通过document来获取和创建</li></ul><h4 id="方法-10"><a href="#方法-10" class="headerlink" title="方法"></a>方法</h4><ul><li><p>首先通过document来获取元素,然后通过元素进行操作<br>  <code>getAttribute(attributename)</code>: 获取指定的属性<br>  <code>setAttribute(attributename,attributevalue)</code>: 给元素添加属性<br>  <code>removeAttribute(attributename)</code>: 移除指定名称的属性</p></li><li><p>注意: 不能删除 <code>value</code></p></li><li><p>获取标签下面的子标签<br>  <code>childNodes</code>: 这个属性兼容性很差<br>  <code>getElementsByTagName(标签名)</code>: <strong>兼容性好</strong>,获取标签下面子标签的唯一有效方法.</p></li></ul><h3 id="Node-节点对象"><a href="#Node-节点对象" class="headerlink" title="Node 节点对象"></a>Node 节点对象</h3><h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><ul><li>所有dom对象都可以被认为是一个节点.</li></ul><h4 id="属性-8"><a href="#属性-8" class="headerlink" title="属性"></a>属性</h4><ul><li><code>parentNode</code> 返回节点的父节点</li></ul><h4 id="方法-11"><a href="#方法-11" class="headerlink" title="方法"></a>方法</h4><p><code>nodeName</code>:获取节点的名称<br><code>nodeType</code>: 获取节点的类型<br><code>nodeValue</code>: 获取节点的value值<br>因为dom在解析html的时候, html里面的标签,属性,文本都是一个节点,所以上面的三个属性对其都是不同的值.</p><ul><li>标签节点对应的nodeType为1</li><li>属性节点对应的nodeType为2</li><li>文本节点对应的nodeType为3</li></ul><p><code>parentNode</code>: 获取父节点的属性<br><code>childNodes</code>: 得到所有子节点,兼容性差<br><code>firstChild</code>: 获取第一个子节点<br><code>lastChild</code>: 获取最后一个子节点<br><code>nextSibling</code>: 返回一个给定节点的下一个兄弟节点<br><code>previousSibling</code>: 返回一个给定节点的上一个兄弟节点</p><h3 id="CRUD-DOM树"><a href="#CRUD-DOM树" class="headerlink" title="CRUD_DOM树"></a>CRUD_DOM树</h3><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><ul><li><code>getElementById()</code>:通过节点的id属性,查找指定节点</li></ul><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><ul><li><code>appendChild()</code>：向节点的子节点列表的结尾添加新的子节点</li></ul><h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><ul><li><code>insertBefore(newNode, oldNode)</code>: 向oldNode节点前插入一个新节点.通过父节点添加</li></ul><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><ul><li><code>removeChild()</code>：删除（并返回）当前节点的指定子节点。</li></ul><h4 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h4><ul><li><code>replaceChild()</code>：用新节点替换一个子节点。通过父节点替换</li></ul><h4 id="复制节点"><a href="#复制节点" class="headerlink" title="复制节点"></a>复制节点</h4><ul><li><code>cloneNode(true)</code>: 复制节点</li></ul><h4 id="innerHTML属性"><a href="#innerHTML属性" class="headerlink" title="innerHTML属性"></a>innerHTML属性</h4><ul><li><code>innerHTML</code>作用:<ol><li>获取文本内容</li><li>向标签里面设置内容(可以是html代码)</li></ol></li></ul><h3 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div#div1 {</span><br><span class="line">            width: 360px;</span><br><span class="line">            height: 150px;</span><br><span class="line">            border: 2px solid red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        div#div2 {</span><br><span class="line">            width: 360px;</span><br><span class="line">            height: 150px;</span><br><span class="line">            border: 2px solid black;</span><br><span class="line">        }</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id="div1"&gt;</span><br><span class="line">    &lt;ul id="ul1"&gt;</span><br><span class="line">        &lt;li id="li1"&gt;one&lt;/li&gt;</span><br><span class="line">        &lt;li id="li2"&gt;two&lt;/li&gt;</span><br><span class="line">        &lt;li id="li3"&gt;three&lt;/li&gt;</span><br><span class="line">        &lt;li id="li4"&gt;four&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id="div2"&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;input id="input1" type="button" value="添加节点"&gt;</span><br><span class="line">&lt;input id="input2" type="button" value="插入节点"&gt;</span><br><span class="line">&lt;input id="input3" type="button" value="删除节点"&gt;</span><br><span class="line">&lt;input id="input4" type="button" value="替换节点"&gt;</span><br><span class="line">&lt;input id="input5" type="button" value="复制节点"&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line"></span><br><span class="line">    // 添加节点</span><br><span class="line">    /*</span><br><span class="line">    1.获取到ul</span><br><span class="line">    2.获取到div2</span><br><span class="line">    3.把ul添加到div2</span><br><span class="line">    */</span><br><span class="line">    var input1 = document.getElementById("input1");</span><br><span class="line">    input1.onclick = function () {</span><br><span class="line">        var ul = document.getElementById("ul1");</span><br><span class="line">        var div = document.getElementById("div2");</span><br><span class="line">        div.appendChild(ul);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 插入节点</span><br><span class="line">    /*</span><br><span class="line">    1.获取到li3标签</span><br><span class="line">    2.创建li</span><br><span class="line">    3.创建文本</span><br><span class="line">    4.把文本添加到li下面</span><br><span class="line">    5.获取到ul</span><br><span class="line">    6.把li添加到ul下面</span><br><span class="line">    */</span><br><span class="line">    var input2 = document.getElementById("input2");</span><br><span class="line">    input2.onclick = function () {</span><br><span class="line">        var li3 = document.getElementById("li3");</span><br><span class="line">        var li = document.createElement("li");</span><br><span class="line">        var text = document.createTextNode("朝阳红");</span><br><span class="line">        li.appendChild(text);</span><br><span class="line">        var ul = document.getElementById("ul1");</span><br><span class="line">        ul.insertBefore(li, li3);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 删除节点</span><br><span class="line">    /*</span><br><span class="line">    1.获取到li标签</span><br><span class="line">    2.执行父节点ul标签</span><br><span class="line">    3.执行删除</span><br><span class="line">    */</span><br><span class="line">    var input3 = document.getElementById("input3");</span><br><span class="line">    input3.onclick = function () {</span><br><span class="line">        var li3 = document.getElementById("li3");</span><br><span class="line">        var ul = document.getElementById("ul1");</span><br><span class="line">        ul.removeChild(li3);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    // 替换节点</span><br><span class="line">    /*</span><br><span class="line">    1.获取到li标签</span><br><span class="line">    2.创建标签li</span><br><span class="line">    3.创建文本</span><br><span class="line">    4.把文本添加到li下面</span><br><span class="line">    5.获取父节点Ul标签</span><br><span class="line">    6.执行替换</span><br><span class="line">    */</span><br><span class="line">    var input4 = document.getElementById("input4");</span><br><span class="line">    input4.onclick = function () {</span><br><span class="line">        var li3 = document.getElementById("li3");</span><br><span class="line">        var li = document.createElement("li");</span><br><span class="line">        var text = document.createTextNode("HelloWorld");</span><br><span class="line">        li.appendChild(text);</span><br><span class="line">        var ul = document.getElementById("ul1");</span><br><span class="line">        ul.replaceChild(li, li3);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 复制节点(把ul列表复制到另一个div中)</span><br><span class="line">    /*</span><br><span class="line">    1.获取到ul</span><br><span class="line">    2.执行复制方法：cloneNode(true)</span><br><span class="line">    3.把复制后的内容放到div2中</span><br><span class="line">        获取div2</span><br><span class="line">        appendChild方法</span><br><span class="line">    */</span><br><span class="line">    var input5 = document.getElementById("input5");</span><br><span class="line">    input5.onclick = function () {</span><br><span class="line">        var ul = document.getElementById("ul1");</span><br><span class="line">        var ulClone = ul.cloneNode(true);</span><br><span class="line">        var div = document.getElementById("div2");</span><br><span class="line">        div.appendChild(ulClone);</span><br><span class="line">    }</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h2><ol><li>标签体的设置和获取：innerHTML</li><li>使用html元素对象的属性</li><li>控制元素样式<ul><li>使用元素的style属性来设置</li><li>提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。<br>如：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//修改样式方式1</span><br><span class="line">div1.style.border = "1px solid red";</span><br><span class="line">div1.style.width = "200px";</span><br><span class="line">//font-size--&gt; fontSize</span><br><span class="line">div1.style.fontSize = "20px";</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><h2 id="控制样式"><a href="#控制样式" class="headerlink" title="控制样式"></a>控制样式</h2><ul><li>通过DOM来控制标签的样式</li><li>使用 <code>style</code> 属性来设置</li><li>提前定义好类选择器的样式，通过元素的 <code>className</code> 属性来设置其class属性值。</li></ul><h3 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .sun {</span><br><span class="line">            font-weight: bold;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">            color: skyblue;</span><br><span class="line">            border: 2px dashed #000;</span><br><span class="line">        }</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class="zy"&gt;桂朝阳&lt;/div&gt;</span><br><span class="line">&lt;div class="sun"&gt;大太阳&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line"></span><br><span class="line">    // 获取类名为zy的标签</span><br><span class="line">    var zy = window.document.getElementsByClassName("zy")[0];</span><br><span class="line">    // alert(zy.className);</span><br><span class="line"></span><br><span class="line">    // 方式一(自己添加)给类名为zy的div添加样式</span><br><span class="line">    // zy.style.border = "1px solid #ccc";</span><br><span class="line">    // zy.style.fontSize = "20px";</span><br><span class="line"></span><br><span class="line">    // 方式二(调用已经写好的)</span><br><span class="line">    zy.className = "sun";</span><br><span class="line">    </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></tbody></table></figure><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="简单学习"><a href="#简单学习" class="headerlink" title="简单学习"></a>简单学习</h2><ul><li><p>功能： 某些组件被执行了某些操作后，触发某些代码的执行。</p><ul><li>比如，造句： xxx被xxx,我就xxx。<ul><li>我方水晶被摧毁后，我就责备对友。</li><li>敌方水晶被摧毁后，我就夸奖自己。</li></ul></li></ul></li><li><p>如何绑定事件</p><ol><li><p>直接在html标签上，指定事件的属性(操作)，<strong>属性值就是 js 代码</strong></p><ul><li>事件：<code>onclick</code> — 单击事件</li></ul></li><li><p>通过 js 获取元素对象，指定事件属性，设置一个函数</p></li></ol></li></ul><ul><li>小案例：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;img id="light" src="img/off.gif"  onclick="fun();"&gt;</span><br><span class="line">&lt;img id="light2" src="img/off.gif"&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function fun(){</span><br><span class="line">alert('我被点了');</span><br><span class="line">alert('我又被点了');</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line">function fun2(){</span><br><span class="line">        alert('咋老点我？');</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> //1.获取light2对象</span><br><span class="line">var light2 = document.getElementById("light2");</span><br><span class="line"> //2.绑定事件</span><br><span class="line">light2.onclick = fun2;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h2><p>些组件被执行了某些操作后，触发某些代码的执行</p><h2 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h2><ul><li>概念: 某些组件被执行了某些操作后，触发某些代码的执行。<ul><li><strong>事件</strong>：某些操作。如： 单击，双击，键盘按下了，鼠标移动了</li><li><strong>事件源</strong>：组件。如： 按钮 文本输入框…</li><li><strong>监听器</strong>：代码。</li><li><strong>注册监听</strong>：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。</li></ul></li></ul><h2 id="常见的事件"><a href="#常见的事件" class="headerlink" title="常见的事件"></a>常见的事件</h2><ol><li><p>点击事件：<br> <code>onclick</code>：单击事件<br> <code>ondblclick</code>：双击事件</p></li><li><p>焦点事件<br> <code>onfocus</code>:元素获得焦点<br> <code>onblur</code>：失去焦点</p><ul><li>一般用于表单验证</li></ul></li><li><p>加载事件：<br> <code>onload</code>：一张页面或一幅图像完成加载。</p></li><li><p>鼠标事件：<br> <code>onmousedown</code>： 鼠标按钮被按下。</p><ul><li>定义方法时，定义一个形参，接受event对象。</li><li>event对象的button属性可以获取鼠标按钮键被点击了。</li></ul><p><code>onmouseup</code> ：鼠标按键被松开。<br><code>onmousemove</code> ：鼠标被移动。<br><code>onmouseover</code> ：鼠标移到某元素之上。<br><code>onmouseout</code> ：鼠标从某元素移开。</p></li><li><p>键盘事件：<br> <code>onkeydown</code> ：某个键盘按键被按下。<br> <code>onkeyup</code> ：某个键盘按键被松开。<br> <code>onmouseout</code>：某个键盘按键被按下并松开。</p></li><li><p>选择和改变<br> <code>onchange</code> ：域的内容被改变。<br> <code>onselect</code> ：文本被选中。</p></li><li><p>表单事件：<br> <code>onsubmit</code> ：确认按钮被点击。</p><ul><li>可以阻止表单的提交</li><li>方法返回false则表单被阻止提交。</li></ul><p><code>onreset</code> ：重置按钮被点击。</p></li></ol><h2 id="Demo-电灯开关"><a href="#Demo-电灯开关" class="headerlink" title="Demo:电灯开关"></a>Demo:电灯开关</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;电灯开关&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;img id="light" src="img/off.gif"&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    /* 分析：</span><br><span class="line">        1.获取图片对象</span><br><span class="line">        2.绑定单击事件</span><br><span class="line">        3.每次点击切换图片</span><br><span class="line">         * 规则：</span><br><span class="line">             * 如果灯是开的 on,切换图片为 off</span><br><span class="line">             * 如果灯是关的 off,切换图片为 on</span><br><span class="line">         * 使用标记flag来完成</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    //1.获取图片对象</span><br><span class="line">    var light = document.getElementById("light");</span><br><span class="line">    var flag = false;//代表灯是灭的。 off图片</span><br><span class="line"></span><br><span class="line">    //2.绑定单击事件</span><br><span class="line">    light.onclick = function(){</span><br><span class="line">        if(flag){//判断如果灯是开的，则灭掉</span><br><span class="line">            light.src = "img/off.gif";</span><br><span class="line">            flag = false;</span><br><span class="line">        }else{</span><br><span class="line">            //如果灯是灭的，则打开</span><br><span class="line">            light.src = "img/on.gif";</span><br><span class="line">            flag = true;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><hr><p>标记&gt;&gt;&gt;学习BOM和DOM时用的是CSDN博主「White Camel」的笔记，原文链接：<a href="https://blog.csdn.net/m0_37989980/article/details/103669620" target="_blank" rel="noopener">https://blog.csdn.net/m0_37989980/article/details/103669620</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;一门&lt;strong&gt;客户端脚本语言&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎&lt;/li&gt;
&lt;li&gt;脚本语言：&lt;strong&gt;不需要编译&lt;/strong&gt;，直接就可以被浏览器解析执行了&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;可以来&lt;strong&gt;增强用户和html页面的交互过程&lt;/strong&gt;，可以来控制html元素，让页面有一些动态的效果，&lt;strong&gt;增强用户的体验&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JavaWeb" scheme="https://melodyjerry.github.io/blog/tags/JavaWeb/"/>
    
      <category term="笔记" scheme="https://melodyjerry.github.io/blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="https://melodyjerry.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>歌《人命之河》</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/17/%E6%AD%8C%E3%80%8A%E4%BA%BA%E5%91%BD%E4%B9%8B%E6%B2%B3%E3%80%8B/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/17/歌《人命之河》/</id>
    <published>2020-02-17T14:49:52.000Z</published>
    <updated>2020-02-17T15:05:26.730Z</updated>
    
    <content type="html"><![CDATA[<p><fancybox><img src="https://s2.ax1x.com/2020/02/17/3i8TL8.png" alt="妈妈的笔记本" style="zoom: 33%;"></fancybox></p><a id="more"></a><hr><p>记录昨天，2020-2-17，周日。</p><p>中午，老爸做了新菜，名叫“凉拌猪肉”（老爸自己起的名字），味道还不错</p><p><fancybox><img src="https://s2.ax1x.com/2020/02/17/3iGio4.png" alt="凉拌猪肉" style="zoom:50%;"></fancybox></p><p>老弟“放假”（在家网上教学六天，周日放假hhh），下午我们去到外公外婆那。</p><p>外公外婆2人+二姨一家4人+我们一家3人=9人。</p><p>老爸又露了一手，一桌的饭菜，。结果留给我收尾，我也吃不完，实则太多了，嗝~~（太撑了hh）</p><p><fancybox><img src="https://s2.ax1x.com/2020/02/17/3iGPwF.png" alt="外公外婆家小聚" style="zoom:50%;"></fancybox></p><p>看见外公的身体比之前还虚弱，很累的样子。保佑阿公身体健康🙆</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;fancybox&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/17/3i8TL8.png&quot; alt=&quot;妈妈的笔记本&quot; style=&quot;zoom: 33%;&quot;&gt;&lt;/fancybox&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://melodyjerry.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>[转]Git很慢怎么办</title>
    <link href="https://melodyjerry.github.io/blog/2020/02/17/%E8%BD%AC-Git-%E5%BE%88%E6%85%A2%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>https://melodyjerry.github.io/blog/2020/02/17/转-Git-很慢怎么办/</id>
    <published>2020-02-17T11:35:47.000Z</published>
    <updated>2020-02-17T11:37:30.465Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="it’s-fucking-slow-guess-why"><a href="#it’s-fucking-slow-guess-why" class="headerlink" title="it’s fucking slow, guess why"></a>it’s fucking slow, guess why</h2><p>当你想要解决一个问题的时候，最好先学会尽可能准确地描述你的问题，像「Git 很慢怎么办」之类的问题就是反面教材，这就像说「我的国家不行了」一样，这种模棱两可、似是而非的问题对出题人和答题人都是一种困扰，出题人把握不了自己的问题，便始终不会自查，答题人无法知晓出题人真正的问题，也只能一顿瞎猜。</p><p>如果你假以思考，结合实际情况，比如你操作的命令，是 <code>git clone</code> 还是 <code>git checkout</code>? 这样就能很快推断出真正的问题，即「Git clone 很慢怎么办」，如果更进一步，你想到你正在 clone 的是一个国外的地址，比如 <a href="http://github.com/" target="_blank" rel="noopener">github.com</a>，你会想到这也许是网络问题。</p><p>当你做出更多的判断而不是用一个模糊的问题来让别人替你判断的时候，你的问题也就迎刃而解了。</p><p>现在这个模糊的问题变成了解决 Git 同步国外项目的网络问题了，这种情况你应该很熟悉，可以使用「代理」来解决。而 Git 支持两种网络传输协议，即 HTTP 和 SSH 协议，于是你只需要在 Google 搜索 <em>Git 如何配置 HTTP 代理和 SSH 代理</em> 就行了，当然也可以继续阅读，参考我用的配置。</p><h2 id="配置-HTTP-代理"><a href="#配置-HTTP-代理" class="headerlink" title="配置 HTTP 代理"></a>配置 HTTP 代理</h2><p>如果你 <code>git clone</code> 时用的是 <code>http</code> 开头的地址，那就得配置 http 代理:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:1087</span><br><span class="line"><span class="comment"># 或者 Socks5 代理</span></span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:1086</span><br></pre></td></tr></tbody></table></figure><h2 id="配置-SSH-代理"><a href="#配置-SSH-代理" class="headerlink" title="配置 SSH 代理"></a>配置 SSH 代理</h2><p>如果你 <code>git clone</code> 时用的是 <code>ssh</code> 开头的地址，那就得配置 SSH 代理。</p><p>对 macOS 用户，你可以使用 <a href="https://bitbucket.org/gotoh/connect/wiki/Home" target="_blank" rel="noopener"><code>connect</code></a>，这是一个让 SSH 支持 SOCKS/HTTPS 代理的工具，这里我们用 <a href="https://brew.sh/" target="_blank" rel="noopener">homebrew</a> 来安装:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install connect</span><br></pre></td></tr></tbody></table></figure><p>然后编辑你的 <code>~/.ssh/config</code> 文件，加入以下代码:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">  User git</span><br><span class="line">  ProxyCommand connect -S 127.0.0.1:1086 %h %p</span><br></pre></td></tr></tbody></table></figure><p>这样 SSH 连接时就会使用位于 <code>127.0.0.1:1086</code> 的代理。</p><hr><p>原文链接：<a href="https://egoist.moe/2019/08/15/git-is-slow/" target="_blank" rel="noopener">https://egoist.moe/2019/08/15/git-is-slow/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;it’s-fucking-slow-guess-why&quot;&gt;&lt;a href=&quot;#it’s-fucking-slow-guess-why&quot; class=&quot;headerlink&quot; title=&quot;it’s fucking slow, 
      
    
    </summary>
    
    
    
      <category term="Git" scheme="https://melodyjerry.github.io/blog/tags/Git/"/>
    
  </entry>
  
</feed>
